{"ast":null,"code":"/**\n * @fileoverview Define utility functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Finds the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n  for (let minIndex = 0, maxIndex = tokens.length - 1; minIndex <= maxIndex;) {\n    /*\n     * Calculate the index in the middle between minIndex and maxIndex.\n     * `| 0` is used to round a fractional value down to the nearest integer: this is similar to\n     * using `Math.trunc()` or `Math.floor()`, but performance tests have shown this method to\n     * be faster.\n     */\n    const index = (minIndex + maxIndex) / 2 | 0;\n    const token = tokens[index];\n    const tokenStartLocation = token.range[0];\n    if (location <= tokenStartLocation) {\n      if (index === minIndex) {\n        return index;\n      }\n      maxIndex = index;\n    } else {\n      minIndex = index + 1;\n    }\n  }\n  return tokens.length;\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n  if (startLoc in indexMap) {\n    return indexMap[startLoc];\n  }\n  if (startLoc - 1 in indexMap) {\n    const index = indexMap[startLoc - 1];\n    const token = tokens[index];\n\n    // If the mapped index is out of bounds, the returned cursor index will point after the end of the tokens array.\n    if (!token) {\n      return tokens.length;\n    }\n\n    /*\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n     * In that case, +1 is unnecessary.\n     */\n    if (token.range[0] >= startLoc) {\n      return index;\n    }\n    return index + 1;\n  }\n  return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n  if (endLoc in indexMap) {\n    return indexMap[endLoc] - 1;\n  }\n  if (endLoc - 1 in indexMap) {\n    const index = indexMap[endLoc - 1];\n    const token = tokens[index];\n\n    // If the mapped index is out of bounds, the returned cursor index will point before the end of the tokens array.\n    if (!token) {\n      return tokens.length - 1;\n    }\n\n    /*\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n     * In that case, -1 is necessary.\n     */\n    if (token.range[1] > endLoc) {\n      return index - 1;\n    }\n    return index;\n  }\n  return tokens.length - 1;\n};","map":{"version":3,"names":["exports","search","tokens","location","minIndex","maxIndex","length","index","token","tokenStartLocation","range","getFirstIndex","indexMap","startLoc","getLastIndex","endLoc"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/source-code/token-store/utils.js"],"sourcesContent":["/**\n * @fileoverview Define utility functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Finds the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    for (let minIndex = 0, maxIndex = tokens.length - 1; minIndex <= maxIndex;) {\n\n        /*\n         * Calculate the index in the middle between minIndex and maxIndex.\n         * `| 0` is used to round a fractional value down to the nearest integer: this is similar to\n         * using `Math.trunc()` or `Math.floor()`, but performance tests have shown this method to\n         * be faster.\n         */\n        const index = (minIndex + maxIndex) / 2 | 0;\n        const token = tokens[index];\n        const tokenStartLocation = token.range[0];\n\n        if (location <= tokenStartLocation) {\n            if (index === minIndex) {\n                return index;\n            }\n            maxIndex = index;\n        } else {\n            minIndex = index + 1;\n        }\n    }\n    return tokens.length;\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = tokens[index];\n\n        // If the mapped index is out of bounds, the returned cursor index will point after the end of the tokens array.\n        if (!token) {\n            return tokens.length;\n        }\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, +1 is unnecessary.\n         */\n        if (token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = tokens[index];\n\n        // If the mapped index is out of bounds, the returned cursor index will point before the end of the tokens array.\n        if (!token) {\n            return tokens.length - 1;\n        }\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, -1 is necessary.\n         */\n        if (token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,OAAO,CAACC,MAAM,GAAG,SAASA,MAAMA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EAC/C,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEC,QAAQ,GAAGH,MAAM,CAACI,MAAM,GAAG,CAAC,EAAEF,QAAQ,IAAIC,QAAQ,GAAG;IAExE;AACR;AACA;AACA;AACA;AACA;IACQ,MAAME,KAAK,GAAG,CAACH,QAAQ,GAAGC,QAAQ,IAAI,CAAC,GAAG,CAAC;IAC3C,MAAMG,KAAK,GAAGN,MAAM,CAACK,KAAK,CAAC;IAC3B,MAAME,kBAAkB,GAAGD,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC;IAEzC,IAAIP,QAAQ,IAAIM,kBAAkB,EAAE;MAChC,IAAIF,KAAK,KAAKH,QAAQ,EAAE;QACpB,OAAOG,KAAK;MAChB;MACAF,QAAQ,GAAGE,KAAK;IACpB,CAAC,MAAM;MACHH,QAAQ,GAAGG,KAAK,GAAG,CAAC;IACxB;EACJ;EACA,OAAOL,MAAM,CAACI,MAAM;AACxB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,OAAO,CAACW,aAAa,GAAG,SAASA,aAAaA,CAACT,MAAM,EAAEU,QAAQ,EAAEC,QAAQ,EAAE;EACvE,IAAIA,QAAQ,IAAID,QAAQ,EAAE;IACtB,OAAOA,QAAQ,CAACC,QAAQ,CAAC;EAC7B;EACA,IAAKA,QAAQ,GAAG,CAAC,IAAKD,QAAQ,EAAE;IAC5B,MAAML,KAAK,GAAGK,QAAQ,CAACC,QAAQ,GAAG,CAAC,CAAC;IACpC,MAAML,KAAK,GAAGN,MAAM,CAACK,KAAK,CAAC;;IAE3B;IACA,IAAI,CAACC,KAAK,EAAE;MACR,OAAON,MAAM,CAACI,MAAM;IACxB;;IAEA;AACR;AACA;AACA;IACQ,IAAIE,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC,IAAIG,QAAQ,EAAE;MAC5B,OAAON,KAAK;IAChB;IACA,OAAOA,KAAK,GAAG,CAAC;EACpB;EACA,OAAO,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAP,OAAO,CAACc,YAAY,GAAG,SAASA,YAAYA,CAACZ,MAAM,EAAEU,QAAQ,EAAEG,MAAM,EAAE;EACnE,IAAIA,MAAM,IAAIH,QAAQ,EAAE;IACpB,OAAOA,QAAQ,CAACG,MAAM,CAAC,GAAG,CAAC;EAC/B;EACA,IAAKA,MAAM,GAAG,CAAC,IAAKH,QAAQ,EAAE;IAC1B,MAAML,KAAK,GAAGK,QAAQ,CAACG,MAAM,GAAG,CAAC,CAAC;IAClC,MAAMP,KAAK,GAAGN,MAAM,CAACK,KAAK,CAAC;;IAE3B;IACA,IAAI,CAACC,KAAK,EAAE;MACR,OAAON,MAAM,CAACI,MAAM,GAAG,CAAC;IAC5B;;IAEA;AACR;AACA;AACA;IACQ,IAAIE,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC,GAAGK,MAAM,EAAE;MACzB,OAAOR,KAAK,GAAG,CAAC;IACpB;IACA,OAAOA,KAAK;EAChB;EACA,OAAOL,MAAM,CAACI,MAAM,GAAG,CAAC;AAC5B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}