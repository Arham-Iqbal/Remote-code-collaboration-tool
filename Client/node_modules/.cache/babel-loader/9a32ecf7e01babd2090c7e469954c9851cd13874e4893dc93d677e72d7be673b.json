{"ast":null,"code":"/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  getGraphemeCount\n} = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce minimum and maximum identifier lengths\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/id-length\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        min: {\n          type: \"integer\",\n          default: 2\n        },\n        max: {\n          type: \"integer\"\n        },\n        exceptions: {\n          type: \"array\",\n          uniqueItems: true,\n          items: {\n            type: \"string\"\n          }\n        },\n        exceptionPatterns: {\n          type: \"array\",\n          uniqueItems: true,\n          items: {\n            type: \"string\"\n          }\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n      tooShortPrivate: \"Identifier name '#{{name}}' is too short (< {{min}}).\",\n      tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\",\n      tooLongPrivate: \"Identifier name #'{{name}}' is too long (> {{max}}).\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n    const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n    const properties = options.properties !== \"never\";\n    const exceptions = new Set(options.exceptions);\n    const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, \"u\"));\n    const reportedNodes = new Set();\n\n    /**\n     * Checks if a string matches the provided exception patterns\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is a match\n     * @private\n     */\n    function matchesExceptionPattern(name) {\n      return exceptionPatterns.some(pattern => pattern.test(name));\n    }\n    const SUPPORTED_EXPRESSIONS = {\n      MemberExpression: properties && function (parent) {\n        return !parent.computed && (\n        // regular property assignment\n        parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n        // or the last identifier in an ObjectPattern destructuring\n        parent.parent.type === \"Property\" && parent.parent.value === parent && parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent);\n      },\n      AssignmentPattern(parent, node) {\n        return parent.left === node;\n      },\n      VariableDeclarator(parent, node) {\n        return parent.id === node;\n      },\n      Property(parent, node) {\n        if (parent.parent.type === \"ObjectPattern\") {\n          const isKeyAndValueSame = parent.value.name === parent.key.name;\n          return !isKeyAndValueSame && parent.value === node || isKeyAndValueSame && parent.key === node && properties;\n        }\n        return properties && !parent.computed && parent.key.name === node.name;\n      },\n      ImportDefaultSpecifier: true,\n      RestElement: true,\n      FunctionExpression: true,\n      ArrowFunctionExpression: true,\n      ClassDeclaration: true,\n      FunctionDeclaration: true,\n      MethodDefinition: true,\n      PropertyDefinition: true,\n      CatchClause: true,\n      ArrayPattern: true\n    };\n    return {\n      [[\"Identifier\", \"PrivateIdentifier\"]](node) {\n        const name = node.name;\n        const parent = node.parent;\n        const nameLength = getGraphemeCount(name);\n        const isShort = nameLength < minLength;\n        const isLong = nameLength > maxLength;\n        if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\n          return; // Nothing to report\n        }\n        const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n        /*\n         * We used the range instead of the node because it's possible\n         * for the same identifier to be represented by two different\n         * nodes, with the most clear example being shorthand properties:\n         * { foo }\n         * In this case, \"foo\" is represented by one node for the name\n         * and one for the value. The only way to know they are the same\n         * is to look at the range.\n         */\n        if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {\n          reportedNodes.add(node.range.toString());\n          let messageId = isShort ? \"tooShort\" : \"tooLong\";\n          if (node.type === \"PrivateIdentifier\") {\n            messageId += \"Private\";\n          }\n          context.report({\n            node,\n            messageId,\n            data: {\n              name,\n              min: minLength,\n              max: maxLength\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["getGraphemeCount","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","min","default","max","exceptions","uniqueItems","items","exceptionPatterns","enum","additionalProperties","messages","tooShort","tooShortPrivate","tooLong","tooLongPrivate","create","context","options","minLength","maxLength","Infinity","Set","map","pattern","RegExp","reportedNodes","matchesExceptionPattern","name","some","test","SUPPORTED_EXPRESSIONS","MemberExpression","parent","computed","left","value","AssignmentPattern","node","VariableDeclarator","id","Property","isKeyAndValueSame","key","ImportDefaultSpecifier","RestElement","FunctionExpression","ArrowFunctionExpression","ClassDeclaration","FunctionDeclaration","MethodDefinition","PropertyDefinition","CatchClause","ArrayPattern","nameLength","isShort","isLong","has","isValidExpression","range","toString","add","messageId","report","data"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/id-length.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { getGraphemeCount } = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce minimum and maximum identifier lengths\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/id-length\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    min: {\n                        type: \"integer\",\n                        default: 2\n                    },\n                    max: {\n                        type: \"integer\"\n                    },\n                    exceptions: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    exceptionPatterns: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n            tooShortPrivate: \"Identifier name '#{{name}}' is too short (< {{min}}).\",\n            tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\",\n            tooLongPrivate: \"Identifier name #'{{name}}' is too long (> {{max}}).\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n        const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n        const properties = options.properties !== \"never\";\n        const exceptions = new Set(options.exceptions);\n        const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, \"u\"));\n        const reportedNodes = new Set();\n\n        /**\n         * Checks if a string matches the provided exception patterns\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function matchesExceptionPattern(name) {\n            return exceptionPatterns.some(pattern => pattern.test(name));\n        }\n\n        const SUPPORTED_EXPRESSIONS = {\n            MemberExpression: properties && function(parent) {\n                return !parent.computed && (\n\n                    // regular property assignment\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n\n                    // or the last identifier in an ObjectPattern destructuring\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\n                );\n            },\n            AssignmentPattern(parent, node) {\n                return parent.left === node;\n            },\n            VariableDeclarator(parent, node) {\n                return parent.id === node;\n            },\n            Property(parent, node) {\n\n                if (parent.parent.type === \"ObjectPattern\") {\n                    const isKeyAndValueSame = parent.value.name === parent.key.name;\n\n                    return (\n                        !isKeyAndValueSame && parent.value === node ||\n                        isKeyAndValueSame && parent.key === node && properties\n                    );\n                }\n                return properties && !parent.computed && parent.key.name === node.name;\n            },\n            ImportDefaultSpecifier: true,\n            RestElement: true,\n            FunctionExpression: true,\n            ArrowFunctionExpression: true,\n            ClassDeclaration: true,\n            FunctionDeclaration: true,\n            MethodDefinition: true,\n            PropertyDefinition: true,\n            CatchClause: true,\n            ArrayPattern: true\n        };\n\n        return {\n            [[\n                \"Identifier\",\n                \"PrivateIdentifier\"\n            ]](node) {\n                const name = node.name;\n                const parent = node.parent;\n\n                const nameLength = getGraphemeCount(name);\n\n                const isShort = nameLength < minLength;\n                const isLong = nameLength > maxLength;\n\n                if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\n                    return; // Nothing to report\n                }\n\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n                /*\n                 * We used the range instead of the node because it's possible\n                 * for the same identifier to be represented by two different\n                 * nodes, with the most clear example being shorthand properties:\n                 * { foo }\n                 * In this case, \"foo\" is represented by one node for the name\n                 * and one for the value. The only way to know they are the same\n                 * is to look at the range.\n                 */\n                if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {\n                    reportedNodes.add(node.range.toString());\n\n                    let messageId = isShort ? \"tooShort\" : \"tooLong\";\n\n                    if (node.type === \"PrivateIdentifier\") {\n                        messageId += \"Private\";\n                    }\n\n                    context.report({\n                        node,\n                        messageId,\n                        data: { name, min: minLength, max: maxLength }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}