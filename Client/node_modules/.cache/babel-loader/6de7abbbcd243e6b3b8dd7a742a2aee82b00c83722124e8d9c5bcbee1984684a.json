{"ast":null,"code":"/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n  const parent = node.parent;\n  if (parent) {\n    switch (parent.type) {\n      case \"WhileStatement\":\n        return node === parent.test;\n      case \"DoWhileStatement\":\n        return node === parent.body;\n      case \"ForStatement\":\n        return node === (parent.update || parent.test || parent.body);\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        return node === parent.left;\n\n      // no default\n    }\n  }\n  return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n  return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow loops with a body that allows only one iteration\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-unreachable-loop\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignore: {\n          type: \"array\",\n          items: {\n            enum: allLoopTypes\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalid: \"Invalid loop. Its body allows only one iteration.\"\n    }\n  },\n  create(context) {\n    const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n      loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n      loopSelector = loopTypesToCheck.join(\",\"),\n      loopsByTargetSegments = new Map(),\n      loopsToReport = new Set();\n    const codePathSegments = [];\n    let currentCodePathSegments = new Set();\n    return {\n      onCodePathStart() {\n        codePathSegments.push(currentCodePathSegments);\n        currentCodePathSegments = new Set();\n      },\n      onCodePathEnd() {\n        currentCodePathSegments = codePathSegments.pop();\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        currentCodePathSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        currentCodePathSegments.delete(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        currentCodePathSegments.delete(segment);\n      },\n      onCodePathSegmentStart(segment, node) {\n        currentCodePathSegments.add(segment);\n        if (isLoopingTarget(node)) {\n          const loop = node.parent;\n          loopsByTargetSegments.set(segment, loop);\n        }\n      },\n      onCodePathSegmentLoop(_, toSegment, node) {\n        const loop = loopsByTargetSegments.get(toSegment);\n\n        /**\n         * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n         * only if there is at least one loop event with the appropriate target (which has been already\n         * determined in the `loopsByTargetSegments` map), raised from either:\n         *\n         * - the end of the loop's body (in which case `node === loop`)\n         * - a `continue` statement\n         *\n         * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n         */\n        if (node === loop || node.type === \"ContinueStatement\") {\n          // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n          loopsToReport.delete(loop);\n        }\n      },\n      [loopSelector](node) {\n        /**\n         * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n         * For unreachable segments, the code path analysis does not raise events required for this implementation.\n         */\n        if (isAnySegmentReachable(currentCodePathSegments)) {\n          loopsToReport.add(node);\n        }\n      },\n      \"Program:exit\"() {\n        loopsToReport.forEach(node => context.report({\n          node,\n          messageId: \"invalid\"\n        }));\n      }\n    };\n  }\n};","map":{"version":3,"names":["allLoopTypes","isAnySegmentReachable","segments","segment","reachable","isLoopingTarget","node","parent","type","test","body","update","left","getDifference","arrA","arrB","filter","a","includes","module","exports","meta","docs","description","recommended","url","schema","properties","ignore","items","enum","uniqueItems","additionalProperties","messages","invalid","create","context","ignoredLoopTypes","options","loopTypesToCheck","loopSelector","join","loopsByTargetSegments","Map","loopsToReport","Set","codePathSegments","currentCodePathSegments","onCodePathStart","push","onCodePathEnd","pop","onUnreachableCodePathSegmentStart","add","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentEnd","onCodePathSegmentStart","loop","set","onCodePathSegmentLoop","_","toSegment","get","Program:exit","forEach","report","messageId"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-unreachable-loop.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n    const parent = node.parent;\n\n    if (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n                return node === parent.test;\n            case \"DoWhileStatement\":\n                return node === parent.body;\n            case \"ForStatement\":\n                return node === (parent.update || parent.test || parent.body);\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                return node === parent.left;\n\n            // no default\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n    return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow loops with a body that allows only one iteration\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-unreachable-loop\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        enum: allLoopTypes\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            invalid: \"Invalid loop. Its body allows only one iteration.\"\n        }\n    },\n\n    create(context) {\n        const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n            loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n            loopSelector = loopTypesToCheck.join(\",\"),\n            loopsByTargetSegments = new Map(),\n            loopsToReport = new Set();\n\n        const codePathSegments = [];\n        let currentCodePathSegments = new Set();\n\n        return {\n\n            onCodePathStart() {\n                codePathSegments.push(currentCodePathSegments);\n                currentCodePathSegments = new Set();\n            },\n\n            onCodePathEnd() {\n                currentCodePathSegments = codePathSegments.pop();\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment, node) {\n\n                currentCodePathSegments.add(segment);\n\n                if (isLoopingTarget(node)) {\n                    const loop = node.parent;\n\n                    loopsByTargetSegments.set(segment, loop);\n                }\n            },\n\n            onCodePathSegmentLoop(_, toSegment, node) {\n                const loop = loopsByTargetSegments.get(toSegment);\n\n                /**\n                 * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n                 * only if there is at least one loop event with the appropriate target (which has been already\n                 * determined in the `loopsByTargetSegments` map), raised from either:\n                 *\n                 * - the end of the loop's body (in which case `node === loop`)\n                 * - a `continue` statement\n                 *\n                 * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n                 */\n                if (node === loop || node.type === \"ContinueStatement\") {\n\n                    // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n                    loopsToReport.delete(loop);\n                }\n            },\n\n            [loopSelector](node) {\n\n                /**\n                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n                 * For unreachable segments, the code path analysis does not raise events required for this implementation.\n                 */\n                if (isAnySegmentReachable(currentCodePathSegments)) {\n                    loopsToReport.add(node);\n                }\n            },\n\n\n            \"Program:exit\"() {\n                loopsToReport.forEach(\n                    node => context.report({ node, messageId: \"invalid\" })\n                );\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}