{"ast":null,"code":"/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce consistent naming when capturing the current execution context\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/consistent-this\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        minLength: 1\n      },\n      uniqueItems: true\n    },\n    messages: {\n      aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n      unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n    }\n  },\n  create(context) {\n    let aliases = [];\n    const sourceCode = context.sourceCode;\n    if (context.options.length === 0) {\n      aliases.push(\"that\");\n    } else {\n      aliases = context.options;\n    }\n\n    /**\n     * Reports that a variable declarator or assignment expression is assigning\n     * a non-'this' value to the specified alias.\n     * @param {ASTNode} node The assigning node.\n     * @param {string} name the name of the alias that was incorrectly used.\n     * @returns {void}\n     */\n    function reportBadAssignment(node, name) {\n      context.report({\n        node,\n        messageId: \"aliasNotAssignedToThis\",\n        data: {\n          name\n        }\n      });\n    }\n\n    /**\n     * Checks that an assignment to an identifier only assigns 'this' to the\n     * appropriate alias, and the alias is only assigned to 'this'.\n     * @param {ASTNode} node The assigning node.\n     * @param {Identifier} name The name of the variable assigned to.\n     * @param {Expression} value The value of the assignment.\n     * @returns {void}\n     */\n    function checkAssignment(node, name, value) {\n      const isThis = value.type === \"ThisExpression\";\n      if (aliases.includes(name)) {\n        if (!isThis || node.operator && node.operator !== \"=\") {\n          reportBadAssignment(node, name);\n        }\n      } else if (isThis) {\n        context.report({\n          node,\n          messageId: \"unexpectedAlias\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n\n    /**\n     * Ensures that a variable declaration of the alias in a program or function\n     * is assigned to the correct value.\n     * @param {string} alias alias the check the assignment of.\n     * @param {Object} scope scope of the current code we are checking.\n     * @private\n     * @returns {void}\n     */\n    function checkWasAssigned(alias, scope) {\n      const variable = scope.set.get(alias);\n      if (!variable) {\n        return;\n      }\n      if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" && def.node.init !== null)) {\n        return;\n      }\n\n      /*\n       * The alias has been declared and not assigned: check it was\n       * assigned later in the same scope.\n       */\n      if (!variable.references.some(reference => {\n        const write = reference.writeExpr;\n        return reference.from === scope && write && write.type === \"ThisExpression\" && write.parent.operator === \"=\";\n      })) {\n        variable.defs.map(def => def.node).forEach(node => {\n          reportBadAssignment(node, alias);\n        });\n      }\n    }\n\n    /**\n     * Check each alias to ensure that is was assigned to the correct value.\n     * @param {ASTNode} node The node that represents the scope to check.\n     * @returns {void}\n     */\n    function ensureWasAssigned(node) {\n      const scope = sourceCode.getScope(node);\n      aliases.forEach(alias => {\n        checkWasAssigned(alias, scope);\n      });\n    }\n    return {\n      \"Program:exit\": ensureWasAssigned,\n      \"FunctionExpression:exit\": ensureWasAssigned,\n      \"FunctionDeclaration:exit\": ensureWasAssigned,\n      VariableDeclarator(node) {\n        const id = node.id;\n        const isDestructuring = id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n        if (node.init !== null && !isDestructuring) {\n          checkAssignment(node, id.name, node.init);\n        }\n      },\n      AssignmentExpression(node) {\n        if (node.left.type === \"Identifier\") {\n          checkAssignment(node, node.left.name, node.right);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","items","minLength","uniqueItems","messages","aliasNotAssignedToThis","unexpectedAlias","create","context","aliases","sourceCode","options","length","push","reportBadAssignment","node","name","report","messageId","data","checkAssignment","value","isThis","includes","operator","checkWasAssigned","alias","scope","variable","set","get","defs","some","def","init","references","reference","write","writeExpr","from","parent","map","forEach","ensureWasAssigned","getScope","VariableDeclarator","id","isDestructuring","AssignmentExpression","left","right"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/consistent-this.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce consistent naming when capturing the current execution context\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/consistent-this\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        },\n\n        messages: {\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n        const sourceCode = context.sourceCode;\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node The assigning node.\n         * @param {string} name the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, name) {\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node The assigning node.\n         * @param {Identifier} name The name of the variable assigned to.\n         * @param {Expression} value The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.includes(name)) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            /*\n             * The alias has been declared and not assigned: check it was\n             * assigned later in the same scope.\n             */\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assigned to the correct value.\n         * @param {ASTNode} node The node that represents the scope to check.\n         * @returns {void}\n         */\n        function ensureWasAssigned(node) {\n            const scope = sourceCode.getScope(node);\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}