{"ast":null,"code":"/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n  for (const reference of scope.references) {\n    if (reference.resolved === null) {\n      continue;\n    }\n    outReferenceMap.set(reference.identifier, reference);\n  }\n  for (const childScope of scope.childScopes) {\n    if (childScope.type !== \"function\") {\n      createReferenceMap(childScope, outReferenceMap);\n    }\n  }\n  return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n  if (reference.writeExpr) {\n    return reference.writeExpr;\n  }\n  let node = reference.identifier;\n  while (node) {\n    const t = node.parent.type;\n    if (t === \"AssignmentExpression\" && node.parent.left === node) {\n      return node.parent.right;\n    }\n    if (t === \"MemberExpression\" && node.parent.object === node) {\n      node = node.parent;\n      continue;\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n  if (!variable) {\n    return false; // A global variable which was not defined.\n  }\n\n  // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n  if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n    return false;\n  }\n  const functionScope = variable.scope.variableScope;\n  return variable.references.every(reference => reference.from.variableScope === functionScope);\n}\n\n/**\n * Represents segment information.\n */\nclass SegmentInfo {\n  constructor() {\n    this.info = new WeakMap();\n  }\n\n  /**\n   * Initialize the segment information.\n   * @param {PathSegment} segment The segment to initialize.\n   * @returns {void}\n   */\n  initialize(segment) {\n    const outdatedReadVariables = new Set();\n    const freshReadVariables = new Set();\n    for (const prevSegment of segment.prevSegments) {\n      const info = this.info.get(prevSegment);\n      if (info) {\n        info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n        info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n      }\n    }\n    this.info.set(segment, {\n      outdatedReadVariables,\n      freshReadVariables\n    });\n  }\n\n  /**\n   * Mark a given variable as read on given segments.\n   * @param {PathSegment[]} segments The segments that it read the variable on.\n   * @param {Variable} variable The variable to be read.\n   * @returns {void}\n   */\n  markAsRead(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n      if (info) {\n        info.freshReadVariables.add(variable);\n\n        // If a variable is freshly read again, then it's no more out-dated.\n        info.outdatedReadVariables.delete(variable);\n      }\n    }\n  }\n\n  /**\n   * Move `freshReadVariables` to `outdatedReadVariables`.\n   * @param {PathSegment[]} segments The segments to process.\n   * @returns {void}\n   */\n  makeOutdated(segments) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n      if (info) {\n        info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n        info.freshReadVariables.clear();\n      }\n    }\n  }\n\n  /**\n   * Check if a given variable is outdated on the current segments.\n   * @param {PathSegment[]} segments The current segments.\n   * @param {Variable} variable The variable to check.\n   * @returns {boolean} `true` if the variable is outdated on the segments.\n   */\n  isOutdated(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n      if (info && info.outdatedReadVariables.has(variable)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/require-atomic-updates\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowProperties: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\",\n      nonAtomicObjectUpdate: \"Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`.\"\n    }\n  },\n  create(context) {\n    const allowProperties = !!context.options[0] && context.options[0].allowProperties;\n    const sourceCode = context.sourceCode;\n    const assignmentReferences = new Map();\n    const segmentInfo = new SegmentInfo();\n    let stack = null;\n    return {\n      onCodePathStart(codePath, node) {\n        const scope = sourceCode.getScope(node);\n        const shouldVerify = scope.type === \"function\" && (scope.block.async || scope.block.generator);\n        stack = {\n          upper: stack,\n          codePath,\n          referenceMap: shouldVerify ? createReferenceMap(scope) : null,\n          currentSegments: new Set()\n        };\n      },\n      onCodePathEnd() {\n        stack = stack.upper;\n      },\n      // Initialize the segment information.\n      onCodePathSegmentStart(segment) {\n        segmentInfo.initialize(segment);\n        stack.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        stack.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        stack.currentSegments.delete(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        stack.currentSegments.delete(segment);\n      },\n      // Handle references to prepare verification.\n      Identifier(node) {\n        const {\n          referenceMap\n        } = stack;\n        const reference = referenceMap && referenceMap.get(node);\n\n        // Ignore if this is not a valid variable reference.\n        if (!reference) {\n          return;\n        }\n        const variable = reference.resolved;\n        const writeExpr = getWriteExpr(reference);\n        const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n        // Add a fresh read variable.\n        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n          segmentInfo.markAsRead(stack.currentSegments, variable);\n        }\n\n        /*\n         * Register the variable to verify after ESLint traversed the `writeExpr` node\n         * if this reference is an assignment to a variable which is referred from other closure.\n         */\n        if (writeExpr && writeExpr.parent.right === writeExpr &&\n        // ‚Üê exclude variable declarations.\n        !isLocalVariableWithoutEscape(variable, isMemberAccess)) {\n          let refs = assignmentReferences.get(writeExpr);\n          if (!refs) {\n            refs = [];\n            assignmentReferences.set(writeExpr, refs);\n          }\n          refs.push(reference);\n        }\n      },\n      /*\n       * Verify assignments.\n       * If the reference exists in `outdatedReadVariables` list, report it.\n       */\n      \":expression:exit\"(node) {\n        // referenceMap exists if this is in a resumable function scope.\n        if (!stack.referenceMap) {\n          return;\n        }\n\n        // Mark the read variables on this code path as outdated.\n        if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n          segmentInfo.makeOutdated(stack.currentSegments);\n        }\n\n        // Verify.\n        const references = assignmentReferences.get(node);\n        if (references) {\n          assignmentReferences.delete(node);\n          for (const reference of references) {\n            const variable = reference.resolved;\n            if (segmentInfo.isOutdated(stack.currentSegments, variable)) {\n              if (node.parent.left === reference.identifier) {\n                context.report({\n                  node: node.parent,\n                  messageId: \"nonAtomicUpdate\",\n                  data: {\n                    value: variable.name\n                  }\n                });\n              } else if (!allowProperties) {\n                context.report({\n                  node: node.parent,\n                  messageId: \"nonAtomicObjectUpdate\",\n                  data: {\n                    value: sourceCode.getText(node.parent.left),\n                    object: variable.name\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["createReferenceMap","scope","outReferenceMap","Map","reference","references","resolved","set","identifier","childScope","childScopes","type","getWriteExpr","writeExpr","node","t","parent","left","right","object","isLocalVariableWithoutEscape","variable","isMemberAccess","defs","some","d","functionScope","variableScope","every","from","SegmentInfo","constructor","info","WeakMap","initialize","segment","outdatedReadVariables","Set","freshReadVariables","prevSegment","prevSegments","get","forEach","prototype","add","markAsRead","segments","delete","makeOutdated","clear","isOutdated","has","module","exports","meta","docs","description","recommended","url","fixable","schema","properties","allowProperties","default","additionalProperties","messages","nonAtomicUpdate","nonAtomicObjectUpdate","create","context","options","sourceCode","assignmentReferences","segmentInfo","stack","onCodePathStart","codePath","getScope","shouldVerify","block","async","generator","upper","referenceMap","currentSegments","onCodePathEnd","onCodePathSegmentStart","onUnreachableCodePathSegmentStart","onUnreachableCodePathSegmentEnd","onCodePathSegmentEnd","Identifier","isRead","operator","refs","push",":expression:exit","report","messageId","data","value","name","getText"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/require-atomic-updates.js"],"sourcesContent":["/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n    for (const reference of scope.references) {\n        if (reference.resolved === null) {\n            continue;\n        }\n\n        outReferenceMap.set(reference.identifier, reference);\n    }\n    for (const childScope of scope.childScopes) {\n        if (childScope.type !== \"function\") {\n            createReferenceMap(childScope, outReferenceMap);\n        }\n    }\n\n    return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n    if (reference.writeExpr) {\n        return reference.writeExpr;\n    }\n    let node = reference.identifier;\n\n    while (node) {\n        const t = node.parent.type;\n\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\n            return node.parent.right;\n        }\n        if (t === \"MemberExpression\" && node.parent.object === node) {\n            node = node.parent;\n            continue;\n        }\n\n        break;\n    }\n\n    return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n    if (!variable) {\n        return false; // A global variable which was not defined.\n    }\n\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n        return false;\n    }\n\n    const functionScope = variable.scope.variableScope;\n\n    return variable.references.every(reference =>\n        reference.from.variableScope === functionScope);\n}\n\n/**\n * Represents segment information.\n */\nclass SegmentInfo {\n    constructor() {\n        this.info = new WeakMap();\n    }\n\n    /**\n     * Initialize the segment information.\n     * @param {PathSegment} segment The segment to initialize.\n     * @returns {void}\n     */\n    initialize(segment) {\n        const outdatedReadVariables = new Set();\n        const freshReadVariables = new Set();\n\n        for (const prevSegment of segment.prevSegments) {\n            const info = this.info.get(prevSegment);\n\n            if (info) {\n                info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n                info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n            }\n        }\n\n        this.info.set(segment, { outdatedReadVariables, freshReadVariables });\n    }\n\n    /**\n     * Mark a given variable as read on given segments.\n     * @param {PathSegment[]} segments The segments that it read the variable on.\n     * @param {Variable} variable The variable to be read.\n     * @returns {void}\n     */\n    markAsRead(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.add(variable);\n\n                // If a variable is freshly read again, then it's no more out-dated.\n                info.outdatedReadVariables.delete(variable);\n            }\n        }\n    }\n\n    /**\n     * Move `freshReadVariables` to `outdatedReadVariables`.\n     * @param {PathSegment[]} segments The segments to process.\n     * @returns {void}\n     */\n    makeOutdated(segments) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n                info.freshReadVariables.clear();\n            }\n        }\n    }\n\n    /**\n     * Check if a given variable is outdated on the current segments.\n     * @param {PathSegment[]} segments The current segments.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is outdated on the segments.\n     */\n    isOutdated(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info && info.outdatedReadVariables.has(variable)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowProperties: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\",\n            nonAtomicObjectUpdate: \"Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`.\"\n        }\n    },\n\n    create(context) {\n        const allowProperties = !!context.options[0] && context.options[0].allowProperties;\n\n        const sourceCode = context.sourceCode;\n        const assignmentReferences = new Map();\n        const segmentInfo = new SegmentInfo();\n        let stack = null;\n\n        return {\n            onCodePathStart(codePath, node) {\n                const scope = sourceCode.getScope(node);\n                const shouldVerify =\n                    scope.type === \"function\" &&\n                    (scope.block.async || scope.block.generator);\n\n                stack = {\n                    upper: stack,\n                    codePath,\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null,\n                    currentSegments: new Set()\n                };\n            },\n            onCodePathEnd() {\n                stack = stack.upper;\n            },\n\n            // Initialize the segment information.\n            onCodePathSegmentStart(segment) {\n                segmentInfo.initialize(segment);\n                stack.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                stack.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                stack.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                stack.currentSegments.delete(segment);\n            },\n\n\n            // Handle references to prepare verification.\n            Identifier(node) {\n                const { referenceMap } = stack;\n                const reference = referenceMap && referenceMap.get(node);\n\n                // Ignore if this is not a valid variable reference.\n                if (!reference) {\n                    return;\n                }\n                const variable = reference.resolved;\n                const writeExpr = getWriteExpr(reference);\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n                // Add a fresh read variable.\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n                    segmentInfo.markAsRead(stack.currentSegments, variable);\n                }\n\n                /*\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\n                 * if this reference is an assignment to a variable which is referred from other closure.\n                 */\n                if (writeExpr &&\n                    writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\n                ) {\n                    let refs = assignmentReferences.get(writeExpr);\n\n                    if (!refs) {\n                        refs = [];\n                        assignmentReferences.set(writeExpr, refs);\n                    }\n\n                    refs.push(reference);\n                }\n            },\n\n            /*\n             * Verify assignments.\n             * If the reference exists in `outdatedReadVariables` list, report it.\n             */\n            \":expression:exit\"(node) {\n\n                // referenceMap exists if this is in a resumable function scope.\n                if (!stack.referenceMap) {\n                    return;\n                }\n\n                // Mark the read variables on this code path as outdated.\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n                    segmentInfo.makeOutdated(stack.currentSegments);\n                }\n\n                // Verify.\n                const references = assignmentReferences.get(node);\n\n                if (references) {\n                    assignmentReferences.delete(node);\n\n                    for (const reference of references) {\n                        const variable = reference.resolved;\n\n                        if (segmentInfo.isOutdated(stack.currentSegments, variable)) {\n                            if (node.parent.left === reference.identifier) {\n                                context.report({\n                                    node: node.parent,\n                                    messageId: \"nonAtomicUpdate\",\n                                    data: {\n                                        value: variable.name\n                                    }\n                                });\n                            } else if (!allowProperties) {\n                                context.report({\n                                    node: node.parent,\n                                    messageId: \"nonAtomicObjectUpdate\",\n                                    data: {\n                                        value: sourceCode.getText(node.parent.left),\n                                        object: variable.name\n                                    }\n                                });\n                            }\n\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}