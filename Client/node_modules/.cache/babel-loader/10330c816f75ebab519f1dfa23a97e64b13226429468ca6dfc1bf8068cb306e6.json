{"ast":null,"code":"/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  KEYS: eslintVisitorKeys\n} = require(\"eslint-visitor-keys\");\nconst esutils = require(\"esutils\");\nconst espree = require(\"espree\");\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst {\n  breakableTypePattern,\n  createGlobalLinebreakMatcher,\n  lineBreakPattern,\n  shebangPattern\n} = require(\"../../shared/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayMethodWithThisArgPattern = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|some)$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst ESLINT_DIRECTIVE_PATTERN = /^(?:eslint[- ]|(?:globals?|exported) )/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"StaticBlock\", \"SwitchCase\"]);\nconst DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\\d*|[1-9](?:_?\\d)*)$/u;\n\n// Tests the presence of at least one LegacyOctalEscapeSequence or NonOctalDecimalEscapeSequence in a raw string\nconst OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\.)*\\\\(?:[1-9]|0[0-9])/su;\nconst LOGICAL_ASSIGNMENT_OPERATORS = new Set([\"&&=\", \"||=\", \"??=\"]);\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference A reference to check.\n * @param {int} index The index of the reference in the references.\n * @param {Reference[]} references The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n  const identifier = reference.identifier;\n\n  /*\n   * Destructuring assignments can have multiple default value, so\n   * possibly there are multiple writeable references for the same\n   * identifier.\n   */\n  const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;\n  return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n * @param {string} s The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n  return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node A function node to check.\n * @returns {boolean} Whether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n  return node.id && startsWithUpperCase(node.id.name);\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (anyFunctionPattern.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n  return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n  return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n  return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n  for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n    if (isLoop(currentNode)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Determines whether the given node is a `null` literal.\n * @param {ASTNode} node The node to check\n * @returns {boolean} `true` if the node is a `null` literal\n */\nfunction isNullLiteral(node) {\n  /*\n   * Checking `node.value === null` does not guarantee that a literal is a null literal.\n   * When parsing values that cannot be represented in the current environment (e.g. unicode\n   * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n   * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n   * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n   */\n  return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n  return isNullLiteral(node) || node.type === \"Identifier\" && node.name === \"undefined\" || node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n  return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Returns the result of the string conversion applied to the evaluated value of the given expression node,\n * if it can be determined statically.\n *\n * This function returns a `string` value for all `Literal` nodes and simple `TemplateLiteral` nodes only.\n * In all other cases, this function returns `null`.\n * @param {ASTNode} node Expression node.\n * @returns {string|null} String value if it can be determined. Otherwise, `null`.\n */\nfunction getStaticStringValue(node) {\n  switch (node.type) {\n    case \"Literal\":\n      if (node.value === null) {\n        if (isNullLiteral(node)) {\n          return String(node.value); // \"null\"\n        }\n        if (node.regex) {\n          return `/${node.regex.pattern}/${node.regex.flags}`;\n        }\n        if (node.bigint) {\n          return node.bigint;\n        }\n\n        // Otherwise, this is an unknown literal. The function will return null.\n      } else {\n        return String(node.value);\n      }\n      break;\n    case \"TemplateLiteral\":\n      if (node.expressions.length === 0 && node.quasis.length === 1) {\n        return node.quasis[0].value.cooked;\n      }\n      break;\n\n    // no default\n  }\n  return null;\n}\n\n/**\n * Gets the property name of a given node.\n * The node can be a MemberExpression, a Property, or a MethodDefinition.\n *\n * If the name is dynamic, this returns `null`.\n *\n * For examples:\n *\n *     a.b           // => \"b\"\n *     a[\"b\"]        // => \"b\"\n *     a['b']        // => \"b\"\n *     a[`b`]        // => \"b\"\n *     a[100]        // => \"100\"\n *     a[b]          // => null\n *     a[\"a\" + \"b\"]  // => null\n *     a[tag`b`]     // => null\n *     a[`${b}`]     // => null\n *\n *     let a = {b: 1}            // => \"b\"\n *     let a = {[\"b\"]: 1}        // => \"b\"\n *     let a = {['b']: 1}        // => \"b\"\n *     let a = {[`b`]: 1}        // => \"b\"\n *     let a = {[100]: 1}        // => \"100\"\n *     let a = {[b]: 1}          // => null\n *     let a = {[\"a\" + \"b\"]: 1}  // => null\n *     let a = {[tag`b`]: 1}     // => null\n *     let a = {[`${b}`]: 1}     // => null\n * @param {ASTNode} node The node to get.\n * @returns {string|null} The property name if static. Otherwise, null.\n */\nfunction getStaticPropertyName(node) {\n  let prop;\n  switch (node && node.type) {\n    case \"ChainExpression\":\n      return getStaticPropertyName(node.expression);\n    case \"Property\":\n    case \"PropertyDefinition\":\n    case \"MethodDefinition\":\n      prop = node.key;\n      break;\n    case \"MemberExpression\":\n      prop = node.property;\n      break;\n\n    // no default\n  }\n  if (prop) {\n    if (prop.type === \"Identifier\" && !node.computed) {\n      return prop.name;\n    }\n    return getStaticStringValue(prop);\n  }\n  return null;\n}\n\n/**\n * Retrieve `ChainExpression#expression` value if the given node a `ChainExpression` node. Otherwise, pass through it.\n * @param {ASTNode} node The node to address.\n * @returns {ASTNode} The `ChainExpression#expression` value if the node is a `ChainExpression` node. Otherwise, the node.\n */\nfunction skipChainExpression(node) {\n  return node && node.type === \"ChainExpression\" ? node.expression : node;\n}\n\n/**\n * Check if the `actual` is an expected value.\n * @param {string} actual The string value to check.\n * @param {string | RegExp} expected The expected string value or pattern.\n * @returns {boolean} `true` if the `actual` is an expected value.\n */\nfunction checkText(actual, expected) {\n  return typeof expected === \"string\" ? actual === expected : expected.test(actual);\n}\n\n/**\n * Check if a given node is an Identifier node with a given name.\n * @param {ASTNode} node The node to check.\n * @param {string | RegExp} name The expected name or the expected pattern of the object name.\n * @returns {boolean} `true` if the node is an Identifier node with the name.\n */\nfunction isSpecificId(node, name) {\n  return node.type === \"Identifier\" && checkText(node.name, name);\n}\n\n/**\n * Check if a given node is member access with a given object name and property name pair.\n * This is regardless of optional or not.\n * @param {ASTNode} node The node to check.\n * @param {string | RegExp | null} objectName The expected name or the expected pattern of the object name. If this is nullish, this method doesn't check object.\n * @param {string | RegExp | null} propertyName The expected name or the expected pattern of the property name. If this is nullish, this method doesn't check property.\n * @returns {boolean} `true` if the node is member access with the object name and property name pair.\n * The node is a `MemberExpression` or `ChainExpression`.\n */\nfunction isSpecificMemberAccess(node, objectName, propertyName) {\n  const checkNode = skipChainExpression(node);\n  if (checkNode.type !== \"MemberExpression\") {\n    return false;\n  }\n  if (objectName && !isSpecificId(checkNode.object, objectName)) {\n    return false;\n  }\n  if (propertyName) {\n    const actualPropertyName = getStaticPropertyName(checkNode);\n    if (typeof actualPropertyName !== \"string\" || !checkText(actualPropertyName, propertyName)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if two literal nodes are the same value.\n * @param {ASTNode} left The Literal node to compare.\n * @param {ASTNode} right The other Literal node to compare.\n * @returns {boolean} `true` if the two literal nodes are the same value.\n */\nfunction equalLiteralValue(left, right) {\n  // RegExp literal.\n  if (left.regex || right.regex) {\n    return Boolean(left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags);\n  }\n\n  // BigInt literal.\n  if (left.bigint || right.bigint) {\n    return left.bigint === right.bigint;\n  }\n  return left.value === right.value;\n}\n\n/**\n * Check if two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param {ASTNode} left The left side of the comparison.\n * @param {ASTNode} right The right side of the comparison.\n * @param {boolean} [disableStaticComputedKey] Don't address `a.b` and `a[\"b\"]` are the same if `true`. For backward compatibility.\n * @returns {boolean} `true` if both sides match and reference the same value.\n */\nfunction isSameReference(left, right, disableStaticComputedKey = false) {\n  if (left.type !== right.type) {\n    // Handle `a.b` and `a?.b` are samely.\n    if (left.type === \"ChainExpression\") {\n      return isSameReference(left.expression, right, disableStaticComputedKey);\n    }\n    if (right.type === \"ChainExpression\") {\n      return isSameReference(left, right.expression, disableStaticComputedKey);\n    }\n    return false;\n  }\n  switch (left.type) {\n    case \"Super\":\n    case \"ThisExpression\":\n      return true;\n    case \"Identifier\":\n    case \"PrivateIdentifier\":\n      return left.name === right.name;\n    case \"Literal\":\n      return equalLiteralValue(left, right);\n    case \"ChainExpression\":\n      return isSameReference(left.expression, right.expression, disableStaticComputedKey);\n    case \"MemberExpression\":\n      {\n        if (!disableStaticComputedKey) {\n          const nameA = getStaticPropertyName(left);\n\n          // x.y = x[\"y\"]\n          if (nameA !== null) {\n            return isSameReference(left.object, right.object, disableStaticComputedKey) && nameA === getStaticPropertyName(right);\n          }\n        }\n\n        /*\n         * x[0] = x[0]\n         * x[y] = x[y]\n         * x.y = x.y\n         */\n        return left.computed === right.computed && isSameReference(left.object, right.object, disableStaticComputedKey) && isSameReference(left.property, right.property, disableStaticComputedKey);\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n  return isSpecificMemberAccess(node, \"Reflect\", \"apply\");\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n  return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, \"from\");\n}\n\n/**\n * Checks whether or not a node is a method which expects a function as a first argument, and `thisArg` as a second argument.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a method which expects a function as a first argument, and `thisArg` as a second argument.\n */\nfunction isMethodWhichHasThisArg(node) {\n  return isSpecificMemberAccess(node, null, arrayMethodWithThisArgPattern);\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n  return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node A node to check.\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n  const jsdocComment = sourceCode.getJSDocComment(node);\n  if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n    return true;\n  }\n\n  // Checks `@this` in its leading comments for callbacks,\n  // because callbacks don't have its JSDoc comment.\n  // e.g.\n  //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n  return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n  const previousToken = sourceCode.getTokenBefore(node),\n    nextToken = sourceCode.getTokenAfter(node);\n  return Boolean(previousToken && nextToken) && previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] && nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is a `=` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `=` token.\n */\nfunction isEqToken(token) {\n  return token.value === \"=\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n  return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n  return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a dot token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a dot token.\n */\nfunction isDotToken(token) {\n  return token.value === \".\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a `?.` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `?.` token.\n */\nfunction isQuestionDotToken(token) {\n  return token.value === \"?.\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n  return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n  return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n  return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n  return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n  return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n  return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n  return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n  return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n  return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n  return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n * @param {ASTNode} node The function node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n  // If the node is an arrow function and doesn't have parens, this returns the identifier of the first param.\n  if (node.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    const argToken = sourceCode.getFirstToken(node.params[0]);\n    const maybeParenToken = sourceCode.getTokenBefore(argToken);\n    return isOpeningParenToken(maybeParenToken) ? maybeParenToken : argToken;\n  }\n\n  // Otherwise, returns paren.\n  return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left A node 1 to compare.\n * @param {ASTNode} right A node 2 to compare.\n * @param {SourceCode} sourceCode The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n  const tokensL = sourceCode.getTokens(left);\n  const tokensR = sourceCode.getTokens(right);\n  if (tokensL.length !== tokensR.length) {\n    return false;\n  }\n  for (let i = 0; i < tokensL.length; ++i) {\n    if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if the given node is a true logical expression or not.\n *\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\n * coalesce (`??`) are known as `ShortCircuitExpression`.\n * But ESTree represents those by `LogicalExpression` node.\n *\n * This function rejects coalesce expressions of `LogicalExpression` node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `&&` or `||`.\n * @see https://tc39.es/ecma262/#prod-ShortCircuitExpression\n */\nfunction isLogicalExpression(node) {\n  return node.type === \"LogicalExpression\" && (node.operator === \"&&\" || node.operator === \"||\");\n}\n\n/**\n * Check if the given node is a nullish coalescing expression or not.\n *\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\n * coalesce (`??`) are known as `ShortCircuitExpression`.\n * But ESTree represents those by `LogicalExpression` node.\n *\n * This function finds only coalesce expressions of `LogicalExpression` node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `??`.\n */\nfunction isCoalesceExpression(node) {\n  return node.type === \"LogicalExpression\" && node.operator === \"??\";\n}\n\n/**\n * Check if given two nodes are the pair of a logical expression and a coalesce expression.\n * @param {ASTNode} left A node to check.\n * @param {ASTNode} right Another node to check.\n * @returns {boolean} `true` if the two nodes are the pair of a logical expression and a coalesce expression.\n */\nfunction isMixedLogicalAndCoalesceExpressions(left, right) {\n  return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);\n}\n\n/**\n * Checks if the given operator is a logical assignment operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} `true` if the operator is a logical assignment operator.\n */\nfunction isLogicalAssignmentOperator(operator) {\n  return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);\n}\n\n/**\n * Get the colon token of the given SwitchCase node.\n * @param {ASTNode} node The SwitchCase node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} The colon token of the node.\n */\nfunction getSwitchCaseColonToken(node, sourceCode) {\n  if (node.test) {\n    return sourceCode.getTokenAfter(node.test, isColonToken);\n  }\n  return sourceCode.getFirstToken(node, 1);\n}\n\n/**\n * Gets ESM module export name represented by the given node.\n * @param {ASTNode} node `Identifier` or string `Literal` node in a position\n * that represents a module export name:\n *   - `ImportSpecifier#imported`\n *   - `ExportSpecifier#local` (if it is a re-export from another module)\n *   - `ExportSpecifier#exported`\n *   - `ExportAllDeclaration#exported`\n * @returns {string} The module export name.\n */\nfunction getModuleExportName(node) {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  }\n\n  // string literal\n  return node.value;\n}\n\n/**\n * Returns literal's value converted to the Boolean type\n * @param {ASTNode} node any `Literal` node\n * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n *  `null` when it cannot be determined.\n */\nfunction getBooleanValue(node) {\n  if (node.value === null) {\n    /*\n     * it might be a null literal or bigint/regex literal in unsupported environments .\n     * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n     * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n     */\n\n    if (node.raw === \"null\") {\n      return false;\n    }\n\n    // regex is always truthy\n    if (typeof node.regex === \"object\") {\n      return true;\n    }\n    return null;\n  }\n  return !!node.value;\n}\n\n/**\n * Checks if a branch node of LogicalExpression short circuits the whole condition\n * @param {ASTNode} node The branch of main condition which needs to be checked\n * @param {string} operator The operator of the main LogicalExpression.\n * @returns {boolean} true when condition short circuits whole condition\n */\nfunction isLogicalIdentity(node, operator) {\n  switch (node.type) {\n    case \"Literal\":\n      return operator === \"||\" && getBooleanValue(node) === true || operator === \"&&\" && getBooleanValue(node) === false;\n    case \"UnaryExpression\":\n      return operator === \"&&\" && node.operator === \"void\";\n    case \"LogicalExpression\":\n      /*\n       * handles `a && false || b`\n       * `false` is an identity element of `&&` but not `||`\n       */\n      return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));\n    case \"AssignmentExpression\":\n      return [\"||=\", \"&&=\"].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);\n\n    // no default\n  }\n  return false;\n}\n\n/**\n * Checks if an identifier is a reference to a global variable.\n * @param {Scope} scope The scope in which the identifier is referenced.\n * @param {ASTNode} node An identifier node to check.\n * @returns {boolean} `true` if the identifier is a reference to a global variable.\n */\nfunction isReferenceToGlobalVariable(scope, node) {\n  const reference = scope.references.find(ref => ref.identifier === node);\n  return Boolean(reference && reference.resolved && reference.resolved.scope.type === \"global\" && reference.resolved.defs.length === 0);\n}\n\n/**\n * Checks if a  node has a constant truthiness value.\n * @param {Scope} scope Scope in which the node appears.\n * @param {ASTNode} node The AST node to check.\n * @param {boolean} inBooleanPosition `true` if checking the test of a\n * condition. `false` in all other cases. When `false`, checks if -- for\n * both string and number -- if coerced to that type, the value will\n * be constant.\n * @returns {boolean} true when node's truthiness is constant\n * @private\n */\nfunction isConstant(scope, node, inBooleanPosition) {\n  // node.elements can return null values in the case of sparse arrays ex. [,]\n  if (!node) {\n    return true;\n  }\n  switch (node.type) {\n    case \"Literal\":\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n      return true;\n    case \"ClassExpression\":\n    case \"ObjectExpression\":\n      /**\n       * In theory objects like:\n       *\n       * `{toString: () => a}`\n       * `{valueOf: () => a}`\n       *\n       * Or a classes like:\n       *\n       * `class { static toString() { return a } }`\n       * `class { static valueOf() { return a } }`\n       *\n       * Are not constant verifiably when `inBooleanPosition` is\n       * false, but it's an edge case we've opted not to handle.\n       */\n      return true;\n    case \"TemplateLiteral\":\n      return inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length) || node.expressions.every(exp => isConstant(scope, exp, false));\n    case \"ArrayExpression\":\n      {\n        if (!inBooleanPosition) {\n          return node.elements.every(element => isConstant(scope, element, false));\n        }\n        return true;\n      }\n    case \"UnaryExpression\":\n      if (node.operator === \"void\" || node.operator === \"typeof\" && inBooleanPosition) {\n        return true;\n      }\n      if (node.operator === \"!\") {\n        return isConstant(scope, node.argument, true);\n      }\n      return isConstant(scope, node.argument, false);\n    case \"BinaryExpression\":\n      return isConstant(scope, node.left, false) && isConstant(scope, node.right, false) && node.operator !== \"in\";\n    case \"LogicalExpression\":\n      {\n        const isLeftConstant = isConstant(scope, node.left, inBooleanPosition);\n        const isRightConstant = isConstant(scope, node.right, inBooleanPosition);\n        const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);\n        const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);\n        return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;\n      }\n    case \"NewExpression\":\n      return inBooleanPosition;\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return isConstant(scope, node.right, inBooleanPosition);\n      }\n      if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n        return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n      }\n      return false;\n    case \"SequenceExpression\":\n      return isConstant(scope, node.expressions[node.expressions.length - 1], inBooleanPosition);\n    case \"SpreadElement\":\n      return isConstant(scope, node.argument, inBooleanPosition);\n    case \"CallExpression\":\n      if (node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\") {\n        if (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true)) {\n          return isReferenceToGlobalVariable(scope, node.callee);\n        }\n      }\n      return false;\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n\n    // no default\n  }\n  return false;\n}\n\n/**\n * Checks whether a node is an ExpressionStatement at the top level of a file or function body.\n * A top-level ExpressionStatement node is a directive if it contains a single unparenthesized\n * string literal and if it occurs either as the first sibling or immediately after another\n * directive.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the node is an ExpressionStatement at the top level of a\n * file or function body.\n */\nfunction isTopLevelExpressionStatement(node) {\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n  const parent = node.parent;\n  return parent.type === \"Program\" || parent.type === \"BlockStatement\" && isFunction(parent.parent);\n}\n\n/**\n * Check whether the given node is a part of a directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirective(node) {\n  return node.type === \"ExpressionStatement\" && typeof node.directive === \"string\";\n}\n\n/**\n * Tests if a node appears at the beginning of an ancestor ExpressionStatement node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether the node appears at the beginning of an ancestor ExpressionStatement node.\n */\nfunction isStartOfExpressionStatement(node) {\n  const start = node.range[0];\n  let ancestor = node;\n  while ((ancestor = ancestor.parent) && ancestor.range[0] === start) {\n    if (ancestor.type === \"ExpressionStatement\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Determines whether an opening parenthesis `(`, bracket `[` or backtick ``` ` ``` needs to be preceded by a semicolon.\n * This opening parenthesis or bracket should be at the start of an `ExpressionStatement` or at the start of the body of an `ArrowFunctionExpression`.\n * @type {(sourceCode: SourceCode, node: ASTNode) => boolean}\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode} node A node at the position where an opening parenthesis or bracket will be inserted.\n * @returns {boolean} Whether a semicolon is required before the opening parenthesis or braket.\n */\nlet needsPrecedingSemicolon;\n{\n  const BREAK_OR_CONTINUE = new Set([\"BreakStatement\", \"ContinueStatement\"]);\n\n  // Declaration types that must contain a string Literal node at the end.\n  const DECLARATIONS = new Set([\"ExportAllDeclaration\", \"ExportNamedDeclaration\", \"ImportDeclaration\"]);\n  const IDENTIFIER_OR_KEYWORD = new Set([\"Identifier\", \"Keyword\"]);\n\n  // Keywords that can immediately precede an ExpressionStatement node, mapped to the their node types.\n  const NODE_TYPES_BY_KEYWORD = {\n    __proto__: null,\n    break: \"BreakStatement\",\n    continue: \"ContinueStatement\",\n    debugger: \"DebuggerStatement\",\n    do: \"DoWhileStatement\",\n    else: \"IfStatement\",\n    return: \"ReturnStatement\",\n    yield: \"YieldExpression\"\n  };\n\n  /*\n   * Before an opening parenthesis, postfix `++` and `--` always trigger ASI;\n   * the tokens `:`, `;`, `{` and `=>` don't expect a semicolon, as that would count as an empty statement.\n   */\n  const PUNCTUATORS = new Set([\":\", \";\", \"{\", \"=>\", \"++\", \"--\"]);\n\n  /*\n   * Statements that can contain an `ExpressionStatement` after a closing parenthesis.\n   * DoWhileStatement is an exception in that it always triggers ASI after the closing parenthesis.\n   */\n  const STATEMENTS = new Set([\"DoWhileStatement\", \"ForInStatement\", \"ForOfStatement\", \"ForStatement\", \"IfStatement\", \"WhileStatement\", \"WithStatement\"]);\n  needsPrecedingSemicolon = function (sourceCode, node) {\n    const prevToken = sourceCode.getTokenBefore(node);\n    if (!prevToken || prevToken.type === \"Punctuator\" && PUNCTUATORS.has(prevToken.value)) {\n      return false;\n    }\n    const prevNode = sourceCode.getNodeByRangeIndex(prevToken.range[0]);\n    if (isClosingParenToken(prevToken)) {\n      return !STATEMENTS.has(prevNode.type);\n    }\n    if (isClosingBraceToken(prevToken)) {\n      return prevNode.type === \"BlockStatement\" && prevNode.parent.type === \"FunctionExpression\" || prevNode.type === \"ClassBody\" && prevNode.parent.type === \"ClassExpression\" || prevNode.type === \"ObjectExpression\";\n    }\n    if (IDENTIFIER_OR_KEYWORD.has(prevToken.type)) {\n      if (BREAK_OR_CONTINUE.has(prevNode.parent.type)) {\n        return false;\n      }\n      const keyword = prevToken.value;\n      const nodeType = NODE_TYPES_BY_KEYWORD[keyword];\n      return prevNode.type !== nodeType;\n    }\n    if (prevToken.type === \"String\") {\n      return !DECLARATIONS.has(prevNode.parent.type);\n    }\n    return true;\n  };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  COMMENTS_IGNORE_PATTERN,\n  LINEBREAKS,\n  LINEBREAK_MATCHER: lineBreakPattern,\n  SHEBANG_MATCHER: shebangPattern,\n  STATEMENT_LIST_PARENTS,\n  /**\n   * Determines whether two adjacent tokens are on the same line.\n   * @param {Object} left The left token object.\n   * @param {Object} right The right token object.\n   * @returns {boolean} Whether or not the tokens are on the same line.\n   * @public\n   */\n  isTokenOnSameLine(left, right) {\n    return left.loc.end.line === right.loc.start.line;\n  },\n  isNullOrUndefined,\n  isCallee,\n  isES5Constructor,\n  getUpperFunction,\n  isFunction,\n  isLoop,\n  isInLoop,\n  isArrayFromMethod,\n  isParenthesised,\n  createGlobalLinebreakMatcher,\n  equalTokens,\n  isArrowToken,\n  isClosingBraceToken,\n  isClosingBracketToken,\n  isClosingParenToken,\n  isColonToken,\n  isCommaToken,\n  isCommentToken,\n  isDotToken,\n  isQuestionDotToken,\n  isKeywordToken,\n  isNotClosingBraceToken: negate(isClosingBraceToken),\n  isNotClosingBracketToken: negate(isClosingBracketToken),\n  isNotClosingParenToken: negate(isClosingParenToken),\n  isNotColonToken: negate(isColonToken),\n  isNotCommaToken: negate(isCommaToken),\n  isNotDotToken: negate(isDotToken),\n  isNotQuestionDotToken: negate(isQuestionDotToken),\n  isNotOpeningBraceToken: negate(isOpeningBraceToken),\n  isNotOpeningBracketToken: negate(isOpeningBracketToken),\n  isNotOpeningParenToken: negate(isOpeningParenToken),\n  isNotSemicolonToken: negate(isSemicolonToken),\n  isOpeningBraceToken,\n  isOpeningBracketToken,\n  isOpeningParenToken,\n  isSemicolonToken,\n  isEqToken,\n  /**\n   * Checks whether or not a given node is a string literal.\n   * @param {ASTNode} node A node to check.\n   * @returns {boolean} `true` if the node is a string literal.\n   */\n  isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\";\n  },\n  /**\n   * Checks whether a given node is a breakable statement or not.\n   * The node is breakable if the node is one of the following type:\n   *\n   * - DoWhileStatement\n   * - ForInStatement\n   * - ForOfStatement\n   * - ForStatement\n   * - SwitchStatement\n   * - WhileStatement\n   * @param {ASTNode} node A node to check.\n   * @returns {boolean} `true` if the node is breakable.\n   */\n  isBreakableStatement(node) {\n    return breakableTypePattern.test(node.type);\n  },\n  /**\n   * Gets references which are non initializer and writable.\n   * @param {Reference[]} references An array of references.\n   * @returns {Reference[]} An array of only references which are non initializer and writable.\n   * @public\n   */\n  getModifyingReferences(references) {\n    return references.filter(isModifyingReference);\n  },\n  /**\n   * Validate that a string passed in is surrounded by the specified character\n   * @param {string} val The text to check.\n   * @param {string} character The character to see if it's surrounded by.\n   * @returns {boolean} True if the text is surrounded by the character, false if not.\n   * @private\n   */\n  isSurroundedBy(val, character) {\n    return val[0] === character && val[val.length - 1] === character;\n  },\n  /**\n   * Returns whether the provided node is an ESLint directive comment or not\n   * @param {Line|Block} node The comment token to be checked\n   * @returns {boolean} `true` if the node is an ESLint directive comment\n   */\n  isDirectiveComment(node) {\n    const comment = node.value.trim();\n    return node.type === \"Line\" && comment.startsWith(\"eslint-\") || node.type === \"Block\" && ESLINT_DIRECTIVE_PATTERN.test(comment);\n  },\n  /**\n   * Gets the trailing statement of a given node.\n   *\n   *     if (code)\n   *         consequent;\n   *\n   * When taking this `IfStatement`, returns `consequent;` statement.\n   * @param {ASTNode} A node to get.\n   * @returns {ASTNode|null} The trailing statement's node.\n   */\n  getTrailingStatement: esutils.ast.trailingStatement,\n  /**\n   * Finds the variable by a given name in a given scope and its upper scopes.\n   * @param {eslint-scope.Scope} initScope A scope to start find.\n   * @param {string} name A variable name to find.\n   * @returns {eslint-scope.Variable|null} A found variable or `null`.\n   */\n  getVariableByName(initScope, name) {\n    let scope = initScope;\n    while (scope) {\n      const variable = scope.set.get(name);\n      if (variable) {\n        return variable;\n      }\n      scope = scope.upper;\n    }\n    return null;\n  },\n  /**\n   * Checks whether or not a given function node is the default `this` binding.\n   *\n   * First, this checks the node:\n   *\n   * - The given node is not in `PropertyDefinition#value` position.\n   * - The given node is not `StaticBlock`.\n   * - The function name does not start with uppercase. It's a convention to capitalize the names\n   *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\n   * - The function does not have a JSDoc comment that has a @this tag.\n   *\n   * Next, this checks the location of the node.\n   * If the location is below, this judges `this` is valid.\n   *\n   * - The location is not on an object literal.\n   * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\n   *   functions only, as the name of the variable is considered to be the name of the function in this case.\n   *   This check is not performed if `capIsConstructor` is set to `false`.\n   * - The location is not on an ES2015 class.\n   * - Its `bind`/`call`/`apply` method is not called directly.\n   * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n   * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`\n   * or any expression that is `PropertyDefinition#value` node.\n   * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n   * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\n   * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\n   * @returns {boolean} The function node is the default `this` binding.\n   */\n  isDefaultThisBinding(node, sourceCode, {\n    capIsConstructor = true\n  } = {}) {\n    /*\n     * Class field initializers are implicit functions, but ESTree doesn't have the AST node of field initializers.\n     * Therefore, A expression node at `PropertyDefinition#value` is a function.\n     * In this case, `this` is always not default binding.\n     */\n    if (node.parent.type === \"PropertyDefinition\" && node.parent.value === node) {\n      return false;\n    }\n\n    // Class static blocks are implicit functions. In this case, `this` is always not default binding.\n    if (node.type === \"StaticBlock\") {\n      return false;\n    }\n    if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n      return false;\n    }\n    const isAnonymous = node.id === null;\n    let currentNode = node;\n    while (currentNode) {\n      const parent = currentNode.parent;\n      switch (parent.type) {\n        /*\n         * Looks up the destination.\n         * e.g., obj.foo = nativeFoo || function foo() { ... };\n         */\n        case \"LogicalExpression\":\n        case \"ConditionalExpression\":\n        case \"ChainExpression\":\n          currentNode = parent;\n          break;\n\n        /*\n         * If the upper function is IIFE, checks the destination of the return value.\n         * e.g.\n         *   obj.foo = (function() {\n         *     // setup...\n         *     return function foo() { ... };\n         *   })();\n         *   obj.foo = (() =>\n         *     function foo() { ... }\n         *   )();\n         */\n        case \"ReturnStatement\":\n          {\n            const func = getUpperFunction(parent);\n            if (func === null || !isCallee(func)) {\n              return true;\n            }\n            currentNode = func.parent;\n            break;\n          }\n        case \"ArrowFunctionExpression\":\n          if (currentNode !== parent.body || !isCallee(parent)) {\n            return true;\n          }\n          currentNode = parent.parent;\n          break;\n\n        /*\n         * e.g.\n         *   var obj = { foo() { ... } };\n         *   var obj = { foo: function() { ... } };\n         *   class A { constructor() { ... } }\n         *   class A { foo() { ... } }\n         *   class A { get foo() { ... } }\n         *   class A { set foo() { ... } }\n         *   class A { static foo() { ... } }\n         *   class A { foo = function() { ... } }\n         */\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n          return parent.value !== currentNode;\n\n        /*\n         * e.g.\n         *   obj.foo = function foo() { ... };\n         *   Foo = function() { ... };\n         *   [obj.foo = function foo() { ... }] = a;\n         *   [Foo = function() { ... }] = a;\n         */\n        case \"AssignmentExpression\":\n        case \"AssignmentPattern\":\n          if (parent.left.type === \"MemberExpression\") {\n            return false;\n          }\n          if (capIsConstructor && isAnonymous && parent.left.type === \"Identifier\" && startsWithUpperCase(parent.left.name)) {\n            return false;\n          }\n          return true;\n\n        /*\n         * e.g.\n         *   var Foo = function() { ... };\n         */\n        case \"VariableDeclarator\":\n          return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === \"Identifier\" && startsWithUpperCase(parent.id.name));\n\n        /*\n         * e.g.\n         *   var foo = function foo() { ... }.bind(obj);\n         *   (function foo() { ... }).call(obj);\n         *   (function foo() { ... }).apply(obj, []);\n         */\n        case \"MemberExpression\":\n          if (parent.object === currentNode && isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)) {\n            const maybeCalleeNode = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n            return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));\n          }\n          return true;\n\n        /*\n         * e.g.\n         *   Reflect.apply(function() {}, obj, []);\n         *   Array.from([], function() {}, obj);\n         *   list.forEach(function() {}, obj);\n         */\n        case \"CallExpression\":\n          if (isReflectApply(parent.callee)) {\n            return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n          }\n          if (isArrayFromMethod(parent.callee)) {\n            return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);\n          }\n          if (isMethodWhichHasThisArg(parent.callee)) {\n            return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n          }\n          return true;\n\n        // Otherwise `this` is default.\n        default:\n          return true;\n      }\n    }\n\n    /* c8 ignore next */\n    return true;\n  },\n  /**\n   * Get the precedence level based on the node type\n   * @param {ASTNode} node node to evaluate\n   * @returns {int} precedence level\n   * @private\n   */\n  getPrecedence(node) {\n    switch (node.type) {\n      case \"SequenceExpression\":\n        return 0;\n      case \"AssignmentExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"YieldExpression\":\n        return 1;\n      case \"ConditionalExpression\":\n        return 3;\n      case \"LogicalExpression\":\n        switch (node.operator) {\n          case \"||\":\n          case \"??\":\n            return 4;\n          case \"&&\":\n            return 5;\n\n          // no default\n        }\n\n      /* falls through */\n\n      case \"BinaryExpression\":\n        switch (node.operator) {\n          case \"|\":\n            return 6;\n          case \"^\":\n            return 7;\n          case \"&\":\n            return 8;\n          case \"==\":\n          case \"!=\":\n          case \"===\":\n          case \"!==\":\n            return 9;\n          case \"<\":\n          case \"<=\":\n          case \">\":\n          case \">=\":\n          case \"in\":\n          case \"instanceof\":\n            return 10;\n          case \"<<\":\n          case \">>\":\n          case \">>>\":\n            return 11;\n          case \"+\":\n          case \"-\":\n            return 12;\n          case \"*\":\n          case \"/\":\n          case \"%\":\n            return 13;\n          case \"**\":\n            return 15;\n\n          // no default\n        }\n\n      /* falls through */\n\n      case \"UnaryExpression\":\n      case \"AwaitExpression\":\n        return 16;\n      case \"UpdateExpression\":\n        return 17;\n      case \"CallExpression\":\n      case \"ChainExpression\":\n      case \"ImportExpression\":\n        return 18;\n      case \"NewExpression\":\n        return 19;\n      default:\n        if (node.type in eslintVisitorKeys) {\n          return 20;\n        }\n\n        /*\n         * if the node is not a standard node that we know about, then assume it has the lowest precedence\n         * this will mean that rules will wrap unknown nodes in parentheses where applicable instead of\n         * unwrapping them and potentially changing the meaning of the code or introducing a syntax error.\n         */\n        return -1;\n    }\n  },\n  /**\n   * Checks whether the given node is an empty block node or not.\n   * @param {ASTNode|null} node The node to check.\n   * @returns {boolean} `true` if the node is an empty block.\n   */\n  isEmptyBlock(node) {\n    return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n  },\n  /**\n   * Checks whether the given node is an empty function node or not.\n   * @param {ASTNode|null} node The node to check.\n   * @returns {boolean} `true` if the node is an empty function.\n   */\n  isEmptyFunction(node) {\n    return isFunction(node) && module.exports.isEmptyBlock(node.body);\n  },\n  /**\n   * Get directives from directive prologue of a Program or Function node.\n   * @param {ASTNode} node The node to check.\n   * @returns {ASTNode[]} The directives found in the directive prologue.\n   */\n  getDirectivePrologue(node) {\n    const directives = [];\n\n    // Directive prologues only occur at the top of files or functions.\n    if (node.type === \"Program\" || node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\" || (\n    /*\n     * Do not check arrow functions with implicit return.\n     * `() => \"use strict\";` returns the string `\"use strict\"`.\n     */\n    node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")) {\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n      for (const statement of statements) {\n        if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\") {\n          directives.push(statement);\n        } else {\n          break;\n        }\n      }\n    }\n    return directives;\n  },\n  /**\n   * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n   * after the node will be parsed as a decimal point, rather than a property-access dot.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if this node is a decimal integer.\n   * @example\n   *\n   * 0         // true\n   * 5         // true\n   * 50        // true\n   * 5_000     // true\n   * 1_234_56  // true\n   * 08        // true\n   * 0192      // true\n   * 5.        // false\n   * .5        // false\n   * 5.0       // false\n   * 5.00_00   // false\n   * 05        // false\n   * 0x5       // false\n   * 0b101     // false\n   * 0b11_01   // false\n   * 0o5       // false\n   * 5e0       // false\n   * 5e1_000   // false\n   * 5n        // false\n   * 1_000n    // false\n   * \"5\"       // false\n   *\n   */\n  isDecimalInteger(node) {\n    return node.type === \"Literal\" && typeof node.value === \"number\" && DECIMAL_INTEGER_PATTERN.test(node.raw);\n  },\n  /**\n   * Determines whether this token is a decimal integer numeric token.\n   * This is similar to isDecimalInteger(), but for tokens.\n   * @param {Token} token The token to check.\n   * @returns {boolean} `true` if this token is a decimal integer.\n   */\n  isDecimalIntegerNumericToken(token) {\n    return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n  },\n  /**\n   * Gets the name and kind of the given function node.\n   *\n   * - `function foo() {}`  .................... `function 'foo'`\n   * - `(function foo() {})`  .................. `function 'foo'`\n   * - `(function() {})`  ...................... `function`\n   * - `function* foo() {}`  ................... `generator function 'foo'`\n   * - `(function* foo() {})`  ................. `generator function 'foo'`\n   * - `(function*() {})`  ..................... `generator function`\n   * - `() => {}`  ............................. `arrow function`\n   * - `async () => {}`  ....................... `async arrow function`\n   * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n   * - `({ foo: function() {} })`  ............. `method 'foo'`\n   * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n   * - `({ [foo]: function() {} })`  ........... `method`\n   * - `({ foo() {} })`  ....................... `method 'foo'`\n   * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n   * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n   * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n   * - `({ [foo]: function*() {} })`  .......... `generator method`\n   * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n   * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n   * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n   * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n   * - `({ [foo]: async function() {} })`  ..... `async method`\n   * - `({ async foo() {} })`  ................. `async method 'foo'`\n   * - `({ get foo() {} })`  ................... `getter 'foo'`\n   * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n   * - `class A { constructor() {} }`  ......... `constructor`\n   * - `class A { foo() {} }`  ................. `method 'foo'`\n   * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n   * - `class A { async foo() {} }`  ........... `async method 'foo'`\n   * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n   * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n   * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n   * - `class A { [foo]() {} }`  ............... `method`\n   * - `class A { *[foo]() {} }`  .............. `generator method`\n   * - `class A { async [foo]() {} }`  ......... `async method`\n   * - `class A { get foo() {} }`  ............. `getter 'foo'`\n   * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n   * - `class A { static foo() {} }`  .......... `static method 'foo'`\n   * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n   * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n   * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n   * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n   * - `class A { foo = () => {}; }`  .......... `method 'foo'`\n   * - `class A { foo = function() {}; }`  ..... `method 'foo'`\n   * - `class A { foo = function bar() {}; }`  . `method 'foo'`\n   * - `class A { static foo = () => {}; }`  ... `static method 'foo'`\n   * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`\n   * - `class A { #foo = () => {}; }`  ......... `private method #foo`\n   * - `class A { static #foo = () => {}; }`  .. `static private method #foo`\n   * - `class A { '#foo'() {} }`  .............. `method '#foo'`\n   * - `class A { #foo() {} }`  ................ `private method #foo`\n   * - `class A { static #foo() {} }`  ......... `static private method #foo`\n   * @param {ASTNode} node The function node to get.\n   * @returns {string} The name and kind of the function node.\n   */\n  getFunctionNameWithKind(node) {\n    const parent = node.parent;\n    const tokens = [];\n    if (parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n      // The proposal uses `static` word consistently before visibility words: https://github.com/tc39/proposal-static-class-features\n      if (parent.static) {\n        tokens.push(\"static\");\n      }\n      if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\n        tokens.push(\"private\");\n      }\n    }\n    if (node.async) {\n      tokens.push(\"async\");\n    }\n    if (node.generator) {\n      tokens.push(\"generator\");\n    }\n    if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n      if (parent.kind === \"constructor\") {\n        return \"constructor\";\n      }\n      if (parent.kind === \"get\") {\n        tokens.push(\"getter\");\n      } else if (parent.kind === \"set\") {\n        tokens.push(\"setter\");\n      } else {\n        tokens.push(\"method\");\n      }\n    } else if (parent.type === \"PropertyDefinition\") {\n      tokens.push(\"method\");\n    } else {\n      if (node.type === \"ArrowFunctionExpression\") {\n        tokens.push(\"arrow\");\n      }\n      tokens.push(\"function\");\n    }\n    if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n      if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\n        tokens.push(`#${parent.key.name}`);\n      } else {\n        const name = getStaticPropertyName(parent);\n        if (name !== null) {\n          tokens.push(`'${name}'`);\n        } else if (node.id) {\n          tokens.push(`'${node.id.name}'`);\n        }\n      }\n    } else if (node.id) {\n      tokens.push(`'${node.id.name}'`);\n    }\n    return tokens.join(\" \");\n  },\n  /**\n   * Gets the location of the given function node for reporting.\n   *\n   * - `function foo() {}`\n   *    ^^^^^^^^^^^^\n   * - `(function foo() {})`\n   *     ^^^^^^^^^^^^\n   * - `(function() {})`\n   *     ^^^^^^^^\n   * - `function* foo() {}`\n   *    ^^^^^^^^^^^^^\n   * - `(function* foo() {})`\n   *     ^^^^^^^^^^^^^\n   * - `(function*() {})`\n   *     ^^^^^^^^^\n   * - `() => {}`\n   *       ^^\n   * - `async () => {}`\n   *             ^^\n   * - `({ foo: function foo() {} })`\n   *       ^^^^^^^^^^^^^^^^^\n   * - `({ foo: function() {} })`\n   *       ^^^^^^^^^^^^^\n   * - `({ ['foo']: function() {} })`\n   *       ^^^^^^^^^^^^^^^^^\n   * - `({ [foo]: function() {} })`\n   *       ^^^^^^^^^^^^^^^\n   * - `({ foo() {} })`\n   *       ^^^\n   * - `({ foo: function* foo() {} })`\n   *       ^^^^^^^^^^^^^^^^^^\n   * - `({ foo: function*() {} })`\n   *       ^^^^^^^^^^^^^^\n   * - `({ ['foo']: function*() {} })`\n   *       ^^^^^^^^^^^^^^^^^^\n   * - `({ [foo]: function*() {} })`\n   *       ^^^^^^^^^^^^^^^^\n   * - `({ *foo() {} })`\n   *       ^^^^\n   * - `({ foo: async function foo() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^^^^^\n   * - `({ foo: async function() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^\n   * - `({ ['foo']: async function() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^^^^^\n   * - `({ [foo]: async function() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^^^\n   * - `({ async foo() {} })`\n   *       ^^^^^^^^^\n   * - `({ get foo() {} })`\n   *       ^^^^^^^\n   * - `({ set foo(a) {} })`\n   *       ^^^^^^^\n   * - `class A { constructor() {} }`\n   *              ^^^^^^^^^^^\n   * - `class A { foo() {} }`\n   *              ^^^\n   * - `class A { *foo() {} }`\n   *              ^^^^\n   * - `class A { async foo() {} }`\n   *              ^^^^^^^^^\n   * - `class A { ['foo']() {} }`\n   *              ^^^^^^^\n   * - `class A { *['foo']() {} }`\n   *              ^^^^^^^^\n   * - `class A { async ['foo']() {} }`\n   *              ^^^^^^^^^^^^^\n   * - `class A { [foo]() {} }`\n   *              ^^^^^\n   * - `class A { *[foo]() {} }`\n   *              ^^^^^^\n   * - `class A { async [foo]() {} }`\n   *              ^^^^^^^^^^^\n   * - `class A { get foo() {} }`\n   *              ^^^^^^^\n   * - `class A { set foo(a) {} }`\n   *              ^^^^^^^\n   * - `class A { static foo() {} }`\n   *              ^^^^^^^^^^\n   * - `class A { static *foo() {} }`\n   *              ^^^^^^^^^^^\n   * - `class A { static async foo() {} }`\n   *              ^^^^^^^^^^^^^^^^\n   * - `class A { static get foo() {} }`\n   *              ^^^^^^^^^^^^^^\n   * - `class A { static set foo(a) {} }`\n   *              ^^^^^^^^^^^^^^\n   * - `class A { foo = function() {} }`\n   *              ^^^^^^^^^^^^^^\n   * - `class A { static foo = function() {} }`\n   *              ^^^^^^^^^^^^^^^^^^^^^\n   * - `class A { foo = (a, b) => {} }`\n   *              ^^^^^^\n   * @param {ASTNode} node The function node to get.\n   * @param {SourceCode} sourceCode The source code object to get tokens.\n   * @returns {string} The location of the function node for reporting.\n   */\n  getFunctionHeadLoc(node, sourceCode) {\n    const parent = node.parent;\n    let start = null;\n    let end = null;\n    if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n      start = parent.loc.start;\n      end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    } else if (node.type === \"ArrowFunctionExpression\") {\n      const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n      start = arrowToken.loc.start;\n      end = arrowToken.loc.end;\n    } else {\n      start = node.loc.start;\n      end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n    return {\n      start: Object.assign({}, start),\n      end: Object.assign({}, end)\n    };\n  },\n  /**\n   * Gets next location when the result is not out of bound, otherwise returns null.\n   *\n   * Assumptions:\n   *\n   * - The given location represents a valid location in the given source code.\n   * - Columns are 0-based.\n   * - Lines are 1-based.\n   * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.\n   * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.\n   *   The start (column 0) of that extra line is considered to be a valid location.\n   *\n   * Examples of successive locations (line, column):\n   *\n   * code: foo\n   * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null\n   *\n   * code: foo<LF>\n   * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\n   *\n   * code: foo<CR><LF>\n   * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\n   *\n   * code: a<LF>b\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null\n   *\n   * code: a<LF>b<LF>\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\n   *\n   * code: a<CR><LF>b<CR><LF>\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\n   *\n   * code: a<LF><LF>\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null\n   *\n   * code: <LF>\n   * locations: (1, 0) -> (2, 0) -> null\n   *\n   * code:\n   * locations: (1, 0) -> null\n   * @param {SourceCode} sourceCode The sourceCode\n   * @param {{line: number, column: number}} location The location\n   * @returns {{line: number, column: number} | null} Next location\n   */\n  getNextLocation(sourceCode, {\n    line,\n    column\n  }) {\n    if (column < sourceCode.lines[line - 1].length) {\n      return {\n        line,\n        column: column + 1\n      };\n    }\n    if (line < sourceCode.lines.length) {\n      return {\n        line: line + 1,\n        column: 0\n      };\n    }\n    return null;\n  },\n  /**\n   * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n   * surrounding the node.\n   * @param {SourceCode} sourceCode The source code object\n   * @param {ASTNode} node An expression node\n   * @returns {string} The text representing the node, with all surrounding parentheses included\n   */\n  getParenthesisedText(sourceCode, node) {\n    let leftToken = sourceCode.getFirstToken(node);\n    let rightToken = sourceCode.getLastToken(node);\n    while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" && sourceCode.getTokenBefore(leftToken).value === \"(\" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" && sourceCode.getTokenAfter(rightToken).value === \")\") {\n      leftToken = sourceCode.getTokenBefore(leftToken);\n      rightToken = sourceCode.getTokenAfter(rightToken);\n    }\n    return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n  },\n  /**\n   * Determine if a node has a possibility to be an Error object\n   * @param {ASTNode} node ASTNode to check\n   * @returns {boolean} True if there is a chance it contains an Error obj\n   */\n  couldBeError(node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"CallExpression\":\n      case \"NewExpression\":\n      case \"MemberExpression\":\n      case \"TaggedTemplateExpression\":\n      case \"YieldExpression\":\n      case \"AwaitExpression\":\n      case \"ChainExpression\":\n        return true;\n      // possibly an error object.\n\n      case \"AssignmentExpression\":\n        if ([\"=\", \"&&=\"].includes(node.operator)) {\n          return module.exports.couldBeError(node.right);\n        }\n        if ([\"||=\", \"??=\"].includes(node.operator)) {\n          return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n        }\n\n        /**\n         * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n         * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n         * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.\n         */\n        return false;\n      case \"SequenceExpression\":\n        {\n          const exprs = node.expressions;\n          return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n        }\n      case \"LogicalExpression\":\n        /*\n         * If the && operator short-circuits, the left side was falsy and therefore not an error, and if it\n         * doesn't short-circuit, it takes the value from the right side, so the right side must always be\n         * a plausible error. A future improvement could verify that the left side could be truthy by\n         * excluding falsy literals.\n         */\n        if (node.operator === \"&&\") {\n          return module.exports.couldBeError(node.right);\n        }\n        return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n      case \"ConditionalExpression\":\n        return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n      default:\n        return false;\n    }\n  },\n  /**\n   * Check if a given node is a numeric literal or not.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if the node is a number or bigint literal.\n   */\n  isNumericLiteral(node) {\n    return node.type === \"Literal\" && (typeof node.value === \"number\" || Boolean(node.bigint));\n  },\n  /**\n   * Determines whether two tokens can safely be placed next to each other without merging into a single token\n   * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\n   * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\n   * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\n   * next to each other, behavior is undefined (although it should return `true` in most cases).\n   */\n  canTokensBeAdjacent(leftValue, rightValue) {\n    const espreeOptions = {\n      ecmaVersion: espree.latestEcmaVersion,\n      comment: true,\n      range: true\n    };\n    let leftToken;\n    if (typeof leftValue === \"string\") {\n      let tokens;\n      try {\n        tokens = espree.tokenize(leftValue, espreeOptions);\n      } catch {\n        return false;\n      }\n      const comments = tokens.comments;\n      leftToken = tokens[tokens.length - 1];\n      if (comments.length) {\n        const lastComment = comments[comments.length - 1];\n        if (!leftToken || lastComment.range[0] > leftToken.range[0]) {\n          leftToken = lastComment;\n        }\n      }\n    } else {\n      leftToken = leftValue;\n    }\n\n    /*\n     * If a hashbang comment was passed as a token object from SourceCode,\n     * its type will be \"Shebang\" because of the way ESLint itself handles hashbangs.\n     * If a hashbang comment was passed in a string and then tokenized in this function,\n     * its type will be \"Hashbang\" because of the way Espree tokenizes hashbangs.\n     */\n    if (leftToken.type === \"Shebang\" || leftToken.type === \"Hashbang\") {\n      return false;\n    }\n    let rightToken;\n    if (typeof rightValue === \"string\") {\n      let tokens;\n      try {\n        tokens = espree.tokenize(rightValue, espreeOptions);\n      } catch {\n        return false;\n      }\n      const comments = tokens.comments;\n      rightToken = tokens[0];\n      if (comments.length) {\n        const firstComment = comments[0];\n        if (!rightToken || firstComment.range[0] < rightToken.range[0]) {\n          rightToken = firstComment;\n        }\n      }\n    } else {\n      rightToken = rightValue;\n    }\n    if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n      if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n        const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n        const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n        return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));\n      }\n      if (leftToken.type === \"Punctuator\" && leftToken.value === \"/\") {\n        return ![\"Block\", \"Line\", \"RegularExpression\"].includes(rightToken.type);\n      }\n      return true;\n    }\n    if (leftToken.type === \"String\" || rightToken.type === \"String\" || leftToken.type === \"Template\" || rightToken.type === \"Template\") {\n      return true;\n    }\n    if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n      return true;\n    }\n    if (leftToken.type === \"Block\" || rightToken.type === \"Block\" || rightToken.type === \"Line\") {\n      return true;\n    }\n    if (rightToken.type === \"PrivateIdentifier\") {\n      return true;\n    }\n    return false;\n  },\n  /**\n   * Get the `loc` object of a given name in a `/*globals` directive comment.\n   * @param {SourceCode} sourceCode The source code to convert index to loc.\n   * @param {Comment} comment The `/*globals` directive comment which include the name.\n   * @param {string} name The name to find.\n   * @returns {SourceLocation} The `loc` object.\n   */\n  getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n    const namePattern = new RegExp(`[\\\\s,]${escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\");\n\n    // To ignore the first text \"global\".\n    namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n    // Search a given variable name.\n    const match = namePattern.exec(comment.value);\n\n    // Convert the index to loc.\n    const start = sourceCode.getLocFromIndex(comment.range[0] + \"/*\".length + (match ? match.index + 1 : 0));\n    const end = {\n      line: start.line,\n      column: start.column + (match ? name.length : 1)\n    };\n    return {\n      start,\n      end\n    };\n  },\n  /**\n   * Determines whether the given raw string contains an octal escape sequence\n   * or a non-octal decimal escape sequence (\"\\8\", \"\\9\").\n   *\n   * \"\\1\", \"\\2\" ... \"\\7\", \"\\8\", \"\\9\"\n   * \"\\00\", \"\\01\" ... \"\\07\", \"\\08\", \"\\09\"\n   *\n   * \"\\0\", when not followed by a digit, is not an octal escape sequence.\n   * @param {string} rawString A string in its raw representation.\n   * @returns {boolean} `true` if the string contains at least one octal escape sequence\n   * or at least one non-octal decimal escape sequence.\n   */\n  hasOctalOrNonOctalDecimalEscapeSequence(rawString) {\n    return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);\n  },\n  /**\n   * Determines whether the given node is a template literal without expressions.\n   * @param {ASTNode} node Node to check.\n   * @returns {boolean} True if the node is a template literal without expressions.\n   */\n  isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n  },\n  isReferenceToGlobalVariable,\n  isLogicalExpression,\n  isCoalesceExpression,\n  isMixedLogicalAndCoalesceExpressions,\n  isNullLiteral,\n  getStaticStringValue,\n  getStaticPropertyName,\n  skipChainExpression,\n  isSpecificId,\n  isSpecificMemberAccess,\n  equalLiteralValue,\n  isSameReference,\n  isLogicalAssignmentOperator,\n  getSwitchCaseColonToken,\n  getModuleExportName,\n  isConstant,\n  isTopLevelExpressionStatement,\n  isDirective,\n  isStartOfExpressionStatement,\n  needsPrecedingSemicolon\n};","map":{"version":3,"names":["KEYS","eslintVisitorKeys","require","esutils","espree","escapeRegExp","breakableTypePattern","createGlobalLinebreakMatcher","lineBreakPattern","shebangPattern","anyFunctionPattern","anyLoopPattern","arrayMethodWithThisArgPattern","arrayOrTypedArrayPattern","bindOrCallOrApplyPattern","thisTagPattern","COMMENTS_IGNORE_PATTERN","ESLINT_DIRECTIVE_PATTERN","LINEBREAKS","Set","STATEMENT_LIST_PARENTS","DECIMAL_INTEGER_PATTERN","OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN","LOGICAL_ASSIGNMENT_OPERATORS","isModifyingReference","reference","index","references","identifier","modifyingDifferentIdentifier","init","isWrite","startsWithUpperCase","s","toLocaleLowerCase","isES5Constructor","node","id","name","getUpperFunction","currentNode","parent","test","type","isFunction","Boolean","isLoop","isInLoop","isNullLiteral","value","regex","bigint","isNullOrUndefined","operator","isCallee","callee","getStaticStringValue","String","pattern","flags","expressions","length","quasis","cooked","getStaticPropertyName","prop","expression","key","property","computed","skipChainExpression","checkText","actual","expected","isSpecificId","isSpecificMemberAccess","objectName","propertyName","checkNode","object","actualPropertyName","equalLiteralValue","left","right","isSameReference","disableStaticComputedKey","nameA","isReflectApply","isArrayFromMethod","isMethodWhichHasThisArg","negate","f","token","hasJSDocThisTag","sourceCode","jsdocComment","getJSDocComment","getCommentsBefore","some","comment","isParenthesised","previousToken","getTokenBefore","nextToken","getTokenAfter","range","isEqToken","isArrowToken","isCommaToken","isDotToken","isQuestionDotToken","isSemicolonToken","isColonToken","isOpeningParenToken","isClosingParenToken","isOpeningBracketToken","isClosingBracketToken","isOpeningBraceToken","isClosingBraceToken","isCommentToken","isKeywordToken","getOpeningParenOfParams","params","argToken","getFirstToken","maybeParenToken","equalTokens","tokensL","getTokens","tokensR","i","isLogicalExpression","isCoalesceExpression","isMixedLogicalAndCoalesceExpressions","isLogicalAssignmentOperator","has","getSwitchCaseColonToken","getModuleExportName","getBooleanValue","raw","isLogicalIdentity","includes","slice","isReferenceToGlobalVariable","scope","find","ref","resolved","defs","isConstant","inBooleanPosition","quasi","every","exp","elements","element","argument","isLeftConstant","isRightConstant","isLeftShortCircuit","isRightShortCircuit","arguments","isTopLevelExpressionStatement","isDirective","directive","isStartOfExpressionStatement","start","ancestor","needsPrecedingSemicolon","BREAK_OR_CONTINUE","DECLARATIONS","IDENTIFIER_OR_KEYWORD","NODE_TYPES_BY_KEYWORD","__proto__","break","continue","debugger","do","else","return","yield","PUNCTUATORS","STATEMENTS","prevToken","prevNode","getNodeByRangeIndex","keyword","nodeType","module","exports","LINEBREAK_MATCHER","SHEBANG_MATCHER","isTokenOnSameLine","loc","end","line","isNotClosingBraceToken","isNotClosingBracketToken","isNotClosingParenToken","isNotColonToken","isNotCommaToken","isNotDotToken","isNotQuestionDotToken","isNotOpeningBraceToken","isNotOpeningBracketToken","isNotOpeningParenToken","isNotSemicolonToken","isStringLiteral","isBreakableStatement","getModifyingReferences","filter","isSurroundedBy","val","character","isDirectiveComment","trim","startsWith","getTrailingStatement","ast","trailingStatement","getVariableByName","initScope","variable","set","get","upper","isDefaultThisBinding","capIsConstructor","isAnonymous","func","body","maybeCalleeNode","getPrecedence","isEmptyBlock","isEmptyFunction","getDirectivePrologue","directives","statements","statement","push","isDecimalInteger","isDecimalIntegerNumericToken","getFunctionNameWithKind","tokens","static","async","generator","kind","join","getFunctionHeadLoc","arrowToken","Object","assign","getNextLocation","column","lines","getParenthesisedText","leftToken","rightToken","getLastToken","getText","couldBeError","exprs","consequent","alternate","isNumericLiteral","canTokensBeAdjacent","leftValue","rightValue","espreeOptions","ecmaVersion","latestEcmaVersion","tokenize","comments","lastComment","firstComment","PLUS_TOKENS","MINUS_TOKENS","getNameLocationInGlobalDirectiveComment","namePattern","RegExp","lastIndex","indexOf","match","exec","getLocFromIndex","hasOctalOrNonOctalDecimalEscapeSequence","rawString","isStaticTemplateLiteral"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/utils/ast-utils.js"],"sourcesContent":["/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { KEYS: eslintVisitorKeys } = require(\"eslint-visitor-keys\");\nconst esutils = require(\"esutils\");\nconst espree = require(\"espree\");\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst {\n    breakableTypePattern,\n    createGlobalLinebreakMatcher,\n    lineBreakPattern,\n    shebangPattern\n} = require(\"../../shared/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayMethodWithThisArgPattern = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|some)$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\n\n\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst ESLINT_DIRECTIVE_PATTERN = /^(?:eslint[- ]|(?:globals?|exported) )/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"StaticBlock\", \"SwitchCase\"]);\n\nconst DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\\d*|[1-9](?:_?\\d)*)$/u;\n\n// Tests the presence of at least one LegacyOctalEscapeSequence or NonOctalDecimalEscapeSequence in a raw string\nconst OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\.)*\\\\(?:[1-9]|0[0-9])/su;\n\nconst LOGICAL_ASSIGNMENT_OPERATORS = new Set([\"&&=\", \"||=\", \"??=\"]);\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference A reference to check.\n * @param {int} index The index of the reference in the references.\n * @param {Reference[]} references The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n * @param {string} s The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node A function node to check.\n * @returns {boolean} Whether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (anyFunctionPattern.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n    return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n    return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n        if (isLoop(currentNode)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Determines whether the given node is a `null` literal.\n * @param {ASTNode} node The node to check\n * @returns {boolean} `true` if the node is a `null` literal\n */\nfunction isNullLiteral(node) {\n\n    /*\n     * Checking `node.value === null` does not guarantee that a literal is a null literal.\n     * When parsing values that cannot be represented in the current environment (e.g. unicode\n     * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n     * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n     * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n     */\n    return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Returns the result of the string conversion applied to the evaluated value of the given expression node,\n * if it can be determined statically.\n *\n * This function returns a `string` value for all `Literal` nodes and simple `TemplateLiteral` nodes only.\n * In all other cases, this function returns `null`.\n * @param {ASTNode} node Expression node.\n * @returns {string|null} String value if it can be determined. Otherwise, `null`.\n */\nfunction getStaticStringValue(node) {\n    switch (node.type) {\n        case \"Literal\":\n            if (node.value === null) {\n                if (isNullLiteral(node)) {\n                    return String(node.value); // \"null\"\n                }\n                if (node.regex) {\n                    return `/${node.regex.pattern}/${node.regex.flags}`;\n                }\n                if (node.bigint) {\n                    return node.bigint;\n                }\n\n                // Otherwise, this is an unknown literal. The function will return null.\n\n            } else {\n                return String(node.value);\n            }\n            break;\n        case \"TemplateLiteral\":\n            if (node.expressions.length === 0 && node.quasis.length === 1) {\n                return node.quasis[0].value.cooked;\n            }\n            break;\n\n            // no default\n    }\n\n    return null;\n}\n\n/**\n * Gets the property name of a given node.\n * The node can be a MemberExpression, a Property, or a MethodDefinition.\n *\n * If the name is dynamic, this returns `null`.\n *\n * For examples:\n *\n *     a.b           // => \"b\"\n *     a[\"b\"]        // => \"b\"\n *     a['b']        // => \"b\"\n *     a[`b`]        // => \"b\"\n *     a[100]        // => \"100\"\n *     a[b]          // => null\n *     a[\"a\" + \"b\"]  // => null\n *     a[tag`b`]     // => null\n *     a[`${b}`]     // => null\n *\n *     let a = {b: 1}            // => \"b\"\n *     let a = {[\"b\"]: 1}        // => \"b\"\n *     let a = {['b']: 1}        // => \"b\"\n *     let a = {[`b`]: 1}        // => \"b\"\n *     let a = {[100]: 1}        // => \"100\"\n *     let a = {[b]: 1}          // => null\n *     let a = {[\"a\" + \"b\"]: 1}  // => null\n *     let a = {[tag`b`]: 1}     // => null\n *     let a = {[`${b}`]: 1}     // => null\n * @param {ASTNode} node The node to get.\n * @returns {string|null} The property name if static. Otherwise, null.\n */\nfunction getStaticPropertyName(node) {\n    let prop;\n\n    switch (node && node.type) {\n        case \"ChainExpression\":\n            return getStaticPropertyName(node.expression);\n\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n            prop = node.key;\n            break;\n\n        case \"MemberExpression\":\n            prop = node.property;\n            break;\n\n            // no default\n    }\n\n    if (prop) {\n        if (prop.type === \"Identifier\" && !node.computed) {\n            return prop.name;\n        }\n\n        return getStaticStringValue(prop);\n    }\n\n    return null;\n}\n\n/**\n * Retrieve `ChainExpression#expression` value if the given node a `ChainExpression` node. Otherwise, pass through it.\n * @param {ASTNode} node The node to address.\n * @returns {ASTNode} The `ChainExpression#expression` value if the node is a `ChainExpression` node. Otherwise, the node.\n */\nfunction skipChainExpression(node) {\n    return node && node.type === \"ChainExpression\" ? node.expression : node;\n}\n\n/**\n * Check if the `actual` is an expected value.\n * @param {string} actual The string value to check.\n * @param {string | RegExp} expected The expected string value or pattern.\n * @returns {boolean} `true` if the `actual` is an expected value.\n */\nfunction checkText(actual, expected) {\n    return typeof expected === \"string\"\n        ? actual === expected\n        : expected.test(actual);\n}\n\n/**\n * Check if a given node is an Identifier node with a given name.\n * @param {ASTNode} node The node to check.\n * @param {string | RegExp} name The expected name or the expected pattern of the object name.\n * @returns {boolean} `true` if the node is an Identifier node with the name.\n */\nfunction isSpecificId(node, name) {\n    return node.type === \"Identifier\" && checkText(node.name, name);\n}\n\n/**\n * Check if a given node is member access with a given object name and property name pair.\n * This is regardless of optional or not.\n * @param {ASTNode} node The node to check.\n * @param {string | RegExp | null} objectName The expected name or the expected pattern of the object name. If this is nullish, this method doesn't check object.\n * @param {string | RegExp | null} propertyName The expected name or the expected pattern of the property name. If this is nullish, this method doesn't check property.\n * @returns {boolean} `true` if the node is member access with the object name and property name pair.\n * The node is a `MemberExpression` or `ChainExpression`.\n */\nfunction isSpecificMemberAccess(node, objectName, propertyName) {\n    const checkNode = skipChainExpression(node);\n\n    if (checkNode.type !== \"MemberExpression\") {\n        return false;\n    }\n\n    if (objectName && !isSpecificId(checkNode.object, objectName)) {\n        return false;\n    }\n\n    if (propertyName) {\n        const actualPropertyName = getStaticPropertyName(checkNode);\n\n        if (typeof actualPropertyName !== \"string\" || !checkText(actualPropertyName, propertyName)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two literal nodes are the same value.\n * @param {ASTNode} left The Literal node to compare.\n * @param {ASTNode} right The other Literal node to compare.\n * @returns {boolean} `true` if the two literal nodes are the same value.\n */\nfunction equalLiteralValue(left, right) {\n\n    // RegExp literal.\n    if (left.regex || right.regex) {\n        return Boolean(\n            left.regex &&\n            right.regex &&\n            left.regex.pattern === right.regex.pattern &&\n            left.regex.flags === right.regex.flags\n        );\n    }\n\n    // BigInt literal.\n    if (left.bigint || right.bigint) {\n        return left.bigint === right.bigint;\n    }\n\n    return left.value === right.value;\n}\n\n/**\n * Check if two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param {ASTNode} left The left side of the comparison.\n * @param {ASTNode} right The right side of the comparison.\n * @param {boolean} [disableStaticComputedKey] Don't address `a.b` and `a[\"b\"]` are the same if `true`. For backward compatibility.\n * @returns {boolean} `true` if both sides match and reference the same value.\n */\nfunction isSameReference(left, right, disableStaticComputedKey = false) {\n    if (left.type !== right.type) {\n\n        // Handle `a.b` and `a?.b` are samely.\n        if (left.type === \"ChainExpression\") {\n            return isSameReference(left.expression, right, disableStaticComputedKey);\n        }\n        if (right.type === \"ChainExpression\") {\n            return isSameReference(left, right.expression, disableStaticComputedKey);\n        }\n\n        return false;\n    }\n\n    switch (left.type) {\n        case \"Super\":\n        case \"ThisExpression\":\n            return true;\n\n        case \"Identifier\":\n        case \"PrivateIdentifier\":\n            return left.name === right.name;\n        case \"Literal\":\n            return equalLiteralValue(left, right);\n\n        case \"ChainExpression\":\n            return isSameReference(left.expression, right.expression, disableStaticComputedKey);\n\n        case \"MemberExpression\": {\n            if (!disableStaticComputedKey) {\n                const nameA = getStaticPropertyName(left);\n\n                // x.y = x[\"y\"]\n                if (nameA !== null) {\n                    return (\n                        isSameReference(left.object, right.object, disableStaticComputedKey) &&\n                        nameA === getStaticPropertyName(right)\n                    );\n                }\n            }\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return (\n                left.computed === right.computed &&\n                isSameReference(left.object, right.object, disableStaticComputedKey) &&\n                isSameReference(left.property, right.property, disableStaticComputedKey)\n            );\n        }\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n    return isSpecificMemberAccess(node, \"Reflect\", \"apply\");\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, \"from\");\n}\n\n/**\n * Checks whether or not a node is a method which expects a function as a first argument, and `thisArg` as a second argument.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a method which expects a function as a first argument, and `thisArg` as a second argument.\n */\nfunction isMethodWhichHasThisArg(node) {\n    return isSpecificMemberAccess(node, null, arrayMethodWithThisArgPattern);\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n    return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node A node to check.\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is a `=` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `=` token.\n */\nfunction isEqToken(token) {\n    return token.value === \"=\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a dot token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a dot token.\n */\nfunction isDotToken(token) {\n    return token.value === \".\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a `?.` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `?.` token.\n */\nfunction isQuestionDotToken(token) {\n    return token.value === \"?.\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n    return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n * @param {ASTNode} node The function node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n\n    // If the node is an arrow function and doesn't have parens, this returns the identifier of the first param.\n    if (node.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n        const argToken = sourceCode.getFirstToken(node.params[0]);\n        const maybeParenToken = sourceCode.getTokenBefore(argToken);\n\n        return isOpeningParenToken(maybeParenToken) ? maybeParenToken : argToken;\n    }\n\n    // Otherwise, returns paren.\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left A node 1 to compare.\n * @param {ASTNode} right A node 2 to compare.\n * @param {SourceCode} sourceCode The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if the given node is a true logical expression or not.\n *\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\n * coalesce (`??`) are known as `ShortCircuitExpression`.\n * But ESTree represents those by `LogicalExpression` node.\n *\n * This function rejects coalesce expressions of `LogicalExpression` node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `&&` or `||`.\n * @see https://tc39.es/ecma262/#prod-ShortCircuitExpression\n */\nfunction isLogicalExpression(node) {\n    return (\n        node.type === \"LogicalExpression\" &&\n            (node.operator === \"&&\" || node.operator === \"||\")\n    );\n}\n\n/**\n * Check if the given node is a nullish coalescing expression or not.\n *\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\n * coalesce (`??`) are known as `ShortCircuitExpression`.\n * But ESTree represents those by `LogicalExpression` node.\n *\n * This function finds only coalesce expressions of `LogicalExpression` node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `??`.\n */\nfunction isCoalesceExpression(node) {\n    return node.type === \"LogicalExpression\" && node.operator === \"??\";\n}\n\n/**\n * Check if given two nodes are the pair of a logical expression and a coalesce expression.\n * @param {ASTNode} left A node to check.\n * @param {ASTNode} right Another node to check.\n * @returns {boolean} `true` if the two nodes are the pair of a logical expression and a coalesce expression.\n */\nfunction isMixedLogicalAndCoalesceExpressions(left, right) {\n    return (\n        (isLogicalExpression(left) && isCoalesceExpression(right)) ||\n            (isCoalesceExpression(left) && isLogicalExpression(right))\n    );\n}\n\n/**\n * Checks if the given operator is a logical assignment operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} `true` if the operator is a logical assignment operator.\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);\n}\n\n/**\n * Get the colon token of the given SwitchCase node.\n * @param {ASTNode} node The SwitchCase node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} The colon token of the node.\n */\nfunction getSwitchCaseColonToken(node, sourceCode) {\n    if (node.test) {\n        return sourceCode.getTokenAfter(node.test, isColonToken);\n    }\n    return sourceCode.getFirstToken(node, 1);\n}\n\n/**\n * Gets ESM module export name represented by the given node.\n * @param {ASTNode} node `Identifier` or string `Literal` node in a position\n * that represents a module export name:\n *   - `ImportSpecifier#imported`\n *   - `ExportSpecifier#local` (if it is a re-export from another module)\n *   - `ExportSpecifier#exported`\n *   - `ExportAllDeclaration#exported`\n * @returns {string} The module export name.\n */\nfunction getModuleExportName(node) {\n    if (node.type === \"Identifier\") {\n        return node.name;\n    }\n\n    // string literal\n    return node.value;\n}\n\n/**\n * Returns literal's value converted to the Boolean type\n * @param {ASTNode} node any `Literal` node\n * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n *  `null` when it cannot be determined.\n */\nfunction getBooleanValue(node) {\n    if (node.value === null) {\n\n        /*\n         * it might be a null literal or bigint/regex literal in unsupported environments .\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n         */\n\n        if (node.raw === \"null\") {\n            return false;\n        }\n\n        // regex is always truthy\n        if (typeof node.regex === \"object\") {\n            return true;\n        }\n\n        return null;\n    }\n\n    return !!node.value;\n}\n\n/**\n * Checks if a branch node of LogicalExpression short circuits the whole condition\n * @param {ASTNode} node The branch of main condition which needs to be checked\n * @param {string} operator The operator of the main LogicalExpression.\n * @returns {boolean} true when condition short circuits whole condition\n */\nfunction isLogicalIdentity(node, operator) {\n    switch (node.type) {\n        case \"Literal\":\n            return (operator === \"||\" && getBooleanValue(node) === true) ||\n                  (operator === \"&&\" && getBooleanValue(node) === false);\n\n        case \"UnaryExpression\":\n            return (operator === \"&&\" && node.operator === \"void\");\n\n        case \"LogicalExpression\":\n\n            /*\n             * handles `a && false || b`\n             * `false` is an identity element of `&&` but not `||`\n             */\n            return operator === node.operator &&\n                    (\n                        isLogicalIdentity(node.left, operator) ||\n                        isLogicalIdentity(node.right, operator)\n                    );\n\n        case \"AssignmentExpression\":\n            return [\"||=\", \"&&=\"].includes(node.operator) &&\n               operator === node.operator.slice(0, -1) &&\n               isLogicalIdentity(node.right, operator);\n\n       // no default\n    }\n    return false;\n}\n\n/**\n * Checks if an identifier is a reference to a global variable.\n * @param {Scope} scope The scope in which the identifier is referenced.\n * @param {ASTNode} node An identifier node to check.\n * @returns {boolean} `true` if the identifier is a reference to a global variable.\n */\nfunction isReferenceToGlobalVariable(scope, node) {\n    const reference = scope.references.find(ref => ref.identifier === node);\n\n    return Boolean(\n        reference &&\n            reference.resolved &&\n            reference.resolved.scope.type === \"global\" &&\n            reference.resolved.defs.length === 0\n    );\n}\n\n\n/**\n * Checks if a  node has a constant truthiness value.\n * @param {Scope} scope Scope in which the node appears.\n * @param {ASTNode} node The AST node to check.\n * @param {boolean} inBooleanPosition `true` if checking the test of a\n * condition. `false` in all other cases. When `false`, checks if -- for\n * both string and number -- if coerced to that type, the value will\n * be constant.\n * @returns {boolean} true when node's truthiness is constant\n * @private\n */\nfunction isConstant(scope, node, inBooleanPosition) {\n\n    // node.elements can return null values in the case of sparse arrays ex. [,]\n    if (!node) {\n        return true;\n    }\n    switch (node.type) {\n        case \"Literal\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n            return true;\n        case \"ClassExpression\":\n        case \"ObjectExpression\":\n\n            /**\n             * In theory objects like:\n             *\n             * `{toString: () => a}`\n             * `{valueOf: () => a}`\n             *\n             * Or a classes like:\n             *\n             * `class { static toString() { return a } }`\n             * `class { static valueOf() { return a } }`\n             *\n             * Are not constant verifiably when `inBooleanPosition` is\n             * false, but it's an edge case we've opted not to handle.\n             */\n            return true;\n        case \"TemplateLiteral\":\n            return (inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length)) ||\n                        node.expressions.every(exp => isConstant(scope, exp, false));\n\n        case \"ArrayExpression\": {\n            if (!inBooleanPosition) {\n                return node.elements.every(element => isConstant(scope, element, false));\n            }\n            return true;\n        }\n\n        case \"UnaryExpression\":\n            if (\n                node.operator === \"void\" ||\n                        node.operator === \"typeof\" && inBooleanPosition\n            ) {\n                return true;\n            }\n\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            return isConstant(scope, node.argument, false);\n\n        case \"BinaryExpression\":\n            return isConstant(scope, node.left, false) &&\n                            isConstant(scope, node.right, false) &&\n                            node.operator !== \"in\";\n\n        case \"LogicalExpression\": {\n            const isLeftConstant = isConstant(scope, node.left, inBooleanPosition);\n            const isRightConstant = isConstant(scope, node.right, inBooleanPosition);\n            const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n            const isRightShortCircuit = (inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n            return (isLeftConstant && isRightConstant) ||\n                        isLeftShortCircuit ||\n                        isRightShortCircuit;\n        }\n        case \"NewExpression\":\n            return inBooleanPosition;\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return isConstant(scope, node.right, inBooleanPosition);\n            }\n\n            if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n                return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n            }\n\n            return false;\n\n        case \"SequenceExpression\":\n            return isConstant(scope, node.expressions[node.expressions.length - 1], inBooleanPosition);\n        case \"SpreadElement\":\n            return isConstant(scope, node.argument, inBooleanPosition);\n        case \"CallExpression\":\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\") {\n                if (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true)) {\n                    return isReferenceToGlobalVariable(scope, node.callee);\n                }\n            }\n            return false;\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n\n                // no default\n    }\n    return false;\n}\n\n/**\n * Checks whether a node is an ExpressionStatement at the top level of a file or function body.\n * A top-level ExpressionStatement node is a directive if it contains a single unparenthesized\n * string literal and if it occurs either as the first sibling or immediately after another\n * directive.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the node is an ExpressionStatement at the top level of a\n * file or function body.\n */\nfunction isTopLevelExpressionStatement(node) {\n    if (node.type !== \"ExpressionStatement\") {\n        return false;\n    }\n    const parent = node.parent;\n\n    return parent.type === \"Program\" || (parent.type === \"BlockStatement\" && isFunction(parent.parent));\n\n}\n\n/**\n * Check whether the given node is a part of a directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirective(node) {\n    return node.type === \"ExpressionStatement\" && typeof node.directive === \"string\";\n}\n\n/**\n * Tests if a node appears at the beginning of an ancestor ExpressionStatement node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether the node appears at the beginning of an ancestor ExpressionStatement node.\n */\nfunction isStartOfExpressionStatement(node) {\n    const start = node.range[0];\n    let ancestor = node;\n\n    while ((ancestor = ancestor.parent) && ancestor.range[0] === start) {\n        if (ancestor.type === \"ExpressionStatement\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines whether an opening parenthesis `(`, bracket `[` or backtick ``` ` ``` needs to be preceded by a semicolon.\n * This opening parenthesis or bracket should be at the start of an `ExpressionStatement` or at the start of the body of an `ArrowFunctionExpression`.\n * @type {(sourceCode: SourceCode, node: ASTNode) => boolean}\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode} node A node at the position where an opening parenthesis or bracket will be inserted.\n * @returns {boolean} Whether a semicolon is required before the opening parenthesis or braket.\n */\nlet needsPrecedingSemicolon;\n\n{\n    const BREAK_OR_CONTINUE = new Set([\"BreakStatement\", \"ContinueStatement\"]);\n\n    // Declaration types that must contain a string Literal node at the end.\n    const DECLARATIONS = new Set([\"ExportAllDeclaration\", \"ExportNamedDeclaration\", \"ImportDeclaration\"]);\n\n    const IDENTIFIER_OR_KEYWORD = new Set([\"Identifier\", \"Keyword\"]);\n\n    // Keywords that can immediately precede an ExpressionStatement node, mapped to the their node types.\n    const NODE_TYPES_BY_KEYWORD = {\n        __proto__: null,\n        break: \"BreakStatement\",\n        continue: \"ContinueStatement\",\n        debugger: \"DebuggerStatement\",\n        do: \"DoWhileStatement\",\n        else: \"IfStatement\",\n        return: \"ReturnStatement\",\n        yield: \"YieldExpression\"\n    };\n\n    /*\n     * Before an opening parenthesis, postfix `++` and `--` always trigger ASI;\n     * the tokens `:`, `;`, `{` and `=>` don't expect a semicolon, as that would count as an empty statement.\n     */\n    const PUNCTUATORS = new Set([\":\", \";\", \"{\", \"=>\", \"++\", \"--\"]);\n\n    /*\n     * Statements that can contain an `ExpressionStatement` after a closing parenthesis.\n     * DoWhileStatement is an exception in that it always triggers ASI after the closing parenthesis.\n     */\n    const STATEMENTS = new Set([\n        \"DoWhileStatement\",\n        \"ForInStatement\",\n        \"ForOfStatement\",\n        \"ForStatement\",\n        \"IfStatement\",\n        \"WhileStatement\",\n        \"WithStatement\"\n    ]);\n\n    needsPrecedingSemicolon =\n    function(sourceCode, node) {\n        const prevToken = sourceCode.getTokenBefore(node);\n\n        if (!prevToken || prevToken.type === \"Punctuator\" && PUNCTUATORS.has(prevToken.value)) {\n            return false;\n        }\n\n        const prevNode = sourceCode.getNodeByRangeIndex(prevToken.range[0]);\n\n        if (isClosingParenToken(prevToken)) {\n            return !STATEMENTS.has(prevNode.type);\n        }\n\n        if (isClosingBraceToken(prevToken)) {\n            return (\n                prevNode.type === \"BlockStatement\" && prevNode.parent.type === \"FunctionExpression\" ||\n                prevNode.type === \"ClassBody\" && prevNode.parent.type === \"ClassExpression\" ||\n                prevNode.type === \"ObjectExpression\"\n            );\n        }\n\n        if (IDENTIFIER_OR_KEYWORD.has(prevToken.type)) {\n            if (BREAK_OR_CONTINUE.has(prevNode.parent.type)) {\n                return false;\n            }\n\n            const keyword = prevToken.value;\n            const nodeType = NODE_TYPES_BY_KEYWORD[keyword];\n\n            return prevNode.type !== nodeType;\n        }\n\n        if (prevToken.type === \"String\") {\n            return !DECLARATIONS.has(prevNode.parent.type);\n        }\n\n        return true;\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    COMMENTS_IGNORE_PATTERN,\n    LINEBREAKS,\n    LINEBREAK_MATCHER: lineBreakPattern,\n    SHEBANG_MATCHER: shebangPattern,\n    STATEMENT_LIST_PARENTS,\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left The left token object.\n     * @param {Object} right The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop,\n    isArrayFromMethod,\n    isParenthesised,\n    createGlobalLinebreakMatcher,\n    equalTokens,\n\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isDotToken,\n    isQuestionDotToken,\n    isKeywordToken,\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotDotToken: negate(isDotToken),\n    isNotQuestionDotToken: negate(isQuestionDotToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n    isEqToken,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param {string} val The text to check.\n     * @param {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {Line|Block} node The comment token to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.startsWith(\"eslint-\") ||\n            node.type === \"Block\" && ESLINT_DIRECTIVE_PATTERN.test(comment)\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     * @param {eslint-scope.Scope} initScope A scope to start find.\n     * @param {string} name A variable name to find.\n     * @returns {eslint-scope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The given node is not in `PropertyDefinition#value` position.\n     * - The given node is not `StaticBlock`.\n     * - The function name does not start with uppercase. It's a convention to capitalize the names\n     *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\n     *   functions only, as the name of the variable is considered to be the name of the function in this case.\n     *   This check is not performed if `capIsConstructor` is set to `false`.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`\n     * or any expression that is `PropertyDefinition#value` node.\n     * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n     * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\n     * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode, { capIsConstructor = true } = {}) {\n\n        /*\n         * Class field initializers are implicit functions, but ESTree doesn't have the AST node of field initializers.\n         * Therefore, A expression node at `PropertyDefinition#value` is a function.\n         * In this case, `this` is always not default binding.\n         */\n        if (node.parent.type === \"PropertyDefinition\" && node.parent.value === node) {\n            return false;\n        }\n\n        // Class static blocks are implicit functions. In this case, `this` is always not default binding.\n        if (node.type === \"StaticBlock\") {\n            return false;\n        }\n\n        if (\n            (capIsConstructor && isES5Constructor(node)) ||\n            hasJSDocThisTag(node, sourceCode)\n        ) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n        let currentNode = node;\n\n        while (currentNode) {\n            const parent = currentNode.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                case \"ChainExpression\":\n                    currentNode = parent;\n                    break;\n\n                /*\n                 * If the upper function is IIFE, checks the destination of the return value.\n                 * e.g.\n                 *   obj.foo = (function() {\n                 *     // setup...\n                 *     return function foo() { ... };\n                 *   })();\n                 *   obj.foo = (() =>\n                 *     function foo() { ... }\n                 *   )();\n                 */\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    currentNode = func.parent;\n                    break;\n                }\n                case \"ArrowFunctionExpression\":\n                    if (currentNode !== parent.body || !isCallee(parent)) {\n                        return true;\n                    }\n                    currentNode = parent.parent;\n                    break;\n\n                /*\n                 * e.g.\n                 *   var obj = { foo() { ... } };\n                 *   var obj = { foo: function() { ... } };\n                 *   class A { constructor() { ... } }\n                 *   class A { foo() { ... } }\n                 *   class A { get foo() { ... } }\n                 *   class A { set foo() { ... } }\n                 *   class A { static foo() { ... } }\n                 *   class A { foo = function() { ... } }\n                 */\n                case \"Property\":\n                case \"PropertyDefinition\":\n                case \"MethodDefinition\":\n                    return parent.value !== currentNode;\n\n                /*\n                 * e.g.\n                 *   obj.foo = function foo() { ... };\n                 *   Foo = function() { ... };\n                 *   [obj.foo = function foo() { ... }] = a;\n                 *   [Foo = function() { ... }] = a;\n                 */\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.left.type === \"MemberExpression\") {\n                        return false;\n                    }\n                    if (\n                        capIsConstructor &&\n                        isAnonymous &&\n                        parent.left.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.left.name)\n                    ) {\n                        return false;\n                    }\n                    return true;\n\n                /*\n                 * e.g.\n                 *   var Foo = function() { ... };\n                 */\n                case \"VariableDeclarator\":\n                    return !(\n                        capIsConstructor &&\n                        isAnonymous &&\n                        parent.init === currentNode &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                /*\n                 * e.g.\n                 *   var foo = function foo() { ... }.bind(obj);\n                 *   (function foo() { ... }).call(obj);\n                 *   (function foo() { ... }).apply(obj, []);\n                 */\n                case \"MemberExpression\":\n                    if (\n                        parent.object === currentNode &&\n                        isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)\n                    ) {\n                        const maybeCalleeNode = parent.parent.type === \"ChainExpression\"\n                            ? parent.parent\n                            : parent;\n\n                        return !(\n                            isCallee(maybeCalleeNode) &&\n                            maybeCalleeNode.parent.arguments.length >= 1 &&\n                            !isNullOrUndefined(maybeCalleeNode.parent.arguments[0])\n                        );\n                    }\n                    return true;\n\n                /*\n                 * e.g.\n                 *   Reflect.apply(function() {}, obj, []);\n                 *   Array.from([], function() {}, obj);\n                 *   list.forEach(function() {}, obj);\n                 */\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* c8 ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                    case \"??\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    case \"**\":\n                        return 15;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 16;\n\n            case \"UpdateExpression\":\n                return 17;\n\n            case \"CallExpression\":\n            case \"ChainExpression\":\n            case \"ImportExpression\":\n                return 18;\n\n            case \"NewExpression\":\n                return 19;\n\n            default:\n                if (node.type in eslintVisitorKeys) {\n                    return 20;\n                }\n\n                /*\n                 * if the node is not a standard node that we know about, then assume it has the lowest precedence\n                 * this will mean that rules will wrap unknown nodes in parentheses where applicable instead of\n                 * unwrapping them and potentially changing the meaning of the code or introducing a syntax error.\n                 */\n                return -1;\n        }\n    },\n\n    /**\n     * Checks whether the given node is an empty block node or not.\n     * @param {ASTNode|null} node The node to check.\n     * @returns {boolean} `true` if the node is an empty block.\n     */\n    isEmptyBlock(node) {\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    /**\n     * Checks whether the given node is an empty function node or not.\n     * @param {ASTNode|null} node The node to check.\n     * @returns {boolean} `true` if the node is an empty function.\n     */\n    isEmptyFunction(node) {\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            /*\n             * Do not check arrow functions with implicit return.\n             * `() => \"use strict\";` returns the string `\"use strict\"`.\n             */\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     * after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 0         // true\n     * 5         // true\n     * 50        // true\n     * 5_000     // true\n     * 1_234_56  // true\n     * 08        // true\n     * 0192      // true\n     * 5.        // false\n     * .5        // false\n     * 5.0       // false\n     * 5.00_00   // false\n     * 05        // false\n     * 0x5       // false\n     * 0b101     // false\n     * 0b11_01   // false\n     * 0o5       // false\n     * 5e0       // false\n     * 5e1_000   // false\n     * 5n        // false\n     * 1_000n    // false\n     * \"5\"       // false\n     *\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" &&\n            DECIMAL_INTEGER_PATTERN.test(node.raw);\n    },\n\n    /**\n     * Determines whether this token is a decimal integer numeric token.\n     * This is similar to isDecimalInteger(), but for tokens.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if this token is a decimal integer.\n     */\n    isDecimalIntegerNumericToken(token) {\n        return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n    },\n\n    /**\n     * Gets the name and kind of the given function node.\n     *\n     * - `function foo() {}`  .................... `function 'foo'`\n     * - `(function foo() {})`  .................. `function 'foo'`\n     * - `(function() {})`  ...................... `function`\n     * - `function* foo() {}`  ................... `generator function 'foo'`\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\n     * - `(function*() {})`  ..................... `generator function`\n     * - `() => {}`  ............................. `arrow function`\n     * - `async () => {}`  ....................... `async arrow function`\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n     * - `({ [foo]: function() {} })`  ........... `method`\n     * - `({ foo() {} })`  ....................... `method 'foo'`\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n     * - `({ [foo]: async function() {} })`  ..... `async method`\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n     * - `class A { constructor() {} }`  ......... `constructor`\n     * - `class A { foo() {} }`  ................. `method 'foo'`\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n     * - `class A { [foo]() {} }`  ............... `method`\n     * - `class A { *[foo]() {} }`  .............. `generator method`\n     * - `class A { async [foo]() {} }`  ......... `async method`\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n     * - `class A { foo = () => {}; }`  .......... `method 'foo'`\n     * - `class A { foo = function() {}; }`  ..... `method 'foo'`\n     * - `class A { foo = function bar() {}; }`  . `method 'foo'`\n     * - `class A { static foo = () => {}; }`  ... `static method 'foo'`\n     * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`\n     * - `class A { #foo = () => {}; }`  ......... `private method #foo`\n     * - `class A { static #foo = () => {}; }`  .. `static private method #foo`\n     * - `class A { '#foo'() {} }`  .............. `method '#foo'`\n     * - `class A { #foo() {} }`  ................ `private method #foo`\n     * - `class A { static #foo() {} }`  ......... `static private method #foo`\n     * @param {ASTNode} node The function node to get.\n     * @returns {string} The name and kind of the function node.\n     */\n    getFunctionNameWithKind(node) {\n        const parent = node.parent;\n        const tokens = [];\n\n        if (parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n\n            // The proposal uses `static` word consistently before visibility words: https://github.com/tc39/proposal-static-class-features\n            if (parent.static) {\n                tokens.push(\"static\");\n            }\n            if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\n                tokens.push(\"private\");\n            }\n        }\n        if (node.async) {\n            tokens.push(\"async\");\n        }\n        if (node.generator) {\n            tokens.push(\"generator\");\n        }\n\n        if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            if (parent.kind === \"constructor\") {\n                return \"constructor\";\n            }\n            if (parent.kind === \"get\") {\n                tokens.push(\"getter\");\n            } else if (parent.kind === \"set\") {\n                tokens.push(\"setter\");\n            } else {\n                tokens.push(\"method\");\n            }\n        } else if (parent.type === \"PropertyDefinition\") {\n            tokens.push(\"method\");\n        } else {\n            if (node.type === \"ArrowFunctionExpression\") {\n                tokens.push(\"arrow\");\n            }\n            tokens.push(\"function\");\n        }\n\n        if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n            if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\n                tokens.push(`#${parent.key.name}`);\n            } else {\n                const name = getStaticPropertyName(parent);\n\n                if (name !== null) {\n                    tokens.push(`'${name}'`);\n                } else if (node.id) {\n                    tokens.push(`'${node.id.name}'`);\n                }\n            }\n        } else if (node.id) {\n            tokens.push(`'${node.id.name}'`);\n        }\n\n        return tokens.join(\" \");\n    },\n\n    /**\n     * Gets the location of the given function node for reporting.\n     *\n     * - `function foo() {}`\n     *    ^^^^^^^^^^^^\n     * - `(function foo() {})`\n     *     ^^^^^^^^^^^^\n     * - `(function() {})`\n     *     ^^^^^^^^\n     * - `function* foo() {}`\n     *    ^^^^^^^^^^^^^\n     * - `(function* foo() {})`\n     *     ^^^^^^^^^^^^^\n     * - `(function*() {})`\n     *     ^^^^^^^^^\n     * - `() => {}`\n     *       ^^\n     * - `async () => {}`\n     *             ^^\n     * - `({ foo: function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ foo: function() {} })`\n     *       ^^^^^^^^^^^^^\n     * - `({ ['foo']: function() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function() {} })`\n     *       ^^^^^^^^^^^^^^^\n     * - `({ foo() {} })`\n     *       ^^^\n     * - `({ foo: function* foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ foo: function*() {} })`\n     *       ^^^^^^^^^^^^^^\n     * - `({ ['foo']: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^\n     * - `({ *foo() {} })`\n     *       ^^^^\n     * - `({ foo: async function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ foo: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^\n     * - `({ ['foo']: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^\n     * - `({ async foo() {} })`\n     *       ^^^^^^^^^\n     * - `({ get foo() {} })`\n     *       ^^^^^^^\n     * - `({ set foo(a) {} })`\n     *       ^^^^^^^\n     * - `class A { constructor() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { foo() {} }`\n     *              ^^^\n     * - `class A { *foo() {} }`\n     *              ^^^^\n     * - `class A { async foo() {} }`\n     *              ^^^^^^^^^\n     * - `class A { ['foo']() {} }`\n     *              ^^^^^^^\n     * - `class A { *['foo']() {} }`\n     *              ^^^^^^^^\n     * - `class A { async ['foo']() {} }`\n     *              ^^^^^^^^^^^^^\n     * - `class A { [foo]() {} }`\n     *              ^^^^^\n     * - `class A { *[foo]() {} }`\n     *              ^^^^^^\n     * - `class A { async [foo]() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { get foo() {} }`\n     *              ^^^^^^^\n     * - `class A { set foo(a) {} }`\n     *              ^^^^^^^\n     * - `class A { static foo() {} }`\n     *              ^^^^^^^^^^\n     * - `class A { static *foo() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { static async foo() {} }`\n     *              ^^^^^^^^^^^^^^^^\n     * - `class A { static get foo() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static set foo(a) {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { foo = function() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static foo = function() {} }`\n     *              ^^^^^^^^^^^^^^^^^^^^^\n     * - `class A { foo = (a, b) => {} }`\n     *              ^^^^^^\n     * @param {ASTNode} node The function node to get.\n     * @param {SourceCode} sourceCode The source code object to get tokens.\n     * @returns {string} The location of the function node for reporting.\n     */\n    getFunctionHeadLoc(node, sourceCode) {\n        const parent = node.parent;\n        let start = null;\n        let end = null;\n\n        if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n            start = parent.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        } else if (node.type === \"ArrowFunctionExpression\") {\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n            start = arrowToken.loc.start;\n            end = arrowToken.loc.end;\n        } else {\n            start = node.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        }\n\n        return {\n            start: Object.assign({}, start),\n            end: Object.assign({}, end)\n        };\n    },\n\n    /**\n     * Gets next location when the result is not out of bound, otherwise returns null.\n     *\n     * Assumptions:\n     *\n     * - The given location represents a valid location in the given source code.\n     * - Columns are 0-based.\n     * - Lines are 1-based.\n     * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.\n     * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.\n     *   The start (column 0) of that extra line is considered to be a valid location.\n     *\n     * Examples of successive locations (line, column):\n     *\n     * code: foo\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null\n     *\n     * code: foo<LF>\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\n     *\n     * code: foo<CR><LF>\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\n     *\n     * code: a<LF>b\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null\n     *\n     * code: a<LF>b<LF>\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\n     *\n     * code: a<CR><LF>b<CR><LF>\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\n     *\n     * code: a<LF><LF>\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null\n     *\n     * code: <LF>\n     * locations: (1, 0) -> (2, 0) -> null\n     *\n     * code:\n     * locations: (1, 0) -> null\n     * @param {SourceCode} sourceCode The sourceCode\n     * @param {{line: number, column: number}} location The location\n     * @returns {{line: number, column: number} | null} Next location\n     */\n    getNextLocation(sourceCode, { line, column }) {\n        if (column < sourceCode.lines[line - 1].length) {\n            return {\n                line,\n                column: column + 1\n            };\n        }\n\n        if (line < sourceCode.lines.length) {\n            return {\n                line: line + 1,\n                column: 0\n            };\n        }\n\n        return null;\n    },\n\n    /**\n     * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n     * surrounding the node.\n     * @param {SourceCode} sourceCode The source code object\n     * @param {ASTNode} node An expression node\n     * @returns {string} The text representing the node, with all surrounding parentheses included\n     */\n    getParenthesisedText(sourceCode, node) {\n        let leftToken = sourceCode.getFirstToken(node);\n        let rightToken = sourceCode.getLastToken(node);\n\n        while (\n            sourceCode.getTokenBefore(leftToken) &&\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\n            sourceCode.getTokenAfter(rightToken) &&\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\n            sourceCode.getTokenAfter(rightToken).value === \")\"\n        ) {\n            leftToken = sourceCode.getTokenBefore(leftToken);\n            rightToken = sourceCode.getTokenAfter(rightToken);\n        }\n\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    /**\n     * Determine if a node has a possibility to be an Error object\n     * @param {ASTNode} node ASTNode to check\n     * @returns {boolean} True if there is a chance it contains an Error obj\n     */\n    couldBeError(node) {\n        switch (node.type) {\n            case \"Identifier\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"YieldExpression\":\n            case \"AwaitExpression\":\n            case \"ChainExpression\":\n                return true; // possibly an error object.\n\n            case \"AssignmentExpression\":\n                if ([\"=\", \"&&=\"].includes(node.operator)) {\n                    return module.exports.couldBeError(node.right);\n                }\n\n                if ([\"||=\", \"??=\"].includes(node.operator)) {\n                    return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n                }\n\n                /**\n                 * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n                 * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n                 * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.\n                 */\n                return false;\n\n            case \"SequenceExpression\": {\n                const exprs = node.expressions;\n\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n            }\n\n            case \"LogicalExpression\":\n\n                /*\n                 * If the && operator short-circuits, the left side was falsy and therefore not an error, and if it\n                 * doesn't short-circuit, it takes the value from the right side, so the right side must always be\n                 * a plausible error. A future improvement could verify that the left side could be truthy by\n                 * excluding falsy literals.\n                 */\n                if (node.operator === \"&&\") {\n                    return module.exports.couldBeError(node.right);\n                }\n\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n            case \"ConditionalExpression\":\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n            default:\n                return false;\n        }\n    },\n\n    /**\n     * Check if a given node is a numeric literal or not.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is a number or bigint literal.\n     */\n    isNumericLiteral(node) {\n        return (\n            node.type === \"Literal\" &&\n            (typeof node.value === \"number\" || Boolean(node.bigint))\n        );\n    },\n\n    /**\n     * Determines whether two tokens can safely be placed next to each other without merging into a single token\n     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\n     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\n     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\n     * next to each other, behavior is undefined (although it should return `true` in most cases).\n     */\n    canTokensBeAdjacent(leftValue, rightValue) {\n        const espreeOptions = {\n            ecmaVersion: espree.latestEcmaVersion,\n            comment: true,\n            range: true\n        };\n\n        let leftToken;\n\n        if (typeof leftValue === \"string\") {\n            let tokens;\n\n            try {\n                tokens = espree.tokenize(leftValue, espreeOptions);\n            } catch {\n                return false;\n            }\n\n            const comments = tokens.comments;\n\n            leftToken = tokens[tokens.length - 1];\n            if (comments.length) {\n                const lastComment = comments[comments.length - 1];\n\n                if (!leftToken || lastComment.range[0] > leftToken.range[0]) {\n                    leftToken = lastComment;\n                }\n            }\n        } else {\n            leftToken = leftValue;\n        }\n\n        /*\n         * If a hashbang comment was passed as a token object from SourceCode,\n         * its type will be \"Shebang\" because of the way ESLint itself handles hashbangs.\n         * If a hashbang comment was passed in a string and then tokenized in this function,\n         * its type will be \"Hashbang\" because of the way Espree tokenizes hashbangs.\n         */\n        if (leftToken.type === \"Shebang\" || leftToken.type === \"Hashbang\") {\n            return false;\n        }\n\n        let rightToken;\n\n        if (typeof rightValue === \"string\") {\n            let tokens;\n\n            try {\n                tokens = espree.tokenize(rightValue, espreeOptions);\n            } catch {\n                return false;\n            }\n\n            const comments = tokens.comments;\n\n            rightToken = tokens[0];\n            if (comments.length) {\n                const firstComment = comments[0];\n\n                if (!rightToken || firstComment.range[0] < rightToken.range[0]) {\n                    rightToken = firstComment;\n                }\n            }\n        } else {\n            rightToken = rightValue;\n        }\n\n        if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n            if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n                const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n                const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n\n                return !(\n                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||\n                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)\n                );\n            }\n            if (leftToken.type === \"Punctuator\" && leftToken.value === \"/\") {\n                return ![\"Block\", \"Line\", \"RegularExpression\"].includes(rightToken.type);\n            }\n            return true;\n        }\n\n        if (\n            leftToken.type === \"String\" || rightToken.type === \"String\" ||\n            leftToken.type === \"Template\" || rightToken.type === \"Template\"\n        ) {\n            return true;\n        }\n\n        if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n            return true;\n        }\n\n        if (leftToken.type === \"Block\" || rightToken.type === \"Block\" || rightToken.type === \"Line\") {\n            return true;\n        }\n\n        if (rightToken.type === \"PrivateIdentifier\") {\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Get the `loc` object of a given name in a `/*globals` directive comment.\n     * @param {SourceCode} sourceCode The source code to convert index to loc.\n     * @param {Comment} comment The `/*globals` directive comment which include the name.\n     * @param {string} name The name to find.\n     * @returns {SourceLocation} The `loc` object.\n     */\n    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n        const namePattern = new RegExp(`[\\\\s,]${escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\");\n\n        // To ignore the first text \"global\".\n        namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n        // Search a given variable name.\n        const match = namePattern.exec(comment.value);\n\n        // Convert the index to loc.\n        const start = sourceCode.getLocFromIndex(\n            comment.range[0] +\n            \"/*\".length +\n            (match ? match.index + 1 : 0)\n        );\n        const end = {\n            line: start.line,\n            column: start.column + (match ? name.length : 1)\n        };\n\n        return { start, end };\n    },\n\n    /**\n     * Determines whether the given raw string contains an octal escape sequence\n     * or a non-octal decimal escape sequence (\"\\8\", \"\\9\").\n     *\n     * \"\\1\", \"\\2\" ... \"\\7\", \"\\8\", \"\\9\"\n     * \"\\00\", \"\\01\" ... \"\\07\", \"\\08\", \"\\09\"\n     *\n     * \"\\0\", when not followed by a digit, is not an octal escape sequence.\n     * @param {string} rawString A string in its raw representation.\n     * @returns {boolean} `true` if the string contains at least one octal escape sequence\n     * or at least one non-octal decimal escape sequence.\n     */\n    hasOctalOrNonOctalDecimalEscapeSequence(rawString) {\n        return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);\n    },\n\n    /**\n     * Determines whether the given node is a template literal without expressions.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is a template literal without expressions.\n     */\n    isStaticTemplateLiteral(node) {\n        return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n    },\n\n    isReferenceToGlobalVariable,\n    isLogicalExpression,\n    isCoalesceExpression,\n    isMixedLogicalAndCoalesceExpressions,\n    isNullLiteral,\n    getStaticStringValue,\n    getStaticPropertyName,\n    skipChainExpression,\n    isSpecificId,\n    isSpecificMemberAccess,\n    equalLiteralValue,\n    isSameReference,\n    isLogicalAssignmentOperator,\n    getSwitchCaseColonToken,\n    getModuleExportName,\n    isConstant,\n    isTopLevelExpressionStatement,\n    isDirective,\n    isStartOfExpressionStatement,\n    needsPrecedingSemicolon\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}