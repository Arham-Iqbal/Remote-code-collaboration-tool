{"ast":null,"code":"/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\nconst escapeRegExp = require(\"escape-string-regexp\");\n\n/**\n * Compares the locations of two objects in a source file\n * @param {{line: number, column: number}} itemA The first object\n * @param {{line: number, column: number}} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\nfunction compareLocations(itemA, itemB) {\n  return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\n/**\n * Groups a set of directives into sub-arrays by their parent comment.\n * @param {Iterable<Directive>} directives Unused directives to be removed.\n * @returns {Directive[][]} Directives grouped by their parent comment.\n */\nfunction groupByParentComment(directives) {\n  const groups = new Map();\n  for (const directive of directives) {\n    const {\n      unprocessedDirective: {\n        parentComment\n      }\n    } = directive;\n    if (groups.has(parentComment)) {\n      groups.get(parentComment).push(directive);\n    } else {\n      groups.set(parentComment, [directive]);\n    }\n  }\n  return [...groups.values()];\n}\n\n/**\n * Creates removal details for a set of directives within the same comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction createIndividualDirectivesRemoval(directives, commentToken) {\n  /*\n   * `commentToken.value` starts right after `//` or `/*`.\n   * All calculated offsets will be relative to this index.\n   */\n  const commentValueStart = commentToken.range[0] + \"//\".length;\n\n  // Find where the list of rules starts. `\\S+` matches with the directive name (e.g. `eslint-disable-line`)\n  const listStartOffset = /^\\s*\\S+\\s+/u.exec(commentToken.value)[0].length;\n\n  /*\n   * Get the list text without any surrounding whitespace. In order to preserve the original\n   * formatting, we don't want to change that whitespace.\n   *\n   *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n   *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   */\n  const listText = commentToken.value.slice(listStartOffset) // remove directive name and all whitespace before the list\n  .split(/\\s-{2,}\\s/u)[0] // remove `-- comment`, if it exists\n  .trimEnd(); // remove all whitespace after the list\n\n  /*\n   * We can assume that `listText` contains multiple elements.\n   * Otherwise, this function wouldn't be called - if there is\n   * only one rule in the list, then the whole comment must be removed.\n   */\n\n  return directives.map(directive => {\n    const {\n      ruleId\n    } = directive;\n    const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)(?<quote>['\"]?)${escapeRegExp(ruleId)}\\k<quote>(?:\\s*,\\s*|$)`, \"u\");\n    const match = regex.exec(listText);\n    const matchedText = match[0];\n    const matchStartOffset = listStartOffset + match.index;\n    const matchEndOffset = matchStartOffset + matchedText.length;\n    const firstIndexOfComma = matchedText.indexOf(\",\");\n    const lastIndexOfComma = matchedText.lastIndexOf(\",\");\n    let removalStartOffset, removalEndOffset;\n    if (firstIndexOfComma !== lastIndexOfComma) {\n      /*\n       * Since there are two commas, this must one of the elements in the middle of the list.\n       * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                                    ^^^^^^^^^^^^^^\n       *\n       * We want to remove only the content between the two commas, and also one of the commas.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                                     ^^^^^^^^^^^\n       */\n      removalStartOffset = matchStartOffset + firstIndexOfComma;\n      removalEndOffset = matchStartOffset + lastIndexOfComma;\n    } else {\n      /*\n       * This is either the first element or the last element.\n       *\n       * If this is the first element, matched range starts where the first rule name starts\n       * and ends where the second rule name starts. This is exactly the range we want\n       * to remove so that the second rule name will start where the first one was starting\n       * and thus preserve the original formatting.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                            ^^^^^^^^^^^\n       *\n       * Similarly, if this is the last element, we've already matched the range we want to\n       * remove. The previous rule name will end where the last one was ending, relative\n       * to the content on the right side.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                                               ^^^^^^^^^^^^^\n       */\n      removalStartOffset = matchStartOffset;\n      removalEndOffset = matchEndOffset;\n    }\n    return {\n      description: `'${ruleId}'`,\n      fix: {\n        range: [commentValueStart + removalStartOffset, commentValueStart + removalEndOffset],\n        text: \"\"\n      },\n      unprocessedDirective: directive.unprocessedDirective\n    };\n  });\n}\n\n/**\n * Creates a description of deleting an entire unused disable comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output Problem.\n */\nfunction createCommentRemoval(directives, commentToken) {\n  const {\n    range\n  } = commentToken;\n  const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\n  return {\n    description: ruleIds.length <= 2 ? ruleIds.join(\" or \") : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds[ruleIds.length - 1]}`,\n    fix: {\n      range,\n      text: \" \"\n    },\n    unprocessedDirective: directives[0].unprocessedDirective\n  };\n}\n\n/**\n * Parses details from directives to create output Problems.\n * @param {Iterable<Directive>} allDirectives Unused directives to be removed.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction processUnusedDirectives(allDirectives) {\n  const directiveGroups = groupByParentComment(allDirectives);\n  return directiveGroups.flatMap(directives => {\n    const {\n      parentComment\n    } = directives[0].unprocessedDirective;\n    const remainingRuleIds = new Set(parentComment.ruleIds);\n    for (const directive of directives) {\n      remainingRuleIds.delete(directive.ruleId);\n    }\n    return remainingRuleIds.size ? createIndividualDirectivesRemoval(directives, parentComment.commentToken) : [createCommentRemoval(directives, parentComment.commentToken)];\n  });\n}\n\n/**\n * Collect eslint-enable comments that are removing suppressions by eslint-disable comments.\n * @param {Directive[]} directives The directives to check.\n * @returns {Set<Directive>} The used eslint-enable comments\n */\nfunction collectUsedEnableDirectives(directives) {\n  /**\n   * A Map of `eslint-enable` keyed by ruleIds that may be marked as used.\n   * If `eslint-enable` does not have a ruleId, the key will be `null`.\n   * @type {Map<string|null, Directive>}\n   */\n  const enabledRules = new Map();\n\n  /**\n   * A Set of `eslint-enable` marked as used.\n   * It is also the return value of `collectUsedEnableDirectives` function.\n   * @type {Set<Directive>}\n   */\n  const usedEnableDirectives = new Set();\n\n  /*\n   * Checks the directives backwards to see if the encountered `eslint-enable` is used by the previous `eslint-disable`,\n   * and if so, stores the `eslint-enable` in `usedEnableDirectives`.\n   */\n  for (let index = directives.length - 1; index >= 0; index--) {\n    const directive = directives[index];\n    if (directive.type === \"disable\") {\n      if (enabledRules.size === 0) {\n        continue;\n      }\n      if (directive.ruleId === null) {\n        // If encounter `eslint-disable` without ruleId,\n        // mark all `eslint-enable` currently held in enabledRules as used.\n        // e.g.\n        //    /* eslint-disable */ <- current directive\n        //    /* eslint-enable rule-id1 */ <- used\n        //    /* eslint-enable rule-id2 */ <- used\n        //    /* eslint-enable */ <- used\n        for (const enableDirective of enabledRules.values()) {\n          usedEnableDirectives.add(enableDirective);\n        }\n        enabledRules.clear();\n      } else {\n        const enableDirective = enabledRules.get(directive.ruleId);\n        if (enableDirective) {\n          // If encounter `eslint-disable` with ruleId, and there is an `eslint-enable` with the same ruleId in enabledRules,\n          // mark `eslint-enable` with ruleId as used.\n          // e.g.\n          //    /* eslint-disable rule-id */ <- current directive\n          //    /* eslint-enable rule-id */ <- used\n          usedEnableDirectives.add(enableDirective);\n        } else {\n          const enabledDirectiveWithoutRuleId = enabledRules.get(null);\n          if (enabledDirectiveWithoutRuleId) {\n            // If encounter `eslint-disable` with ruleId, and there is no `eslint-enable` with the same ruleId in enabledRules,\n            // mark `eslint-enable` without ruleId as used.\n            // e.g.\n            //    /* eslint-disable rule-id */ <- current directive\n            //    /* eslint-enable */ <- used\n            usedEnableDirectives.add(enabledDirectiveWithoutRuleId);\n          }\n        }\n      }\n    } else if (directive.type === \"enable\") {\n      if (directive.ruleId === null) {\n        // If encounter `eslint-enable` without ruleId, the `eslint-enable` that follows it are unused.\n        // So clear enabledRules.\n        // e.g.\n        //    /* eslint-enable */ <- current directive\n        //    /* eslint-enable rule-id *// <- unused\n        //    /* eslint-enable */ <- unused\n        enabledRules.clear();\n        enabledRules.set(null, directive);\n      } else {\n        enabledRules.set(directive.ruleId, directive);\n      }\n    }\n  }\n  return usedEnableDirectives;\n}\n\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: LintMessage[], unusedDirectives: LintMessage[]}} An object with a list\n * of problems (including suppressed ones) and unused eslint-disable directives\n */\nfunction applyDirectives(options) {\n  const problems = [];\n  const usedDisableDirectives = new Set();\n  for (const problem of options.problems) {\n    let disableDirectivesForProblem = [];\n    let nextDirectiveIndex = 0;\n    while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {\n      const directive = options.directives[nextDirectiveIndex++];\n      if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\n        switch (directive.type) {\n          case \"disable\":\n            disableDirectivesForProblem.push(directive);\n            break;\n          case \"enable\":\n            disableDirectivesForProblem = [];\n            break;\n\n          // no default\n        }\n      }\n    }\n    if (disableDirectivesForProblem.length > 0) {\n      const suppressions = disableDirectivesForProblem.map(directive => ({\n        kind: \"directive\",\n        justification: directive.unprocessedDirective.justification\n      }));\n      if (problem.suppressions) {\n        problem.suppressions = problem.suppressions.concat(suppressions);\n      } else {\n        problem.suppressions = suppressions;\n        usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);\n      }\n    }\n    problems.push(problem);\n  }\n  const unusedDisableDirectivesToReport = options.directives.filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive));\n  const unusedEnableDirectivesToReport = new Set(options.directives.filter(directive => directive.unprocessedDirective.type === \"enable\"));\n\n  /*\n   * If directives has the eslint-enable directive,\n   * check whether the eslint-enable comment is used.\n   */\n  if (unusedEnableDirectivesToReport.size > 0) {\n    for (const directive of collectUsedEnableDirectives(options.directives)) {\n      unusedEnableDirectivesToReport.delete(directive);\n    }\n  }\n  const processed = processUnusedDirectives(unusedDisableDirectivesToReport).concat(processUnusedDirectives(unusedEnableDirectivesToReport));\n  const unusedDirectives = processed.map(({\n    description,\n    fix,\n    unprocessedDirective\n  }) => {\n    const {\n      parentComment,\n      type,\n      line,\n      column\n    } = unprocessedDirective;\n    let message;\n    if (type === \"enable\") {\n      message = description ? `Unused eslint-enable directive (no matching eslint-disable directives were found for ${description}).` : \"Unused eslint-enable directive (no matching eslint-disable directives were found).\";\n    } else {\n      message = description ? `Unused eslint-disable directive (no problems were reported from ${description}).` : \"Unused eslint-disable directive (no problems were reported).\";\n    }\n    return {\n      ruleId: null,\n      message,\n      line: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.line : line,\n      column: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.column + 1 : column,\n      severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n      nodeType: null,\n      ...(options.disableFixes ? {} : {\n        fix\n      })\n    };\n  });\n  return {\n    problems,\n    unusedDirectives\n  };\n}\n\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, adds the suppression information to the problems.\n * @param {Object} options Information about directives and problems\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number,\n *      justification: string\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\n */\nmodule.exports = ({\n  directives,\n  disableFixes,\n  problems,\n  reportUnusedDisableDirectives = \"off\"\n}) => {\n  const blockDirectives = directives.filter(directive => directive.type === \"disable\" || directive.type === \"enable\").map(directive => Object.assign({}, directive, {\n    unprocessedDirective: directive\n  })).sort(compareLocations);\n  const lineDirectives = directives.flatMap(directive => {\n    switch (directive.type) {\n      case \"disable\":\n      case \"enable\":\n        return [];\n      case \"disable-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 1,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n      case \"disable-next-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line + 1,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 2,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n      default:\n        throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n    }\n  }).sort(compareLocations);\n  const blockDirectivesResult = applyDirectives({\n    problems,\n    directives: blockDirectives,\n    disableFixes,\n    reportUnusedDisableDirectives\n  });\n  const lineDirectivesResult = applyDirectives({\n    problems: blockDirectivesResult.problems,\n    directives: lineDirectives,\n    disableFixes,\n    reportUnusedDisableDirectives\n  });\n  return reportUnusedDisableDirectives !== \"off\" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDirectives).concat(lineDirectivesResult.unusedDirectives).sort(compareLocations) : lineDirectivesResult.problems;\n};","map":{"version":3,"names":["escapeRegExp","require","compareLocations","itemA","itemB","line","column","groupByParentComment","directives","groups","Map","directive","unprocessedDirective","parentComment","has","get","push","set","values","createIndividualDirectivesRemoval","commentToken","commentValueStart","range","length","listStartOffset","exec","value","listText","slice","split","trimEnd","map","ruleId","regex","RegExp","String","raw","match","matchedText","matchStartOffset","index","matchEndOffset","firstIndexOfComma","indexOf","lastIndexOfComma","lastIndexOf","removalStartOffset","removalEndOffset","description","fix","text","createCommentRemoval","ruleIds","filter","join","processUnusedDirectives","allDirectives","directiveGroups","flatMap","remainingRuleIds","Set","delete","size","collectUsedEnableDirectives","enabledRules","usedEnableDirectives","type","enableDirective","add","clear","enabledDirectiveWithoutRuleId","applyDirectives","options","problems","usedDisableDirectives","problem","disableDirectivesForProblem","nextDirectiveIndex","suppressions","kind","justification","concat","unusedDisableDirectivesToReport","unusedEnableDirectivesToReport","processed","unusedDirectives","message","loc","start","severity","reportUnusedDisableDirectives","nodeType","disableFixes","module","exports","blockDirectives","Object","assign","sort","lineDirectives","TypeError","blockDirectivesResult","lineDirectivesResult"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/apply-disable-directives.js"],"sourcesContent":["/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\n/**\n * Compares the locations of two objects in a source file\n * @param {{line: number, column: number}} itemA The first object\n * @param {{line: number, column: number}} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\nfunction compareLocations(itemA, itemB) {\n    return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\n/**\n * Groups a set of directives into sub-arrays by their parent comment.\n * @param {Iterable<Directive>} directives Unused directives to be removed.\n * @returns {Directive[][]} Directives grouped by their parent comment.\n */\nfunction groupByParentComment(directives) {\n    const groups = new Map();\n\n    for (const directive of directives) {\n        const { unprocessedDirective: { parentComment } } = directive;\n\n        if (groups.has(parentComment)) {\n            groups.get(parentComment).push(directive);\n        } else {\n            groups.set(parentComment, [directive]);\n        }\n    }\n\n    return [...groups.values()];\n}\n\n/**\n * Creates removal details for a set of directives within the same comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction createIndividualDirectivesRemoval(directives, commentToken) {\n\n    /*\n     * `commentToken.value` starts right after `//` or `/*`.\n     * All calculated offsets will be relative to this index.\n     */\n    const commentValueStart = commentToken.range[0] + \"//\".length;\n\n    // Find where the list of rules starts. `\\S+` matches with the directive name (e.g. `eslint-disable-line`)\n    const listStartOffset = /^\\s*\\S+\\s+/u.exec(commentToken.value)[0].length;\n\n    /*\n     * Get the list text without any surrounding whitespace. In order to preserve the original\n     * formatting, we don't want to change that whitespace.\n     *\n     *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n     *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     */\n    const listText = commentToken.value\n        .slice(listStartOffset) // remove directive name and all whitespace before the list\n        .split(/\\s-{2,}\\s/u)[0] // remove `-- comment`, if it exists\n        .trimEnd(); // remove all whitespace after the list\n\n    /*\n     * We can assume that `listText` contains multiple elements.\n     * Otherwise, this function wouldn't be called - if there is\n     * only one rule in the list, then the whole comment must be removed.\n     */\n\n    return directives.map(directive => {\n        const { ruleId } = directive;\n\n        const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)(?<quote>['\"]?)${escapeRegExp(ruleId)}\\k<quote>(?:\\s*,\\s*|$)`, \"u\");\n        const match = regex.exec(listText);\n        const matchedText = match[0];\n        const matchStartOffset = listStartOffset + match.index;\n        const matchEndOffset = matchStartOffset + matchedText.length;\n\n        const firstIndexOfComma = matchedText.indexOf(\",\");\n        const lastIndexOfComma = matchedText.lastIndexOf(\",\");\n\n        let removalStartOffset, removalEndOffset;\n\n        if (firstIndexOfComma !== lastIndexOfComma) {\n\n            /*\n             * Since there are two commas, this must one of the elements in the middle of the list.\n             * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                    ^^^^^^^^^^^^^^\n             *\n             * We want to remove only the content between the two commas, and also one of the commas.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                     ^^^^^^^^^^^\n             */\n            removalStartOffset = matchStartOffset + firstIndexOfComma;\n            removalEndOffset = matchStartOffset + lastIndexOfComma;\n\n        } else {\n\n            /*\n             * This is either the first element or the last element.\n             *\n             * If this is the first element, matched range starts where the first rule name starts\n             * and ends where the second rule name starts. This is exactly the range we want\n             * to remove so that the second rule name will start where the first one was starting\n             * and thus preserve the original formatting.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                            ^^^^^^^^^^^\n             *\n             * Similarly, if this is the last element, we've already matched the range we want to\n             * remove. The previous rule name will end where the last one was ending, relative\n             * to the content on the right side.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                               ^^^^^^^^^^^^^\n             */\n            removalStartOffset = matchStartOffset;\n            removalEndOffset = matchEndOffset;\n        }\n\n        return {\n            description: `'${ruleId}'`,\n            fix: {\n                range: [\n                    commentValueStart + removalStartOffset,\n                    commentValueStart + removalEndOffset\n                ],\n                text: \"\"\n            },\n            unprocessedDirective: directive.unprocessedDirective\n        };\n    });\n}\n\n/**\n * Creates a description of deleting an entire unused disable comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output Problem.\n */\nfunction createCommentRemoval(directives, commentToken) {\n    const { range } = commentToken;\n    const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\n\n    return {\n        description: ruleIds.length <= 2\n            ? ruleIds.join(\" or \")\n            : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds[ruleIds.length - 1]}`,\n        fix: {\n            range,\n            text: \" \"\n        },\n        unprocessedDirective: directives[0].unprocessedDirective\n    };\n}\n\n/**\n * Parses details from directives to create output Problems.\n * @param {Iterable<Directive>} allDirectives Unused directives to be removed.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction processUnusedDirectives(allDirectives) {\n    const directiveGroups = groupByParentComment(allDirectives);\n\n    return directiveGroups.flatMap(\n        directives => {\n            const { parentComment } = directives[0].unprocessedDirective;\n            const remainingRuleIds = new Set(parentComment.ruleIds);\n\n            for (const directive of directives) {\n                remainingRuleIds.delete(directive.ruleId);\n            }\n\n            return remainingRuleIds.size\n                ? createIndividualDirectivesRemoval(directives, parentComment.commentToken)\n                : [createCommentRemoval(directives, parentComment.commentToken)];\n        }\n    );\n}\n\n/**\n * Collect eslint-enable comments that are removing suppressions by eslint-disable comments.\n * @param {Directive[]} directives The directives to check.\n * @returns {Set<Directive>} The used eslint-enable comments\n */\nfunction collectUsedEnableDirectives(directives) {\n\n    /**\n     * A Map of `eslint-enable` keyed by ruleIds that may be marked as used.\n     * If `eslint-enable` does not have a ruleId, the key will be `null`.\n     * @type {Map<string|null, Directive>}\n     */\n    const enabledRules = new Map();\n\n    /**\n     * A Set of `eslint-enable` marked as used.\n     * It is also the return value of `collectUsedEnableDirectives` function.\n     * @type {Set<Directive>}\n     */\n    const usedEnableDirectives = new Set();\n\n    /*\n     * Checks the directives backwards to see if the encountered `eslint-enable` is used by the previous `eslint-disable`,\n     * and if so, stores the `eslint-enable` in `usedEnableDirectives`.\n     */\n    for (let index = directives.length - 1; index >= 0; index--) {\n        const directive = directives[index];\n\n        if (directive.type === \"disable\") {\n            if (enabledRules.size === 0) {\n                continue;\n            }\n            if (directive.ruleId === null) {\n\n                // If encounter `eslint-disable` without ruleId,\n                // mark all `eslint-enable` currently held in enabledRules as used.\n                // e.g.\n                //    /* eslint-disable */ <- current directive\n                //    /* eslint-enable rule-id1 */ <- used\n                //    /* eslint-enable rule-id2 */ <- used\n                //    /* eslint-enable */ <- used\n                for (const enableDirective of enabledRules.values()) {\n                    usedEnableDirectives.add(enableDirective);\n                }\n                enabledRules.clear();\n            } else {\n                const enableDirective = enabledRules.get(directive.ruleId);\n\n                if (enableDirective) {\n\n                    // If encounter `eslint-disable` with ruleId, and there is an `eslint-enable` with the same ruleId in enabledRules,\n                    // mark `eslint-enable` with ruleId as used.\n                    // e.g.\n                    //    /* eslint-disable rule-id */ <- current directive\n                    //    /* eslint-enable rule-id */ <- used\n                    usedEnableDirectives.add(enableDirective);\n                } else {\n                    const enabledDirectiveWithoutRuleId = enabledRules.get(null);\n\n                    if (enabledDirectiveWithoutRuleId) {\n\n                        // If encounter `eslint-disable` with ruleId, and there is no `eslint-enable` with the same ruleId in enabledRules,\n                        // mark `eslint-enable` without ruleId as used.\n                        // e.g.\n                        //    /* eslint-disable rule-id */ <- current directive\n                        //    /* eslint-enable */ <- used\n                        usedEnableDirectives.add(enabledDirectiveWithoutRuleId);\n                    }\n                }\n            }\n        } else if (directive.type === \"enable\") {\n            if (directive.ruleId === null) {\n\n                // If encounter `eslint-enable` without ruleId, the `eslint-enable` that follows it are unused.\n                // So clear enabledRules.\n                // e.g.\n                //    /* eslint-enable */ <- current directive\n                //    /* eslint-enable rule-id *// <- unused\n                //    /* eslint-enable */ <- unused\n                enabledRules.clear();\n                enabledRules.set(null, directive);\n            } else {\n                enabledRules.set(directive.ruleId, directive);\n            }\n        }\n    }\n    return usedEnableDirectives;\n}\n\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: LintMessage[], unusedDirectives: LintMessage[]}} An object with a list\n * of problems (including suppressed ones) and unused eslint-disable directives\n */\nfunction applyDirectives(options) {\n    const problems = [];\n    const usedDisableDirectives = new Set();\n\n    for (const problem of options.problems) {\n        let disableDirectivesForProblem = [];\n        let nextDirectiveIndex = 0;\n\n        while (\n            nextDirectiveIndex < options.directives.length &&\n            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0\n        ) {\n            const directive = options.directives[nextDirectiveIndex++];\n\n            if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\n                switch (directive.type) {\n                    case \"disable\":\n                        disableDirectivesForProblem.push(directive);\n                        break;\n\n                    case \"enable\":\n                        disableDirectivesForProblem = [];\n                        break;\n\n                    // no default\n                }\n            }\n        }\n\n        if (disableDirectivesForProblem.length > 0) {\n            const suppressions = disableDirectivesForProblem.map(directive => ({\n                kind: \"directive\",\n                justification: directive.unprocessedDirective.justification\n            }));\n\n            if (problem.suppressions) {\n                problem.suppressions = problem.suppressions.concat(suppressions);\n            } else {\n                problem.suppressions = suppressions;\n                usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);\n            }\n        }\n\n        problems.push(problem);\n    }\n\n    const unusedDisableDirectivesToReport = options.directives\n        .filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive));\n\n\n    const unusedEnableDirectivesToReport = new Set(\n        options.directives.filter(directive => directive.unprocessedDirective.type === \"enable\")\n    );\n\n    /*\n     * If directives has the eslint-enable directive,\n     * check whether the eslint-enable comment is used.\n     */\n    if (unusedEnableDirectivesToReport.size > 0) {\n        for (const directive of collectUsedEnableDirectives(options.directives)) {\n            unusedEnableDirectivesToReport.delete(directive);\n        }\n    }\n\n    const processed = processUnusedDirectives(unusedDisableDirectivesToReport)\n        .concat(processUnusedDirectives(unusedEnableDirectivesToReport));\n\n    const unusedDirectives = processed\n        .map(({ description, fix, unprocessedDirective }) => {\n            const { parentComment, type, line, column } = unprocessedDirective;\n\n            let message;\n\n            if (type === \"enable\") {\n                message = description\n                    ? `Unused eslint-enable directive (no matching eslint-disable directives were found for ${description}).`\n                    : \"Unused eslint-enable directive (no matching eslint-disable directives were found).\";\n            } else {\n                message = description\n                    ? `Unused eslint-disable directive (no problems were reported from ${description}).`\n                    : \"Unused eslint-disable directive (no problems were reported).\";\n            }\n            return {\n                ruleId: null,\n                message,\n                line: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.line : line,\n                column: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.column + 1 : column,\n                severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n                nodeType: null,\n                ...options.disableFixes ? {} : { fix }\n            };\n        });\n\n    return { problems, unusedDirectives };\n}\n\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, adds the suppression information to the problems.\n * @param {Object} options Information about directives and problems\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number,\n *      justification: string\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\n */\nmodule.exports = ({ directives, disableFixes, problems, reportUnusedDisableDirectives = \"off\" }) => {\n    const blockDirectives = directives\n        .filter(directive => directive.type === \"disable\" || directive.type === \"enable\")\n        .map(directive => Object.assign({}, directive, { unprocessedDirective: directive }))\n        .sort(compareLocations);\n\n    const lineDirectives = directives.flatMap(directive => {\n        switch (directive.type) {\n            case \"disable\":\n            case \"enable\":\n                return [];\n\n            case \"disable-line\":\n                return [\n                    { type: \"disable\", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            case \"disable-next-line\":\n                return [\n                    { type: \"disable\", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            default:\n                throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n        }\n    }).sort(compareLocations);\n\n    const blockDirectivesResult = applyDirectives({\n        problems,\n        directives: blockDirectives,\n        disableFixes,\n        reportUnusedDisableDirectives\n    });\n    const lineDirectivesResult = applyDirectives({\n        problems: blockDirectivesResult.problems,\n        directives: lineDirectives,\n        disableFixes,\n        reportUnusedDisableDirectives\n    });\n\n    return reportUnusedDisableDirectives !== \"off\"\n        ? lineDirectivesResult.problems\n            .concat(blockDirectivesResult.unusedDirectives)\n            .concat(lineDirectivesResult.unusedDirectives)\n            .sort(compareLocations)\n        : lineDirectivesResult.problems;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,sBAAsB,CAAC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,KAAK,EAAEC,KAAK,EAAE;EACpC,OAAOD,KAAK,CAACE,IAAI,GAAGD,KAAK,CAACC,IAAI,IAAIF,KAAK,CAACG,MAAM,GAAGF,KAAK,CAACE,MAAM;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAACC,UAAU,EAAE;EACtC,MAAMC,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;EAExB,KAAK,MAAMC,SAAS,IAAIH,UAAU,EAAE;IAChC,MAAM;MAAEI,oBAAoB,EAAE;QAAEC;MAAc;IAAE,CAAC,GAAGF,SAAS;IAE7D,IAAIF,MAAM,CAACK,GAAG,CAACD,aAAa,CAAC,EAAE;MAC3BJ,MAAM,CAACM,GAAG,CAACF,aAAa,CAAC,CAACG,IAAI,CAACL,SAAS,CAAC;IAC7C,CAAC,MAAM;MACHF,MAAM,CAACQ,GAAG,CAACJ,aAAa,EAAE,CAACF,SAAS,CAAC,CAAC;IAC1C;EACJ;EAEA,OAAO,CAAC,GAAGF,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iCAAiCA,CAACX,UAAU,EAAEY,YAAY,EAAE;EAEjE;AACJ;AACA;AACA;EACI,MAAMC,iBAAiB,GAAGD,YAAY,CAACE,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAACC,MAAM;;EAE7D;EACA,MAAMC,eAAe,GAAG,aAAa,CAACC,IAAI,CAACL,YAAY,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,CAACH,MAAM;;EAExE;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMI,QAAQ,GAAGP,YAAY,CAACM,KAAK,CAC9BE,KAAK,CAACJ,eAAe,CAAC,CAAC;EAAA,CACvBK,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;EAAA,CACvBC,OAAO,CAAC,CAAC,CAAC,CAAC;;EAEhB;AACJ;AACA;AACA;AACA;;EAEI,OAAOtB,UAAU,CAACuB,GAAG,CAACpB,SAAS,IAAI;IAC/B,MAAM;MAAEqB;IAAO,CAAC,GAAGrB,SAAS;IAE5B,MAAMsB,KAAK,GAAG,IAAIC,MAAM,CAACC,MAAM,CAACC,GAAG,+BAA+BpC,YAAY,CAACgC,MAAM,CAAC,wBAAwB,EAAE,GAAG,CAAC;IACpH,MAAMK,KAAK,GAAGJ,KAAK,CAACR,IAAI,CAACE,QAAQ,CAAC;IAClC,MAAMW,WAAW,GAAGD,KAAK,CAAC,CAAC,CAAC;IAC5B,MAAME,gBAAgB,GAAGf,eAAe,GAAGa,KAAK,CAACG,KAAK;IACtD,MAAMC,cAAc,GAAGF,gBAAgB,GAAGD,WAAW,CAACf,MAAM;IAE5D,MAAMmB,iBAAiB,GAAGJ,WAAW,CAACK,OAAO,CAAC,GAAG,CAAC;IAClD,MAAMC,gBAAgB,GAAGN,WAAW,CAACO,WAAW,CAAC,GAAG,CAAC;IAErD,IAAIC,kBAAkB,EAAEC,gBAAgB;IAExC,IAAIL,iBAAiB,KAAKE,gBAAgB,EAAE;MAExC;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYE,kBAAkB,GAAGP,gBAAgB,GAAGG,iBAAiB;MACzDK,gBAAgB,GAAGR,gBAAgB,GAAGK,gBAAgB;IAE1D,CAAC,MAAM;MAEH;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYE,kBAAkB,GAAGP,gBAAgB;MACrCQ,gBAAgB,GAAGN,cAAc;IACrC;IAEA,OAAO;MACHO,WAAW,EAAE,IAAIhB,MAAM,GAAG;MAC1BiB,GAAG,EAAE;QACD3B,KAAK,EAAE,CACHD,iBAAiB,GAAGyB,kBAAkB,EACtCzB,iBAAiB,GAAG0B,gBAAgB,CACvC;QACDG,IAAI,EAAE;MACV,CAAC;MACDtC,oBAAoB,EAAED,SAAS,CAACC;IACpC,CAAC;EACL,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuC,oBAAoBA,CAAC3C,UAAU,EAAEY,YAAY,EAAE;EACpD,MAAM;IAAEE;EAAM,CAAC,GAAGF,YAAY;EAC9B,MAAMgC,OAAO,GAAG5C,UAAU,CAAC6C,MAAM,CAAC1C,SAAS,IAAIA,SAAS,CAACqB,MAAM,CAAC,CAACD,GAAG,CAACpB,SAAS,IAAI,IAAIA,SAAS,CAACqB,MAAM,GAAG,CAAC;EAE1G,OAAO;IACHgB,WAAW,EAAEI,OAAO,CAAC7B,MAAM,IAAI,CAAC,GAC1B6B,OAAO,CAACE,IAAI,CAAC,MAAM,CAAC,GACpB,GAAGF,OAAO,CAACxB,KAAK,CAAC,CAAC,EAAEwB,OAAO,CAAC7B,MAAM,GAAG,CAAC,CAAC,CAAC+B,IAAI,CAAC,IAAI,CAAC,QAAQF,OAAO,CAACA,OAAO,CAAC7B,MAAM,GAAG,CAAC,CAAC,EAAE;IAC7F0B,GAAG,EAAE;MACD3B,KAAK;MACL4B,IAAI,EAAE;IACV,CAAC;IACDtC,oBAAoB,EAAEJ,UAAU,CAAC,CAAC,CAAC,CAACI;EACxC,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS2C,uBAAuBA,CAACC,aAAa,EAAE;EAC5C,MAAMC,eAAe,GAAGlD,oBAAoB,CAACiD,aAAa,CAAC;EAE3D,OAAOC,eAAe,CAACC,OAAO,CAC1BlD,UAAU,IAAI;IACV,MAAM;MAAEK;IAAc,CAAC,GAAGL,UAAU,CAAC,CAAC,CAAC,CAACI,oBAAoB;IAC5D,MAAM+C,gBAAgB,GAAG,IAAIC,GAAG,CAAC/C,aAAa,CAACuC,OAAO,CAAC;IAEvD,KAAK,MAAMzC,SAAS,IAAIH,UAAU,EAAE;MAChCmD,gBAAgB,CAACE,MAAM,CAAClD,SAAS,CAACqB,MAAM,CAAC;IAC7C;IAEA,OAAO2B,gBAAgB,CAACG,IAAI,GACtB3C,iCAAiC,CAACX,UAAU,EAAEK,aAAa,CAACO,YAAY,CAAC,GACzE,CAAC+B,oBAAoB,CAAC3C,UAAU,EAAEK,aAAa,CAACO,YAAY,CAAC,CAAC;EACxE,CACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS2C,2BAA2BA,CAACvD,UAAU,EAAE;EAE7C;AACJ;AACA;AACA;AACA;EACI,MAAMwD,YAAY,GAAG,IAAItD,GAAG,CAAC,CAAC;;EAE9B;AACJ;AACA;AACA;AACA;EACI,MAAMuD,oBAAoB,GAAG,IAAIL,GAAG,CAAC,CAAC;;EAEtC;AACJ;AACA;AACA;EACI,KAAK,IAAIpB,KAAK,GAAGhC,UAAU,CAACe,MAAM,GAAG,CAAC,EAAEiB,KAAK,IAAI,CAAC,EAAEA,KAAK,EAAE,EAAE;IACzD,MAAM7B,SAAS,GAAGH,UAAU,CAACgC,KAAK,CAAC;IAEnC,IAAI7B,SAAS,CAACuD,IAAI,KAAK,SAAS,EAAE;MAC9B,IAAIF,YAAY,CAACF,IAAI,KAAK,CAAC,EAAE;QACzB;MACJ;MACA,IAAInD,SAAS,CAACqB,MAAM,KAAK,IAAI,EAAE;QAE3B;QACA;QACA;QACA;QACA;QACA;QACA;QACA,KAAK,MAAMmC,eAAe,IAAIH,YAAY,CAAC9C,MAAM,CAAC,CAAC,EAAE;UACjD+C,oBAAoB,CAACG,GAAG,CAACD,eAAe,CAAC;QAC7C;QACAH,YAAY,CAACK,KAAK,CAAC,CAAC;MACxB,CAAC,MAAM;QACH,MAAMF,eAAe,GAAGH,YAAY,CAACjD,GAAG,CAACJ,SAAS,CAACqB,MAAM,CAAC;QAE1D,IAAImC,eAAe,EAAE;UAEjB;UACA;UACA;UACA;UACA;UACAF,oBAAoB,CAACG,GAAG,CAACD,eAAe,CAAC;QAC7C,CAAC,MAAM;UACH,MAAMG,6BAA6B,GAAGN,YAAY,CAACjD,GAAG,CAAC,IAAI,CAAC;UAE5D,IAAIuD,6BAA6B,EAAE;YAE/B;YACA;YACA;YACA;YACA;YACAL,oBAAoB,CAACG,GAAG,CAACE,6BAA6B,CAAC;UAC3D;QACJ;MACJ;IACJ,CAAC,MAAM,IAAI3D,SAAS,CAACuD,IAAI,KAAK,QAAQ,EAAE;MACpC,IAAIvD,SAAS,CAACqB,MAAM,KAAK,IAAI,EAAE;QAE3B;QACA;QACA;QACA;QACA;QACA;QACAgC,YAAY,CAACK,KAAK,CAAC,CAAC;QACpBL,YAAY,CAAC/C,GAAG,CAAC,IAAI,EAAEN,SAAS,CAAC;MACrC,CAAC,MAAM;QACHqD,YAAY,CAAC/C,GAAG,CAACN,SAAS,CAACqB,MAAM,EAAErB,SAAS,CAAC;MACjD;IACJ;EACJ;EACA,OAAOsD,oBAAoB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,eAAeA,CAACC,OAAO,EAAE;EAC9B,MAAMC,QAAQ,GAAG,EAAE;EACnB,MAAMC,qBAAqB,GAAG,IAAId,GAAG,CAAC,CAAC;EAEvC,KAAK,MAAMe,OAAO,IAAIH,OAAO,CAACC,QAAQ,EAAE;IACpC,IAAIG,2BAA2B,GAAG,EAAE;IACpC,IAAIC,kBAAkB,GAAG,CAAC;IAE1B,OACIA,kBAAkB,GAAGL,OAAO,CAAChE,UAAU,CAACe,MAAM,IAC9CrB,gBAAgB,CAACsE,OAAO,CAAChE,UAAU,CAACqE,kBAAkB,CAAC,EAAEF,OAAO,CAAC,IAAI,CAAC,EACxE;MACE,MAAMhE,SAAS,GAAG6D,OAAO,CAAChE,UAAU,CAACqE,kBAAkB,EAAE,CAAC;MAE1D,IAAIlE,SAAS,CAACqB,MAAM,KAAK,IAAI,IAAIrB,SAAS,CAACqB,MAAM,KAAK2C,OAAO,CAAC3C,MAAM,EAAE;QAClE,QAAQrB,SAAS,CAACuD,IAAI;UAClB,KAAK,SAAS;YACVU,2BAA2B,CAAC5D,IAAI,CAACL,SAAS,CAAC;YAC3C;UAEJ,KAAK,QAAQ;YACTiE,2BAA2B,GAAG,EAAE;YAChC;;UAEJ;QACJ;MACJ;IACJ;IAEA,IAAIA,2BAA2B,CAACrD,MAAM,GAAG,CAAC,EAAE;MACxC,MAAMuD,YAAY,GAAGF,2BAA2B,CAAC7C,GAAG,CAACpB,SAAS,KAAK;QAC/DoE,IAAI,EAAE,WAAW;QACjBC,aAAa,EAAErE,SAAS,CAACC,oBAAoB,CAACoE;MAClD,CAAC,CAAC,CAAC;MAEH,IAAIL,OAAO,CAACG,YAAY,EAAE;QACtBH,OAAO,CAACG,YAAY,GAAGH,OAAO,CAACG,YAAY,CAACG,MAAM,CAACH,YAAY,CAAC;MACpE,CAAC,MAAM;QACHH,OAAO,CAACG,YAAY,GAAGA,YAAY;QACnCJ,qBAAqB,CAACN,GAAG,CAACQ,2BAA2B,CAACA,2BAA2B,CAACrD,MAAM,GAAG,CAAC,CAAC,CAAC;MAClG;IACJ;IAEAkD,QAAQ,CAACzD,IAAI,CAAC2D,OAAO,CAAC;EAC1B;EAEA,MAAMO,+BAA+B,GAAGV,OAAO,CAAChE,UAAU,CACrD6C,MAAM,CAAC1C,SAAS,IAAIA,SAAS,CAACuD,IAAI,KAAK,SAAS,IAAI,CAACQ,qBAAqB,CAAC5D,GAAG,CAACH,SAAS,CAAC,CAAC;EAG/F,MAAMwE,8BAA8B,GAAG,IAAIvB,GAAG,CAC1CY,OAAO,CAAChE,UAAU,CAAC6C,MAAM,CAAC1C,SAAS,IAAIA,SAAS,CAACC,oBAAoB,CAACsD,IAAI,KAAK,QAAQ,CAC3F,CAAC;;EAED;AACJ;AACA;AACA;EACI,IAAIiB,8BAA8B,CAACrB,IAAI,GAAG,CAAC,EAAE;IACzC,KAAK,MAAMnD,SAAS,IAAIoD,2BAA2B,CAACS,OAAO,CAAChE,UAAU,CAAC,EAAE;MACrE2E,8BAA8B,CAACtB,MAAM,CAAClD,SAAS,CAAC;IACpD;EACJ;EAEA,MAAMyE,SAAS,GAAG7B,uBAAuB,CAAC2B,+BAA+B,CAAC,CACrED,MAAM,CAAC1B,uBAAuB,CAAC4B,8BAA8B,CAAC,CAAC;EAEpE,MAAME,gBAAgB,GAAGD,SAAS,CAC7BrD,GAAG,CAAC,CAAC;IAAEiB,WAAW;IAAEC,GAAG;IAAErC;EAAqB,CAAC,KAAK;IACjD,MAAM;MAAEC,aAAa;MAAEqD,IAAI;MAAE7D,IAAI;MAAEC;IAAO,CAAC,GAAGM,oBAAoB;IAElE,IAAI0E,OAAO;IAEX,IAAIpB,IAAI,KAAK,QAAQ,EAAE;MACnBoB,OAAO,GAAGtC,WAAW,GACf,wFAAwFA,WAAW,IAAI,GACvG,oFAAoF;IAC9F,CAAC,MAAM;MACHsC,OAAO,GAAGtC,WAAW,GACf,mEAAmEA,WAAW,IAAI,GAClF,8DAA8D;IACxE;IACA,OAAO;MACHhB,MAAM,EAAE,IAAI;MACZsD,OAAO;MACPjF,IAAI,EAAE6D,IAAI,KAAK,mBAAmB,GAAGrD,aAAa,CAACO,YAAY,CAACmE,GAAG,CAACC,KAAK,CAACnF,IAAI,GAAGA,IAAI;MACrFC,MAAM,EAAE4D,IAAI,KAAK,mBAAmB,GAAGrD,aAAa,CAACO,YAAY,CAACmE,GAAG,CAACC,KAAK,CAAClF,MAAM,GAAG,CAAC,GAAGA,MAAM;MAC/FmF,QAAQ,EAAEjB,OAAO,CAACkB,6BAA6B,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC;MAClEC,QAAQ,EAAE,IAAI;MACd,IAAGnB,OAAO,CAACoB,YAAY,GAAG,CAAC,CAAC,GAAG;QAAE3C;MAAI,CAAC;IAC1C,CAAC;EACL,CAAC,CAAC;EAEN,OAAO;IAAEwB,QAAQ;IAAEY;EAAiB,CAAC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,MAAM,CAACC,OAAO,GAAG,CAAC;EAAEtF,UAAU;EAAEoF,YAAY;EAAEnB,QAAQ;EAAEiB,6BAA6B,GAAG;AAAM,CAAC,KAAK;EAChG,MAAMK,eAAe,GAAGvF,UAAU,CAC7B6C,MAAM,CAAC1C,SAAS,IAAIA,SAAS,CAACuD,IAAI,KAAK,SAAS,IAAIvD,SAAS,CAACuD,IAAI,KAAK,QAAQ,CAAC,CAChFnC,GAAG,CAACpB,SAAS,IAAIqF,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEtF,SAAS,EAAE;IAAEC,oBAAoB,EAAED;EAAU,CAAC,CAAC,CAAC,CACnFuF,IAAI,CAAChG,gBAAgB,CAAC;EAE3B,MAAMiG,cAAc,GAAG3F,UAAU,CAACkD,OAAO,CAAC/C,SAAS,IAAI;IACnD,QAAQA,SAAS,CAACuD,IAAI;MAClB,KAAK,SAAS;MACd,KAAK,QAAQ;QACT,OAAO,EAAE;MAEb,KAAK,cAAc;QACf,OAAO,CACH;UAAEA,IAAI,EAAE,SAAS;UAAE7D,IAAI,EAAEM,SAAS,CAACN,IAAI;UAAEC,MAAM,EAAE,CAAC;UAAE0B,MAAM,EAAErB,SAAS,CAACqB,MAAM;UAAEpB,oBAAoB,EAAED;QAAU,CAAC,EAC/G;UAAEuD,IAAI,EAAE,QAAQ;UAAE7D,IAAI,EAAEM,SAAS,CAACN,IAAI,GAAG,CAAC;UAAEC,MAAM,EAAE,CAAC;UAAE0B,MAAM,EAAErB,SAAS,CAACqB,MAAM;UAAEpB,oBAAoB,EAAED;QAAU,CAAC,CACrH;MAEL,KAAK,mBAAmB;QACpB,OAAO,CACH;UAAEuD,IAAI,EAAE,SAAS;UAAE7D,IAAI,EAAEM,SAAS,CAACN,IAAI,GAAG,CAAC;UAAEC,MAAM,EAAE,CAAC;UAAE0B,MAAM,EAAErB,SAAS,CAACqB,MAAM;UAAEpB,oBAAoB,EAAED;QAAU,CAAC,EACnH;UAAEuD,IAAI,EAAE,QAAQ;UAAE7D,IAAI,EAAEM,SAAS,CAACN,IAAI,GAAG,CAAC;UAAEC,MAAM,EAAE,CAAC;UAAE0B,MAAM,EAAErB,SAAS,CAACqB,MAAM;UAAEpB,oBAAoB,EAAED;QAAU,CAAC,CACrH;MAEL;QACI,MAAM,IAAIyF,SAAS,CAAC,gCAAgCzF,SAAS,CAACuD,IAAI,GAAG,CAAC;IAC9E;EACJ,CAAC,CAAC,CAACgC,IAAI,CAAChG,gBAAgB,CAAC;EAEzB,MAAMmG,qBAAqB,GAAG9B,eAAe,CAAC;IAC1CE,QAAQ;IACRjE,UAAU,EAAEuF,eAAe;IAC3BH,YAAY;IACZF;EACJ,CAAC,CAAC;EACF,MAAMY,oBAAoB,GAAG/B,eAAe,CAAC;IACzCE,QAAQ,EAAE4B,qBAAqB,CAAC5B,QAAQ;IACxCjE,UAAU,EAAE2F,cAAc;IAC1BP,YAAY;IACZF;EACJ,CAAC,CAAC;EAEF,OAAOA,6BAA6B,KAAK,KAAK,GACxCY,oBAAoB,CAAC7B,QAAQ,CAC1BQ,MAAM,CAACoB,qBAAqB,CAAChB,gBAAgB,CAAC,CAC9CJ,MAAM,CAACqB,oBAAoB,CAACjB,gBAAgB,CAAC,CAC7Ca,IAAI,CAAChG,gBAAgB,CAAC,GACzBoG,oBAAoB,CAAC7B,QAAQ;AACvC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}