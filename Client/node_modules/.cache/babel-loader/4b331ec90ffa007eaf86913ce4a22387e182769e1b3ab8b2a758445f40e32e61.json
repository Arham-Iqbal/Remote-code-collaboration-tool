{"ast":null,"code":"/**\n * @fileoverview Rule to forbid control characters from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst RegExpValidator = require(\"@eslint-community/regexpp\").RegExpValidator;\nconst collector = new class {\n  constructor() {\n    this._source = \"\";\n    this._controlChars = [];\n    this._validator = new RegExpValidator(this);\n  }\n  onPatternEnter() {\n    /*\n     * `RegExpValidator` may parse the pattern twice in one `validatePattern`.\n     * So `this._controlChars` should be cleared here as well.\n     *\n     * For example, the `/(?<a>\\x1f)/` regex will parse the pattern twice.\n     * This is based on the content described in Annex B.\n     * If the regex contains a `GroupName` and the `u` flag is not used, `ParseText` will be called twice.\n     * See https://tc39.es/ecma262/2023/multipage/additional-ecmascript-features-for-web-browsers.html#sec-parsepattern-annexb\n     */\n    this._controlChars = [];\n  }\n  onCharacter(start, end, cp) {\n    if (cp >= 0x00 && cp <= 0x1F && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith(\"\\\\x\") || this._source.slice(start, end).startsWith(\"\\\\u\"))) {\n      this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n    }\n  }\n  collectControlChars(regexpStr, flags) {\n    const uFlag = typeof flags === \"string\" && flags.includes(\"u\");\n    const vFlag = typeof flags === \"string\" && flags.includes(\"v\");\n    this._controlChars = [];\n    this._source = regexpStr;\n    try {\n      this._validator.validatePattern(regexpStr, void 0, void 0, {\n        unicode: uFlag,\n        unicodeSets: vFlag\n      }); // Call onCharacter hook\n    } catch {\n\n      // Ignore syntax errors in RegExp.\n    }\n    return this._controlChars;\n  }\n}();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow control characters in regular expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-control-regex\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n    }\n  },\n  create(context) {\n    /**\n     * Get the regex expression\n     * @param {ASTNode} node `Literal` node to evaluate\n     * @returns {{ pattern: string, flags: string | null } | null} Regex if found (the given node is either a regex literal\n     * or a string literal that is the pattern argument of a RegExp constructor call). Otherwise `null`. If flags cannot be determined,\n     * the `flags` property will be `null`.\n     * @private\n     */\n    function getRegExp(node) {\n      if (node.regex) {\n        return node.regex;\n      }\n      if (typeof node.value === \"string\" && (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") && node.parent.callee.type === \"Identifier\" && node.parent.callee.name === \"RegExp\" && node.parent.arguments[0] === node) {\n        const pattern = node.value;\n        const flags = node.parent.arguments.length > 1 && node.parent.arguments[1].type === \"Literal\" && typeof node.parent.arguments[1].value === \"string\" ? node.parent.arguments[1].value : null;\n        return {\n          pattern,\n          flags\n        };\n      }\n      return null;\n    }\n    return {\n      Literal(node) {\n        const regExp = getRegExp(node);\n        if (regExp) {\n          const {\n            pattern,\n            flags\n          } = regExp;\n          const controlCharacters = collector.collectControlChars(pattern, flags);\n          if (controlCharacters.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                controlChars: controlCharacters.join(\", \")\n              }\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["RegExpValidator","require","collector","constructor","_source","_controlChars","_validator","onPatternEnter","onCharacter","start","end","cp","codePointAt","slice","startsWith","push","toString","collectControlChars","regexpStr","flags","uFlag","includes","vFlag","validatePattern","unicode","unicodeSets","module","exports","meta","type","docs","description","recommended","url","schema","messages","unexpected","create","context","getRegExp","node","regex","value","parent","callee","name","arguments","pattern","length","Literal","regExp","controlCharacters","report","messageId","data","controlChars","join"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-control-regex.js"],"sourcesContent":["/**\n * @fileoverview Rule to forbid control characters from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst RegExpValidator = require(\"@eslint-community/regexpp\").RegExpValidator;\nconst collector = new (class {\n    constructor() {\n        this._source = \"\";\n        this._controlChars = [];\n        this._validator = new RegExpValidator(this);\n    }\n\n    onPatternEnter() {\n\n        /*\n         * `RegExpValidator` may parse the pattern twice in one `validatePattern`.\n         * So `this._controlChars` should be cleared here as well.\n         *\n         * For example, the `/(?<a>\\x1f)/` regex will parse the pattern twice.\n         * This is based on the content described in Annex B.\n         * If the regex contains a `GroupName` and the `u` flag is not used, `ParseText` will be called twice.\n         * See https://tc39.es/ecma262/2023/multipage/additional-ecmascript-features-for-web-browsers.html#sec-parsepattern-annexb\n         */\n        this._controlChars = [];\n    }\n\n    onCharacter(start, end, cp) {\n        if (cp >= 0x00 &&\n            cp <= 0x1F &&\n            (\n                this._source.codePointAt(start) === cp ||\n                this._source.slice(start, end).startsWith(\"\\\\x\") ||\n                this._source.slice(start, end).startsWith(\"\\\\u\")\n            )\n        ) {\n            this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n        }\n    }\n\n    collectControlChars(regexpStr, flags) {\n        const uFlag = typeof flags === \"string\" && flags.includes(\"u\");\n        const vFlag = typeof flags === \"string\" && flags.includes(\"v\");\n\n        this._controlChars = [];\n        this._source = regexpStr;\n\n        try {\n            this._validator.validatePattern(regexpStr, void 0, void 0, { unicode: uFlag, unicodeSets: vFlag }); // Call onCharacter hook\n        } catch {\n\n            // Ignore syntax errors in RegExp.\n        }\n        return this._controlChars;\n    }\n})();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow control characters in regular expressions\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-control-regex\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node `Literal` node to evaluate\n         * @returns {{ pattern: string, flags: string | null } | null} Regex if found (the given node is either a regex literal\n         * or a string literal that is the pattern argument of a RegExp constructor call). Otherwise `null`. If flags cannot be determined,\n         * the `flags` property will be `null`.\n         * @private\n         */\n        function getRegExp(node) {\n            if (node.regex) {\n                return node.regex;\n            }\n            if (typeof node.value === \"string\" &&\n                (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") &&\n                node.parent.callee.type === \"Identifier\" &&\n                node.parent.callee.name === \"RegExp\" &&\n                node.parent.arguments[0] === node\n            ) {\n                const pattern = node.value;\n                const flags =\n                    node.parent.arguments.length > 1 &&\n                    node.parent.arguments[1].type === \"Literal\" &&\n                    typeof node.parent.arguments[1].value === \"string\"\n                        ? node.parent.arguments[1].value\n                        : null;\n\n                return { pattern, flags };\n            }\n\n            return null;\n        }\n\n        return {\n            Literal(node) {\n                const regExp = getRegExp(node);\n\n                if (regExp) {\n                    const { pattern, flags } = regExp;\n                    const controlCharacters = collector.collectControlChars(pattern, flags);\n\n                    if (controlCharacters.length > 0) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: {\n                                controlChars: controlCharacters.join(\", \")\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}