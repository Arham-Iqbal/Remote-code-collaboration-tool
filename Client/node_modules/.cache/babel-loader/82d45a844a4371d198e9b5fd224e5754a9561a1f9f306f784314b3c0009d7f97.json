{"ast":null,"code":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst assert = require(\"assert\"),\n  {\n    breakableTypePattern\n  } = require(\"../../shared/ast-utils\"),\n  CodePath = require(\"./code-path\"),\n  CodePathSegment = require(\"./code-path-segment\"),\n  IdGenerator = require(\"./id-generator\"),\n  debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n\n/**\n * Checks if a given node appears as the value of a PropertyDefinition node.\n * @param {ASTNode} node THe node to check.\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\n *      false if not.\n */\nfunction isPropertyDefinitionValue(node) {\n  const parent = node.parent;\n  return parent && parent.type === \"PropertyDefinition\" && parent.value === node;\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n  return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n  return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n    case \"AssignmentExpression\":\n      return isLogicalAssignmentOperator(parent.operator);\n    default:\n      return false;\n  }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n  return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n    case \"Property\":\n    case \"PropertyDefinition\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n    default:\n      return true;\n  }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment;\n\n  // Fires leaving events.\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n    if (currentSegment !== headSegment && currentSegment) {\n      const eventName = currentSegment.reachable ? \"onCodePathSegmentEnd\" : \"onUnreachableCodePathSegmentEnd\";\n      debug.dump(`${eventName} ${currentSegment.id}`);\n      analyzer.emitter.emit(eventName, currentSegment, node);\n    }\n  }\n\n  // Update state.\n  state.currentSegments = headSegments;\n\n  // Fires entering events.\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n    if (currentSegment !== headSegment && headSegment) {\n      const eventName = headSegment.reachable ? \"onCodePathSegmentStart\" : \"onUnreachableCodePathSegmentStart\";\n      debug.dump(`${eventName} ${headSegment.id}`);\n      CodePathSegment.markUsed(headSegment);\n      analyzer.emitter.emit(eventName, headSegment, node);\n    }\n  }\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = CodePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    const eventName = currentSegment.reachable ? \"onCodePathSegmentEnd\" : \"onUnreachableCodePathSegmentEnd\";\n    debug.dump(`${eventName} ${currentSegment.id}`);\n    analyzer.emitter.emit(eventName, currentSegment, node);\n  }\n  state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const parent = node.parent;\n  switch (parent.type) {\n    // The `arguments.length == 0` case is in `postprocess` function.\n    case \"CallExpression\":\n      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n        state.makeOptionalRight();\n      }\n      break;\n    case \"MemberExpression\":\n      if (parent.optional === true && parent.property === node) {\n        state.makeOptionalRight();\n      }\n      break;\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n      break;\n    case \"AssignmentExpression\":\n      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n      break;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      /*\n       * Fork if this node is at `consequent`/`alternate`.\n       * `popForkContext()` exists at `IfStatement:exit` and\n       * `ConditionalExpression:exit`.\n       */\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n      break;\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n      break;\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n      break;\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert(parent.body === node);\n        state.makeWhileBody();\n      }\n      break;\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert(parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n      break;\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n      break;\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert(parent.body === node);\n        state.makeForInOfBody();\n      }\n      break;\n    case \"AssignmentPattern\":\n      /*\n       * Fork if this node is at `right`.\n       * `left` is executed always, so it uses the current path.\n       * `popForkContext()` exists at `AssignmentPattern:exit`.\n       */\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n      break;\n    default:\n      break;\n  }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath = analyzer.codePath;\n  let state = codePath && CodePath.getState(codePath);\n  const parent = node.parent;\n\n  /**\n   * Creates a new code path and trigger the onCodePathStart event\n   * based on the currently selected node.\n   * @param {string} origin The reason the code path was started.\n   * @returns {void}\n   */\n  function startCodePath(origin) {\n    if (codePath) {\n      // Emits onCodePathSegmentStart events if updated.\n      forwardCurrentToHead(analyzer, node);\n      debug.dumpState(node, state, false);\n    }\n\n    // Create the code path of this scope.\n    codePath = analyzer.codePath = new CodePath({\n      id: analyzer.idGenerator.next(),\n      origin,\n      upper: codePath,\n      onLooped: analyzer.onLooped\n    });\n    state = CodePath.getState(codePath);\n\n    // Emits onCodePathStart events.\n    debug.dump(`onCodePathStart ${codePath.id}`);\n    analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n  }\n\n  /*\n   * Special case: The right side of class field initializer is considered\n   * to be its own function, so we need to start a new code path in this\n   * case.\n   */\n  if (isPropertyDefinitionValue(node)) {\n    startCodePath(\"class-field-initializer\");\n\n    /*\n     * Intentional fall through because `node` needs to also be\n     * processed by the code below. For example, if we have:\n     *\n     * class Foo {\n     *     a = () => {}\n     * }\n     *\n     * In this case, we also need start a second code path.\n     */\n  }\n  switch (node.type) {\n    case \"Program\":\n      startCodePath(\"program\");\n      break;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      startCodePath(\"function\");\n      break;\n    case \"StaticBlock\":\n      startCodePath(\"class-static-block\");\n      break;\n    case \"ChainExpression\":\n      state.pushChainContext();\n      break;\n    case \"CallExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n      break;\n    case \"MemberExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n      break;\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n      break;\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.pushChoiceContext(node.operator.slice(0, -1),\n        // removes `=` from the end\n        isForkingByTrueOrFalse(node));\n      }\n      break;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n    case \"SwitchCase\":\n      /*\n       * Fork if this node is after the 2st node in `cases`.\n       * It's similar to `else` blocks.\n       * The next `test` node is processed in this path.\n       */\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n      break;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n      break;\n    default:\n      break;\n  }\n\n  // Emits onCodePathSegmentStart events if updated.\n  forwardCurrentToHead(analyzer, node);\n  debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  let dontForward = false;\n  switch (node.type) {\n    case \"ChainExpression\":\n      state.popChainContext();\n      break;\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n      break;\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n      break;\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n    case \"SwitchCase\":\n      /*\n       * This is the same as the process at the 1st `consequent` node in\n       * `preprocess` function.\n       * Must do if this `consequent` is empty.\n       */\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n      break;\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n      break;\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n      break;\n    default:\n      break;\n  }\n\n  // Emits onCodePathSegmentStart events if updated.\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n  debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n  /**\n   * Ends the code path for the current node.\n   * @returns {void}\n   */\n  function endCodePath() {\n    let codePath = analyzer.codePath;\n\n    // Mark the current path as the final node.\n    CodePath.getState(codePath).makeFinal();\n\n    // Emits onCodePathSegmentEnd event of the current segments.\n    leaveFromCurrentSegment(analyzer, node);\n\n    // Emits onCodePathEnd event of this code path.\n    debug.dump(`onCodePathEnd ${codePath.id}`);\n    analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n    debug.dumpDot(codePath);\n    codePath = analyzer.codePath = analyzer.codePath.upper;\n    if (codePath) {\n      debug.dumpState(node, CodePath.getState(codePath), true);\n    }\n  }\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"StaticBlock\":\n      {\n        endCodePath();\n        break;\n      }\n\n    // The `arguments.length >= 1` case is in `preprocess` function.\n    case \"CallExpression\":\n      if (node.optional === true && node.arguments.length === 0) {\n        CodePath.getState(analyzer.codePath).makeOptionalRight();\n      }\n      break;\n    default:\n      break;\n  }\n\n  /*\n   * Special case: The right side of class field initializer is considered\n   * to be its own function, so we need to end a code path in this\n   * case.\n   *\n   * We need to check after the other checks in order to close the\n   * code paths in the correct order for code like this:\n   *\n   *\n   * class Foo {\n   *     a = () => {}\n   * }\n   *\n   * In this case, The ArrowFunctionExpression code path is closed first\n   * and then we need to close the code path for the PropertyDefinition\n   * value.\n   */\n  if (isPropertyDefinitionValue(node)) {\n    endCodePath();\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n  /**\n   * @param {EventGenerator} eventGenerator An event generator to wrap.\n   */\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n\n  /**\n   * Does the process to enter a given AST node.\n   * This updates state of analysis and calls `enterNode` of the wrapped.\n   * @param {ASTNode} node A node which is entering.\n   * @returns {void}\n   */\n  enterNode(node) {\n    this.currentNode = node;\n\n    // Updates the code path due to node's position in its parent node.\n    if (node.parent) {\n      preprocess(this, node);\n    }\n\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n    processCodePathToEnter(this, node);\n\n    // Emits node events.\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n\n  /**\n   * Does the process to leave a given AST node.\n   * This updates state of analysis and calls `leaveNode` of the wrapped.\n   * @param {ASTNode} node A node which is leaving.\n   * @returns {void}\n   */\n  leaveNode(node) {\n    this.currentNode = node;\n\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n    processCodePathToExit(this, node);\n\n    // Emits node events.\n    this.original.leaveNode(node);\n\n    // Emits the last onCodePathStart/onCodePathSegmentStart events.\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n\n  /**\n   * This is called on a code path looped.\n   * Then this raises a looped event.\n   * @param {CodePathSegment} fromSegment A segment of prev.\n   * @param {CodePathSegment} toSegment A segment of next.\n   * @returns {void}\n   */\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n}\nmodule.exports = CodePathAnalyzer;","map":{"version":3,"names":["assert","require","breakableTypePattern","CodePath","CodePathSegment","IdGenerator","debug","isCaseNode","node","Boolean","test","isPropertyDefinitionValue","parent","type","value","isHandledLogicalOperator","operator","isLogicalAssignmentOperator","getLabel","label","name","isForkingByTrueOrFalse","getBooleanValueIfSimpleConstant","isIdentifierReference","id","key","computed","shorthand","forwardCurrentToHead","analyzer","codePath","state","getState","currentSegments","headSegments","end","Math","max","length","i","currentSegment","headSegment","eventName","reachable","dump","emitter","emit","markUsed","leaveFromCurrentSegment","preprocess","optional","arguments","makeOptionalRight","property","right","makeLogicalRight","consequent","makeIfConsequent","alternate","makeIfAlternate","makeSwitchCaseBody","handler","makeCatchBlock","finalizer","makeFinallyBlock","makeWhileTest","body","makeWhileBody","makeDoWhileBody","makeDoWhileTest","makeForTest","update","makeForUpdate","makeForBody","left","makeForInOfLeft","makeForInOfRight","makeForInOfBody","pushForkContext","forkBypassPath","forkPath","processCodePathToEnter","startCodePath","origin","dumpState","idGenerator","next","upper","onLooped","pushChainContext","makeOptionalNode","pushChoiceContext","slice","pushSwitchContext","cases","some","pushTryContext","discriminant","pushLoopContext","pushBreakContext","processCodePathToExit","dontForward","popChainContext","popChoiceContext","popSwitchContext","forkContext","popTryContext","makeBreak","makeContinue","makeReturn","makeThrow","makeFirstThrowablePathInTryBlock","popLoopContext","popForkContext","popBreakContext","postprocess","endCodePath","makeFinal","dumpDot","CodePathAnalyzer","constructor","eventGenerator","original","currentNode","bind","enterNode","leaveNode","fromSegment","toSegment","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks if a given node appears as the value of a PropertyDefinition node.\n * @param {ASTNode} node THe node to check.\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\n *      false if not.\n */\nfunction isPropertyDefinitionValue(node) {\n    const parent = node.parent;\n\n    return parent && parent.type === \"PropertyDefinition\" && parent.value === node;\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n    if (node.parent.type === \"LabeledStatement\") {\n        return node.parent.label.name;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        case \"AssignmentExpression\":\n            return isLogicalAssignmentOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n\n            const eventName = currentSegment.reachable\n                ? \"onCodePathSegmentEnd\"\n                : \"onUnreachableCodePathSegmentEnd\";\n\n            debug.dump(`${eventName} ${currentSegment.id}`);\n\n            analyzer.emitter.emit(\n                eventName,\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n\n            const eventName = headSegment.reachable\n                ? \"onCodePathSegmentStart\"\n                : \"onUnreachableCodePathSegmentStart\";\n\n            debug.dump(`${eventName} ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            analyzer.emitter.emit(\n                eventName,\n                headSegment,\n                node\n            );\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n        const eventName = currentSegment.reachable\n            ? \"onCodePathSegmentEnd\"\n            : \"onUnreachableCodePathSegmentEnd\";\n\n        debug.dump(`${eventName} ${currentSegment.id}`);\n\n        analyzer.emitter.emit(\n            eventName,\n            currentSegment,\n            node\n        );\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n        case \"CallExpression\":\n            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n                state.makeOptionalRight();\n            }\n            break;\n        case \"MemberExpression\":\n            if (parent.optional === true && parent.property === node) {\n                state.makeOptionalRight();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (\n                parent.right === node &&\n                isLogicalAssignmentOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    /**\n     * Creates a new code path and trigger the onCodePathStart event\n     * based on the currently selected node.\n     * @param {string} origin The reason the code path was started.\n     * @returns {void}\n     */\n    function startCodePath(origin) {\n        if (codePath) {\n\n            // Emits onCodePathSegmentStart events if updated.\n            forwardCurrentToHead(analyzer, node);\n            debug.dumpState(node, state, false);\n        }\n\n        // Create the code path of this scope.\n        codePath = analyzer.codePath = new CodePath({\n            id: analyzer.idGenerator.next(),\n            origin,\n            upper: codePath,\n            onLooped: analyzer.onLooped\n        });\n        state = CodePath.getState(codePath);\n\n        // Emits onCodePathStart events.\n        debug.dump(`onCodePathStart ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n    }\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to start a new code path in this\n     * case.\n     */\n    if (isPropertyDefinitionValue(node)) {\n        startCodePath(\"class-field-initializer\");\n\n        /*\n         * Intentional fall through because `node` needs to also be\n         * processed by the code below. For example, if we have:\n         *\n         * class Foo {\n         *     a = () => {}\n         * }\n         *\n         * In this case, we also need start a second code path.\n         */\n\n    }\n\n    switch (node.type) {\n        case \"Program\":\n            startCodePath(\"program\");\n            break;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            startCodePath(\"function\");\n            break;\n\n        case \"StaticBlock\":\n            startCodePath(\"class-static-block\");\n            break;\n\n        case \"ChainExpression\":\n            state.pushChainContext();\n            break;\n        case \"CallExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n        case \"MemberExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator.slice(0, -1), // removes `=` from the end\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"ChainExpression\":\n            state.popChainContext();\n            break;\n\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"ImportExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n\n    /**\n     * Ends the code path for the current node.\n     * @returns {void}\n     */\n    function endCodePath() {\n        let codePath = analyzer.codePath;\n\n        // Mark the current path as the final node.\n        CodePath.getState(codePath).makeFinal();\n\n        // Emits onCodePathSegmentEnd event of the current segments.\n        leaveFromCurrentSegment(analyzer, node);\n\n        // Emits onCodePathEnd event of this code path.\n        debug.dump(`onCodePathEnd ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n        debug.dumpDot(codePath);\n\n        codePath = analyzer.codePath = analyzer.codePath.upper;\n        if (codePath) {\n            debug.dumpState(node, CodePath.getState(codePath), true);\n        }\n\n    }\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"StaticBlock\": {\n            endCodePath();\n            break;\n        }\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n        case \"CallExpression\":\n            if (node.optional === true && node.arguments.length === 0) {\n                CodePath.getState(analyzer.codePath).makeOptionalRight();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to end a code path in this\n     * case.\n     *\n     * We need to check after the other checks in order to close the\n     * code paths in the correct order for code like this:\n     *\n     *\n     * class Foo {\n     *     a = () => {}\n     * }\n     *\n     * In this case, The ArrowFunctionExpression code path is closed first\n     * and then we need to close the code path for the PropertyDefinition\n     * value.\n     */\n    if (isPropertyDefinitionValue(node)) {\n        endCodePath();\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}