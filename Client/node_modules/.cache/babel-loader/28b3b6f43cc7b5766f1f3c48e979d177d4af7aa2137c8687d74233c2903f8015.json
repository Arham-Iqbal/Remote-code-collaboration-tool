{"ast":null,"code":"/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow literal numbers that lose precision\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-loss-of-precision\"\n    },\n    schema: [],\n    messages: {\n      noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n    }\n  },\n  create(context) {\n    /**\n     * Returns whether the node is number literal\n     * @param {Node} node the node literal being evaluated\n     * @returns {boolean} true if the node is a number literal\n     */\n    function isNumber(node) {\n      return typeof node.value === \"number\";\n    }\n\n    /**\n     * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n     * @param {Node} node the number `Literal` node\n     * @returns {string} raw source code of the literal, without numeric separators\n     */\n    function getRaw(node) {\n      return node.raw.replace(/_/gu, \"\");\n    }\n\n    /**\n     * Checks whether the number is  base ten\n     * @param {ASTNode} node the node being evaluated\n     * @returns {boolean} true if the node is in base ten\n     */\n    function isBaseTen(node) {\n      const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n      return prefixes.every(prefix => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);\n    }\n\n    /**\n     * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n    function notBaseTenLosesPrecision(node) {\n      const rawString = getRaw(node).toUpperCase();\n      let base = 0;\n      if (rawString.startsWith(\"0B\")) {\n        base = 2;\n      } else if (rawString.startsWith(\"0X\")) {\n        base = 16;\n      } else {\n        base = 8;\n      }\n      return !rawString.endsWith(node.value.toString(base).toUpperCase());\n    }\n\n    /**\n     * Adds a decimal point to the numeric string at index 1\n     * @param {string} stringNumber the numeric string without any decimal point\n     * @returns {string} the numeric string with a decimal point in the proper place\n     */\n    function addDecimalPointToNumber(stringNumber) {\n      return `${stringNumber[0]}.${stringNumber.slice(1)}`;\n    }\n\n    /**\n     * Returns the number stripped of leading zeros\n     * @param {string} numberAsString the string representation of the number\n     * @returns {string} the stripped string\n     */\n    function removeLeadingZeros(numberAsString) {\n      for (let i = 0; i < numberAsString.length; i++) {\n        if (numberAsString[i] !== \"0\") {\n          return numberAsString.slice(i);\n        }\n      }\n      return numberAsString;\n    }\n\n    /**\n     * Returns the number stripped of trailing zeros\n     * @param {string} numberAsString the string representation of the number\n     * @returns {string} the stripped string\n     */\n    function removeTrailingZeros(numberAsString) {\n      for (let i = numberAsString.length - 1; i >= 0; i--) {\n        if (numberAsString[i] !== \"0\") {\n          return numberAsString.slice(0, i + 1);\n        }\n      }\n      return numberAsString;\n    }\n\n    /**\n     * Converts an integer to an object containing the integer's coefficient and order of magnitude\n     * @param {string} stringInteger the string representation of the integer being converted\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\n     */\n    function normalizeInteger(stringInteger) {\n      const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n      return {\n        magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n        coefficient: addDecimalPointToNumber(significantDigits)\n      };\n    }\n\n    /**\n     *\n     * Converts a float to an object containing the floats's coefficient and order of magnitude\n     * @param {string} stringFloat the string representation of the float being converted\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\n     */\n    function normalizeFloat(stringFloat) {\n      const trimmedFloat = removeLeadingZeros(stringFloat);\n      if (trimmedFloat.startsWith(\".\")) {\n        const decimalDigits = trimmedFloat.slice(1);\n        const significantDigits = removeLeadingZeros(decimalDigits);\n        return {\n          magnitude: significantDigits.length - decimalDigits.length - 1,\n          coefficient: addDecimalPointToNumber(significantDigits)\n        };\n      }\n      return {\n        magnitude: trimmedFloat.indexOf(\".\") - 1,\n        coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n      };\n    }\n\n    /**\n     * Converts a base ten number to proper scientific notation\n     * @param {string} stringNumber the string representation of the base ten number to be converted\n     * @returns {string} the number converted to scientific notation\n     */\n    function convertNumberToScientificNotation(stringNumber) {\n      const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n      const originalCoefficient = splitNumber[0];\n      const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);\n      const normalizedCoefficient = normalizedNumber.coefficient;\n      const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;\n      return `${normalizedCoefficient}e${magnitude}`;\n    }\n\n    /**\n     * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n    function baseTenLosesPrecision(node) {\n      const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n      const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n      if (requestedPrecision > 100) {\n        return true;\n      }\n      const storedNumber = node.value.toPrecision(requestedPrecision);\n      const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n      return normalizedRawNumber !== normalizedStoredNumber;\n    }\n\n    /**\n     * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n    function losesPrecision(node) {\n      return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n    }\n    return {\n      Literal(node) {\n        if (node.value && isNumber(node) && losesPrecision(node)) {\n          context.report({\n            messageId: \"noLossOfPrecision\",\n            node\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","noLossOfPrecision","create","context","isNumber","node","value","getRaw","raw","replace","isBaseTen","prefixes","every","prefix","startsWith","test","notBaseTenLosesPrecision","rawString","toUpperCase","base","endsWith","toString","addDecimalPointToNumber","stringNumber","slice","removeLeadingZeros","numberAsString","i","length","removeTrailingZeros","normalizeInteger","stringInteger","significantDigits","magnitude","coefficient","normalizeFloat","stringFloat","trimmedFloat","decimalDigits","indexOf","convertNumberToScientificNotation","splitNumber","split","originalCoefficient","normalizedNumber","includes","normalizedCoefficient","parseInt","baseTenLosesPrecision","normalizedRawNumber","requestedPrecision","storedNumber","toPrecision","normalizedStoredNumber","losesPrecision","Literal","report","messageId"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-loss-of-precision.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow literal numbers that lose precision\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-loss-of-precision\"\n        },\n        schema: [],\n        messages: {\n            noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n         * @param {Node} node the number `Literal` node\n         * @returns {string} raw source code of the literal, without numeric separators\n         */\n        function getRaw(node) {\n            return node.raw.replace(/_/gu, \"\");\n        }\n\n        /**\n         * Checks whether the number is  base ten\n         * @param {ASTNode} node the node being evaluated\n         * @returns {boolean} true if the node is in base ten\n         */\n        function isBaseTen(node) {\n            const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n\n            return prefixes.every(prefix => !node.raw.startsWith(prefix)) &&\n            !/^0[0-7]+$/u.test(node.raw);\n        }\n\n        /**\n         * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function notBaseTenLosesPrecision(node) {\n            const rawString = getRaw(node).toUpperCase();\n            let base = 0;\n\n            if (rawString.startsWith(\"0B\")) {\n                base = 2;\n            } else if (rawString.startsWith(\"0X\")) {\n                base = 16;\n            } else {\n                base = 8;\n            }\n\n            return !rawString.endsWith(node.value.toString(base).toUpperCase());\n        }\n\n        /**\n         * Adds a decimal point to the numeric string at index 1\n         * @param {string} stringNumber the numeric string without any decimal point\n         * @returns {string} the numeric string with a decimal point in the proper place\n         */\n        function addDecimalPointToNumber(stringNumber) {\n            return `${stringNumber[0]}.${stringNumber.slice(1)}`;\n        }\n\n        /**\n         * Returns the number stripped of leading zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeLeadingZeros(numberAsString) {\n            for (let i = 0; i < numberAsString.length; i++) {\n                if (numberAsString[i] !== \"0\") {\n                    return numberAsString.slice(i);\n                }\n            }\n            return numberAsString;\n        }\n\n        /**\n         * Returns the number stripped of trailing zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeTrailingZeros(numberAsString) {\n            for (let i = numberAsString.length - 1; i >= 0; i--) {\n                if (numberAsString[i] !== \"0\") {\n                    return numberAsString.slice(0, i + 1);\n                }\n            }\n            return numberAsString;\n        }\n\n        /**\n         * Converts an integer to an object containing the integer's coefficient and order of magnitude\n         * @param {string} stringInteger the string representation of the integer being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeInteger(stringInteger) {\n            const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n\n            return {\n                magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n                coefficient: addDecimalPointToNumber(significantDigits)\n            };\n        }\n\n        /**\n         *\n         * Converts a float to an object containing the floats's coefficient and order of magnitude\n         * @param {string} stringFloat the string representation of the float being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeFloat(stringFloat) {\n            const trimmedFloat = removeLeadingZeros(stringFloat);\n\n            if (trimmedFloat.startsWith(\".\")) {\n                const decimalDigits = trimmedFloat.slice(1);\n                const significantDigits = removeLeadingZeros(decimalDigits);\n\n                return {\n                    magnitude: significantDigits.length - decimalDigits.length - 1,\n                    coefficient: addDecimalPointToNumber(significantDigits)\n                };\n\n            }\n            return {\n                magnitude: trimmedFloat.indexOf(\".\") - 1,\n                coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n\n            };\n        }\n\n        /**\n         * Converts a base ten number to proper scientific notation\n         * @param {string} stringNumber the string representation of the base ten number to be converted\n         * @returns {string} the number converted to scientific notation\n         */\n        function convertNumberToScientificNotation(stringNumber) {\n            const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n            const originalCoefficient = splitNumber[0];\n            const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient)\n                : normalizeInteger(originalCoefficient);\n            const normalizedCoefficient = normalizedNumber.coefficient;\n            const magnitude = splitNumber.length > 1 ? (parseInt(splitNumber[1], 10) + normalizedNumber.magnitude)\n                : normalizedNumber.magnitude;\n\n            return `${normalizedCoefficient}e${magnitude}`;\n        }\n\n        /**\n         * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function baseTenLosesPrecision(node) {\n            const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n            const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n            if (requestedPrecision > 100) {\n                return true;\n            }\n            const storedNumber = node.value.toPrecision(requestedPrecision);\n            const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n\n            return normalizedRawNumber !== normalizedStoredNumber;\n        }\n\n\n        /**\n         * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function losesPrecision(node) {\n            return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n        }\n\n\n        return {\n            Literal(node) {\n                if (node.value && isNumber(node) && losesPrecision(node)) {\n                    context.report({\n                        messageId: \"noLossOfPrecision\",\n                        node\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}