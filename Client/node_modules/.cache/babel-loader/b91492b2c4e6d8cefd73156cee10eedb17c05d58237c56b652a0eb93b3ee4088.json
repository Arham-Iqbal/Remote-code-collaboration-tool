{"ast":null,"code":"/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst path = require(\"path\"),\n  eslintScope = require(\"eslint-scope\"),\n  evk = require(\"eslint-visitor-keys\"),\n  espree = require(\"espree\"),\n  merge = require(\"lodash.merge\"),\n  pkg = require(\"../../package.json\"),\n  astUtils = require(\"../shared/ast-utils\"),\n  {\n    directivesPattern\n  } = require(\"../shared/directives\"),\n  {\n    Legacy: {\n      ConfigOps,\n      ConfigValidator,\n      environments: BuiltInEnvironments\n    }\n  } = require(\"@eslint/eslintrc/universal\"),\n  Traverser = require(\"../shared/traverser\"),\n  {\n    SourceCode\n  } = require(\"../source-code\"),\n  CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n  applyDisableDirectives = require(\"./apply-disable-directives\"),\n  ConfigCommentParser = require(\"./config-comment-parser\"),\n  NodeEventGenerator = require(\"./node-event-generator\"),\n  createReportTranslator = require(\"./report-translator\"),\n  Rules = require(\"./rules\"),\n  createEmitter = require(\"./safe-emitter\"),\n  SourceCodeFixer = require(\"./source-code-fixer\"),\n  timing = require(\"./timing\"),\n  ruleReplacements = require(\"../../conf/replacements.json\");\nconst {\n  getRuleFromConfig\n} = require(\"../config/flat-config-helpers\");\nconst {\n  FlatConfigArray\n} = require(\"../config/flat-config-array\");\nconst {\n  RuleValidator\n} = require(\"../config/rule-validator\");\nconst {\n  assertIsRuleOptions,\n  assertIsRuleSeverity\n} = require(\"../config/flat-config-schema\");\nconst {\n  normalizeSeverityToString\n} = require(\"../shared/severity\");\nconst debug = require(\"debug\")(\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = {\n  start: {\n    line: 1,\n    column: 0\n  },\n  end: {\n    line: 1,\n    column: 1\n  }\n};\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ConfigArray>} ConfigArray */\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ExtractedConfig>} ExtractedConfig */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type Type of directive\n * @property {number} line The line number\n * @property {number} column The column number\n * @property {(string|null)} ruleId The rule ID\n * @property {string} justification The justification of directive\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {SuppressedLintMessage[]} lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor.postprocess} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor.preprocess} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if a given object is Espree.\n * @param {Object} parser The parser to check.\n * @returns {boolean} True if the parser is Espree or false if not.\n */\nfunction isEspree(parser) {\n  return !!(parser === espree || parser[parserSymbol] === espree);\n}\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals, {\n  exportedVariables,\n  enabledGlobals\n}) {\n  // Define configured global variables.\n  for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n    /*\n     * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n     * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n     */\n    const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n    const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n    const value = commentValue || configValue;\n    const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n    if (value === \"off\") {\n      continue;\n    }\n    let variable = globalScope.set.get(id);\n    if (!variable) {\n      variable = new eslintScope.Variable(id, globalScope);\n      globalScope.variables.push(variable);\n      globalScope.set.set(id, variable);\n    }\n    variable.eslintImplicitGlobalSetting = configValue;\n    variable.eslintExplicitGlobal = sourceComments !== void 0;\n    variable.eslintExplicitGlobalComments = sourceComments;\n    variable.writeable = value === \"writable\";\n  }\n\n  // mark all exported variables as such\n  Object.keys(exportedVariables).forEach(name => {\n    const variable = globalScope.set.get(name);\n    if (variable) {\n      variable.eslintUsed = true;\n      variable.eslintExported = true;\n    }\n  });\n\n  /*\n   * \"through\" contains all references which definitions cannot be found.\n   * Since we augment the global scope using configuration, we need to update\n   * references and remove the ones that were added by configuration.\n   */\n  globalScope.through = globalScope.through.filter(reference => {\n    const name = reference.identifier.name;\n    const variable = globalScope.set.get(name);\n    if (variable) {\n      /*\n       * Links the variable and the reference.\n       * And this reference is removed from `Scope#through`.\n       */\n      reference.resolved = variable;\n      variable.references.push(reference);\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\nfunction createMissingRuleMessage(ruleId) {\n  return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}` : `Definition for rule '${ruleId}' was not found.`;\n}\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\nfunction createLintingProblem(options) {\n  const {\n    ruleId = null,\n    loc = DEFAULT_ERROR_LOC,\n    message = createMissingRuleMessage(options.ruleId),\n    severity = 2\n  } = options;\n  return {\n    ruleId,\n    message,\n    line: loc.start.line,\n    column: loc.start.column + 1,\n    endLine: loc.end.line,\n    endColumn: loc.end.column + 1,\n    severity,\n    nodeType: null\n  };\n}\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {token} options.commentToken The Comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {string} options.justification The justification of the directive\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\nfunction createDisableDirectives(options) {\n  const {\n    commentToken,\n    type,\n    value,\n    justification,\n    ruleMapper\n  } = options;\n  const ruleIds = Object.keys(commentParser.parseListConfig(value));\n  const directiveRules = ruleIds.length ? ruleIds : [null];\n  const result = {\n    directives: [],\n    // valid disable directives\n    directiveProblems: [] // problems in directives\n  };\n  const parentComment = {\n    commentToken,\n    ruleIds\n  };\n  for (const ruleId of directiveRules) {\n    // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n    if (ruleId === null || !!ruleMapper(ruleId)) {\n      if (type === \"disable-next-line\") {\n        result.directives.push({\n          parentComment,\n          type,\n          line: commentToken.loc.end.line,\n          column: commentToken.loc.end.column + 1,\n          ruleId,\n          justification\n        });\n      } else {\n        result.directives.push({\n          parentComment,\n          type,\n          line: commentToken.loc.start.line,\n          column: commentToken.loc.start.column + 1,\n          ruleId,\n          justification\n        });\n      }\n    } else {\n      result.directiveProblems.push(createLintingProblem({\n        ruleId,\n        loc: commentToken.loc\n      }));\n    }\n  }\n  return result;\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveComments(sourceCode, ruleMapper, warnInlineConfig) {\n  const configuredRules = {};\n  const enabledGlobals = Object.create(null);\n  const exportedVariables = {};\n  const problems = [];\n  const disableDirectives = [];\n  const validator = new ConfigValidator({\n    builtInRules: Rules\n  });\n  sourceCode.getInlineConfigNodes().filter(token => token.type !== \"Shebang\").forEach(comment => {\n    const {\n      directivePart,\n      justificationPart\n    } = commentParser.extractDirectiveComment(comment.value);\n    const match = directivesPattern.exec(directivePart);\n    if (!match) {\n      return;\n    }\n    const directiveText = match[1];\n    const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n    if (comment.type === \"Line\" && !lineCommentSupported) {\n      return;\n    }\n    if (warnInlineConfig) {\n      const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n        loc: comment.loc,\n        severity: 1\n      }));\n      return;\n    }\n    if (directiveText === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\n      const message = `${directiveText} comment should not span multiple lines.`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message,\n        loc: comment.loc\n      }));\n      return;\n    }\n    const directiveValue = directivePart.slice(match.index + directiveText.length);\n    switch (directiveText) {\n      case \"eslint-disable\":\n      case \"eslint-enable\":\n      case \"eslint-disable-next-line\":\n      case \"eslint-disable-line\":\n        {\n          const directiveType = directiveText.slice(\"eslint-\".length);\n          const options = {\n            commentToken: comment,\n            type: directiveType,\n            value: directiveValue,\n            justification: justificationPart,\n            ruleMapper\n          };\n          const {\n            directives,\n            directiveProblems\n          } = createDisableDirectives(options);\n          disableDirectives.push(...directives);\n          problems.push(...directiveProblems);\n          break;\n        }\n      case \"exported\":\n        Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n        break;\n      case \"globals\":\n      case \"global\":\n        for (const [id, {\n          value\n        }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n          let normalizedValue;\n          try {\n            normalizedValue = ConfigOps.normalizeConfigGlobal(value);\n          } catch (err) {\n            problems.push(createLintingProblem({\n              ruleId: null,\n              loc: comment.loc,\n              message: err.message\n            }));\n            continue;\n          }\n          if (enabledGlobals[id]) {\n            enabledGlobals[id].comments.push(comment);\n            enabledGlobals[id].value = normalizedValue;\n          } else {\n            enabledGlobals[id] = {\n              comments: [comment],\n              value: normalizedValue\n            };\n          }\n        }\n        break;\n      case \"eslint\":\n        {\n          const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n          if (parseResult.success) {\n            Object.keys(parseResult.config).forEach(name => {\n              const rule = ruleMapper(name);\n              const ruleValue = parseResult.config[name];\n              if (!rule) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  loc: comment.loc\n                }));\n                return;\n              }\n              try {\n                validator.validateRuleOptions(rule, name, ruleValue);\n              } catch (err) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  message: err.message,\n                  loc: comment.loc\n                }));\n\n                // do not apply the config, if found invalid options.\n                return;\n              }\n              configuredRules[name] = ruleValue;\n            });\n          } else {\n            problems.push(parseResult.error);\n          }\n          break;\n        }\n\n      // no default\n    }\n  });\n  return {\n    configuredRules,\n    enabledGlobals,\n    exportedVariables,\n    problems,\n    disableDirectives\n  };\n}\n\n/**\n * Parses comments in file to extract disable directives.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @returns {{problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveCommentsForFlatConfig(sourceCode, ruleMapper) {\n  const problems = [];\n  const disableDirectives = [];\n  sourceCode.getInlineConfigNodes().filter(token => token.type !== \"Shebang\").forEach(comment => {\n    const {\n      directivePart,\n      justificationPart\n    } = commentParser.extractDirectiveComment(comment.value);\n    const match = directivesPattern.exec(directivePart);\n    if (!match) {\n      return;\n    }\n    const directiveText = match[1];\n    const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n    if (comment.type === \"Line\" && !lineCommentSupported) {\n      return;\n    }\n    if (directiveText === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\n      const message = `${directiveText} comment should not span multiple lines.`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message,\n        loc: comment.loc\n      }));\n      return;\n    }\n    const directiveValue = directivePart.slice(match.index + directiveText.length);\n    switch (directiveText) {\n      case \"eslint-disable\":\n      case \"eslint-enable\":\n      case \"eslint-disable-next-line\":\n      case \"eslint-disable-line\":\n        {\n          const directiveType = directiveText.slice(\"eslint-\".length);\n          const options = {\n            commentToken: comment,\n            type: directiveType,\n            value: directiveValue,\n            justification: justificationPart,\n            ruleMapper\n          };\n          const {\n            directives,\n            directiveProblems\n          } = createDisableDirectives(options);\n          disableDirectives.push(...directives);\n          problems.push(...directiveProblems);\n          break;\n        }\n\n      // no default\n    }\n  });\n  return {\n    problems,\n    disableDirectives\n  };\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param {Parser} parser The parser which uses this options.\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n  if (isEspree(parser)) {\n    if (ecmaVersion === \"latest\") {\n      return espree.latestEcmaVersion;\n    }\n  }\n\n  /*\n   * Calculate ECMAScript edition number from official year version starting with\n   * ES2015, which corresponds with ES6 (or a difference of 2009).\n   */\n  return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\n/**\n * Normalize ECMAScript version from the initial config into languageOptions (year)\n * format.\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersionForLanguageOptions(ecmaVersion) {\n  switch (ecmaVersion) {\n    case 3:\n      return 3;\n\n    // void 0 = no ecmaVersion specified so use the default\n    case 5:\n    case void 0:\n      return 5;\n    default:\n      if (typeof ecmaVersion === \"number\") {\n        return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;\n      }\n  }\n\n  /*\n   * We default to the latest supported ecmaVersion for everything else.\n   * Remember, this is for languageOptions.ecmaVersion, which sets the version\n   * that is used for a number of processes inside of ESLint. It's normally\n   * safe to assume people want the latest unless otherwise specified.\n   */\n  return espree.latestEcmaVersion + 2009;\n}\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)(?:\\*\\/|$)/gsu;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n  let match, retv;\n  eslintEnvPattern.lastIndex = 0;\n  while ((match = eslintEnvPattern.exec(text)) !== null) {\n    if (match[0].endsWith(\"*/\")) {\n      retv = Object.assign(retv || {}, commentParser.parseListConfig(commentParser.extractDirectiveComment(match[1]).directivePart));\n    }\n  }\n  return retv;\n}\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#filename` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\nfunction normalizeFilename(filename) {\n  const parts = filename.split(path.sep);\n  const index = parts.lastIndexOf(\"<text>\");\n  return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\nfunction normalizeVerifyOptions(providedOptions, config) {\n  const linterOptions = config.linterOptions || config;\n\n  // .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat\n  const disableInlineConfig = linterOptions.noInlineConfig === true;\n  const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n  const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : \"\";\n  let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n  if (typeof reportUnusedDisableDirectives === \"boolean\") {\n    reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n  }\n  if (typeof reportUnusedDisableDirectives !== \"string\") {\n    if (typeof linterOptions.reportUnusedDisableDirectives === \"boolean\") {\n      reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n    } else {\n      reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives === void 0 ? \"off\" : normalizeSeverityToString(linterOptions.reportUnusedDisableDirectives);\n    }\n  }\n  return {\n    filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n    allowInlineConfig: !ignoreInlineConfig,\n    warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,\n    reportUnusedDisableDirectives,\n    disableFixes: Boolean(providedOptions.disableFixes)\n  };\n}\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {Parser} parser The parser which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n  const parserOptionsFromEnv = enabledEnvironments.filter(env => env.parserOptions).reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\n  const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\n  const isModule = mergedParserOptions.sourceType === \"module\";\n  if (isModule) {\n    /*\n     * can't have global return inside of modules\n     * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n     */\n    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {\n      globalReturn: false\n    });\n  }\n  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n  return mergedParserOptions;\n}\n\n/**\n * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.\n * @param {ConfigData} config Config object.\n * @param {Object} config.globals Global variable definitions.\n * @param {Parser} config.parser The parser to use.\n * @param {ParserOptions} config.parserOptions The parserOptions to use.\n * @returns {LanguageOptions} The languageOptions equivalent.\n */\nfunction createLanguageOptions({\n  globals: configuredGlobals,\n  parser,\n  parserOptions\n}) {\n  const {\n    ecmaVersion,\n    sourceType\n  } = parserOptions;\n  return {\n    globals: configuredGlobals,\n    ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),\n    sourceType,\n    parser,\n    parserOptions\n  };\n}\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n  return Object.assign(Object.create(null), ...enabledEnvironments.filter(env => env.globals).map(env => env.globals), providedGlobals);\n}\n\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n  /*\n   * Check Unicode BOM.\n   * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n   * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n   */\n  if (text.charCodeAt(0) === 0xFEFF) {\n    return text.slice(1);\n  }\n  return text;\n}\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\nfunction getRuleOptions(ruleConfig) {\n  if (Array.isArray(ruleConfig)) {\n    return ruleConfig.slice(1);\n  }\n  return [];\n}\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {LanguageOptions} languageOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, languageOptions, visitorKeys) {\n  const parserOptions = languageOptions.parserOptions;\n  const ecmaFeatures = parserOptions.ecmaFeatures || {};\n  const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n  return eslintScope.analyze(ast, {\n    ignoreEval: true,\n    nodejsScope: ecmaFeatures.globalReturn,\n    impliedStrict: ecmaFeatures.impliedStrict,\n    ecmaVersion: typeof ecmaVersion === \"number\" ? ecmaVersion : 6,\n    sourceType: languageOptions.sourceType || \"script\",\n    childVisitorKeys: visitorKeys || evk.KEYS,\n    fallback: Traverser.getKeys\n  });\n}\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {LanguageOptions} languageOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: LintMessage}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\nfunction parse(text, languageOptions, filePath) {\n  const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n  const {\n    ecmaVersion,\n    sourceType,\n    parser\n  } = languageOptions;\n  const parserOptions = Object.assign({\n    ecmaVersion,\n    sourceType\n  }, languageOptions.parserOptions, {\n    loc: true,\n    range: true,\n    raw: true,\n    tokens: true,\n    comment: true,\n    eslintVisitorKeys: true,\n    eslintScopeManager: true,\n    filePath\n  });\n\n  /*\n   * Check for parsing errors first. If there's a parsing error, nothing\n   * else can happen. However, a parsing error does not throw an error\n   * from this method - it's just considered a fatal error message, a\n   * problem that ESLint identified just like any other.\n   */\n  try {\n    debug(\"Parsing:\", filePath);\n    const parseResult = typeof parser.parseForESLint === \"function\" ? parser.parseForESLint(textToParse, parserOptions) : {\n      ast: parser.parse(textToParse, parserOptions)\n    };\n    debug(\"Parsing successful:\", filePath);\n    const ast = parseResult.ast;\n    const parserServices = parseResult.services || {};\n    const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n    debug(\"Scope analysis:\", filePath);\n    const scopeManager = parseResult.scopeManager || analyzeScope(ast, languageOptions, visitorKeys);\n    debug(\"Scope analysis successful:\", filePath);\n    return {\n      success: true,\n      /*\n       * Save all values that `parseForESLint()` returned.\n       * If a `SourceCode` object is given as the first parameter instead of source code text,\n       * linter skips the parsing process and reuses the source code object.\n       * In that case, linter needs all the values that `parseForESLint()` returned.\n       */\n      sourceCode: new SourceCode({\n        text,\n        ast,\n        parserServices,\n        scopeManager,\n        visitorKeys\n      })\n    };\n  } catch (ex) {\n    // If the message includes a leading line number, strip it:\n    const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n    debug(\"%s\\n%s\", message, ex.stack);\n    return {\n      success: false,\n      error: {\n        ruleId: null,\n        fatal: true,\n        severity: 2,\n        message,\n        line: ex.lineNumber,\n        column: ex.column,\n        nodeType: null\n      }\n    };\n  }\n}\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @throws {any} Any error during the rule's `create`\n * @returns {Object} A map of selector listeners provided by the rule\n */\nfunction createRuleListeners(rule, ruleContext) {\n  try {\n    return rule.create(ruleContext);\n  } catch (ex) {\n    ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n    throw ex;\n  }\n}\n\n// methods that exist on SourceCode object\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n  getSource: \"getText\",\n  getSourceLines: \"getLines\",\n  getAllComments: \"getAllComments\",\n  getNodeByRangeIndex: \"getNodeByRangeIndex\",\n  getComments: \"getComments\",\n  getCommentsBefore: \"getCommentsBefore\",\n  getCommentsAfter: \"getCommentsAfter\",\n  getCommentsInside: \"getCommentsInside\",\n  getJSDocComment: \"getJSDocComment\",\n  getFirstToken: \"getFirstToken\",\n  getFirstTokens: \"getFirstTokens\",\n  getLastToken: \"getLastToken\",\n  getLastTokens: \"getLastTokens\",\n  getTokenAfter: \"getTokenAfter\",\n  getTokenBefore: \"getTokenBefore\",\n  getTokenByRangeStart: \"getTokenByRangeStart\",\n  getTokens: \"getTokens\",\n  getTokensAfter: \"getTokensAfter\",\n  getTokensBefore: \"getTokensBefore\",\n  getTokensBetween: \"getTokensBetween\"\n};\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {\n  [methodName](...args) {\n    return this.sourceCode[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\n  }\n}), {}));\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {string | undefined} parserName The name of the parser in the config\n * @param {LanguageOptions} languageOptions The options for parsing the code.\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @param {string} physicalFilename The full path of the file on disk without any code block information\n * @returns {LintMessage[]} An array of reported problems\n */\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserName, languageOptions, settings, filename, disableFixes, cwd, physicalFilename) {\n  const emitter = createEmitter();\n  const nodeQueue = [];\n  let currentNode = sourceCode.ast;\n  Traverser.traverse(sourceCode.ast, {\n    enter(node, parent) {\n      node.parent = parent;\n      nodeQueue.push({\n        isEntering: true,\n        node\n      });\n    },\n    leave(node) {\n      nodeQueue.push({\n        isEntering: false,\n        node\n      });\n    },\n    visitorKeys: sourceCode.visitorKeys\n  });\n\n  /*\n   * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n   * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n   * properties once for each rule.\n   */\n  const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {\n    getAncestors: () => sourceCode.getAncestors(currentNode),\n    getDeclaredVariables: node => sourceCode.getDeclaredVariables(node),\n    getCwd: () => cwd,\n    cwd,\n    getFilename: () => filename,\n    filename,\n    getPhysicalFilename: () => physicalFilename || filename,\n    physicalFilename: physicalFilename || filename,\n    getScope: () => sourceCode.getScope(currentNode),\n    getSourceCode: () => sourceCode,\n    sourceCode,\n    markVariableAsUsed: name => sourceCode.markVariableAsUsed(name, currentNode),\n    parserOptions: {\n      ...languageOptions.parserOptions\n    },\n    parserPath: parserName,\n    languageOptions,\n    parserServices: sourceCode.parserServices,\n    settings\n  }));\n  const lintingProblems = [];\n  Object.keys(configuredRules).forEach(ruleId => {\n    const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n    // not load disabled rules\n    if (severity === 0) {\n      return;\n    }\n    const rule = ruleMapper(ruleId);\n    if (!rule) {\n      lintingProblems.push(createLintingProblem({\n        ruleId\n      }));\n      return;\n    }\n    const messageIds = rule.meta && rule.meta.messages;\n    let reportTranslator = null;\n    const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {\n      id: ruleId,\n      options: getRuleOptions(configuredRules[ruleId]),\n      report(...args) {\n        /*\n         * Create a report translator lazily.\n         * In a vast majority of cases, any given rule reports zero errors on a given\n         * piece of code. Creating a translator lazily avoids the performance cost of\n         * creating a new translator function for each rule that usually doesn't get\n         * called.\n         *\n         * Using lazy report translators improves end-to-end performance by about 3%\n         * with Node 8.4.0.\n         */\n        if (reportTranslator === null) {\n          reportTranslator = createReportTranslator({\n            ruleId,\n            severity,\n            sourceCode,\n            messageIds,\n            disableFixes\n          });\n        }\n        const problem = reportTranslator(...args);\n        if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n          throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n        }\n        if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {\n          if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== \"undefined\") {\n            // Encourage migration from the former property name.\n            throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.\");\n          }\n          throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`.\");\n        }\n        lintingProblems.push(problem);\n      }\n    }));\n    const ruleListeners = timing.enabled ? timing.time(ruleId, createRuleListeners)(rule, ruleContext) : createRuleListeners(rule, ruleContext);\n\n    /**\n     * Include `ruleId` in error logs\n     * @param {Function} ruleListener A rule method that listens for a node.\n     * @returns {Function} ruleListener wrapped in error handler\n     */\n    function addRuleErrorHandler(ruleListener) {\n      return function ruleErrorHandler(...listenerArgs) {\n        try {\n          return ruleListener(...listenerArgs);\n        } catch (e) {\n          e.ruleId = ruleId;\n          throw e;\n        }\n      };\n    }\n    if (typeof ruleListeners === \"undefined\" || ruleListeners === null) {\n      throw new Error(`The create() function for rule '${ruleId}' did not return an object.`);\n    }\n\n    // add all the selectors from the rule as listeners\n    Object.keys(ruleListeners).forEach(selector => {\n      const ruleListener = timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector];\n      emitter.on(selector, addRuleErrorHandler(ruleListener));\n    });\n  });\n\n  // only run code path analyzer if the top level node is \"Program\", skip otherwise\n  const eventGenerator = nodeQueue[0].node.type === \"Program\" ? new CodePathAnalyzer(new NodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: Traverser.getKeys\n  })) : new NodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: Traverser.getKeys\n  });\n  nodeQueue.forEach(traversalInfo => {\n    currentNode = traversalInfo.node;\n    try {\n      if (traversalInfo.isEntering) {\n        eventGenerator.enterNode(currentNode);\n      } else {\n        eventGenerator.leaveNode(currentNode);\n      }\n    } catch (err) {\n      err.currentNode = currentNode;\n      throw err;\n    }\n  });\n  return lintingProblems;\n}\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\nfunction ensureText(textOrSourceCode) {\n  if (typeof textOrSourceCode === \"object\") {\n    const {\n      hasBOM,\n      text\n    } = textOrSourceCode;\n    const bom = hasBOM ? \"\\uFEFF\" : \"\";\n    return bom + text;\n  }\n  return String(textOrSourceCode);\n}\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\nfunction getEnv(slots, envId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;\n}\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\nfunction getRule(slots, ruleId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);\n}\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\nfunction normalizeCwd(cwd) {\n  if (cwd) {\n    return cwd;\n  }\n  if (typeof process === \"object\") {\n    return process.cwd();\n  }\n\n  // It's more explicit to assign the undefined\n  // eslint-disable-next-line no-undefined -- Consistently returning a value\n  return undefined;\n}\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Throws an error when the given linter is in flat config mode.\n * @param {Linter} linter The linter to check.\n * @returns {void}\n * @throws {Error} If the linter is in flat config mode.\n */\nfunction assertEslintrcConfig(linter) {\n  const {\n    configType\n  } = internalSlotsMap.get(linter);\n  if (configType === \"flat\") {\n    throw new Error(\"This method cannot be used with flat config. Add your entries directly into the config array.\");\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name Linter\n */\nclass Linter {\n  /**\n   * Initialize the Linter.\n   * @param {Object} [config] the config object\n   * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.\n   * @param {\"flat\"|\"eslintrc\"} [config.configType=\"eslintrc\"] the type of config used.\n   */\n  constructor({\n    cwd,\n    configType\n  } = {}) {\n    internalSlotsMap.set(this, {\n      cwd: normalizeCwd(cwd),\n      lastConfigArray: null,\n      lastSourceCode: null,\n      lastSuppressedMessages: [],\n      configType,\n      // TODO: Remove after flat config conversion\n      parserMap: new Map([[\"espree\", espree]]),\n      ruleMap: new Rules()\n    });\n    this.version = pkg.version;\n  }\n\n  /**\n   * Getter for package version.\n   * @static\n   * @returns {string} The version from package.json.\n   */\n  static get version() {\n    return pkg.version;\n  }\n\n  /**\n   * Same as linter.verify, except without support for processors.\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n   * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n   * @throws {Error} If during rule execution.\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n   */\n  _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n    const slots = internalSlotsMap.get(this);\n    const config = providedConfig || {};\n    const options = normalizeVerifyOptions(providedOptions, config);\n    let text;\n\n    // evaluate arguments\n    if (typeof textOrSourceCode === \"string\") {\n      slots.lastSourceCode = null;\n      text = textOrSourceCode;\n    } else {\n      slots.lastSourceCode = textOrSourceCode;\n      text = textOrSourceCode.text;\n    }\n\n    // Resolve parser.\n    let parserName = DEFAULT_PARSER_NAME;\n    let parser = espree;\n    if (typeof config.parser === \"object\" && config.parser !== null) {\n      parserName = config.parser.filePath;\n      parser = config.parser.definition;\n    } else if (typeof config.parser === \"string\") {\n      if (!slots.parserMap.has(config.parser)) {\n        return [{\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Configured parser '${config.parser}' was not found.`,\n          line: 0,\n          column: 0,\n          nodeType: null\n        }];\n      }\n      parserName = config.parser;\n      parser = slots.parserMap.get(config.parser);\n    }\n\n    // search and apply \"eslint-env *\".\n    const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};\n    const resolvedEnvConfig = Object.assign({\n      builtin: true\n    }, config.env, envInFile);\n    const enabledEnvs = Object.keys(resolvedEnvConfig).filter(envName => resolvedEnvConfig[envName]).map(envName => getEnv(slots, envName)).filter(env => env);\n    const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n    const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n    const settings = config.settings || {};\n    const languageOptions = createLanguageOptions({\n      globals: config.globals,\n      parser,\n      parserOptions\n    });\n    if (!slots.lastSourceCode) {\n      const parseResult = parse(text, languageOptions, options.filename);\n      if (!parseResult.success) {\n        return [parseResult.error];\n      }\n      slots.lastSourceCode = parseResult.sourceCode;\n    } else {\n      /*\n       * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n       * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n       */\n      if (!slots.lastSourceCode.scopeManager) {\n        slots.lastSourceCode = new SourceCode({\n          text: slots.lastSourceCode.text,\n          ast: slots.lastSourceCode.ast,\n          parserServices: slots.lastSourceCode.parserServices,\n          visitorKeys: slots.lastSourceCode.visitorKeys,\n          scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n        });\n      }\n    }\n    const sourceCode = slots.lastSourceCode;\n    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(sourceCode, ruleId => getRule(slots, ruleId), options.warnInlineConfig) : {\n      configuredRules: {},\n      enabledGlobals: {},\n      exportedVariables: {},\n      problems: [],\n      disableDirectives: []\n    };\n\n    // augment global scope with declared global variables\n    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {\n      exportedVariables: commentDirectives.exportedVariables,\n      enabledGlobals: commentDirectives.enabledGlobals\n    });\n    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n    let lintingProblems;\n    try {\n      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRule(slots, ruleId), parserName, languageOptions, settings, options.filename, options.disableFixes, slots.cwd, providedOptions.physicalFilename);\n    } catch (err) {\n      err.message += `\\nOccurred while linting ${options.filename}`;\n      debug(\"An error occurred while traversing\");\n      debug(\"Filename:\", options.filename);\n      if (err.currentNode) {\n        const {\n          line\n        } = err.currentNode.loc.start;\n        debug(\"Line:\", line);\n        err.message += `:${line}`;\n      }\n      debug(\"Parser Options:\", parserOptions);\n      debug(\"Parser Path:\", parserName);\n      debug(\"Settings:\", settings);\n      if (err.ruleId) {\n        err.message += `\\nRule: \"${err.ruleId}\"`;\n      }\n      throw err;\n    }\n    return applyDisableDirectives({\n      directives: commentDirectives.disableDirectives,\n      disableFixes: options.disableFixes,\n      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n    });\n  }\n\n  /**\n   * Verifies the text against the rules specified by the second argument.\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n   * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n   * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n   *      If this is not set, the filename will default to '<input>' in the rule context. If\n   *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n   * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n   */\n  verify(textOrSourceCode, config, filenameOrOptions) {\n    debug(\"Verify\");\n    const {\n      configType,\n      cwd\n    } = internalSlotsMap.get(this);\n    const options = typeof filenameOrOptions === \"string\" ? {\n      filename: filenameOrOptions\n    } : filenameOrOptions || {};\n    if (config) {\n      if (configType === \"flat\") {\n        /*\n         * Because of how Webpack packages up the files, we can't\n         * compare directly to `FlatConfigArray` using `instanceof`\n         * because it's not the same `FlatConfigArray` as in the tests.\n         * So, we work around it by assuming an array is, in fact, a\n         * `FlatConfigArray` if it has a `getConfig()` method.\n         */\n        let configArray = config;\n        if (!Array.isArray(config) || typeof config.getConfig !== \"function\") {\n          configArray = new FlatConfigArray(config, {\n            basePath: cwd\n          });\n          configArray.normalizeSync();\n        }\n        return this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(textOrSourceCode, configArray, options, true));\n      }\n      if (typeof config.extractConfig === \"function\") {\n        return this._distinguishSuppressedMessages(this._verifyWithConfigArray(textOrSourceCode, config, options));\n      }\n    }\n\n    /*\n     * If we get to here, it means `config` is just an object rather\n     * than a config array so we can go right into linting.\n     */\n\n    /*\n     * `Linter` doesn't support `overrides` property in configuration.\n     * So we cannot apply multiple processors.\n     */\n    if (options.preprocess || options.postprocess) {\n      return this._distinguishSuppressedMessages(this._verifyWithProcessor(textOrSourceCode, config, options));\n    }\n    return this._distinguishSuppressedMessages(this._verifyWithoutProcessors(textOrSourceCode, config, options));\n  }\n\n  /**\n   * Verify with a processor.\n   * @param {string|SourceCode} textOrSourceCode The source code.\n   * @param {FlatConfig} config The config array.\n   * @param {VerifyOptions&ProcessorOptions} options The options.\n   * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n   */\n  _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options, configForRecursive) {\n    const filename = options.filename || \"<input>\";\n    const filenameToExpose = normalizeFilename(filename);\n    const physicalFilename = options.physicalFilename || filenameToExpose;\n    const text = ensureText(textOrSourceCode);\n    const preprocess = options.preprocess || (rawText => [rawText]);\n    const postprocess = options.postprocess || (messagesList => messagesList.flat());\n    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(\".js\"));\n    const originalExtname = path.extname(filename);\n    let blocks;\n    try {\n      blocks = preprocess(text, filenameToExpose);\n    } catch (ex) {\n      // If the message includes a leading line number, strip it:\n      const message = `Preprocessing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n      debug(\"%s\\n%s\", message, ex.stack);\n      return [{\n        ruleId: null,\n        fatal: true,\n        severity: 2,\n        message,\n        line: ex.lineNumber,\n        column: ex.column,\n        nodeType: null\n      }];\n    }\n    const messageLists = blocks.map((block, i) => {\n      debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n      // Keep the legacy behavior.\n      if (typeof block === \"string\") {\n        return this._verifyWithFlatConfigArrayAndWithoutProcessors(block, config, options);\n      }\n      const blockText = block.text;\n      const blockName = path.join(filename, `${i}_${block.filename}`);\n\n      // Skip this block if filtered.\n      if (!filterCodeBlock(blockName, blockText)) {\n        debug(\"This code block was skipped.\");\n        return [];\n      }\n\n      // Resolve configuration again if the file content or extension was changed.\n      if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n        debug(\"Resolving configuration again because the file content or extension was changed.\");\n        return this._verifyWithFlatConfigArray(blockText, configForRecursive, {\n          ...options,\n          filename: blockName,\n          physicalFilename\n        });\n      }\n\n      // Does lint.\n      return this._verifyWithFlatConfigArrayAndWithoutProcessors(blockText, config, {\n        ...options,\n        filename: blockName,\n        physicalFilename\n      });\n    });\n    return postprocess(messageLists, filenameToExpose);\n  }\n\n  /**\n   * Same as linter.verify, except without support for processors.\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n   * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\n   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n   * @throws {Error} If during rule execution.\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n   */\n  _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n    const slots = internalSlotsMap.get(this);\n    const config = providedConfig || {};\n    const options = normalizeVerifyOptions(providedOptions, config);\n    let text;\n\n    // evaluate arguments\n    if (typeof textOrSourceCode === \"string\") {\n      slots.lastSourceCode = null;\n      text = textOrSourceCode;\n    } else {\n      slots.lastSourceCode = textOrSourceCode;\n      text = textOrSourceCode.text;\n    }\n    const languageOptions = config.languageOptions;\n    languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(languageOptions.ecmaVersion);\n\n    // double check that there is a parser to avoid mysterious error messages\n    if (!languageOptions.parser) {\n      throw new TypeError(`No parser specified for ${options.filename}`);\n    }\n\n    // Espree expects this information to be passed in\n    if (isEspree(languageOptions.parser)) {\n      const parserOptions = languageOptions.parserOptions;\n      if (languageOptions.sourceType) {\n        parserOptions.sourceType = languageOptions.sourceType;\n        if (parserOptions.sourceType === \"module\" && parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) {\n          parserOptions.ecmaFeatures.globalReturn = false;\n        }\n      }\n    }\n    const settings = config.settings || {};\n    if (!slots.lastSourceCode) {\n      const parseResult = parse(text, languageOptions, options.filename);\n      if (!parseResult.success) {\n        return [parseResult.error];\n      }\n      slots.lastSourceCode = parseResult.sourceCode;\n    } else {\n      /*\n       * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n       * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n       */\n      if (!slots.lastSourceCode.scopeManager) {\n        slots.lastSourceCode = new SourceCode({\n          text: slots.lastSourceCode.text,\n          ast: slots.lastSourceCode.ast,\n          parserServices: slots.lastSourceCode.parserServices,\n          visitorKeys: slots.lastSourceCode.visitorKeys,\n          scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n        });\n      }\n    }\n    const sourceCode = slots.lastSourceCode;\n\n    /*\n     * Make adjustments based on the language options. For JavaScript,\n     * this is primarily about adding variables into the global scope\n     * to account for ecmaVersion and configured globals.\n     */\n    sourceCode.applyLanguageOptions(languageOptions);\n    const mergedInlineConfig = {\n      rules: {}\n    };\n    const inlineConfigProblems = [];\n\n    /*\n     * Inline config can be either enabled or disabled. If disabled, it's possible\n     * to detect the inline config and emit a warning (though this is not required).\n     * So we first check to see if inline config is allowed at all, and if so, we\n     * need to check if it's a warning or not.\n     */\n    if (options.allowInlineConfig) {\n      // if inline config should warn then add the warnings\n      if (options.warnInlineConfig) {\n        sourceCode.getInlineConfigNodes().forEach(node => {\n          inlineConfigProblems.push(createLintingProblem({\n            ruleId: null,\n            message: `'${sourceCode.text.slice(node.range[0], node.range[1])}' has no effect because you have 'noInlineConfig' setting in ${options.warnInlineConfig}.`,\n            loc: node.loc,\n            severity: 1\n          }));\n        });\n      } else {\n        const inlineConfigResult = sourceCode.applyInlineConfig();\n        inlineConfigProblems.push(...inlineConfigResult.problems.map(createLintingProblem).map(problem => {\n          problem.fatal = true;\n          return problem;\n        }));\n\n        // next we need to verify information about the specified rules\n        const ruleValidator = new RuleValidator();\n        for (const {\n          config: inlineConfig,\n          node\n        } of inlineConfigResult.configs) {\n          Object.keys(inlineConfig.rules).forEach(ruleId => {\n            const rule = getRuleFromConfig(ruleId, config);\n            const ruleValue = inlineConfig.rules[ruleId];\n            if (!rule) {\n              inlineConfigProblems.push(createLintingProblem({\n                ruleId,\n                loc: node.loc\n              }));\n              return;\n            }\n            try {\n              const ruleOptions = Array.isArray(ruleValue) ? ruleValue : [ruleValue];\n              assertIsRuleOptions(ruleId, ruleValue);\n              assertIsRuleSeverity(ruleId, ruleOptions[0]);\n              ruleValidator.validate({\n                plugins: config.plugins,\n                rules: {\n                  [ruleId]: ruleOptions\n                }\n              });\n              mergedInlineConfig.rules[ruleId] = ruleValue;\n            } catch (err) {\n              let baseMessage = err.message.slice(err.message.startsWith(\"Key \\\"rules\\\":\") ? err.message.indexOf(\":\", 12) + 1 : err.message.indexOf(\":\") + 1).trim();\n              if (err.messageTemplate) {\n                baseMessage += ` You passed \"${ruleValue}\".`;\n              }\n              inlineConfigProblems.push(createLintingProblem({\n                ruleId,\n                message: `Inline configuration for rule \"${ruleId}\" is invalid:\\n\\t${baseMessage}\\n`,\n                loc: node.loc\n              }));\n            }\n          });\n        }\n      }\n    }\n    const commentDirectives = options.allowInlineConfig && !options.warnInlineConfig ? getDirectiveCommentsForFlatConfig(sourceCode, ruleId => getRuleFromConfig(ruleId, config)) : {\n      problems: [],\n      disableDirectives: []\n    };\n    const configuredRules = Object.assign({}, config.rules, mergedInlineConfig.rules);\n    let lintingProblems;\n    sourceCode.finalize();\n    try {\n      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRuleFromConfig(ruleId, config), void 0, languageOptions, settings, options.filename, options.disableFixes, slots.cwd, providedOptions.physicalFilename);\n    } catch (err) {\n      err.message += `\\nOccurred while linting ${options.filename}`;\n      debug(\"An error occurred while traversing\");\n      debug(\"Filename:\", options.filename);\n      if (err.currentNode) {\n        const {\n          line\n        } = err.currentNode.loc.start;\n        debug(\"Line:\", line);\n        err.message += `:${line}`;\n      }\n      debug(\"Parser Options:\", languageOptions.parserOptions);\n\n      // debug(\"Parser Path:\", parserName);\n      debug(\"Settings:\", settings);\n      if (err.ruleId) {\n        err.message += `\\nRule: \"${err.ruleId}\"`;\n      }\n      throw err;\n    }\n    return applyDisableDirectives({\n      directives: commentDirectives.disableDirectives,\n      disableFixes: options.disableFixes,\n      problems: lintingProblems.concat(commentDirectives.problems).concat(inlineConfigProblems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n    });\n  }\n\n  /**\n   * Verify a given code with `ConfigArray`.\n   * @param {string|SourceCode} textOrSourceCode The source code.\n   * @param {ConfigArray} configArray The config array.\n   * @param {VerifyOptions&ProcessorOptions} options The options.\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n   */\n  _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n    debug(\"With ConfigArray: %s\", options.filename);\n\n    // Store the config array in order to get plugin envs and rules later.\n    internalSlotsMap.get(this).lastConfigArray = configArray;\n\n    // Extract the final config for this file.\n    const config = configArray.extractConfig(options.filename);\n    const processor = config.processor && configArray.pluginProcessors.get(config.processor);\n\n    // Verify.\n    if (processor) {\n      debug(\"Apply the processor: %o\", config.processor);\n      const {\n        preprocess,\n        postprocess,\n        supportsAutofix\n      } = processor;\n      const disableFixes = options.disableFixes || !supportsAutofix;\n      return this._verifyWithProcessor(textOrSourceCode, config, {\n        ...options,\n        disableFixes,\n        postprocess,\n        preprocess\n      }, configArray);\n    }\n    return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n  }\n\n  /**\n   * Verify a given code with a flat config.\n   * @param {string|SourceCode} textOrSourceCode The source code.\n   * @param {FlatConfigArray} configArray The config array.\n   * @param {VerifyOptions&ProcessorOptions} options The options.\n   * @param {boolean} [firstCall=false] Indicates if this is being called directly\n   *      from verify(). (TODO: Remove once eslintrc is removed.)\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n   */\n  _verifyWithFlatConfigArray(textOrSourceCode, configArray, options, firstCall = false) {\n    debug(\"With flat config: %s\", options.filename);\n\n    // we need a filename to match configs against\n    const filename = options.filename || \"__placeholder__.js\";\n\n    // Store the config array in order to get plugin envs and rules later.\n    internalSlotsMap.get(this).lastConfigArray = configArray;\n    const config = configArray.getConfig(filename);\n    if (!config) {\n      return [{\n        ruleId: null,\n        severity: 1,\n        message: `No matching configuration found for ${filename}.`,\n        line: 0,\n        column: 0,\n        nodeType: null\n      }];\n    }\n\n    // Verify.\n    if (config.processor) {\n      debug(\"Apply the processor: %o\", config.processor);\n      const {\n        preprocess,\n        postprocess,\n        supportsAutofix\n      } = config.processor;\n      const disableFixes = options.disableFixes || !supportsAutofix;\n      return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, {\n        ...options,\n        filename,\n        disableFixes,\n        postprocess,\n        preprocess\n      }, configArray);\n    }\n\n    // check for options-based processing\n    if (firstCall && (options.preprocess || options.postprocess)) {\n      return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options);\n    }\n    return this._verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, config, options);\n  }\n\n  /**\n   * Verify with a processor.\n   * @param {string|SourceCode} textOrSourceCode The source code.\n   * @param {ConfigData|ExtractedConfig} config The config array.\n   * @param {VerifyOptions&ProcessorOptions} options The options.\n   * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n   */\n  _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n    const filename = options.filename || \"<input>\";\n    const filenameToExpose = normalizeFilename(filename);\n    const physicalFilename = options.physicalFilename || filenameToExpose;\n    const text = ensureText(textOrSourceCode);\n    const preprocess = options.preprocess || (rawText => [rawText]);\n    const postprocess = options.postprocess || (messagesList => messagesList.flat());\n    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(\".js\"));\n    const originalExtname = path.extname(filename);\n    let blocks;\n    try {\n      blocks = preprocess(text, filenameToExpose);\n    } catch (ex) {\n      // If the message includes a leading line number, strip it:\n      const message = `Preprocessing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n      debug(\"%s\\n%s\", message, ex.stack);\n      return [{\n        ruleId: null,\n        fatal: true,\n        severity: 2,\n        message,\n        line: ex.lineNumber,\n        column: ex.column,\n        nodeType: null\n      }];\n    }\n    const messageLists = blocks.map((block, i) => {\n      debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n      // Keep the legacy behavior.\n      if (typeof block === \"string\") {\n        return this._verifyWithoutProcessors(block, config, options);\n      }\n      const blockText = block.text;\n      const blockName = path.join(filename, `${i}_${block.filename}`);\n\n      // Skip this block if filtered.\n      if (!filterCodeBlock(blockName, blockText)) {\n        debug(\"This code block was skipped.\");\n        return [];\n      }\n\n      // Resolve configuration again if the file content or extension was changed.\n      if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n        debug(\"Resolving configuration again because the file content or extension was changed.\");\n        return this._verifyWithConfigArray(blockText, configForRecursive, {\n          ...options,\n          filename: blockName,\n          physicalFilename\n        });\n      }\n\n      // Does lint.\n      return this._verifyWithoutProcessors(blockText, config, {\n        ...options,\n        filename: blockName,\n        physicalFilename\n      });\n    });\n    return postprocess(messageLists, filenameToExpose);\n  }\n\n  /**\n   * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.\n   * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.\n   * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.\n   * @returns {LintMessage[]} A list of LintMessage.\n   */\n  _distinguishSuppressedMessages(problems) {\n    const messages = [];\n    const suppressedMessages = [];\n    const slots = internalSlotsMap.get(this);\n    for (const problem of problems) {\n      if (problem.suppressions) {\n        suppressedMessages.push(problem);\n      } else {\n        messages.push(problem);\n      }\n    }\n    slots.lastSuppressedMessages = suppressedMessages;\n    return messages;\n  }\n\n  /**\n   * Gets the SourceCode object representing the parsed source.\n   * @returns {SourceCode} The SourceCode object.\n   */\n  getSourceCode() {\n    return internalSlotsMap.get(this).lastSourceCode;\n  }\n\n  /**\n   * Gets the list of SuppressedLintMessage produced in the last running.\n   * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage\n   */\n  getSuppressedMessages() {\n    return internalSlotsMap.get(this).lastSuppressedMessages;\n  }\n\n  /**\n   * Defines a new linting rule.\n   * @param {string} ruleId A unique rule identifier\n   * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n   * @returns {void}\n   */\n  defineRule(ruleId, ruleModule) {\n    assertEslintrcConfig(this);\n    internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n  }\n\n  /**\n   * Defines many new linting rules.\n   * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n   * @returns {void}\n   */\n  defineRules(rulesToDefine) {\n    assertEslintrcConfig(this);\n    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n      this.defineRule(ruleId, rulesToDefine[ruleId]);\n    });\n  }\n\n  /**\n   * Gets an object with all loaded rules.\n   * @returns {Map<string, Rule>} All loaded rules\n   */\n  getRules() {\n    assertEslintrcConfig(this);\n    const {\n      lastConfigArray,\n      ruleMap\n    } = internalSlotsMap.get(this);\n    return new Map(function* () {\n      yield* ruleMap;\n      if (lastConfigArray) {\n        yield* lastConfigArray.pluginRules;\n      }\n    }());\n  }\n\n  /**\n   * Define a new parser module\n   * @param {string} parserId Name of the parser\n   * @param {Parser} parserModule The parser object\n   * @returns {void}\n   */\n  defineParser(parserId, parserModule) {\n    assertEslintrcConfig(this);\n    internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n  }\n\n  /**\n   * Performs multiple autofix passes over the text until as many fixes as possible\n   * have been applied.\n   * @param {string} text The source text to apply fixes to.\n   * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.\n   * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n   * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n   *      SourceCodeFixer.\n   */\n  verifyAndFix(text, config, options) {\n    let messages = [],\n      fixedResult,\n      fixed = false,\n      passNumber = 0,\n      currentText = text;\n    const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n    const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n\n    /**\n     * This loop continues until one of the following is true:\n     *\n     * 1. No more fixes have been applied.\n     * 2. Ten passes have been made.\n     *\n     * That means anytime a fix is successfully applied, there will be another pass.\n     * Essentially, guaranteeing a minimum of two passes.\n     */\n    do {\n      passNumber++;\n      debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n      messages = this.verify(currentText, config, options);\n      debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n      fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n      /*\n       * stop if there are any syntax errors.\n       * 'fixedResult.output' is a empty string.\n       */\n      if (messages.length === 1 && messages[0].fatal) {\n        break;\n      }\n\n      // keep track if any fixes were ever applied - important for return value\n      fixed = fixed || fixedResult.fixed;\n\n      // update to use the fixed output instead of the original text\n      currentText = fixedResult.output;\n    } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);\n\n    /*\n     * If the last result had fixes, we need to lint again to be sure we have\n     * the most up-to-date information.\n     */\n    if (fixedResult.fixed) {\n      fixedResult.messages = this.verify(currentText, config, options);\n    }\n\n    // ensure the last result properly reflects if fixes were done\n    fixedResult.fixed = fixed;\n    fixedResult.output = currentText;\n    return fixedResult;\n  }\n}\nmodule.exports = {\n  Linter,\n  /**\n   * Get the internal slots of a given Linter instance for tests.\n   * @param {Linter} instance The Linter instance to get.\n   * @returns {LinterInternalSlots} The internal slots.\n   */\n  getLinterInternalSlots(instance) {\n    return internalSlotsMap.get(instance);\n  }\n};","map":{"version":3,"names":["path","require","eslintScope","evk","espree","merge","pkg","astUtils","directivesPattern","Legacy","ConfigOps","ConfigValidator","environments","BuiltInEnvironments","Traverser","SourceCode","CodePathAnalyzer","applyDisableDirectives","ConfigCommentParser","NodeEventGenerator","createReportTranslator","Rules","createEmitter","SourceCodeFixer","timing","ruleReplacements","getRuleFromConfig","FlatConfigArray","RuleValidator","assertIsRuleOptions","assertIsRuleSeverity","normalizeSeverityToString","debug","MAX_AUTOFIX_PASSES","DEFAULT_PARSER_NAME","DEFAULT_ECMA_VERSION","commentParser","DEFAULT_ERROR_LOC","start","line","column","end","parserSymbol","Symbol","for","isEspree","parser","addDeclaredGlobals","globalScope","configGlobals","exportedVariables","enabledGlobals","id","Set","Object","keys","configValue","normalizeConfigGlobal","commentValue","value","sourceComments","comments","variable","set","get","Variable","variables","push","eslintImplicitGlobalSetting","eslintExplicitGlobal","eslintExplicitGlobalComments","writeable","forEach","name","eslintUsed","eslintExported","through","filter","reference","identifier","resolved","references","createMissingRuleMessage","ruleId","prototype","hasOwnProperty","call","rules","join","createLintingProblem","options","loc","message","severity","endLine","endColumn","nodeType","createDisableDirectives","commentToken","type","justification","ruleMapper","ruleIds","parseListConfig","directiveRules","length","result","directives","directiveProblems","parentComment","getDirectiveComments","sourceCode","warnInlineConfig","configuredRules","create","problems","disableDirectives","validator","builtInRules","getInlineConfigNodes","token","comment","directivePart","justificationPart","extractDirectiveComment","match","exec","directiveText","lineCommentSupported","test","kind","directiveValue","slice","index","directiveType","assign","parseStringConfig","entries","normalizedValue","err","parseResult","parseJsonConfig","success","config","rule","ruleValue","validateRuleOptions","error","getDirectiveCommentsForFlatConfig","normalizeEcmaVersion","ecmaVersion","latestEcmaVersion","normalizeEcmaVersionForLanguageOptions","eslintEnvPattern","findEslintEnv","text","retv","lastIndex","endsWith","normalizeFilename","filename","parts","split","sep","lastIndexOf","normalizeVerifyOptions","providedOptions","linterOptions","disableInlineConfig","noInlineConfig","ignoreInlineConfig","allowInlineConfig","configNameOfNoInlineConfig","reportUnusedDisableDirectives","disableFixes","Boolean","resolveParserOptions","enabledEnvironments","parserOptionsFromEnv","env","parserOptions","reduce","mergedParserOptions","isModule","sourceType","ecmaFeatures","globalReturn","createLanguageOptions","globals","configuredGlobals","resolveGlobals","providedGlobals","map","stripUnicodeBOM","charCodeAt","getRuleOptions","ruleConfig","Array","isArray","analyzeScope","ast","languageOptions","visitorKeys","analyze","ignoreEval","nodejsScope","impliedStrict","childVisitorKeys","KEYS","fallback","getKeys","parse","filePath","textToParse","replace","shebangPattern","captured","range","raw","tokens","eslintVisitorKeys","eslintScopeManager","parseForESLint","parserServices","services","scopeManager","ex","trim","stack","fatal","lineNumber","createRuleListeners","ruleContext","DEPRECATED_SOURCECODE_PASSTHROUGHS","getSource","getSourceLines","getAllComments","getNodeByRangeIndex","getComments","getCommentsBefore","getCommentsAfter","getCommentsInside","getJSDocComment","getFirstToken","getFirstTokens","getLastToken","getLastTokens","getTokenAfter","getTokenBefore","getTokenByRangeStart","getTokens","getTokensAfter","getTokensBefore","getTokensBetween","BASE_TRAVERSAL_CONTEXT","freeze","contextInfo","methodName","args","runRules","parserName","settings","cwd","physicalFilename","emitter","nodeQueue","currentNode","traverse","enter","node","parent","isEntering","leave","sharedTraversalContext","getAncestors","getDeclaredVariables","getCwd","getFilename","getPhysicalFilename","getScope","getSourceCode","markVariableAsUsed","parserPath","lintingProblems","getRuleSeverity","messageIds","meta","messages","reportTranslator","report","problem","fix","fixable","Error","suggestions","hasSuggestions","docs","suggestion","ruleListeners","enabled","time","addRuleErrorHandler","ruleListener","ruleErrorHandler","listenerArgs","e","selector","on","eventGenerator","traversalInfo","enterNode","leaveNode","ensureText","textOrSourceCode","hasBOM","bom","String","getEnv","slots","envId","lastConfigArray","pluginEnvironments","getRule","pluginRules","ruleMap","normalizeCwd","process","undefined","internalSlotsMap","WeakMap","assertEslintrcConfig","linter","configType","Linter","constructor","lastSourceCode","lastSuppressedMessages","parserMap","Map","version","_verifyWithoutProcessors","providedConfig","definition","has","envInFile","resolvedEnvConfig","builtin","enabledEnvs","envName","commentDirectives","scopes","concat","sort","problemA","problemB","verify","filenameOrOptions","configArray","getConfig","basePath","normalizeSync","_distinguishSuppressedMessages","_verifyWithFlatConfigArray","extractConfig","_verifyWithConfigArray","preprocess","postprocess","_verifyWithProcessor","_verifyWithFlatConfigArrayAndProcessor","configForRecursive","filenameToExpose","rawText","messagesList","flat","filterCodeBlock","blockFilename","originalExtname","extname","blocks","messageLists","block","i","_verifyWithFlatConfigArrayAndWithoutProcessors","blockText","blockName","TypeError","applyLanguageOptions","mergedInlineConfig","inlineConfigProblems","inlineConfigResult","applyInlineConfig","ruleValidator","inlineConfig","configs","ruleOptions","validate","plugins","baseMessage","startsWith","indexOf","messageTemplate","finalize","processor","pluginProcessors","supportsAutofix","firstCall","suppressedMessages","suppressions","getSuppressedMessages","defineRule","ruleModule","define","defineRules","rulesToDefine","getOwnPropertyNames","getRules","defineParser","parserId","parserModule","verifyAndFix","fixedResult","fixed","passNumber","currentText","debugTextDescription","shouldFix","applyFixes","output","module","exports","getLinterInternalSlots","instance"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/linter.js"],"sourcesContent":["/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    path = require(\"path\"),\n    eslintScope = require(\"eslint-scope\"),\n    evk = require(\"eslint-visitor-keys\"),\n    espree = require(\"espree\"),\n    merge = require(\"lodash.merge\"),\n    pkg = require(\"../../package.json\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    {\n        directivesPattern\n    } = require(\"../shared/directives\"),\n    {\n        Legacy: {\n            ConfigOps,\n            ConfigValidator,\n            environments: BuiltInEnvironments\n        }\n    } = require(\"@eslint/eslintrc/universal\"),\n    Traverser = require(\"../shared/traverser\"),\n    { SourceCode } = require(\"../source-code\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    applyDisableDirectives = require(\"./apply-disable-directives\"),\n    ConfigCommentParser = require(\"./config-comment-parser\"),\n    NodeEventGenerator = require(\"./node-event-generator\"),\n    createReportTranslator = require(\"./report-translator\"),\n    Rules = require(\"./rules\"),\n    createEmitter = require(\"./safe-emitter\"),\n    SourceCodeFixer = require(\"./source-code-fixer\"),\n    timing = require(\"./timing\"),\n    ruleReplacements = require(\"../../conf/replacements.json\");\nconst { getRuleFromConfig } = require(\"../config/flat-config-helpers\");\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\nconst { RuleValidator } = require(\"../config/rule-validator\");\nconst { assertIsRuleOptions, assertIsRuleSeverity } = require(\"../config/flat-config-schema\");\nconst { normalizeSeverityToString } = require(\"../shared/severity\");\nconst debug = require(\"debug\")(\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ConfigArray>} ConfigArray */\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ExtractedConfig>} ExtractedConfig */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type Type of directive\n * @property {number} line The line number\n * @property {number} column The column number\n * @property {(string|null)} ruleId The rule ID\n * @property {string} justification The justification of directive\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {SuppressedLintMessage[]} lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor.postprocess} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor.preprocess} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if a given object is Espree.\n * @param {Object} parser The parser to check.\n * @returns {boolean} True if the parser is Espree or false if not.\n */\nfunction isEspree(parser) {\n    return !!(parser === espree || parser[parserSymbol] === espree);\n}\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {\n\n    // Define configured global variables.\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n\n        /*\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n        const value = commentValue || configValue;\n        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n        if (value === \"off\") {\n            continue;\n        }\n\n        let variable = globalScope.set.get(id);\n\n        if (!variable) {\n            variable = new eslintScope.Variable(id, globalScope);\n\n            globalScope.variables.push(variable);\n            globalScope.set.set(id, variable);\n        }\n\n        variable.eslintImplicitGlobalSetting = configValue;\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\n        variable.eslintExplicitGlobalComments = sourceComments;\n        variable.writeable = (value === \"writable\");\n    }\n\n    // mark all exported variables as such\n    Object.keys(exportedVariables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            variable.eslintExported = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\nfunction createMissingRuleMessage(ruleId) {\n    return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId)\n        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}`\n        : `Definition for rule '${ruleId}' was not found.`;\n}\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\nfunction createLintingProblem(options) {\n    const {\n        ruleId = null,\n        loc = DEFAULT_ERROR_LOC,\n        message = createMissingRuleMessage(options.ruleId),\n        severity = 2\n    } = options;\n\n    return {\n        ruleId,\n        message,\n        line: loc.start.line,\n        column: loc.start.column + 1,\n        endLine: loc.end.line,\n        endColumn: loc.end.column + 1,\n        severity,\n        nodeType: null\n    };\n}\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {token} options.commentToken The Comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {string} options.justification The justification of the directive\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\nfunction createDisableDirectives(options) {\n    const { commentToken, type, value, justification, ruleMapper } = options;\n    const ruleIds = Object.keys(commentParser.parseListConfig(value));\n    const directiveRules = ruleIds.length ? ruleIds : [null];\n    const result = {\n        directives: [], // valid disable directives\n        directiveProblems: [] // problems in directives\n    };\n\n    const parentComment = { commentToken, ruleIds };\n\n    for (const ruleId of directiveRules) {\n\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n        if (ruleId === null || !!ruleMapper(ruleId)) {\n            if (type === \"disable-next-line\") {\n                result.directives.push({\n                    parentComment,\n                    type,\n                    line: commentToken.loc.end.line,\n                    column: commentToken.loc.end.column + 1,\n                    ruleId,\n                    justification\n                });\n            } else {\n                result.directives.push({\n                    parentComment,\n                    type,\n                    line: commentToken.loc.start.line,\n                    column: commentToken.loc.start.column + 1,\n                    ruleId,\n                    justification\n                });\n            }\n        } else {\n            result.directiveProblems.push(createLintingProblem({ ruleId, loc: commentToken.loc }));\n        }\n    }\n    return result;\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveComments(sourceCode, ruleMapper, warnInlineConfig) {\n    const configuredRules = {};\n    const enabledGlobals = Object.create(null);\n    const exportedVariables = {};\n    const problems = [];\n    const disableDirectives = [];\n    const validator = new ConfigValidator({\n        builtInRules: Rules\n    });\n\n    sourceCode.getInlineConfigNodes().filter(token => token.type !== \"Shebang\").forEach(comment => {\n        const { directivePart, justificationPart } = commentParser.extractDirectiveComment(comment.value);\n\n        const match = directivesPattern.exec(directivePart);\n\n        if (!match) {\n            return;\n        }\n        const directiveText = match[1];\n        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n        if (comment.type === \"Line\" && !lineCommentSupported) {\n            return;\n        }\n\n        if (warnInlineConfig) {\n            const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n                loc: comment.loc,\n                severity: 1\n            }));\n            return;\n        }\n\n        if (directiveText === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\n            const message = `${directiveText} comment should not span multiple lines.`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message,\n                loc: comment.loc\n            }));\n            return;\n        }\n\n        const directiveValue = directivePart.slice(match.index + directiveText.length);\n\n        switch (directiveText) {\n            case \"eslint-disable\":\n            case \"eslint-enable\":\n            case \"eslint-disable-next-line\":\n            case \"eslint-disable-line\": {\n                const directiveType = directiveText.slice(\"eslint-\".length);\n                const options = { commentToken: comment, type: directiveType, value: directiveValue, justification: justificationPart, ruleMapper };\n                const { directives, directiveProblems } = createDisableDirectives(options);\n\n                disableDirectives.push(...directives);\n                problems.push(...directiveProblems);\n                break;\n            }\n\n            case \"exported\":\n                Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n                break;\n\n            case \"globals\":\n            case \"global\":\n                for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n                    let normalizedValue;\n\n                    try {\n                        normalizedValue = ConfigOps.normalizeConfigGlobal(value);\n                    } catch (err) {\n                        problems.push(createLintingProblem({\n                            ruleId: null,\n                            loc: comment.loc,\n                            message: err.message\n                        }));\n                        continue;\n                    }\n\n                    if (enabledGlobals[id]) {\n                        enabledGlobals[id].comments.push(comment);\n                        enabledGlobals[id].value = normalizedValue;\n                    } else {\n                        enabledGlobals[id] = {\n                            comments: [comment],\n                            value: normalizedValue\n                        };\n                    }\n                }\n                break;\n\n            case \"eslint\": {\n                const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n                if (parseResult.success) {\n                    Object.keys(parseResult.config).forEach(name => {\n                        const rule = ruleMapper(name);\n                        const ruleValue = parseResult.config[name];\n\n                        if (!rule) {\n                            problems.push(createLintingProblem({ ruleId: name, loc: comment.loc }));\n                            return;\n                        }\n\n                        try {\n                            validator.validateRuleOptions(rule, name, ruleValue);\n                        } catch (err) {\n                            problems.push(createLintingProblem({\n                                ruleId: name,\n                                message: err.message,\n                                loc: comment.loc\n                            }));\n\n                            // do not apply the config, if found invalid options.\n                            return;\n                        }\n\n                        configuredRules[name] = ruleValue;\n                    });\n                } else {\n                    problems.push(parseResult.error);\n                }\n\n                break;\n            }\n\n            // no default\n        }\n    });\n\n    return {\n        configuredRules,\n        enabledGlobals,\n        exportedVariables,\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Parses comments in file to extract disable directives.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @returns {{problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveCommentsForFlatConfig(sourceCode, ruleMapper) {\n    const problems = [];\n    const disableDirectives = [];\n\n    sourceCode.getInlineConfigNodes().filter(token => token.type !== \"Shebang\").forEach(comment => {\n        const { directivePart, justificationPart } = commentParser.extractDirectiveComment(comment.value);\n\n        const match = directivesPattern.exec(directivePart);\n\n        if (!match) {\n            return;\n        }\n        const directiveText = match[1];\n        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n        if (comment.type === \"Line\" && !lineCommentSupported) {\n            return;\n        }\n\n        if (directiveText === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\n            const message = `${directiveText} comment should not span multiple lines.`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message,\n                loc: comment.loc\n            }));\n            return;\n        }\n\n        const directiveValue = directivePart.slice(match.index + directiveText.length);\n\n        switch (directiveText) {\n            case \"eslint-disable\":\n            case \"eslint-enable\":\n            case \"eslint-disable-next-line\":\n            case \"eslint-disable-line\": {\n                const directiveType = directiveText.slice(\"eslint-\".length);\n                const options = { commentToken: comment, type: directiveType, value: directiveValue, justification: justificationPart, ruleMapper };\n                const { directives, directiveProblems } = createDisableDirectives(options);\n\n                disableDirectives.push(...directives);\n                problems.push(...directiveProblems);\n                break;\n            }\n\n            // no default\n        }\n    });\n\n    return {\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param {Parser} parser The parser which uses this options.\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n\n    if (isEspree(parser)) {\n        if (ecmaVersion === \"latest\") {\n            return espree.latestEcmaVersion;\n        }\n    }\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\n/**\n * Normalize ECMAScript version from the initial config into languageOptions (year)\n * format.\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersionForLanguageOptions(ecmaVersion) {\n\n    switch (ecmaVersion) {\n        case 3:\n            return 3;\n\n        // void 0 = no ecmaVersion specified so use the default\n        case 5:\n        case void 0:\n            return 5;\n\n        default:\n            if (typeof ecmaVersion === \"number\") {\n                return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;\n            }\n    }\n\n    /*\n     * We default to the latest supported ecmaVersion for everything else.\n     * Remember, this is for languageOptions.ecmaVersion, which sets the version\n     * that is used for a number of processes inside of ESLint. It's normally\n     * safe to assume people want the latest unless otherwise specified.\n     */\n    return espree.latestEcmaVersion + 2009;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)(?:\\*\\/|$)/gsu;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text)) !== null) {\n        if (match[0].endsWith(\"*/\")) {\n            retv = Object.assign(\n                retv || {},\n                commentParser.parseListConfig(commentParser.extractDirectiveComment(match[1]).directivePart)\n            );\n        }\n    }\n\n    return retv;\n}\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#filename` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\nfunction normalizeFilename(filename) {\n    const parts = filename.split(path.sep);\n    const index = parts.lastIndexOf(\"<text>\");\n\n    return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\nfunction normalizeVerifyOptions(providedOptions, config) {\n\n    const linterOptions = config.linterOptions || config;\n\n    // .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat\n    const disableInlineConfig = linterOptions.noInlineConfig === true;\n    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig\n        ? ` (${config.configNameOfNoInlineConfig})`\n        : \"\";\n\n    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n    if (typeof reportUnusedDisableDirectives === \"boolean\") {\n        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n    }\n    if (typeof reportUnusedDisableDirectives !== \"string\") {\n        if (typeof linterOptions.reportUnusedDisableDirectives === \"boolean\") {\n            reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n        } else {\n            reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives === void 0 ? \"off\" : normalizeSeverityToString(linterOptions.reportUnusedDisableDirectives);\n        }\n    }\n\n    return {\n        filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n        allowInlineConfig: !ignoreInlineConfig,\n        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig\n            ? `your config${configNameOfNoInlineConfig}`\n            : null,\n        reportUnusedDisableDirectives,\n        disableFixes: Boolean(providedOptions.disableFixes)\n    };\n}\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {Parser} parser The parser which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n\n    const parserOptionsFromEnv = enabledEnvironments\n        .filter(env => env.parserOptions)\n        .reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\n    const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\n    const isModule = mergedParserOptions.sourceType === \"module\";\n\n    if (isModule) {\n\n        /*\n         * can't have global return inside of modules\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n         */\n        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });\n    }\n\n    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n\n    return mergedParserOptions;\n}\n\n/**\n * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.\n * @param {ConfigData} config Config object.\n * @param {Object} config.globals Global variable definitions.\n * @param {Parser} config.parser The parser to use.\n * @param {ParserOptions} config.parserOptions The parserOptions to use.\n * @returns {LanguageOptions} The languageOptions equivalent.\n */\nfunction createLanguageOptions({ globals: configuredGlobals, parser, parserOptions }) {\n\n    const {\n        ecmaVersion,\n        sourceType\n    } = parserOptions;\n\n    return {\n        globals: configuredGlobals,\n        ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),\n        sourceType,\n        parser,\n        parserOptions\n    };\n}\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n    return Object.assign(\n        Object.create(null),\n        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),\n        providedGlobals\n    );\n}\n\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\nfunction getRuleOptions(ruleConfig) {\n    if (Array.isArray(ruleConfig)) {\n        return ruleConfig.slice(1);\n    }\n    return [];\n\n}\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {LanguageOptions} languageOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, languageOptions, visitorKeys) {\n    const parserOptions = languageOptions.parserOptions;\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\n    const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n\n    return eslintScope.analyze(ast, {\n        ignoreEval: true,\n        nodejsScope: ecmaFeatures.globalReturn,\n        impliedStrict: ecmaFeatures.impliedStrict,\n        ecmaVersion: typeof ecmaVersion === \"number\" ? ecmaVersion : 6,\n        sourceType: languageOptions.sourceType || \"script\",\n        childVisitorKeys: visitorKeys || evk.KEYS,\n        fallback: Traverser.getKeys\n    });\n}\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {LanguageOptions} languageOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: LintMessage}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\nfunction parse(text, languageOptions, filePath) {\n    const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n    const { ecmaVersion, sourceType, parser } = languageOptions;\n    const parserOptions = Object.assign(\n        { ecmaVersion, sourceType },\n        languageOptions.parserOptions,\n        {\n            loc: true,\n            range: true,\n            raw: true,\n            tokens: true,\n            comment: true,\n            eslintVisitorKeys: true,\n            eslintScopeManager: true,\n            filePath\n        }\n    );\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n    try {\n        debug(\"Parsing:\", filePath);\n        const parseResult = (typeof parser.parseForESLint === \"function\")\n            ? parser.parseForESLint(textToParse, parserOptions)\n            : { ast: parser.parse(textToParse, parserOptions) };\n\n        debug(\"Parsing successful:\", filePath);\n        const ast = parseResult.ast;\n        const parserServices = parseResult.services || {};\n        const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n\n        debug(\"Scope analysis:\", filePath);\n        const scopeManager = parseResult.scopeManager || analyzeScope(ast, languageOptions, visitorKeys);\n\n        debug(\"Scope analysis successful:\", filePath);\n\n        return {\n            success: true,\n\n            /*\n             * Save all values that `parseForESLint()` returned.\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\n             * linter skips the parsing process and reuses the source code object.\n             * In that case, linter needs all the values that `parseForESLint()` returned.\n             */\n            sourceCode: new SourceCode({\n                text,\n                ast,\n                parserServices,\n                scopeManager,\n                visitorKeys\n            })\n        };\n    } catch (ex) {\n\n        // If the message includes a leading line number, strip it:\n        const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n\n        debug(\"%s\\n%s\", message, ex.stack);\n\n        return {\n            success: false,\n            error: {\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                message,\n                line: ex.lineNumber,\n                column: ex.column,\n                nodeType: null\n            }\n        };\n    }\n}\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @throws {any} Any error during the rule's `create`\n * @returns {Object} A map of selector listeners provided by the rule\n */\nfunction createRuleListeners(rule, ruleContext) {\n    try {\n        return rule.create(ruleContext);\n    } catch (ex) {\n        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n        throw ex;\n    }\n}\n\n// methods that exist on SourceCode object\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n    getSource: \"getText\",\n    getSourceLines: \"getLines\",\n    getAllComments: \"getAllComments\",\n    getNodeByRangeIndex: \"getNodeByRangeIndex\",\n    getComments: \"getComments\",\n    getCommentsBefore: \"getCommentsBefore\",\n    getCommentsAfter: \"getCommentsAfter\",\n    getCommentsInside: \"getCommentsInside\",\n    getJSDocComment: \"getJSDocComment\",\n    getFirstToken: \"getFirstToken\",\n    getFirstTokens: \"getFirstTokens\",\n    getLastToken: \"getLastToken\",\n    getLastTokens: \"getLastTokens\",\n    getTokenAfter: \"getTokenAfter\",\n    getTokenBefore: \"getTokenBefore\",\n    getTokenByRangeStart: \"getTokenByRangeStart\",\n    getTokens: \"getTokens\",\n    getTokensAfter: \"getTokensAfter\",\n    getTokensBefore: \"getTokensBefore\",\n    getTokensBetween: \"getTokensBetween\"\n};\n\n\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(\n    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(\n        (contextInfo, methodName) =>\n            Object.assign(contextInfo, {\n                [methodName](...args) {\n                    return this.sourceCode[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\n                }\n            }),\n        {}\n    )\n);\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {string | undefined} parserName The name of the parser in the config\n * @param {LanguageOptions} languageOptions The options for parsing the code.\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @param {string} physicalFilename The full path of the file on disk without any code block information\n * @returns {LintMessage[]} An array of reported problems\n */\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserName, languageOptions, settings, filename, disableFixes, cwd, physicalFilename) {\n    const emitter = createEmitter();\n    const nodeQueue = [];\n    let currentNode = sourceCode.ast;\n\n    Traverser.traverse(sourceCode.ast, {\n        enter(node, parent) {\n            node.parent = parent;\n            nodeQueue.push({ isEntering: true, node });\n        },\n        leave(node) {\n            nodeQueue.push({ isEntering: false, node });\n        },\n        visitorKeys: sourceCode.visitorKeys\n    });\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n    const sharedTraversalContext = Object.freeze(\n        Object.assign(\n            Object.create(BASE_TRAVERSAL_CONTEXT),\n            {\n                getAncestors: () => sourceCode.getAncestors(currentNode),\n                getDeclaredVariables: node => sourceCode.getDeclaredVariables(node),\n                getCwd: () => cwd,\n                cwd,\n                getFilename: () => filename,\n                filename,\n                getPhysicalFilename: () => physicalFilename || filename,\n                physicalFilename: physicalFilename || filename,\n                getScope: () => sourceCode.getScope(currentNode),\n                getSourceCode: () => sourceCode,\n                sourceCode,\n                markVariableAsUsed: name => sourceCode.markVariableAsUsed(name, currentNode),\n                parserOptions: {\n                    ...languageOptions.parserOptions\n                },\n                parserPath: parserName,\n                languageOptions,\n                parserServices: sourceCode.parserServices,\n                settings\n            }\n        )\n    );\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId => {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n        // not load disabled rules\n        if (severity === 0) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n\n        if (!rule) {\n            lintingProblems.push(createLintingProblem({ ruleId }));\n            return;\n        }\n\n        const messageIds = rule.meta && rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\n                Object.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId]),\n                    report(...args) {\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n                        if (reportTranslator === null) {\n                            reportTranslator = createReportTranslator({\n                                ruleId,\n                                severity,\n                                sourceCode,\n                                messageIds,\n                                disableFixes\n                            });\n                        }\n                        const problem = reportTranslator(...args);\n\n                        if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n                            throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n                        }\n                        if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {\n                            if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== \"undefined\") {\n\n                                // Encourage migration from the former property name.\n                                throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.\");\n                            }\n                            throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`.\");\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListeners = timing.enabled ? timing.time(ruleId, createRuleListeners)(rule, ruleContext) : createRuleListeners(rule, ruleContext);\n\n        /**\n         * Include `ruleId` in error logs\n         * @param {Function} ruleListener A rule method that listens for a node.\n         * @returns {Function} ruleListener wrapped in error handler\n         */\n        function addRuleErrorHandler(ruleListener) {\n            return function ruleErrorHandler(...listenerArgs) {\n                try {\n                    return ruleListener(...listenerArgs);\n                } catch (e) {\n                    e.ruleId = ruleId;\n                    throw e;\n                }\n            };\n        }\n\n        if (typeof ruleListeners === \"undefined\" || ruleListeners === null) {\n            throw new Error(`The create() function for rule '${ruleId}' did not return an object.`);\n        }\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector => {\n            const ruleListener = timing.enabled\n                ? timing.time(ruleId, ruleListeners[selector])\n                : ruleListeners[selector];\n\n            emitter.on(\n                selector,\n                addRuleErrorHandler(ruleListener)\n            );\n        });\n    });\n\n    // only run code path analyzer if the top level node is \"Program\", skip otherwise\n    const eventGenerator = nodeQueue[0].node.type === \"Program\"\n        ? new CodePathAnalyzer(new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys }))\n        : new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys });\n\n    nodeQueue.forEach(traversalInfo => {\n        currentNode = traversalInfo.node;\n\n        try {\n            if (traversalInfo.isEntering) {\n                eventGenerator.enterNode(currentNode);\n            } else {\n                eventGenerator.leaveNode(currentNode);\n            }\n        } catch (err) {\n            err.currentNode = currentNode;\n            throw err;\n        }\n    });\n\n    return lintingProblems;\n}\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\nfunction ensureText(textOrSourceCode) {\n    if (typeof textOrSourceCode === \"object\") {\n        const { hasBOM, text } = textOrSourceCode;\n        const bom = hasBOM ? \"\\uFEFF\" : \"\";\n\n        return bom + text;\n    }\n\n    return String(textOrSourceCode);\n}\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\nfunction getEnv(slots, envId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId)) ||\n        BuiltInEnvironments.get(envId) ||\n        null\n    );\n}\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\nfunction getRule(slots, ruleId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId)) ||\n        slots.ruleMap.get(ruleId)\n    );\n}\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\nfunction normalizeCwd(cwd) {\n    if (cwd) {\n        return cwd;\n    }\n    if (typeof process === \"object\") {\n        return process.cwd();\n    }\n\n    // It's more explicit to assign the undefined\n    // eslint-disable-next-line no-undefined -- Consistently returning a value\n    return undefined;\n}\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Throws an error when the given linter is in flat config mode.\n * @param {Linter} linter The linter to check.\n * @returns {void}\n * @throws {Error} If the linter is in flat config mode.\n */\nfunction assertEslintrcConfig(linter) {\n    const { configType } = internalSlotsMap.get(linter);\n\n    if (configType === \"flat\") {\n        throw new Error(\"This method cannot be used with flat config. Add your entries directly into the config array.\");\n    }\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name Linter\n */\nclass Linter {\n\n    /**\n     * Initialize the Linter.\n     * @param {Object} [config] the config object\n     * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.\n     * @param {\"flat\"|\"eslintrc\"} [config.configType=\"eslintrc\"] the type of config used.\n     */\n    constructor({ cwd, configType } = {}) {\n        internalSlotsMap.set(this, {\n            cwd: normalizeCwd(cwd),\n            lastConfigArray: null,\n            lastSourceCode: null,\n            lastSuppressedMessages: [],\n            configType, // TODO: Remove after flat config conversion\n            parserMap: new Map([[\"espree\", espree]]),\n            ruleMap: new Rules()\n        });\n\n        this.version = pkg.version;\n    }\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n    static get version() {\n        return pkg.version;\n    }\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n        const slots = internalSlotsMap.get(this);\n        const config = providedConfig || {};\n        const options = normalizeVerifyOptions(providedOptions, config);\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            slots.lastSourceCode = null;\n            text = textOrSourceCode;\n        } else {\n            slots.lastSourceCode = textOrSourceCode;\n            text = textOrSourceCode.text;\n        }\n\n        // Resolve parser.\n        let parserName = DEFAULT_PARSER_NAME;\n        let parser = espree;\n\n        if (typeof config.parser === \"object\" && config.parser !== null) {\n            parserName = config.parser.filePath;\n            parser = config.parser.definition;\n        } else if (typeof config.parser === \"string\") {\n            if (!slots.parserMap.has(config.parser)) {\n                return [{\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Configured parser '${config.parser}' was not found.`,\n                    line: 0,\n                    column: 0,\n                    nodeType: null\n                }];\n            }\n            parserName = config.parser;\n            parser = slots.parserMap.get(config.parser);\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = options.allowInlineConfig && !options.warnInlineConfig\n            ? findEslintEnv(text)\n            : {};\n        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);\n        const enabledEnvs = Object.keys(resolvedEnvConfig)\n            .filter(envName => resolvedEnvConfig[envName])\n            .map(envName => getEnv(slots, envName))\n            .filter(env => env);\n\n        const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n        const settings = config.settings || {};\n        const languageOptions = createLanguageOptions({\n            globals: config.globals,\n            parser,\n            parserOptions\n        });\n\n        if (!slots.lastSourceCode) {\n            const parseResult = parse(\n                text,\n                languageOptions,\n                options.filename\n            );\n\n            if (!parseResult.success) {\n                return [parseResult.error];\n            }\n\n            slots.lastSourceCode = parseResult.sourceCode;\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n            if (!slots.lastSourceCode.scopeManager) {\n                slots.lastSourceCode = new SourceCode({\n                    text: slots.lastSourceCode.text,\n                    ast: slots.lastSourceCode.ast,\n                    parserServices: slots.lastSourceCode.parserServices,\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n                });\n            }\n        }\n\n        const sourceCode = slots.lastSourceCode;\n        const commentDirectives = options.allowInlineConfig\n            ? getDirectiveComments(sourceCode, ruleId => getRule(slots, ruleId), options.warnInlineConfig)\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\n\n        // augment global scope with declared global variables\n        addDeclaredGlobals(\n            sourceCode.scopeManager.scopes[0],\n            configuredGlobals,\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\n        );\n\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n        let lintingProblems;\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => getRule(slots, ruleId),\n                parserName,\n                languageOptions,\n                settings,\n                options.filename,\n                options.disableFixes,\n                slots.cwd,\n                providedOptions.physicalFilename\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = err.currentNode.loc.start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", parserOptions);\n            debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n\n            if (err.ruleId) {\n                err.message += `\\nRule: \"${err.ruleId}\"`;\n            }\n\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            directives: commentDirectives.disableDirectives,\n            disableFixes: options.disableFixes,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n        });\n    }\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n    verify(textOrSourceCode, config, filenameOrOptions) {\n        debug(\"Verify\");\n\n        const { configType, cwd } = internalSlotsMap.get(this);\n\n        const options = typeof filenameOrOptions === \"string\"\n            ? { filename: filenameOrOptions }\n            : filenameOrOptions || {};\n\n        if (config) {\n            if (configType === \"flat\") {\n\n                /*\n                 * Because of how Webpack packages up the files, we can't\n                 * compare directly to `FlatConfigArray` using `instanceof`\n                 * because it's not the same `FlatConfigArray` as in the tests.\n                 * So, we work around it by assuming an array is, in fact, a\n                 * `FlatConfigArray` if it has a `getConfig()` method.\n                 */\n                let configArray = config;\n\n                if (!Array.isArray(config) || typeof config.getConfig !== \"function\") {\n                    configArray = new FlatConfigArray(config, { basePath: cwd });\n                    configArray.normalizeSync();\n                }\n\n                return this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(textOrSourceCode, configArray, options, true));\n            }\n\n            if (typeof config.extractConfig === \"function\") {\n                return this._distinguishSuppressedMessages(this._verifyWithConfigArray(textOrSourceCode, config, options));\n            }\n        }\n\n        /*\n         * If we get to here, it means `config` is just an object rather\n         * than a config array so we can go right into linting.\n         */\n\n        /*\n         * `Linter` doesn't support `overrides` property in configuration.\n         * So we cannot apply multiple processors.\n         */\n        if (options.preprocess || options.postprocess) {\n            return this._distinguishSuppressedMessages(this._verifyWithProcessor(textOrSourceCode, config, options));\n        }\n        return this._distinguishSuppressedMessages(this._verifyWithoutProcessors(textOrSourceCode, config, options));\n    }\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {FlatConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options, configForRecursive) {\n        const filename = options.filename || \"<input>\";\n        const filenameToExpose = normalizeFilename(filename);\n        const physicalFilename = options.physicalFilename || filenameToExpose;\n        const text = ensureText(textOrSourceCode);\n        const preprocess = options.preprocess || (rawText => [rawText]);\n        const postprocess = options.postprocess || (messagesList => messagesList.flat());\n        const filterCodeBlock =\n            options.filterCodeBlock ||\n            (blockFilename => blockFilename.endsWith(\".js\"));\n        const originalExtname = path.extname(filename);\n\n        let blocks;\n\n        try {\n            blocks = preprocess(text, filenameToExpose);\n        } catch (ex) {\n\n            // If the message includes a leading line number, strip it:\n            const message = `Preprocessing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n\n            debug(\"%s\\n%s\", message, ex.stack);\n\n            return [\n                {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message,\n                    line: ex.lineNumber,\n                    column: ex.column,\n                    nodeType: null\n                }\n            ];\n        }\n\n        const messageLists = blocks.map((block, i) => {\n            debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n            // Keep the legacy behavior.\n            if (typeof block === \"string\") {\n                return this._verifyWithFlatConfigArrayAndWithoutProcessors(block, config, options);\n            }\n\n            const blockText = block.text;\n            const blockName = path.join(filename, `${i}_${block.filename}`);\n\n            // Skip this block if filtered.\n            if (!filterCodeBlock(blockName, blockText)) {\n                debug(\"This code block was skipped.\");\n                return [];\n            }\n\n            // Resolve configuration again if the file content or extension was changed.\n            if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\n                return this._verifyWithFlatConfigArray(\n                    blockText,\n                    configForRecursive,\n                    { ...options, filename: blockName, physicalFilename }\n                );\n            }\n\n            // Does lint.\n            return this._verifyWithFlatConfigArrayAndWithoutProcessors(\n                blockText,\n                config,\n                { ...options, filename: blockName, physicalFilename }\n            );\n        });\n\n        return postprocess(messageLists, filenameToExpose);\n    }\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n        const slots = internalSlotsMap.get(this);\n        const config = providedConfig || {};\n        const options = normalizeVerifyOptions(providedOptions, config);\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            slots.lastSourceCode = null;\n            text = textOrSourceCode;\n        } else {\n            slots.lastSourceCode = textOrSourceCode;\n            text = textOrSourceCode.text;\n        }\n\n        const languageOptions = config.languageOptions;\n\n        languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(\n            languageOptions.ecmaVersion\n        );\n\n        // double check that there is a parser to avoid mysterious error messages\n        if (!languageOptions.parser) {\n            throw new TypeError(`No parser specified for ${options.filename}`);\n        }\n\n        // Espree expects this information to be passed in\n        if (isEspree(languageOptions.parser)) {\n            const parserOptions = languageOptions.parserOptions;\n\n            if (languageOptions.sourceType) {\n\n                parserOptions.sourceType = languageOptions.sourceType;\n\n                if (\n                    parserOptions.sourceType === \"module\" &&\n                    parserOptions.ecmaFeatures &&\n                    parserOptions.ecmaFeatures.globalReturn\n                ) {\n                    parserOptions.ecmaFeatures.globalReturn = false;\n                }\n            }\n        }\n\n        const settings = config.settings || {};\n\n        if (!slots.lastSourceCode) {\n            const parseResult = parse(\n                text,\n                languageOptions,\n                options.filename\n            );\n\n            if (!parseResult.success) {\n                return [parseResult.error];\n            }\n\n            slots.lastSourceCode = parseResult.sourceCode;\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n            if (!slots.lastSourceCode.scopeManager) {\n                slots.lastSourceCode = new SourceCode({\n                    text: slots.lastSourceCode.text,\n                    ast: slots.lastSourceCode.ast,\n                    parserServices: slots.lastSourceCode.parserServices,\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n                });\n            }\n        }\n\n        const sourceCode = slots.lastSourceCode;\n\n        /*\n         * Make adjustments based on the language options. For JavaScript,\n         * this is primarily about adding variables into the global scope\n         * to account for ecmaVersion and configured globals.\n         */\n        sourceCode.applyLanguageOptions(languageOptions);\n\n        const mergedInlineConfig = {\n            rules: {}\n        };\n        const inlineConfigProblems = [];\n\n        /*\n         * Inline config can be either enabled or disabled. If disabled, it's possible\n         * to detect the inline config and emit a warning (though this is not required).\n         * So we first check to see if inline config is allowed at all, and if so, we\n         * need to check if it's a warning or not.\n         */\n        if (options.allowInlineConfig) {\n\n            // if inline config should warn then add the warnings\n            if (options.warnInlineConfig) {\n                sourceCode.getInlineConfigNodes().forEach(node => {\n                    inlineConfigProblems.push(createLintingProblem({\n                        ruleId: null,\n                        message: `'${sourceCode.text.slice(node.range[0], node.range[1])}' has no effect because you have 'noInlineConfig' setting in ${options.warnInlineConfig}.`,\n                        loc: node.loc,\n                        severity: 1\n                    }));\n\n                });\n            } else {\n                const inlineConfigResult = sourceCode.applyInlineConfig();\n\n                inlineConfigProblems.push(\n                    ...inlineConfigResult.problems\n                        .map(createLintingProblem)\n                        .map(problem => {\n                            problem.fatal = true;\n                            return problem;\n                        })\n                );\n\n                // next we need to verify information about the specified rules\n                const ruleValidator = new RuleValidator();\n\n                for (const { config: inlineConfig, node } of inlineConfigResult.configs) {\n\n                    Object.keys(inlineConfig.rules).forEach(ruleId => {\n                        const rule = getRuleFromConfig(ruleId, config);\n                        const ruleValue = inlineConfig.rules[ruleId];\n\n                        if (!rule) {\n                            inlineConfigProblems.push(createLintingProblem({ ruleId, loc: node.loc }));\n                            return;\n                        }\n\n                        try {\n\n                            const ruleOptions = Array.isArray(ruleValue) ? ruleValue : [ruleValue];\n\n                            assertIsRuleOptions(ruleId, ruleValue);\n                            assertIsRuleSeverity(ruleId, ruleOptions[0]);\n\n                            ruleValidator.validate({\n                                plugins: config.plugins,\n                                rules: {\n                                    [ruleId]: ruleOptions\n                                }\n                            });\n                            mergedInlineConfig.rules[ruleId] = ruleValue;\n                        } catch (err) {\n\n                            let baseMessage = err.message.slice(\n                                err.message.startsWith(\"Key \\\"rules\\\":\")\n                                    ? err.message.indexOf(\":\", 12) + 1\n                                    : err.message.indexOf(\":\") + 1\n                            ).trim();\n\n                            if (err.messageTemplate) {\n                                baseMessage += ` You passed \"${ruleValue}\".`;\n                            }\n\n                            inlineConfigProblems.push(createLintingProblem({\n                                ruleId,\n                                message: `Inline configuration for rule \"${ruleId}\" is invalid:\\n\\t${baseMessage}\\n`,\n                                loc: node.loc\n                            }));\n                        }\n                    });\n                }\n            }\n        }\n\n        const commentDirectives = options.allowInlineConfig && !options.warnInlineConfig\n            ? getDirectiveCommentsForFlatConfig(\n                sourceCode,\n                ruleId => getRuleFromConfig(ruleId, config)\n            )\n            : { problems: [], disableDirectives: [] };\n\n        const configuredRules = Object.assign({}, config.rules, mergedInlineConfig.rules);\n        let lintingProblems;\n\n        sourceCode.finalize();\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => getRuleFromConfig(ruleId, config),\n                void 0,\n                languageOptions,\n                settings,\n                options.filename,\n                options.disableFixes,\n                slots.cwd,\n                providedOptions.physicalFilename\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = err.currentNode.loc.start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", languageOptions.parserOptions);\n\n            // debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n\n            if (err.ruleId) {\n                err.message += `\\nRule: \"${err.ruleId}\"`;\n            }\n\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            directives: commentDirectives.disableDirectives,\n            disableFixes: options.disableFixes,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .concat(inlineConfigProblems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n        });\n    }\n\n    /**\n     * Verify a given code with `ConfigArray`.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n        debug(\"With ConfigArray: %s\", options.filename);\n\n        // Store the config array in order to get plugin envs and rules later.\n        internalSlotsMap.get(this).lastConfigArray = configArray;\n\n        // Extract the final config for this file.\n        const config = configArray.extractConfig(options.filename);\n        const processor =\n            config.processor &&\n            configArray.pluginProcessors.get(config.processor);\n\n        // Verify.\n        if (processor) {\n            debug(\"Apply the processor: %o\", config.processor);\n            const { preprocess, postprocess, supportsAutofix } = processor;\n            const disableFixes = options.disableFixes || !supportsAutofix;\n\n            return this._verifyWithProcessor(\n                textOrSourceCode,\n                config,\n                { ...options, disableFixes, postprocess, preprocess },\n                configArray\n            );\n        }\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify a given code with a flat config.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {FlatConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {boolean} [firstCall=false] Indicates if this is being called directly\n     *      from verify(). (TODO: Remove once eslintrc is removed.)\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithFlatConfigArray(textOrSourceCode, configArray, options, firstCall = false) {\n        debug(\"With flat config: %s\", options.filename);\n\n        // we need a filename to match configs against\n        const filename = options.filename || \"__placeholder__.js\";\n\n        // Store the config array in order to get plugin envs and rules later.\n        internalSlotsMap.get(this).lastConfigArray = configArray;\n        const config = configArray.getConfig(filename);\n\n        if (!config) {\n            return [\n                {\n                    ruleId: null,\n                    severity: 1,\n                    message: `No matching configuration found for ${filename}.`,\n                    line: 0,\n                    column: 0,\n                    nodeType: null\n                }\n            ];\n        }\n\n        // Verify.\n        if (config.processor) {\n            debug(\"Apply the processor: %o\", config.processor);\n            const { preprocess, postprocess, supportsAutofix } = config.processor;\n            const disableFixes = options.disableFixes || !supportsAutofix;\n\n            return this._verifyWithFlatConfigArrayAndProcessor(\n                textOrSourceCode,\n                config,\n                { ...options, filename, disableFixes, postprocess, preprocess },\n                configArray\n            );\n        }\n\n        // check for options-based processing\n        if (firstCall && (options.preprocess || options.postprocess)) {\n            return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options);\n        }\n\n        return this._verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigData|ExtractedConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n        const filename = options.filename || \"<input>\";\n        const filenameToExpose = normalizeFilename(filename);\n        const physicalFilename = options.physicalFilename || filenameToExpose;\n        const text = ensureText(textOrSourceCode);\n        const preprocess = options.preprocess || (rawText => [rawText]);\n        const postprocess = options.postprocess || (messagesList => messagesList.flat());\n        const filterCodeBlock =\n            options.filterCodeBlock ||\n            (blockFilename => blockFilename.endsWith(\".js\"));\n        const originalExtname = path.extname(filename);\n\n        let blocks;\n\n        try {\n            blocks = preprocess(text, filenameToExpose);\n        } catch (ex) {\n\n            // If the message includes a leading line number, strip it:\n            const message = `Preprocessing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n\n            debug(\"%s\\n%s\", message, ex.stack);\n\n            return [\n                {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message,\n                    line: ex.lineNumber,\n                    column: ex.column,\n                    nodeType: null\n                }\n            ];\n        }\n\n        const messageLists = blocks.map((block, i) => {\n            debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n            // Keep the legacy behavior.\n            if (typeof block === \"string\") {\n                return this._verifyWithoutProcessors(block, config, options);\n            }\n\n            const blockText = block.text;\n            const blockName = path.join(filename, `${i}_${block.filename}`);\n\n            // Skip this block if filtered.\n            if (!filterCodeBlock(blockName, blockText)) {\n                debug(\"This code block was skipped.\");\n                return [];\n            }\n\n            // Resolve configuration again if the file content or extension was changed.\n            if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\n                return this._verifyWithConfigArray(\n                    blockText,\n                    configForRecursive,\n                    { ...options, filename: blockName, physicalFilename }\n                );\n            }\n\n            // Does lint.\n            return this._verifyWithoutProcessors(\n                blockText,\n                config,\n                { ...options, filename: blockName, physicalFilename }\n            );\n        });\n\n        return postprocess(messageLists, filenameToExpose);\n    }\n\n    /**\n     * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.\n     * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.\n     * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.\n     * @returns {LintMessage[]} A list of LintMessage.\n     */\n    _distinguishSuppressedMessages(problems) {\n        const messages = [];\n        const suppressedMessages = [];\n        const slots = internalSlotsMap.get(this);\n\n        for (const problem of problems) {\n            if (problem.suppressions) {\n                suppressedMessages.push(problem);\n            } else {\n                messages.push(problem);\n            }\n        }\n\n        slots.lastSuppressedMessages = suppressedMessages;\n\n        return messages;\n    }\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    getSourceCode() {\n        return internalSlotsMap.get(this).lastSourceCode;\n    }\n\n    /**\n     * Gets the list of SuppressedLintMessage produced in the last running.\n     * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage\n     */\n    getSuppressedMessages() {\n        return internalSlotsMap.get(this).lastSuppressedMessages;\n    }\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    defineRule(ruleId, ruleModule) {\n        assertEslintrcConfig(this);\n        internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n    }\n\n    /**\n     * Defines many new linting rules.\n     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    defineRules(rulesToDefine) {\n        assertEslintrcConfig(this);\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            this.defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    }\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map<string, Rule>} All loaded rules\n     */\n    getRules() {\n        assertEslintrcConfig(this);\n        const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);\n\n        return new Map(function *() {\n            yield* ruleMap;\n\n            if (lastConfigArray) {\n                yield* lastConfigArray.pluginRules;\n            }\n        }());\n    }\n\n    /**\n     * Define a new parser module\n     * @param {string} parserId Name of the parser\n     * @param {Parser} parserModule The parser object\n     * @returns {void}\n     */\n    defineParser(parserId, parserModule) {\n        assertEslintrcConfig(this);\n        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n    }\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n    verifyAndFix(text, config, options) {\n        let messages = [],\n            fixedResult,\n            fixed = false,\n            passNumber = 0,\n            currentText = text;\n        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n        const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n        do {\n            passNumber++;\n\n            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n            messages = this.verify(currentText, config, options);\n\n            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n            if (messages.length === 1 && messages[0].fatal) {\n                break;\n            }\n\n            // keep track if any fixes were ever applied - important for return value\n            fixed = fixed || fixedResult.fixed;\n\n            // update to use the fixed output instead of the original text\n            currentText = fixedResult.output;\n\n        } while (\n            fixedResult.fixed &&\n            passNumber < MAX_AUTOFIX_PASSES\n        );\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n        if (fixedResult.fixed) {\n            fixedResult.messages = this.verify(currentText, config, options);\n        }\n\n        // ensure the last result properly reflects if fixes were done\n        fixedResult.fixed = fixed;\n        fixedResult.output = currentText;\n\n        return fixedResult;\n    }\n}\n\nmodule.exports = {\n    Linter,\n\n    /**\n     * Get the internal slots of a given Linter instance for tests.\n     * @param {Linter} instance The Linter instance to get.\n     * @returns {LinterInternalSlots} The internal slots.\n     */\n    getLinterInternalSlots(instance) {\n        return internalSlotsMap.get(instance);\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}