{"ast":null,"code":"/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param {string} operator Operator to check.\n * @returns {boolean} True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n  return [\"*\", \"&\", \"^\", \"|\"].includes(operator);\n}\n\n/**\n * Checks whether an operator is not commutative and has an operator assignment\n * shorthand form.\n * @param {string} operator Operator to check.\n * @returns {boolean} True if the operator is not commutative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n  return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].includes(operator);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\nfunction canBeFixed(node) {\n  return node.type === \"Identifier\" || node.type === \"MemberExpression\" && (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") && (!node.computed || node.property.type === \"Literal\");\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require or disallow assignment operator shorthand where possible\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/operator-assignment\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      replaced: \"Assignment (=) can be replaced with operator assignment ({{operator}}).\",\n      unexpected: \"Unexpected operator assignment ({{operator}}) shorthand.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Returns the operator token of an AssignmentExpression or BinaryExpression\n     * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n     * @returns {Token} The operator token in the node\n     */\n    function getOperatorToken(node) {\n      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n    }\n\n    /**\n     * Ensures that an assignment uses the shorthand form where possible.\n     * @param {ASTNode} node An AssignmentExpression node.\n     * @returns {void}\n     */\n    function verify(node) {\n      if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n        return;\n      }\n      const left = node.left;\n      const expr = node.right;\n      const operator = expr.operator;\n      if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n        const replacementOperator = `${operator}=`;\n        if (astUtils.isSameReference(left, expr.left, true)) {\n          context.report({\n            node,\n            messageId: \"replaced\",\n            data: {\n              operator: replacementOperator\n            },\n            fix(fixer) {\n              if (canBeFixed(left) && canBeFixed(expr.left)) {\n                const equalsToken = getOperatorToken(node);\n                const operatorToken = getOperatorToken(expr);\n                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                // Check for comments that would be removed.\n                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                  return null;\n                }\n                return fixer.replaceText(node, `${leftText}${replacementOperator}${rightText}`);\n              }\n              return null;\n            }\n          });\n        } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\n          /*\n           * This case can't be fixed safely.\n           * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n           * change the execution order of the valueOf() functions.\n           */\n          context.report({\n            node,\n            messageId: \"replaced\",\n            data: {\n              operator: replacementOperator\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Warns if an assignment expression uses operator assignment shorthand.\n     * @param {ASTNode} node An AssignmentExpression node.\n     * @returns {void}\n     */\n    function prohibit(node) {\n      if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            operator: node.operator\n          },\n          fix(fixer) {\n            if (canBeFixed(node.left)) {\n              const firstToken = sourceCode.getFirstToken(node);\n              const operatorToken = getOperatorToken(node);\n              const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n              const newOperator = node.operator.slice(0, -1);\n              let rightText;\n\n              // Check for comments that would be duplicated.\n              if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                return null;\n              }\n\n              // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n              if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({\n                type: \"BinaryExpression\",\n                operator: newOperator\n              }) && !astUtils.isParenthesised(sourceCode, node.right)) {\n                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n              } else {\n                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, {\n                  includeComments: true\n                });\n                let rightTextPrefix = \"\";\n                if (operatorToken.range[1] === tokenAfterOperator.range[0] && !astUtils.canTokensBeAdjacent({\n                  type: \"Punctuator\",\n                  value: newOperator\n                }, tokenAfterOperator)) {\n                  rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                }\n                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n              }\n              return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n            }\n            return null;\n          }\n        });\n      }\n    }\n    return {\n      AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isCommutativeOperatorWithShorthand","operator","includes","isNonCommutativeOperatorWithShorthand","canBeFixed","node","type","object","computed","property","module","exports","meta","docs","description","recommended","url","schema","enum","fixable","messages","replaced","unexpected","create","context","sourceCode","getOperatorToken","getFirstTokenBetween","left","right","token","value","verify","expr","replacementOperator","isSameReference","report","messageId","data","fix","fixer","equalsToken","operatorToken","leftText","getText","slice","range","rightText","commentsExistBetween","replaceText","prohibit","isLogicalAssignmentOperator","firstToken","getFirstToken","newOperator","getPrecedence","isParenthesised","text","tokenAfterOperator","getTokenAfter","includeComments","rightTextPrefix","canTokensBeAdjacent","AssignmentExpression","options"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/operator-assignment.js"],"sourcesContent":["/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param {string} operator Operator to check.\n * @returns {boolean} True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].includes(operator);\n}\n\n/**\n * Checks whether an operator is not commutative and has an operator assignment\n * shorthand form.\n * @param {string} operator Operator to check.\n * @returns {boolean} True if the operator is not commutative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].includes(operator);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\nfunction canBeFixed(node) {\n    return (\n        node.type === \"Identifier\" ||\n        (\n            node.type === \"MemberExpression\" &&\n            (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") &&\n            (!node.computed || node.property.type === \"Literal\")\n        )\n    );\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require or disallow assignment operator shorthand where possible\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/operator-assignment\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            replaced: \"Assignment (=) can be replaced with operator assignment ({{operator}}).\",\n            unexpected: \"Unexpected operator assignment ({{operator}}) shorthand.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Returns the operator token of an AssignmentExpression or BinaryExpression\n         * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n         * @returns {Token} The operator token in the node\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                const replacementOperator = `${operator}=`;\n\n                if (astUtils.isSameReference(left, expr.left, true)) {\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        data: { operator: replacementOperator },\n                        fix(fixer) {\n                            if (canBeFixed(left) && canBeFixed(expr.left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                // Check for comments that would be removed.\n                                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, `${leftText}${replacementOperator}${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        data: { operator: replacementOperator }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: { operator: node.operator },\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const firstToken = sourceCode.getFirstToken(node);\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // Check for comments that would be duplicated.\n                            if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                                return null;\n                            }\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, { includeComments: true });\n                                let rightTextPrefix = \"\";\n\n                                if (\n                                    operatorToken.range[1] === tokenAfterOperator.range[0] &&\n                                    !astUtils.canTokensBeAdjacent({ type: \"Punctuator\", value: newOperator }, tokenAfterOperator)\n                                ) {\n                                    rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                                }\n\n                                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}