{"ast":null,"code":"/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Require or disallow newline at the end of files\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/eol-last\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"unix\", \"windows\"]\n    }],\n    messages: {\n      missing: \"Newline required at end of file but not found.\",\n      unexpected: \"Newline not allowed at end of file.\"\n    }\n  },\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: function checkBadEOF(node) {\n        const sourceCode = context.sourceCode,\n          src = sourceCode.getText(),\n          lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n          location = {\n            column: lastLine.length,\n            line: sourceCode.lines.length\n          },\n          LF = \"\\n\",\n          CRLF = `\\r${LF}`,\n          endsWithNewline = src.endsWith(LF);\n\n        /*\n         * Empty source is always valid: No content in file so we don't\n         * need to lint for a newline on the last line of content.\n         */\n        if (!src.length) {\n          return;\n        }\n        let mode = context.options[0] || \"always\",\n          appendCRLF = false;\n        if (mode === \"unix\") {\n          // `\"unix\"` should behave exactly as `\"always\"`\n          mode = \"always\";\n        }\n        if (mode === \"windows\") {\n          // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n          mode = \"always\";\n          appendCRLF = true;\n        }\n        if (mode === \"always\" && !endsWithNewline) {\n          // File is not newline-terminated, but should be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"missing\",\n            fix(fixer) {\n              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n            }\n          });\n        } else if (mode === \"never\" && endsWithNewline) {\n          const secondLastLine = sourceCode.lines[sourceCode.lines.length - 2];\n\n          // File is newline-terminated, but shouldn't be\n          context.report({\n            node,\n            loc: {\n              start: {\n                line: sourceCode.lines.length - 1,\n                column: secondLastLine.length\n              },\n              end: {\n                line: sourceCode.lines.length,\n                column: 0\n              }\n            },\n            messageId: \"unexpected\",\n            fix(fixer) {\n              const finalEOLs = /(?:\\r?\\n)+$/u,\n                match = finalEOLs.exec(sourceCode.text),\n                start = match.index,\n                end = sourceCode.text.length;\n              return fixer.replaceTextRange([start, end], \"\");\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","enum","messages","missing","unexpected","create","context","Program","checkBadEOF","node","sourceCode","src","getText","lastLine","lines","length","location","column","line","LF","CRLF","endsWithNewline","endsWith","mode","options","appendCRLF","report","loc","messageId","fix","fixer","insertTextAfterRange","secondLastLine","start","end","finalEOLs","match","exec","text","index","replaceTextRange"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/eol-last.js"],"sourcesContent":["/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow newline at the end of files\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/eol-last\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ],\n\n        messages: {\n            missing: \"Newline required at end of file but not found.\",\n            unexpected: \"Newline not allowed at end of file.\"\n        }\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.sourceCode,\n                    src = sourceCode.getText(),\n                    lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n                    location = {\n                        column: lastLine.length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = src.endsWith(LF);\n\n                /*\n                 * Empty source is always valid: No content in file so we don't\n                 * need to lint for a newline on the last line of content.\n                 */\n                if (!src.length) {\n                    return;\n                }\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"missing\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    const secondLastLine = sourceCode.lines[sourceCode.lines.length - 2];\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: {\n                            start: { line: sourceCode.lines.length - 1, column: secondLastLine.length },\n                            end: { line: sourceCode.lines.length, column: 0 }\n                        },\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}