{"ast":null,"code":"/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\nconst {\n  isEqToken\n} = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Require spacing around infix operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/space-infix-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        int32Hint: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingSpace: \"Operator '{{operator}}' must be spaced.\"\n    }\n  },\n  create(context) {\n    const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Returns the first token which violates the rule\n     * @param {ASTNode} left The left node of the main node\n     * @param {ASTNode} right The right node of the main node\n     * @param {string} op The operator of the main node\n     * @returns {Object} The violator token or null\n     * @private\n     */\n    function getFirstNonSpacedToken(left, right, op) {\n      const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n      const prev = sourceCode.getTokenBefore(operator);\n      const next = sourceCode.getTokenAfter(operator);\n      if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n        return operator;\n      }\n      return null;\n    }\n\n    /**\n     * Reports an AST node as a rule violation\n     * @param {ASTNode} mainNode The node to report\n     * @param {Object} culpritToken The token which has a problem\n     * @returns {void}\n     * @private\n     */\n    function report(mainNode, culpritToken) {\n      context.report({\n        node: mainNode,\n        loc: culpritToken.loc,\n        messageId: \"missingSpace\",\n        data: {\n          operator: culpritToken.value\n        },\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(culpritToken);\n          const afterToken = sourceCode.getTokenAfter(culpritToken);\n          let fixString = \"\";\n          if (culpritToken.range[0] - previousToken.range[1] === 0) {\n            fixString = \" \";\n          }\n          fixString += culpritToken.value;\n          if (afterToken.range[0] - culpritToken.range[1] === 0) {\n            fixString += \" \";\n          }\n          return fixer.replaceText(culpritToken, fixString);\n        }\n      });\n    }\n\n    /**\n     * Check if the node is binary then report\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkBinary(node) {\n      const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;\n      const rightNode = node.right;\n\n      // search for = in AssignmentPattern nodes\n      const operator = node.operator || \"=\";\n      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n      if (nonSpacedNode) {\n        if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n\n    /**\n     * Check if the node is conditional\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkConditional(node) {\n      const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n      const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n      if (nonSpacedConsequentNode) {\n        report(node, nonSpacedConsequentNode);\n      }\n      if (nonSpacedAlternateNode) {\n        report(node, nonSpacedAlternateNode);\n      }\n    }\n\n    /**\n     * Check if the node is a variable\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkVar(node) {\n      const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;\n      const rightNode = node.init;\n      if (rightNode) {\n        const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n        if (nonSpacedNode) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n    return {\n      AssignmentExpression: checkBinary,\n      AssignmentPattern: checkBinary,\n      BinaryExpression: checkBinary,\n      LogicalExpression: checkBinary,\n      ConditionalExpression: checkConditional,\n      VariableDeclarator: checkVar,\n      PropertyDefinition(node) {\n        if (!node.value) {\n          return;\n        }\n\n        /*\n         * Because of computed properties and type annotations, some\n         * tokens may exist between `node.key` and `=`.\n         * Therefore, find the `=` from the right.\n         */\n        const operatorToken = sourceCode.getTokenBefore(node.value, isEqToken);\n        const leftToken = sourceCode.getTokenBefore(operatorToken);\n        const rightToken = sourceCode.getTokenAfter(operatorToken);\n        if (!sourceCode.isSpaceBetweenTokens(leftToken, operatorToken) || !sourceCode.isSpaceBetweenTokens(operatorToken, rightToken)) {\n          report(node, operatorToken);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["isEqToken","require","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","properties","int32Hint","default","additionalProperties","messages","missingSpace","create","context","options","sourceCode","getFirstNonSpacedToken","left","right","op","operator","getFirstTokenBetween","token","value","prev","getTokenBefore","next","getTokenAfter","isSpaceBetweenTokens","report","mainNode","culpritToken","node","loc","messageId","data","fix","fixer","previousToken","afterToken","fixString","range","replaceText","checkBinary","leftNode","typeAnnotation","rightNode","nonSpacedNode","getText","endsWith","checkConditional","nonSpacedConsequentNode","test","consequent","nonSpacedAlternateNode","alternate","checkVar","id","init","AssignmentExpression","AssignmentPattern","BinaryExpression","LogicalExpression","ConditionalExpression","VariableDeclarator","PropertyDefinition","operatorToken","leftToken","rightToken"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/space-infix-ops.js"],"sourcesContent":["/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\nconst { isEqToken } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Require spacing around infix operators\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/space-infix-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingSpace: \"Operator '{{operator}}' must be spaced.\"\n        }\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left The left node of the main node\n         * @param {ASTNode} right The right node of the main node\n         * @param {string} op The operator of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right, op) {\n            const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n            const prev = sourceCode.getTokenBefore(operator);\n            const next = sourceCode.getTokenAfter(operator);\n\n            if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n                return operator;\n            }\n\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode The node to report\n         * @param {Object} culpritToken The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc,\n                messageId: \"missingSpace\",\n                data: {\n                    operator: culpritToken.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\n            const rightNode = node.right;\n\n            // search for = in AssignmentPattern nodes\n            const operator = node.operator || \"=\";\n\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n            if (nonSpacedConsequentNode) {\n                report(node, nonSpacedConsequentNode);\n            }\n\n            if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\n            const rightNode = node.init;\n\n            if (rightNode) {\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar,\n\n            PropertyDefinition(node) {\n                if (!node.value) {\n                    return;\n                }\n\n                /*\n                 * Because of computed properties and type annotations, some\n                 * tokens may exist between `node.key` and `=`.\n                 * Therefore, find the `=` from the right.\n                 */\n                const operatorToken = sourceCode.getTokenBefore(node.value, isEqToken);\n                const leftToken = sourceCode.getTokenBefore(operatorToken);\n                const rightToken = sourceCode.getTokenAfter(operatorToken);\n\n                if (\n                    !sourceCode.isSpaceBetweenTokens(leftToken, operatorToken) ||\n                    !sourceCode.isSpaceBetweenTokens(operatorToken, rightToken)\n                ) {\n                    report(node, operatorToken);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}