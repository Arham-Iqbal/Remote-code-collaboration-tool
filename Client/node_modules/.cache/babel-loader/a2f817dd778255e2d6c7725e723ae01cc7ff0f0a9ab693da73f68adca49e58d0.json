{"ast":null,"code":"/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents the body of a function.\n * @param {ASTNode} node the node to check.\n * @returns {boolean} `true` if the node is function body.\n */\nfunction isFunctionBody(node) {\n  const parent = node.parent;\n  return node.type === \"BlockStatement\" && astUtils.isFunction(parent) && parent.body === node;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent spacing before blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/space-before-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          keywords: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          functions: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\", \"off\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before opening brace.\",\n      missingSpace: \"Missing space before opening brace.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0],\n      sourceCode = context.sourceCode;\n    let alwaysFunctions = true,\n      alwaysKeywords = true,\n      alwaysClasses = true,\n      neverFunctions = false,\n      neverKeywords = false,\n      neverClasses = false;\n    if (typeof config === \"object\") {\n      alwaysFunctions = config.functions === \"always\";\n      alwaysKeywords = config.keywords === \"always\";\n      alwaysClasses = config.classes === \"always\";\n      neverFunctions = config.functions === \"never\";\n      neverKeywords = config.keywords === \"never\";\n      neverClasses = config.classes === \"never\";\n    } else if (config === \"never\") {\n      alwaysFunctions = false;\n      alwaysKeywords = false;\n      alwaysClasses = false;\n      neverFunctions = true;\n      neverKeywords = true;\n      neverClasses = true;\n    }\n\n    /**\n     * Checks whether the spacing before the given block is already controlled by another rule:\n     * - `arrow-spacing` checks spaces after `=>`.\n     * - `keyword-spacing` checks spaces after keywords in certain contexts.\n     * - `switch-colon-spacing` checks spaces after `:` of switch cases.\n     * @param {Token} precedingToken first token before the block.\n     * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\n     * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\n     */\n    function isConflicted(precedingToken, node) {\n      return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node) || astUtils.isColonToken(precedingToken) && node.parent && node.parent.type === \"SwitchCase\" && precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode);\n    }\n\n    /**\n     * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n     * @param {ASTNode|Token} node The AST node of a BlockStatement.\n     * @returns {void} undefined.\n     */\n    function checkPrecedingSpace(node) {\n      const precedingToken = sourceCode.getTokenBefore(node);\n      if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n        let requireSpace;\n        let requireNoSpace;\n        if (isFunctionBody(node)) {\n          requireSpace = alwaysFunctions;\n          requireNoSpace = neverFunctions;\n        } else if (node.type === \"ClassBody\") {\n          requireSpace = alwaysClasses;\n          requireNoSpace = neverClasses;\n        } else {\n          requireSpace = alwaysKeywords;\n          requireNoSpace = neverKeywords;\n        }\n        if (requireSpace && !hasSpace) {\n          context.report({\n            node,\n            messageId: \"missingSpace\",\n            fix(fixer) {\n              return fixer.insertTextBefore(node, \" \");\n            }\n          });\n        } else if (requireNoSpace && hasSpace) {\n          context.report({\n            node,\n            messageId: \"unexpectedSpace\",\n            fix(fixer) {\n              return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n     * @param {ASTNode} node The node of a SwitchStatement.\n     * @returns {void} undefined.\n     */\n    function checkSpaceBeforeCaseBlock(node) {\n      const cases = node.cases;\n      let openingBrace;\n      if (cases.length > 0) {\n        openingBrace = sourceCode.getTokenBefore(cases[0]);\n      } else {\n        openingBrace = sourceCode.getLastToken(node, 1);\n      }\n      checkPrecedingSpace(openingBrace);\n    }\n    return {\n      BlockStatement: checkPrecedingSpace,\n      ClassBody: checkPrecedingSpace,\n      SwitchStatement: checkSpaceBeforeCaseBlock\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isFunctionBody","node","parent","type","isFunction","body","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","keywords","functions","classes","additionalProperties","messages","unexpectedSpace","missingSpace","create","context","config","options","sourceCode","alwaysFunctions","alwaysKeywords","alwaysClasses","neverFunctions","neverKeywords","neverClasses","isConflicted","precedingToken","isArrowToken","isKeywordToken","isColonToken","getSwitchCaseColonToken","checkPrecedingSpace","getTokenBefore","isTokenOnSameLine","hasSpace","isSpaceBetweenTokens","requireSpace","requireNoSpace","report","messageId","fix","fixer","insertTextBefore","removeRange","range","checkSpaceBeforeCaseBlock","cases","openingBrace","length","getLastToken","BlockStatement","ClassBody","SwitchStatement"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/space-before-blocks.js"],"sourcesContent":["/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents the body of a function.\n * @param {ASTNode} node the node to check.\n * @returns {boolean} `true` if the node is function body.\n */\nfunction isFunctionBody(node) {\n    const parent = node.parent;\n\n    return (\n        node.type === \"BlockStatement\" &&\n        astUtils.isFunction(parent) &&\n        parent.body === node\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent spacing before blocks\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/space-before-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedSpace: \"Unexpected space before opening brace.\",\n            missingSpace: \"Missing space before opening brace.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.sourceCode;\n        let alwaysFunctions = true,\n            alwaysKeywords = true,\n            alwaysClasses = true,\n            neverFunctions = false,\n            neverKeywords = false,\n            neverClasses = false;\n\n        if (typeof config === \"object\") {\n            alwaysFunctions = config.functions === \"always\";\n            alwaysKeywords = config.keywords === \"always\";\n            alwaysClasses = config.classes === \"always\";\n            neverFunctions = config.functions === \"never\";\n            neverKeywords = config.keywords === \"never\";\n            neverClasses = config.classes === \"never\";\n        } else if (config === \"never\") {\n            alwaysFunctions = false;\n            alwaysKeywords = false;\n            alwaysClasses = false;\n            neverFunctions = true;\n            neverKeywords = true;\n            neverClasses = true;\n        }\n\n        /**\n         * Checks whether the spacing before the given block is already controlled by another rule:\n         * - `arrow-spacing` checks spaces after `=>`.\n         * - `keyword-spacing` checks spaces after keywords in certain contexts.\n         * - `switch-colon-spacing` checks spaces after `:` of switch cases.\n         * @param {Token} precedingToken first token before the block.\n         * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\n         * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\n         */\n        function isConflicted(precedingToken, node) {\n            return (\n                astUtils.isArrowToken(precedingToken) ||\n                (\n                    astUtils.isKeywordToken(precedingToken) &&\n                    !isFunctionBody(node)\n                ) ||\n                (\n                    astUtils.isColonToken(precedingToken) &&\n                    node.parent &&\n                    node.parent.type === \"SwitchCase\" &&\n                    precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode)\n                )\n            );\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n\n            if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                let requireSpace;\n                let requireNoSpace;\n\n                if (isFunctionBody(node)) {\n                    requireSpace = alwaysFunctions;\n                    requireNoSpace = neverFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = alwaysClasses;\n                    requireNoSpace = neverClasses;\n                } else {\n                    requireSpace = alwaysKeywords;\n                    requireNoSpace = neverKeywords;\n                }\n\n                if (requireSpace && !hasSpace) {\n                    context.report({\n                        node,\n                        messageId: \"missingSpace\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                    });\n                } else if (requireNoSpace && hasSpace) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedSpace\",\n                        fix(fixer) {\n                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}