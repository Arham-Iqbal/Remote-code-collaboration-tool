{"ast":null,"code":"var path = require('path');\nvar fs = require('fs');\nvar Keyv = require('keyv');\nvar utils = require('./utils');\nvar del = require('./del');\nvar writeJSON = utils.writeJSON;\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n    me.keyv = new Keyv();\n    me.__visited = {};\n    me.__persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n  get _persisted() {\n    return this.__persisted;\n  },\n  set _persisted(value) {\n    this.__persisted = value;\n    this.keyv.set('persisted', value);\n  },\n  get _visited() {\n    return this.__visited;\n  },\n  set _visited(value) {\n    this.__visited = value;\n    this.keyv.set('visited', value);\n  },\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n    me.load(fName, dir);\n  },\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n    var keys = Object.keys(me._visited);\n\n    // no keys visited for either get or set value\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n    me._visited = {};\n    me._persisted = obj;\n  },\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me.removeCacheFile();\n  }\n};\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  }\n};","map":{"version":3,"names":["path","require","fs","Keyv","utils","del","writeJSON","cache","load","docId","cacheDir","me","keyv","__visited","__persisted","_pathToFile","resolve","__dirname","existsSync","_persisted","tryParse","value","set","_visited","loadFile","pathToFile","dir","dirname","fName","basename","all","keys","Object","setKey","key","removeKey","getKey","_prune","obj","length","forEach","save","noPrune","removeCacheFile","destroy","module","exports","create","createFromFile","filePath","clearCacheById","clearAll"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/flat-cache/src/cache.js"],"sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar Keyv = require('keyv');\nvar utils = require('./utils');\nvar del = require('./del');\nvar writeJSON = utils.writeJSON;\n\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n\n    me.keyv = new Keyv();\n\n    me.__visited = {};\n    me.__persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n\n  get _persisted() {\n    return this.__persisted;\n  },\n\n  set _persisted(value) {\n    this.__persisted = value;\n    this.keyv.set('persisted', value);\n  },\n\n  get _visited() {\n    return this.__visited;\n  },\n\n  set _visited(value) {\n    this.__visited = value;\n    this.keyv.set('visited', value);\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n\n    me.load(fName, dir);\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n\n    var keys = Object.keys(me._visited);\n\n    // no keys visited for either get or set value\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n\n    me.removeCacheFile();\n  },\n};\n\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}