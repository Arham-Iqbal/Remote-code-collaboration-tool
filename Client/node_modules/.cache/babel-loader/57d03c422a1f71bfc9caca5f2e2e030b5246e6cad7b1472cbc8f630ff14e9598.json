{"ast":null,"code":"/**\n * @fileoverview Shared functions to work with configs.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Functions\n//-----------------------------------------------------------------------------\n\n/**\n * Parses a ruleId into its plugin and rule parts.\n * @param {string} ruleId The rule ID to parse.\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\n *      parts of the ruleId;\n */\nfunction parseRuleId(ruleId) {\n  let pluginName, ruleName;\n\n  // distinguish between core rules and plugin rules\n  if (ruleId.includes(\"/\")) {\n    // mimic scoped npm packages\n    if (ruleId.startsWith(\"@\")) {\n      pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\n    } else {\n      pluginName = ruleId.slice(0, ruleId.indexOf(\"/\"));\n    }\n    ruleName = ruleId.slice(pluginName.length + 1);\n  } else {\n    pluginName = \"@\";\n    ruleName = ruleId;\n  }\n  return {\n    pluginName,\n    ruleName\n  };\n}\n\n/**\n * Retrieves a rule instance from a given config based on the ruleId.\n * @param {string} ruleId The rule ID to look for.\n * @param {FlatConfig} config The config to search.\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\n *      or undefined if not.\n */\nfunction getRuleFromConfig(ruleId, config) {\n  const {\n    pluginName,\n    ruleName\n  } = parseRuleId(ruleId);\n  const plugin = config.plugins && config.plugins[pluginName];\n  let rule = plugin && plugin.rules && plugin.rules[ruleName];\n\n  // normalize function rules into objects\n  if (rule && typeof rule === \"function\") {\n    rule = {\n      create: rule\n    };\n  }\n  return rule;\n}\n\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(rule) {\n  if (!rule) {\n    return null;\n  }\n  const schema = rule.schema || rule.meta && rule.meta.schema;\n  if (Array.isArray(schema)) {\n    if (schema.length) {\n      return {\n        type: \"array\",\n        items: schema,\n        minItems: 0,\n        maxItems: schema.length\n      };\n    }\n    return {\n      type: \"array\",\n      minItems: 0,\n      maxItems: 0\n    };\n  }\n\n  // Given a full schema, leave it alone\n  return schema || null;\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n  parseRuleId,\n  getRuleFromConfig,\n  getRuleOptionsSchema\n};","map":{"version":3,"names":["parseRuleId","ruleId","pluginName","ruleName","includes","startsWith","slice","lastIndexOf","indexOf","length","getRuleFromConfig","config","plugin","plugins","rule","rules","create","getRuleOptionsSchema","schema","meta","Array","isArray","type","items","minItems","maxItems","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/config/flat-config-helpers.js"],"sourcesContent":["/**\n * @fileoverview Shared functions to work with configs.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Functions\n//-----------------------------------------------------------------------------\n\n/**\n * Parses a ruleId into its plugin and rule parts.\n * @param {string} ruleId The rule ID to parse.\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\n *      parts of the ruleId;\n */\nfunction parseRuleId(ruleId) {\n    let pluginName, ruleName;\n\n    // distinguish between core rules and plugin rules\n    if (ruleId.includes(\"/\")) {\n\n        // mimic scoped npm packages\n        if (ruleId.startsWith(\"@\")) {\n            pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\n        } else {\n            pluginName = ruleId.slice(0, ruleId.indexOf(\"/\"));\n        }\n\n        ruleName = ruleId.slice(pluginName.length + 1);\n    } else {\n        pluginName = \"@\";\n        ruleName = ruleId;\n    }\n\n    return {\n        pluginName,\n        ruleName\n    };\n}\n\n/**\n * Retrieves a rule instance from a given config based on the ruleId.\n * @param {string} ruleId The rule ID to look for.\n * @param {FlatConfig} config The config to search.\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\n *      or undefined if not.\n */\nfunction getRuleFromConfig(ruleId, config) {\n\n    const { pluginName, ruleName } = parseRuleId(ruleId);\n\n    const plugin = config.plugins && config.plugins[pluginName];\n    let rule = plugin && plugin.rules && plugin.rules[ruleName];\n\n\n    // normalize function rules into objects\n    if (rule && typeof rule === \"function\") {\n        rule = {\n            create: rule\n        };\n    }\n\n    return rule;\n}\n\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(rule) {\n\n    if (!rule) {\n        return null;\n    }\n\n    const schema = rule.schema || rule.meta && rule.meta.schema;\n\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n        return {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 0\n        };\n\n    }\n\n    // Given a full schema, leave it alone\n    return schema || null;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    parseRuleId,\n    getRuleFromConfig,\n    getRuleOptionsSchema\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAWA,CAACC,MAAM,EAAE;EACzB,IAAIC,UAAU,EAAEC,QAAQ;;EAExB;EACA,IAAIF,MAAM,CAACG,QAAQ,CAAC,GAAG,CAAC,EAAE;IAEtB;IACA,IAAIH,MAAM,CAACI,UAAU,CAAC,GAAG,CAAC,EAAE;MACxBH,UAAU,GAAGD,MAAM,CAACK,KAAK,CAAC,CAAC,EAAEL,MAAM,CAACM,WAAW,CAAC,GAAG,CAAC,CAAC;IACzD,CAAC,MAAM;MACHL,UAAU,GAAGD,MAAM,CAACK,KAAK,CAAC,CAAC,EAAEL,MAAM,CAACO,OAAO,CAAC,GAAG,CAAC,CAAC;IACrD;IAEAL,QAAQ,GAAGF,MAAM,CAACK,KAAK,CAACJ,UAAU,CAACO,MAAM,GAAG,CAAC,CAAC;EAClD,CAAC,MAAM;IACHP,UAAU,GAAG,GAAG;IAChBC,QAAQ,GAAGF,MAAM;EACrB;EAEA,OAAO;IACHC,UAAU;IACVC;EACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,iBAAiBA,CAACT,MAAM,EAAEU,MAAM,EAAE;EAEvC,MAAM;IAAET,UAAU;IAAEC;EAAS,CAAC,GAAGH,WAAW,CAACC,MAAM,CAAC;EAEpD,MAAMW,MAAM,GAAGD,MAAM,CAACE,OAAO,IAAIF,MAAM,CAACE,OAAO,CAACX,UAAU,CAAC;EAC3D,IAAIY,IAAI,GAAGF,MAAM,IAAIA,MAAM,CAACG,KAAK,IAAIH,MAAM,CAACG,KAAK,CAACZ,QAAQ,CAAC;;EAG3D;EACA,IAAIW,IAAI,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;IACpCA,IAAI,GAAG;MACHE,MAAM,EAAEF;IACZ,CAAC;EACL;EAEA,OAAOA,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASG,oBAAoBA,CAACH,IAAI,EAAE;EAEhC,IAAI,CAACA,IAAI,EAAE;IACP,OAAO,IAAI;EACf;EAEA,MAAMI,MAAM,GAAGJ,IAAI,CAACI,MAAM,IAAIJ,IAAI,CAACK,IAAI,IAAIL,IAAI,CAACK,IAAI,CAACD,MAAM;EAE3D,IAAIE,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE;IACvB,IAAIA,MAAM,CAACT,MAAM,EAAE;MACf,OAAO;QACHa,IAAI,EAAE,OAAO;QACbC,KAAK,EAAEL,MAAM;QACbM,QAAQ,EAAE,CAAC;QACXC,QAAQ,EAAEP,MAAM,CAACT;MACrB,CAAC;IACL;IACA,OAAO;MACHa,IAAI,EAAE,OAAO;MACbE,QAAQ,EAAE,CAAC;MACXC,QAAQ,EAAE;IACd,CAAC;EAEL;;EAEA;EACA,OAAOP,MAAM,IAAI,IAAI;AACzB;;AAGA;AACA;AACA;;AAEAQ,MAAM,CAACC,OAAO,GAAG;EACb3B,WAAW;EACXU,iBAAiB;EACjBO;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}