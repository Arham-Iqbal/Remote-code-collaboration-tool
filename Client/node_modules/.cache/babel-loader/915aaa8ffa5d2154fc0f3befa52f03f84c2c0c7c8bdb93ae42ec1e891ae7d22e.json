{"ast":null,"code":"/**\n * @fileoverview Rule to require grouped accessor pairs in object literals and classes\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n  for (let i = 0; i < left.length; i++) {\n    const leftToken = left[i],\n      rightToken = right[i];\n    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    // Statically computed names.\n    return left === right;\n  }\n  if (Array.isArray(left) && Array.isArray(right)) {\n    // Token lists.\n    return areEqualTokenLists(left, right);\n  }\n  return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require grouped accessor pairs in object literals and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/grouped-accessor-pairs\"\n    },\n    schema: [{\n      enum: [\"anyOrder\", \"getBeforeSet\", \"setBeforeGet\"]\n    }],\n    messages: {\n      notGrouped: \"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.\",\n      invalidOrder: \"Expected {{ latterName }} to be before {{ formerName }}.\"\n    }\n  },\n  create(context) {\n    const order = context.options[0] || \"anyOrder\";\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Reports the given accessor pair.\n     * @param {string} messageId messageId to report.\n     * @param {ASTNode} formerNode getter/setter node that is defined before `latterNode`.\n     * @param {ASTNode} latterNode getter/setter node that is defined after `formerNode`.\n     * @returns {void}\n     * @private\n     */\n    function report(messageId, formerNode, latterNode) {\n      context.report({\n        node: latterNode,\n        messageId,\n        loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),\n        data: {\n          formerName: astUtils.getFunctionNameWithKind(formerNode.value),\n          latterName: astUtils.getFunctionNameWithKind(latterNode.value)\n        }\n      });\n    }\n\n    /**\n     * Checks accessor pairs in the given list of nodes.\n     * @param {ASTNode[]} nodes The list to check.\n     * @param {Function} shouldCheck – Predicate that returns `true` if the node should be checked.\n     * @returns {void}\n     * @private\n     */\n    function checkList(nodes, shouldCheck) {\n      const accessors = [];\n      let found = false;\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (shouldCheck(node) && isAccessorKind(node)) {\n          // Creates a new `AccessorData` object for the given getter or setter node.\n          const name = astUtils.getStaticPropertyName(node);\n          const key = name !== null ? name : sourceCode.getTokens(node.key);\n\n          // Merges the given `AccessorData` object into the given accessors list.\n          for (let j = 0; j < accessors.length; j++) {\n            const accessor = accessors[j];\n            if (areEqualKeys(accessor.key, key)) {\n              accessor.getters.push(...(node.kind === \"get\" ? [node] : []));\n              accessor.setters.push(...(node.kind === \"set\" ? [node] : []));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            accessors.push({\n              key,\n              getters: node.kind === \"get\" ? [node] : [],\n              setters: node.kind === \"set\" ? [node] : []\n            });\n          }\n          found = false;\n        }\n      }\n      for (const {\n        getters,\n        setters\n      } of accessors) {\n        // Don't report accessor properties that have duplicate getters or setters.\n        if (getters.length === 1 && setters.length === 1) {\n          const [getter] = getters,\n            [setter] = setters,\n            getterIndex = nodes.indexOf(getter),\n            setterIndex = nodes.indexOf(setter),\n            formerNode = getterIndex < setterIndex ? getter : setter,\n            latterNode = getterIndex < setterIndex ? setter : getter;\n          if (Math.abs(getterIndex - setterIndex) > 1) {\n            report(\"notGrouped\", formerNode, latterNode);\n          } else if (order === \"getBeforeSet\" && getterIndex > setterIndex || order === \"setBeforeGet\" && getterIndex < setterIndex) {\n            report(\"invalidOrder\", formerNode, latterNode);\n          }\n        }\n      }\n    }\n    return {\n      ObjectExpression(node) {\n        checkList(node.properties, n => n.type === \"Property\");\n      },\n      ClassBody(node) {\n        checkList(node.body, n => n.type === \"MethodDefinition\" && !n.static);\n        checkList(node.body, n => n.type === \"MethodDefinition\" && n.static);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","areEqualTokenLists","left","right","length","i","leftToken","rightToken","type","value","areEqualKeys","Array","isArray","isAccessorKind","node","kind","module","exports","meta","docs","description","recommended","url","schema","enum","messages","notGrouped","invalidOrder","create","context","order","options","sourceCode","report","messageId","formerNode","latterNode","loc","getFunctionHeadLoc","data","formerName","getFunctionNameWithKind","latterName","checkList","nodes","shouldCheck","accessors","found","name","getStaticPropertyName","key","getTokens","j","accessor","getters","push","setters","getter","setter","getterIndex","indexOf","setterIndex","Math","abs","ObjectExpression","properties","n","ClassBody","body","static"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/grouped-accessor-pairs.js"],"sourcesContent":["/**\n * @fileoverview Rule to require grouped accessor pairs in object literals and classes\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n\n    for (let i = 0; i < left.length; i++) {\n        const leftToken = left[i],\n            rightToken = right[i];\n\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n    if (typeof left === \"string\" && typeof right === \"string\") {\n\n        // Statically computed names.\n        return left === right;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n\n        // Token lists.\n        return areEqualTokenLists(left, right);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n    return node.kind === \"get\" || node.kind === \"set\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require grouped accessor pairs in object literals and classes\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/grouped-accessor-pairs\"\n        },\n\n        schema: [\n            {\n                enum: [\"anyOrder\", \"getBeforeSet\", \"setBeforeGet\"]\n            }\n        ],\n\n        messages: {\n            notGrouped: \"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.\",\n            invalidOrder: \"Expected {{ latterName }} to be before {{ formerName }}.\"\n        }\n    },\n\n    create(context) {\n        const order = context.options[0] || \"anyOrder\";\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports the given accessor pair.\n         * @param {string} messageId messageId to report.\n         * @param {ASTNode} formerNode getter/setter node that is defined before `latterNode`.\n         * @param {ASTNode} latterNode getter/setter node that is defined after `formerNode`.\n         * @returns {void}\n         * @private\n         */\n        function report(messageId, formerNode, latterNode) {\n            context.report({\n                node: latterNode,\n                messageId,\n                loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),\n                data: {\n                    formerName: astUtils.getFunctionNameWithKind(formerNode.value),\n                    latterName: astUtils.getFunctionNameWithKind(latterNode.value)\n                }\n            });\n        }\n\n        /**\n         * Checks accessor pairs in the given list of nodes.\n         * @param {ASTNode[]} nodes The list to check.\n         * @param {Function} shouldCheck – Predicate that returns `true` if the node should be checked.\n         * @returns {void}\n         * @private\n         */\n        function checkList(nodes, shouldCheck) {\n            const accessors = [];\n            let found = false;\n\n            for (let i = 0; i < nodes.length; i++) {\n                const node = nodes[i];\n\n                if (shouldCheck(node) && isAccessorKind(node)) {\n\n                    // Creates a new `AccessorData` object for the given getter or setter node.\n                    const name = astUtils.getStaticPropertyName(node);\n                    const key = (name !== null) ? name : sourceCode.getTokens(node.key);\n\n                    // Merges the given `AccessorData` object into the given accessors list.\n                    for (let j = 0; j < accessors.length; j++) {\n                        const accessor = accessors[j];\n\n                        if (areEqualKeys(accessor.key, key)) {\n                            accessor.getters.push(...node.kind === \"get\" ? [node] : []);\n                            accessor.setters.push(...node.kind === \"set\" ? [node] : []);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        accessors.push({\n                            key,\n                            getters: node.kind === \"get\" ? [node] : [],\n                            setters: node.kind === \"set\" ? [node] : []\n                        });\n                    }\n                    found = false;\n                }\n            }\n\n            for (const { getters, setters } of accessors) {\n\n                // Don't report accessor properties that have duplicate getters or setters.\n                if (getters.length === 1 && setters.length === 1) {\n                    const [getter] = getters,\n                        [setter] = setters,\n                        getterIndex = nodes.indexOf(getter),\n                        setterIndex = nodes.indexOf(setter),\n                        formerNode = getterIndex < setterIndex ? getter : setter,\n                        latterNode = getterIndex < setterIndex ? setter : getter;\n\n                    if (Math.abs(getterIndex - setterIndex) > 1) {\n                        report(\"notGrouped\", formerNode, latterNode);\n                    } else if (\n                        (order === \"getBeforeSet\" && getterIndex > setterIndex) ||\n                        (order === \"setBeforeGet\" && getterIndex < setterIndex)\n                    ) {\n                        report(\"invalidOrder\", formerNode, latterNode);\n                    }\n                }\n            }\n        }\n\n        return {\n            ObjectExpression(node) {\n                checkList(node.properties, n => n.type === \"Property\");\n            },\n            ClassBody(node) {\n                checkList(node.body, n => n.type === \"MethodDefinition\" && !n.static);\n                checkList(node.body, n => n.type === \"MethodDefinition\" && n.static);\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}