{"ast":null,"code":"/**\n * @fileoverview Rule to enforce getter and setter pairs in objects and classes.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n  for (let i = 0; i < left.length; i++) {\n    const leftToken = left[i],\n      rightToken = right[i];\n    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    // Statically computed names.\n    return left === right;\n  }\n  if (Array.isArray(left) && Array.isArray(right)) {\n    // Token lists.\n    return areEqualTokenLists(left, right);\n  }\n  return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node A node to check.\n * @param {number} index An expected index of the node in arguments.\n * @param {string} object An expected name of the object of the method.\n * @param {string} property An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n  const parent = node.parent;\n  return parent.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node;\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n  // Object.defineProperty(obj, \"foo\", {set: ...})\n  if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") || isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")) {\n    return true;\n  }\n\n  /*\n   * Object.defineProperties(obj, {foo: {set: ...}})\n   * Object.create(proto, {foo: {set: ...}})\n   */\n  const grandparent = node.parent.parent;\n  return grandparent.type === \"ObjectExpression\" && (isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") || isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\"));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce getter and setter pairs in objects and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/accessor-pairs\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        getWithoutSet: {\n          type: \"boolean\",\n          default: false\n        },\n        setWithoutGet: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\n      missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\n      missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\n      missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\n      missingGetterInClass: \"Getter is not present for class {{ name }}.\",\n      missingSetterInClass: \"Setter is not present for class {{ name }}.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || {};\n    const checkGetWithoutSet = config.getWithoutSet === true;\n    const checkSetWithoutGet = config.setWithoutGet !== false;\n    const enforceForClassMembers = config.enforceForClassMembers !== false;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Reports the given node.\n     * @param {ASTNode} node The node to report.\n     * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n     * @returns {void}\n     * @private\n     */\n    function report(node, messageKind) {\n      if (node.type === \"Property\") {\n        context.report({\n          node,\n          messageId: `${messageKind}InObjectLiteral`,\n          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n          data: {\n            name: astUtils.getFunctionNameWithKind(node.value)\n          }\n        });\n      } else if (node.type === \"MethodDefinition\") {\n        context.report({\n          node,\n          messageId: `${messageKind}InClass`,\n          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n          data: {\n            name: astUtils.getFunctionNameWithKind(node.value)\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: `${messageKind}InPropertyDescriptor`\n        });\n      }\n    }\n\n    /**\n     * Reports each of the nodes in the given list using the same messageId.\n     * @param {ASTNode[]} nodes Nodes to report.\n     * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n     * @returns {void}\n     * @private\n     */\n    function reportList(nodes, messageKind) {\n      for (const node of nodes) {\n        report(node, messageKind);\n      }\n    }\n\n    /**\n     * Checks accessor pairs in the given list of nodes.\n     * @param {ASTNode[]} nodes The list to check.\n     * @returns {void}\n     * @private\n     */\n    function checkList(nodes) {\n      const accessors = [];\n      let found = false;\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (isAccessorKind(node)) {\n          // Creates a new `AccessorData` object for the given getter or setter node.\n          const name = astUtils.getStaticPropertyName(node);\n          const key = name !== null ? name : sourceCode.getTokens(node.key);\n\n          // Merges the given `AccessorData` object into the given accessors list.\n          for (let j = 0; j < accessors.length; j++) {\n            const accessor = accessors[j];\n            if (areEqualKeys(accessor.key, key)) {\n              accessor.getters.push(...(node.kind === \"get\" ? [node] : []));\n              accessor.setters.push(...(node.kind === \"set\" ? [node] : []));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            accessors.push({\n              key,\n              getters: node.kind === \"get\" ? [node] : [],\n              setters: node.kind === \"set\" ? [node] : []\n            });\n          }\n          found = false;\n        }\n      }\n      for (const {\n        getters,\n        setters\n      } of accessors) {\n        if (checkSetWithoutGet && setters.length && !getters.length) {\n          reportList(setters, \"missingGetter\");\n        }\n        if (checkGetWithoutSet && getters.length && !setters.length) {\n          reportList(getters, \"missingSetter\");\n        }\n      }\n    }\n\n    /**\n     * Checks accessor pairs in an object literal.\n     * @param {ASTNode} node `ObjectExpression` node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkObjectLiteral(node) {\n      checkList(node.properties.filter(p => p.type === \"Property\"));\n    }\n\n    /**\n     * Checks accessor pairs in a property descriptor.\n     * @param {ASTNode} node Property descriptor `ObjectExpression` node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkPropertyDescriptor(node) {\n      const namesToCheck = new Set(node.properties.filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed).map(({\n        key\n      }) => key.name));\n      const hasGetter = namesToCheck.has(\"get\");\n      const hasSetter = namesToCheck.has(\"set\");\n      if (checkSetWithoutGet && hasSetter && !hasGetter) {\n        report(node, \"missingGetter\");\n      }\n      if (checkGetWithoutSet && hasGetter && !hasSetter) {\n        report(node, \"missingSetter\");\n      }\n    }\n\n    /**\n     * Checks the given object expression as an object literal and as a possible property descriptor.\n     * @param {ASTNode} node `ObjectExpression` node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkObjectExpression(node) {\n      checkObjectLiteral(node);\n      if (isPropertyDescriptor(node)) {\n        checkPropertyDescriptor(node);\n      }\n    }\n\n    /**\n     * Checks the given class body.\n     * @param {ASTNode} node `ClassBody` node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkClassBody(node) {\n      const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\n      checkList(methodDefinitions.filter(m => m.static));\n      checkList(methodDefinitions.filter(m => !m.static));\n    }\n    const listeners = {};\n    if (checkSetWithoutGet || checkGetWithoutSet) {\n      listeners.ObjectExpression = checkObjectExpression;\n      if (enforceForClassMembers) {\n        listeners.ClassBody = checkClassBody;\n      }\n    }\n    return listeners;\n  }\n};","map":{"version":3,"names":["astUtils","require","areEqualTokenLists","left","right","length","i","leftToken","rightToken","type","value","areEqualKeys","Array","isArray","isAccessorKind","node","kind","isArgumentOfMethodCall","index","object","property","parent","isSpecificMemberAccess","callee","arguments","isPropertyDescriptor","grandparent","module","exports","meta","docs","description","recommended","url","schema","properties","getWithoutSet","default","setWithoutGet","enforceForClassMembers","additionalProperties","messages","missingGetterInPropertyDescriptor","missingSetterInPropertyDescriptor","missingGetterInObjectLiteral","missingSetterInObjectLiteral","missingGetterInClass","missingSetterInClass","create","context","config","options","checkGetWithoutSet","checkSetWithoutGet","sourceCode","report","messageKind","messageId","loc","getFunctionHeadLoc","data","name","getFunctionNameWithKind","reportList","nodes","checkList","accessors","found","getStaticPropertyName","key","getTokens","j","accessor","getters","push","setters","checkObjectLiteral","filter","p","checkPropertyDescriptor","namesToCheck","Set","computed","map","hasGetter","has","hasSetter","checkObjectExpression","checkClassBody","methodDefinitions","body","m","static","listeners","ObjectExpression","ClassBody"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/accessor-pairs.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce getter and setter pairs in objects and classes.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n\n    for (let i = 0; i < left.length; i++) {\n        const leftToken = left[i],\n            rightToken = right[i];\n\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n    if (typeof left === \"string\" && typeof right === \"string\") {\n\n        // Statically computed names.\n        return left === right;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n\n        // Token lists.\n        return areEqualTokenLists(left, right);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n    return node.kind === \"get\" || node.kind === \"set\";\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node A node to check.\n * @param {number} index An expected index of the node in arguments.\n * @param {string} object An expected name of the object of the method.\n * @param {string} property An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(parent.callee, object, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    const grandparent = node.parent.parent;\n\n    return grandparent.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce getter and setter pairs in objects and classes\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/accessor-pairs\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\",\n                    default: false\n                },\n                setWithoutGet: {\n                    type: \"boolean\",\n                    default: true\n                },\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\n            missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\n            missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\n            missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\n            missingGetterInClass: \"Getter is not present for class {{ name }}.\",\n            missingSetterInClass: \"Setter is not present for class {{ name }}.\"\n        }\n    },\n    create(context) {\n        const config = context.options[0] || {};\n        const checkGetWithoutSet = config.getWithoutSet === true;\n        const checkSetWithoutGet = config.setWithoutGet !== false;\n        const enforceForClassMembers = config.enforceForClassMembers !== false;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n         * @returns {void}\n         * @private\n         */\n        function report(node, messageKind) {\n            if (node.type === \"Property\") {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InObjectLiteral`,\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\n                });\n            } else if (node.type === \"MethodDefinition\") {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InClass`,\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InPropertyDescriptor`\n                });\n            }\n        }\n\n        /**\n         * Reports each of the nodes in the given list using the same messageId.\n         * @param {ASTNode[]} nodes Nodes to report.\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n         * @returns {void}\n         * @private\n         */\n        function reportList(nodes, messageKind) {\n            for (const node of nodes) {\n                report(node, messageKind);\n            }\n        }\n\n        /**\n         * Checks accessor pairs in the given list of nodes.\n         * @param {ASTNode[]} nodes The list to check.\n         * @returns {void}\n         * @private\n         */\n        function checkList(nodes) {\n            const accessors = [];\n            let found = false;\n\n            for (let i = 0; i < nodes.length; i++) {\n                const node = nodes[i];\n\n                if (isAccessorKind(node)) {\n\n                    // Creates a new `AccessorData` object for the given getter or setter node.\n                    const name = astUtils.getStaticPropertyName(node);\n                    const key = (name !== null) ? name : sourceCode.getTokens(node.key);\n\n                    // Merges the given `AccessorData` object into the given accessors list.\n                    for (let j = 0; j < accessors.length; j++) {\n                        const accessor = accessors[j];\n\n                        if (areEqualKeys(accessor.key, key)) {\n                            accessor.getters.push(...node.kind === \"get\" ? [node] : []);\n                            accessor.setters.push(...node.kind === \"set\" ? [node] : []);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        accessors.push({\n                            key,\n                            getters: node.kind === \"get\" ? [node] : [],\n                            setters: node.kind === \"set\" ? [node] : []\n                        });\n                    }\n                    found = false;\n                }\n            }\n\n            for (const { getters, setters } of accessors) {\n                if (checkSetWithoutGet && setters.length && !getters.length) {\n                    reportList(setters, \"missingGetter\");\n                }\n                if (checkGetWithoutSet && getters.length && !setters.length) {\n                    reportList(getters, \"missingSetter\");\n                }\n            }\n        }\n\n        /**\n         * Checks accessor pairs in an object literal.\n         * @param {ASTNode} node `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkObjectLiteral(node) {\n            checkList(node.properties.filter(p => p.type === \"Property\"));\n        }\n\n        /**\n         * Checks accessor pairs in a property descriptor.\n         * @param {ASTNode} node Property descriptor `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkPropertyDescriptor(node) {\n            const namesToCheck = new Set(node.properties\n                .filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed)\n                .map(({ key }) => key.name));\n\n            const hasGetter = namesToCheck.has(\"get\");\n            const hasSetter = namesToCheck.has(\"set\");\n\n            if (checkSetWithoutGet && hasSetter && !hasGetter) {\n                report(node, \"missingGetter\");\n            }\n            if (checkGetWithoutSet && hasGetter && !hasSetter) {\n                report(node, \"missingSetter\");\n            }\n        }\n\n        /**\n         * Checks the given object expression as an object literal and as a possible property descriptor.\n         * @param {ASTNode} node `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkObjectExpression(node) {\n            checkObjectLiteral(node);\n            if (isPropertyDescriptor(node)) {\n                checkPropertyDescriptor(node);\n            }\n        }\n\n        /**\n         * Checks the given class body.\n         * @param {ASTNode} node `ClassBody` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkClassBody(node) {\n            const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\n\n            checkList(methodDefinitions.filter(m => m.static));\n            checkList(methodDefinitions.filter(m => !m.static));\n        }\n\n        const listeners = {};\n\n        if (checkSetWithoutGet || checkGetWithoutSet) {\n            listeners.ObjectExpression = checkObjectExpression;\n            if (enforceForClassMembers) {\n                listeners.ClassBody = checkClassBody;\n            }\n        }\n\n        return listeners;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}