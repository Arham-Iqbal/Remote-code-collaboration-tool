{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused private class members\n * @author Tim van der Lippe\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow unused private class members\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-unused-private-class-members\"\n    },\n    schema: [],\n    messages: {\n      unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\n    }\n  },\n  create(context) {\n    const trackedClasses = [];\n\n    /**\n     * Check whether the current node is in a write only assignment.\n     * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\n     * @returns {boolean} Whether the node is in a write only assignment\n     * @private\n     */\n    function isWriteOnlyAssignment(privateIdentifierNode) {\n      const parentStatement = privateIdentifierNode.parent.parent;\n      const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\n      if (!isAssignmentExpression && parentStatement.type !== \"ForInStatement\" && parentStatement.type !== \"ForOfStatement\" && parentStatement.type !== \"AssignmentPattern\") {\n        return false;\n      }\n\n      // It is a write-only usage, since we still allow usages on the right for reads\n      if (parentStatement.left !== privateIdentifierNode.parent) {\n        return false;\n      }\n\n      // For any other operator (such as '+=') we still consider it a read operation\n      if (isAssignmentExpression && parentStatement.operator !== \"=\") {\n        /*\n         * However, if the read operation is \"discarded\" in an empty statement, then\n         * we consider it write only.\n         */\n        return parentStatement.parent.type === \"ExpressionStatement\";\n      }\n      return true;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      // Collect all declared members up front and assume they are all unused\n      ClassBody(classBodyNode) {\n        const privateMembers = new Map();\n        trackedClasses.unshift(privateMembers);\n        for (const bodyMember of classBodyNode.body) {\n          if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\n            if (bodyMember.key.type === \"PrivateIdentifier\") {\n              privateMembers.set(bodyMember.key.name, {\n                declaredNode: bodyMember,\n                isAccessor: bodyMember.type === \"MethodDefinition\" && (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\n              });\n            }\n          }\n        }\n      },\n      /*\n       * Process all usages of the private identifier and remove a member from\n       * `declaredAndUnusedPrivateMembers` if we deem it used.\n       */\n      PrivateIdentifier(privateIdentifierNode) {\n        const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name));\n\n        // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\n        if (!classBody) {\n          return;\n        }\n\n        // In case any other usage was already detected, we can short circuit the logic here.\n        const memberDefinition = classBody.get(privateIdentifierNode.name);\n        if (memberDefinition.isUsed) {\n          return;\n        }\n\n        // The definition of the class member itself\n        if (privateIdentifierNode.parent.type === \"PropertyDefinition\" || privateIdentifierNode.parent.type === \"MethodDefinition\") {\n          return;\n        }\n\n        /*\n         * Any usage of an accessor is considered a read, as the getter/setter can have\n         * side-effects in its definition.\n         */\n        if (memberDefinition.isAccessor) {\n          memberDefinition.isUsed = true;\n          return;\n        }\n\n        // Any assignments to this member, except for assignments that also read\n        if (isWriteOnlyAssignment(privateIdentifierNode)) {\n          return;\n        }\n        const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\n        const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;\n\n        // A statement which only increments (`this.#x++;`)\n        if (wrappingExpressionType === \"UpdateExpression\" && parentOfWrappingExpressionType === \"ExpressionStatement\") {\n          return;\n        }\n\n        /*\n         * ({ x: this.#usedInDestructuring } = bar);\n         *\n         * But should treat the following as a read:\n         * ({ [this.#x]: a } = foo);\n         */\n        if (wrappingExpressionType === \"Property\" && parentOfWrappingExpressionType === \"ObjectPattern\" && privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\n          return;\n        }\n\n        // [...this.#unusedInRestPattern] = bar;\n        if (wrappingExpressionType === \"RestElement\") {\n          return;\n        }\n\n        // [this.#unusedInAssignmentPattern] = bar;\n        if (wrappingExpressionType === \"ArrayPattern\") {\n          return;\n        }\n\n        /*\n         * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\n         * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\n         * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\n         * as used, which is incorrect.\n         */\n        memberDefinition.isUsed = true;\n      },\n      /*\n       * Post-process the class members and report any remaining members.\n       * Since private members can only be accessed in the current class context,\n       * we can safely assume that all usages are within the current class body.\n       */\n      \"ClassBody:exit\"() {\n        const unusedPrivateMembers = trackedClasses.shift();\n        for (const [classMemberName, {\n          declaredNode,\n          isUsed\n        }] of unusedPrivateMembers.entries()) {\n          if (isUsed) {\n            continue;\n          }\n          context.report({\n            node: declaredNode,\n            loc: declaredNode.key.loc,\n            messageId: \"unusedPrivateClassMember\",\n            data: {\n              classMemberName: `#${classMemberName}`\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","unusedPrivateClassMember","create","context","trackedClasses","isWriteOnlyAssignment","privateIdentifierNode","parentStatement","parent","isAssignmentExpression","left","operator","ClassBody","classBodyNode","privateMembers","Map","unshift","bodyMember","body","key","set","name","declaredNode","isAccessor","kind","PrivateIdentifier","classBody","find","classProperties","has","memberDefinition","get","isUsed","wrappingExpressionType","parentOfWrappingExpressionType","value","ClassBody:exit","unusedPrivateMembers","shift","classMemberName","entries","report","node","loc","messageId","data"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-unused-private-class-members.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused private class members\n * @author Tim van der Lippe\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unused private class members\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-private-class-members\"\n        },\n\n        schema: [],\n\n        messages: {\n            unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const trackedClasses = [];\n\n        /**\n         * Check whether the current node is in a write only assignment.\n         * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\n         * @returns {boolean} Whether the node is in a write only assignment\n         * @private\n         */\n        function isWriteOnlyAssignment(privateIdentifierNode) {\n            const parentStatement = privateIdentifierNode.parent.parent;\n            const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\n\n            if (!isAssignmentExpression &&\n                parentStatement.type !== \"ForInStatement\" &&\n                parentStatement.type !== \"ForOfStatement\" &&\n                parentStatement.type !== \"AssignmentPattern\") {\n                return false;\n            }\n\n            // It is a write-only usage, since we still allow usages on the right for reads\n            if (parentStatement.left !== privateIdentifierNode.parent) {\n                return false;\n            }\n\n            // For any other operator (such as '+=') we still consider it a read operation\n            if (isAssignmentExpression && parentStatement.operator !== \"=\") {\n\n                /*\n                 * However, if the read operation is \"discarded\" in an empty statement, then\n                 * we consider it write only.\n                 */\n                return parentStatement.parent.type === \"ExpressionStatement\";\n            }\n\n            return true;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // Collect all declared members up front and assume they are all unused\n            ClassBody(classBodyNode) {\n                const privateMembers = new Map();\n\n                trackedClasses.unshift(privateMembers);\n                for (const bodyMember of classBodyNode.body) {\n                    if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\n                        if (bodyMember.key.type === \"PrivateIdentifier\") {\n                            privateMembers.set(bodyMember.key.name, {\n                                declaredNode: bodyMember,\n                                isAccessor: bodyMember.type === \"MethodDefinition\" &&\n                                    (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\n                            });\n                        }\n                    }\n                }\n            },\n\n            /*\n             * Process all usages of the private identifier and remove a member from\n             * `declaredAndUnusedPrivateMembers` if we deem it used.\n             */\n            PrivateIdentifier(privateIdentifierNode) {\n                const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name));\n\n                // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\n                if (!classBody) {\n                    return;\n                }\n\n                // In case any other usage was already detected, we can short circuit the logic here.\n                const memberDefinition = classBody.get(privateIdentifierNode.name);\n\n                if (memberDefinition.isUsed) {\n                    return;\n                }\n\n                // The definition of the class member itself\n                if (privateIdentifierNode.parent.type === \"PropertyDefinition\" ||\n                    privateIdentifierNode.parent.type === \"MethodDefinition\") {\n                    return;\n                }\n\n                /*\n                 * Any usage of an accessor is considered a read, as the getter/setter can have\n                 * side-effects in its definition.\n                 */\n                if (memberDefinition.isAccessor) {\n                    memberDefinition.isUsed = true;\n                    return;\n                }\n\n                // Any assignments to this member, except for assignments that also read\n                if (isWriteOnlyAssignment(privateIdentifierNode)) {\n                    return;\n                }\n\n                const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\n                const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;\n\n                // A statement which only increments (`this.#x++;`)\n                if (wrappingExpressionType === \"UpdateExpression\" &&\n                    parentOfWrappingExpressionType === \"ExpressionStatement\") {\n                    return;\n                }\n\n                /*\n                 * ({ x: this.#usedInDestructuring } = bar);\n                 *\n                 * But should treat the following as a read:\n                 * ({ [this.#x]: a } = foo);\n                 */\n                if (wrappingExpressionType === \"Property\" &&\n                    parentOfWrappingExpressionType === \"ObjectPattern\" &&\n                    privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\n                    return;\n                }\n\n                // [...this.#unusedInRestPattern] = bar;\n                if (wrappingExpressionType === \"RestElement\") {\n                    return;\n                }\n\n                // [this.#unusedInAssignmentPattern] = bar;\n                if (wrappingExpressionType === \"ArrayPattern\") {\n                    return;\n                }\n\n                /*\n                 * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\n                 * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\n                 * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\n                 * as used, which is incorrect.\n                 */\n                memberDefinition.isUsed = true;\n            },\n\n            /*\n             * Post-process the class members and report any remaining members.\n             * Since private members can only be accessed in the current class context,\n             * we can safely assume that all usages are within the current class body.\n             */\n            \"ClassBody:exit\"() {\n                const unusedPrivateMembers = trackedClasses.shift();\n\n                for (const [classMemberName, { declaredNode, isUsed }] of unusedPrivateMembers.entries()) {\n                    if (isUsed) {\n                        continue;\n                    }\n                    context.report({\n                        node: declaredNode,\n                        loc: declaredNode.key.loc,\n                        messageId: \"unusedPrivateClassMember\",\n                        data: {\n                            classMemberName: `#${classMemberName}`\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}