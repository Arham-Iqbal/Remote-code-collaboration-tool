{"ast":null,"code":"/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint class-methods-use-this: off -- Methods desired on instance */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst levn = require(\"levn\"),\n  {\n    Legacy: {\n      ConfigOps\n    }\n  } = require(\"@eslint/eslintrc/universal\"),\n  {\n    directivesPattern\n  } = require(\"../shared/directives\");\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n  /**\n   * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n   * whitespace. Used for \"global\" and \"exported\" comments.\n   * @param {string} string The string to parse.\n   * @param {Comment} comment The comment node which has the string.\n   * @returns {Object} Result map object of names and string values, or null values if no value was provided\n   */\n  parseStringConfig(string, comment) {\n    debug(\"Parsing String config\");\n    const items = {};\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n    const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n    trimmedString.split(/\\s|,+/u).forEach(name => {\n      if (!name) {\n        return;\n      }\n\n      // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n      const [key, value = null] = name.split(\":\");\n      items[key] = {\n        value,\n        comment\n      };\n    });\n    return items;\n  }\n\n  /**\n   * Parses a JSON-like config.\n   * @param {string} string The string to parse.\n   * @param {Object} location Start line and column of comments for potential error message.\n   * @returns {({success: true, config: Object}|{success: false, error: LintMessage})} Result map object\n   */\n  parseJsonConfig(string, location) {\n    debug(\"Parsing JSON config\");\n    let items = {};\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n    try {\n      items = levn.parse(\"Object\", string) || {};\n\n      // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n      // Also, commaless notations have invalid severity:\n      //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n      // Should ignore that case as well.\n      if (ConfigOps.isEverySeverityValid(items)) {\n        return {\n          success: true,\n          config: items\n        };\n      }\n    } catch {\n      debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n      // ignore to parse the string by a fallback.\n    }\n\n    /*\n     * Optionator cannot parse commaless notations.\n     * But we are supporting that. So this is a fallback for that.\n     */\n    items = {};\n    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n    try {\n      items = JSON.parse(`{${normalizedString}}`);\n    } catch (ex) {\n      debug(\"Manual parsing failed.\");\n      return {\n        success: false,\n        error: {\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n          line: location.start.line,\n          column: location.start.column + 1,\n          nodeType: null\n        }\n      };\n    }\n    return {\n      success: true,\n      config: items\n    };\n  }\n\n  /**\n   * Parses a config of values separated by comma.\n   * @param {string} string The string to parse.\n   * @returns {Object} Result map of values and true values\n   */\n  parseListConfig(string) {\n    debug(\"Parsing list config\");\n    const items = {};\n    string.split(\",\").forEach(name => {\n      const trimmedName = name.trim().replace(/^(?<quote>['\"]?)(?<ruleId>.*)\\k<quote>$/us, \"$<ruleId>\");\n      if (trimmedName) {\n        items[trimmedName] = true;\n      }\n    });\n    return items;\n  }\n\n  /**\n   * Extract the directive and the justification from a given directive comment and trim them.\n   * @param {string} value The comment text to extract.\n   * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.\n   */\n  extractDirectiveComment(value) {\n    const match = /\\s-{2,}\\s/u.exec(value);\n    if (!match) {\n      return {\n        directivePart: value.trim(),\n        justificationPart: \"\"\n      };\n    }\n    const directive = value.slice(0, match.index).trim();\n    const justification = value.slice(match.index + match[0].length).trim();\n    return {\n      directivePart: directive,\n      justificationPart: justification\n    };\n  }\n\n  /**\n   * Parses a directive comment into directive text and value.\n   * @param {Comment} comment The comment node with the directive to be parsed.\n   * @returns {{directiveText: string, directiveValue: string}} The directive text and value.\n   */\n  parseDirective(comment) {\n    const {\n      directivePart\n    } = this.extractDirectiveComment(comment.value);\n    const match = directivesPattern.exec(directivePart);\n    const directiveText = match[1];\n    const directiveValue = directivePart.slice(match.index + directiveText.length);\n    return {\n      directiveText,\n      directiveValue\n    };\n  }\n};","map":{"version":3,"names":["levn","require","Legacy","ConfigOps","directivesPattern","debug","module","exports","ConfigCommentParser","parseStringConfig","string","comment","items","trimmedString","replace","split","forEach","name","key","value","parseJsonConfig","location","parse","isEverySeverityValid","success","config","normalizedString","JSON","ex","error","ruleId","fatal","severity","message","line","start","column","nodeType","parseListConfig","trimmedName","trim","extractDirectiveComment","match","exec","directivePart","justificationPart","directive","slice","index","justification","length","parseDirective","directiveText","directiveValue"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/config-comment-parser.js"],"sourcesContent":["/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint class-methods-use-this: off -- Methods desired on instance */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n    {\n        Legacy: {\n            ConfigOps\n        }\n    } = require(\"@eslint/eslintrc/universal\"),\n    {\n        directivesPattern\n    } = require(\"../shared/directives\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" and \"exported\" comments.\n     * @param {string} string The string to parse.\n     * @param {Comment} comment The comment node which has the string.\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\n     */\n    parseStringConfig(string, comment) {\n        debug(\"Parsing String config\");\n\n        const items = {};\n\n        // Collapse whitespace around `:` and `,` to make parsing easier\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n\n        trimmedString.split(/\\s|,+/u).forEach(name => {\n            if (!name) {\n                return;\n            }\n\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n            const [key, value = null] = name.split(\":\");\n\n            items[key] = { value, comment };\n        });\n        return items;\n    }\n\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @param {Object} location Start line and column of comments for potential error message.\n     * @returns {({success: true, config: Object}|{success: false, error: LintMessage})} Result map object\n     */\n    parseJsonConfig(string, location) {\n        debug(\"Parsing JSON config\");\n\n        let items = {};\n\n        // Parses a JSON-like comment by the same way as parsing CLI option.\n        try {\n            items = levn.parse(\"Object\", string) || {};\n\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n            // Also, commaless notations have invalid severity:\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n            // Should ignore that case as well.\n            if (ConfigOps.isEverySeverityValid(items)) {\n                return {\n                    success: true,\n                    config: items\n                };\n            }\n        } catch {\n\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n            // ignore to parse the string by a fallback.\n        }\n\n        /*\n         * Optionator cannot parse commaless notations.\n         * But we are supporting that. So this is a fallback for that.\n         */\n        items = {};\n        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n        try {\n            items = JSON.parse(`{${normalizedString}}`);\n        } catch (ex) {\n            debug(\"Manual parsing failed.\");\n\n            return {\n                success: false,\n                error: {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n                    line: location.start.line,\n                    column: location.start.column + 1,\n                    nodeType: null\n                }\n            };\n\n        }\n\n        return {\n            success: true,\n            config: items\n        };\n    }\n\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {Object} Result map of values and true values\n     */\n    parseListConfig(string) {\n        debug(\"Parsing list config\");\n\n        const items = {};\n\n        string.split(\",\").forEach(name => {\n            const trimmedName = name.trim().replace(/^(?<quote>['\"]?)(?<ruleId>.*)\\k<quote>$/us, \"$<ruleId>\");\n\n            if (trimmedName) {\n                items[trimmedName] = true;\n            }\n        });\n        return items;\n    }\n\n    /**\n     * Extract the directive and the justification from a given directive comment and trim them.\n     * @param {string} value The comment text to extract.\n     * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.\n     */\n    extractDirectiveComment(value) {\n        const match = /\\s-{2,}\\s/u.exec(value);\n\n        if (!match) {\n            return { directivePart: value.trim(), justificationPart: \"\" };\n        }\n\n        const directive = value.slice(0, match.index).trim();\n        const justification = value.slice(match.index + match[0].length).trim();\n\n        return { directivePart: directive, justificationPart: justification };\n    }\n\n    /**\n     * Parses a directive comment into directive text and value.\n     * @param {Comment} comment The comment node with the directive to be parsed.\n     * @returns {{directiveText: string, directiveValue: string}} The directive text and value.\n     */\n    parseDirective(comment) {\n        const { directivePart } = this.extractDirectiveComment(comment.value);\n        const match = directivesPattern.exec(directivePart);\n        const directiveText = match[1];\n        const directiveValue = directivePart.slice(match.index + directiveText.length);\n\n        return { directiveText, directiveValue };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}