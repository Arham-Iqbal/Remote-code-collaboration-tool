{"ast":null,"code":"/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require `var` declarations be placed at the top of their containing scope\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/vars-on-top\"\n    },\n    schema: [],\n    messages: {\n      top: \"All 'var' declarations must be at the top of the function scope.\"\n    }\n  },\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Has AST suggesting a directive.\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node structurally represents a directive\n     */\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n\n    /**\n     * Check to see if its a ES6 import declaration\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node represents a import declaration\n     */\n    function looksLikeImport(node) {\n      return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" || node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n    }\n\n    /**\n     * Checks whether a given node is a variable declaration or not.\n     * @param {ASTNode} node any node\n     * @returns {boolean} `true` if the node is a variable declaration.\n     */\n    function isVariableDeclaration(node) {\n      return node.type === \"VariableDeclaration\" || node.type === \"ExportNamedDeclaration\" && node.declaration && node.declaration.type === \"VariableDeclaration\";\n    }\n\n    /**\n     * Checks whether this variable is on top of the block body\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode[]} statements collection of ASTNodes for the parent node block\n     * @returns {boolean} True if var is on top otherwise false\n     */\n    function isVarOnTop(node, statements) {\n      const l = statements.length;\n      let i = 0;\n\n      // Skip over directives and imports. Static blocks don't have either.\n      if (node.parent.type !== \"StaticBlock\") {\n        for (; i < l; ++i) {\n          if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n            break;\n          }\n        }\n      }\n      for (; i < l; ++i) {\n        if (!isVariableDeclaration(statements[i])) {\n          return false;\n        }\n        if (statements[i] === node) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether variable is on top at the global level\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode} parent Parent of the node\n     * @returns {void}\n     */\n    function globalVarCheck(node, parent) {\n      if (!isVarOnTop(node, parent.body)) {\n        context.report({\n          node,\n          messageId: \"top\"\n        });\n      }\n    }\n\n    /**\n     * Checks whether variable is on top at functional block scope level\n     * @param {ASTNode} node The node to check\n     * @returns {void}\n     */\n    function blockScopeVarCheck(node) {\n      const {\n        parent\n      } = node;\n      if (parent.type === \"BlockStatement\" && /Function/u.test(parent.parent.type) && isVarOnTop(node, parent.body)) {\n        return;\n      }\n      if (parent.type === \"StaticBlock\" && isVarOnTop(node, parent.body)) {\n        return;\n      }\n      context.report({\n        node,\n        messageId: \"top\"\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      \"VariableDeclaration[kind='var']\"(node) {\n        if (node.parent.type === \"ExportNamedDeclaration\") {\n          globalVarCheck(node.parent, node.parent.parent);\n        } else if (node.parent.type === \"Program\") {\n          globalVarCheck(node, node.parent);\n        } else {\n          blockScopeVarCheck(node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","top","create","context","looksLikeDirective","node","expression","value","looksLikeImport","isVariableDeclaration","declaration","isVarOnTop","statements","l","length","i","parent","globalVarCheck","body","report","messageId","blockScopeVarCheck","test","VariableDeclaration[kind='var']"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/vars-on-top.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require `var` declarations be placed at the top of their containing scope\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/vars-on-top\"\n        },\n\n        schema: [],\n        messages: {\n            top: \"All 'var' declarations must be at the top of the function scope.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Has AST suggesting a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         * @param {ASTNode} node any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode[]} statements collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // Skip over directives and imports. Static blocks don't have either.\n            if (node.parent.type !== \"StaticBlock\") {\n                for (; i < l; ++i) {\n                    if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                        break;\n                    }\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} parent Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node The node to check\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node) {\n            const { parent } = node;\n\n            if (\n                parent.type === \"BlockStatement\" &&\n                /Function/u.test(parent.parent.type) &&\n                isVarOnTop(node, parent.body)\n            ) {\n                return;\n            }\n\n            if (\n                parent.type === \"StaticBlock\" &&\n                isVarOnTop(node, parent.body)\n            ) {\n                return;\n            }\n\n            context.report({ node, messageId: \"top\" });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration[kind='var']\"(node) {\n                if (node.parent.type === \"ExportNamedDeclaration\") {\n                    globalVarCheck(node.parent, node.parent.parent);\n                } else if (node.parent.type === \"Program\") {\n                    globalVarCheck(node, node.parent);\n                } else {\n                    blockScopeVarCheck(node);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}