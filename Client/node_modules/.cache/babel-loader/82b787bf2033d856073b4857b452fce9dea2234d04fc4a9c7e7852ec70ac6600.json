{"ast":null,"code":"/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\nconst OPTIONS_SCHEMA = {\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"integer\",\n      minimum: 0\n    },\n    comments: {\n      type: \"integer\",\n      minimum: 0\n    },\n    tabWidth: {\n      type: \"integer\",\n      minimum: 0\n    },\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreComments: {\n      type: \"boolean\"\n    },\n    ignoreStrings: {\n      type: \"boolean\"\n    },\n    ignoreUrls: {\n      type: \"boolean\"\n    },\n    ignoreTemplateLiterals: {\n      type: \"boolean\"\n    },\n    ignoreRegExpLiterals: {\n      type: \"boolean\"\n    },\n    ignoreTrailingComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n  anyOf: [OPTIONS_SCHEMA, {\n    type: \"integer\",\n    minimum: 0\n  }]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce a maximum line length\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/max-len\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA],\n    messages: {\n      max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n      maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n    }\n  },\n  create(context) {\n    /*\n     * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n     * - They're matching an entire string that we know is a URI\n     * - We're matching part of a string where we think there *might* be a URL\n     * - We're only concerned about URLs, as picking out any URI would cause\n     *   too many false positives\n     * - We don't care about matching the entire URL, any small segment is fine\n     */\n    const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Computes the length of a line that may contain tabs. The width of each\n     * tab will be the number of spaces to the next tab stop.\n     * @param {string} line The line.\n     * @param {int} tabWidth The width of each tab stop in spaces.\n     * @returns {int} The computed line length.\n     * @private\n     */\n    function computeLineLength(line, tabWidth) {\n      let extraCharacterCount = 0;\n      line.replace(/\\t/gu, (match, offset) => {\n        const totalOffset = offset + extraCharacterCount,\n          previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n          spaceCount = tabWidth - previousTabStopOffset;\n        extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n      });\n      return Array.from(line).length + extraCharacterCount;\n    }\n\n    // The options object must be the last option specified…\n    const options = Object.assign({}, context.options[context.options.length - 1]);\n\n    // …but max code length…\n    if (typeof context.options[0] === \"number\") {\n      options.code = context.options[0];\n    }\n\n    // …and tabWidth can be optionally specified directly as integers.\n    if (typeof context.options[1] === \"number\") {\n      options.tabWidth = context.options[1];\n    }\n    const maxLength = typeof options.code === \"number\" ? options.code : 80,\n      tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n      ignoreComments = !!options.ignoreComments,\n      ignoreStrings = !!options.ignoreStrings,\n      ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n      ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n      ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n      ignoreUrls = !!options.ignoreUrls,\n      maxCommentLength = options.comments;\n    let ignorePattern = options.ignorePattern || null;\n    if (ignorePattern) {\n      ignorePattern = new RegExp(ignorePattern, \"u\");\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Tells if a given comment is trailing: it starts on the current line and\n     * extends to or past the end of the current line.\n     * @param {string} line The source line we want to check for a trailing comment on\n     * @param {number} lineNumber The one-indexed line number for line\n     * @param {ASTNode} comment The comment to inspect\n     * @returns {boolean} If the comment is trailing on the given line\n     */\n    function isTrailingComment(line, lineNumber, comment) {\n      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n    }\n\n    /**\n     * Tells if a comment encompasses the entire line.\n     * @param {string} line The source line with a trailing comment\n     * @param {number} lineNumber The one-indexed line number this is on\n     * @param {ASTNode} comment The comment to remove\n     * @returns {boolean} If the comment covers the entire line\n     */\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n        end = comment.loc.end,\n        isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);\n    }\n\n    /**\n     * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n     */\n    function isJSXEmptyExpressionInSingleLineContainer(node) {\n      if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n        return false;\n      }\n      const parent = node.parent;\n      return parent.loc.start.line === parent.loc.end.line;\n    }\n\n    /**\n     * Gets the line after the comment and any remaining trailing whitespace is\n     * stripped.\n     * @param {string} line The source line with a trailing comment\n     * @param {ASTNode} comment The comment to remove\n     * @returns {string} Line without comment and trailing whitespace\n     */\n    function stripTrailingComment(line, comment) {\n      // loc.column is zero-indexed\n      return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n    }\n\n    /**\n     * Ensure that an array exists at [key] on `object`, and add `value` to it.\n     * @param {Object} object the object to mutate\n     * @param {string} key the object's key\n     * @param {any} value the value to add\n     * @returns {void}\n     * @private\n     */\n    function ensureArrayAndPush(object, key, value) {\n      if (!Array.isArray(object[key])) {\n        object[key] = [];\n      }\n      object[key].push(value);\n    }\n\n    /**\n     * Retrieves an array containing all strings (\" or ') in the source code.\n     * @returns {ASTNode[]} An array of string nodes.\n     */\n    function getAllStrings() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"String\" || token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\");\n    }\n\n    /**\n     * Retrieves an array containing all template literals in the source code.\n     * @returns {ASTNode[]} An array of template literal nodes.\n     */\n    function getAllTemplateLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n    }\n\n    /**\n     * Retrieves an array containing all RegExp literals in the source code.\n     * @returns {ASTNode[]} An array of RegExp literal nodes.\n     */\n    function getAllRegExpLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n    }\n\n    /**\n     *\n     * reduce an array of AST nodes by line number, both start and end.\n     * @param {ASTNode[]} arr array of AST nodes\n     * @returns {Object} accululated AST nodes\n     */\n    function groupArrayByLineNumber(arr) {\n      const obj = {};\n      for (let i = 0; i < arr.length; i++) {\n        const node = arr[i];\n        for (let j = node.loc.start.line; j <= node.loc.end.line; ++j) {\n          ensureArrayAndPush(obj, j, node);\n        }\n      }\n      return obj;\n    }\n\n    /**\n     * Returns an array of all comments in the source code.\n     * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\n     * the element is changed with JSXExpressionContainer node.\n     * @returns {ASTNode[]} An array of comment nodes\n     */\n    function getAllComments() {\n      const comments = [];\n      sourceCode.getAllComments().forEach(commentNode => {\n        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n          // push a unique node only\n          if (comments[comments.length - 1] !== containingNode.parent) {\n            comments.push(containingNode.parent);\n          }\n        } else {\n          comments.push(commentNode);\n        }\n      });\n      return comments;\n    }\n\n    /**\n     * Check the program for max length\n     * @param {ASTNode} node Node to examine\n     * @returns {void}\n     * @private\n     */\n    function checkProgramForMaxLength(node) {\n      // split (honors line-ending)\n      const lines = sourceCode.lines,\n        // list of comments to ignore\n        comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\n\n      // we iterate over comments in parallel with the lines\n      let commentsIndex = 0;\n      const strings = getAllStrings();\n      const stringsByLine = groupArrayByLineNumber(strings);\n      const templateLiterals = getAllTemplateLiterals();\n      const templateLiteralsByLine = groupArrayByLineNumber(templateLiterals);\n      const regExpLiterals = getAllRegExpLiterals();\n      const regExpLiteralsByLine = groupArrayByLineNumber(regExpLiterals);\n      lines.forEach((line, i) => {\n        // i is zero-indexed, line numbers are one-indexed\n        const lineNumber = i + 1;\n\n        /*\n         * if we're checking comment length; we need to know whether this\n         * line is a comment\n         */\n        let lineIsComment = false;\n        let textToMeasure;\n\n        /*\n         * We can short-circuit the comment checks if we're already out of\n         * comments to check.\n         */\n        if (commentsIndex < comments.length) {\n          let comment = null;\n\n          // iterate over comments until we find one past the current line\n          do {\n            comment = comments[++commentsIndex];\n          } while (comment && comment.loc.start.line <= lineNumber);\n\n          // and step back by one\n          comment = comments[--commentsIndex];\n          if (isFullLineComment(line, lineNumber, comment)) {\n            lineIsComment = true;\n            textToMeasure = line;\n          } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n            textToMeasure = stripTrailingComment(line, comment);\n\n            // ignore multiple trailing comments in the same line\n            let lastIndex = commentsIndex;\n            while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n              textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n            }\n          } else {\n            textToMeasure = line;\n          }\n        } else {\n          textToMeasure = line;\n        }\n        if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {\n          // ignore this line\n          return;\n        }\n        const lineLength = computeLineLength(textToMeasure, tabWidth);\n        const commentLengthApplies = lineIsComment && maxCommentLength;\n        if (lineIsComment && ignoreComments) {\n          return;\n        }\n        const loc = {\n          start: {\n            line: lineNumber,\n            column: 0\n          },\n          end: {\n            line: lineNumber,\n            column: textToMeasure.length\n          }\n        };\n        if (commentLengthApplies) {\n          if (lineLength > maxCommentLength) {\n            context.report({\n              node,\n              loc,\n              messageId: \"maxComment\",\n              data: {\n                lineLength,\n                maxCommentLength\n              }\n            });\n          }\n        } else if (lineLength > maxLength) {\n          context.report({\n            node,\n            loc,\n            messageId: \"max\",\n            data: {\n              lineLength,\n              maxLength\n            }\n          });\n        }\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: checkProgramForMaxLength\n    };\n  }\n};","map":{"version":3,"names":["OPTIONS_SCHEMA","type","properties","code","minimum","comments","tabWidth","ignorePattern","ignoreComments","ignoreStrings","ignoreUrls","ignoreTemplateLiterals","ignoreRegExpLiterals","ignoreTrailingComments","additionalProperties","OPTIONS_OR_INTEGER_SCHEMA","anyOf","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","schema","messages","max","maxComment","create","context","URL_REGEXP","sourceCode","computeLineLength","line","extraCharacterCount","replace","match","offset","totalOffset","previousTabStopOffset","spaceCount","Array","from","length","options","Object","assign","maxLength","maxCommentLength","RegExp","isTrailingComment","lineNumber","comment","loc","start","end","column","isFullLineComment","isFirstTokenOnLine","slice","trim","isJSXEmptyExpressionInSingleLineContainer","node","parent","stripTrailingComment","ensureArrayAndPush","object","key","value","isArray","push","getAllStrings","ast","tokens","filter","token","getNodeByRangeIndex","range","getAllTemplateLiterals","getAllRegExpLiterals","groupArrayByLineNumber","arr","obj","i","j","getAllComments","forEach","commentNode","containingNode","checkProgramForMaxLength","lines","commentsIndex","strings","stringsByLine","templateLiterals","templateLiteralsByLine","regExpLiterals","regExpLiteralsByLine","lineIsComment","textToMeasure","lastIndex","test","lineLength","commentLengthApplies","report","messageId","data","Program"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/max-len.js"],"sourcesContent":["/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\"\n        },\n        ignoreStrings: {\n            type: \"boolean\"\n        },\n        ignoreUrls: {\n            type: \"boolean\"\n        },\n        ignoreTemplateLiterals: {\n            type: \"boolean\"\n        },\n        ignoreRegExpLiterals: {\n            type: \"boolean\"\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce a maximum line length\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/max-len\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ],\n        messages: {\n            max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n            maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            let extraCharacterCount = 0;\n\n            line.replace(/\\t/gu, (match, offset) => {\n                const totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n            });\n            return Array.from(line).length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specified…\n        const options = Object.assign({}, context.options[context.options.length - 1]);\n\n        // …but max code length…\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // …and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        const maxLength = typeof options.code === \"number\" ? options.code : 80,\n            tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n            ignoreComments = !!options.ignoreComments,\n            ignoreStrings = !!options.ignoreStrings,\n            ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n            ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n            ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n            ignoreUrls = !!options.ignoreUrls,\n            maxCommentLength = options.comments;\n        let ignorePattern = options.ignorePattern || null;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern, \"u\");\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\n        }\n\n        /**\n         * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n         */\n        function isJSXEmptyExpressionInSingleLineContainer(node) {\n            if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            return parent.loc.start.line === parent.loc.end.line;\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitespace\n         */\n        function stripTrailingComment(line, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n        }\n\n        /**\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\n         * @param {Object} object the object to mutate\n         * @param {string} key the object's key\n         * @param {any} value the value to add\n         * @returns {void}\n         * @private\n         */\n        function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }\n\n        /**\n         * Retrieves an array containing all strings (\" or ') in the source code.\n         * @returns {ASTNode[]} An array of string nodes.\n         */\n        function getAllStrings() {\n            return sourceCode.ast.tokens.filter(token => (token.type === \"String\" ||\n                (token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\")));\n        }\n\n        /**\n         * Retrieves an array containing all template literals in the source code.\n         * @returns {ASTNode[]} An array of template literal nodes.\n         */\n        function getAllTemplateLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n        }\n\n\n        /**\n         * Retrieves an array containing all RegExp literals in the source code.\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\n         */\n        function getAllRegExpLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n        }\n\n        /**\n         *\n         * reduce an array of AST nodes by line number, both start and end.\n         * @param {ASTNode[]} arr array of AST nodes\n         * @returns {Object} accululated AST nodes\n         */\n        function groupArrayByLineNumber(arr) {\n            const obj = {};\n\n            for (let i = 0; i < arr.length; i++) {\n                const node = arr[i];\n\n                for (let j = node.loc.start.line; j <= node.loc.end.line; ++j) {\n                    ensureArrayAndPush(obj, j, node);\n                }\n            }\n            return obj;\n        }\n\n        /**\n         * Returns an array of all comments in the source code.\n         * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\n         * the element is changed with JSXExpressionContainer node.\n         * @returns {ASTNode[]} An array of comment nodes\n         */\n        function getAllComments() {\n            const comments = [];\n\n            sourceCode.getAllComments()\n                .forEach(commentNode => {\n                    const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n\n                    if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n\n                        // push a unique node only\n                        if (comments[comments.length - 1] !== containingNode.parent) {\n                            comments.push(containingNode.parent);\n                        }\n                    } else {\n                        comments.push(commentNode);\n                    }\n                });\n\n            return comments;\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            const lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\n\n            // we iterate over comments in parallel with the lines\n            let commentsIndex = 0;\n\n            const strings = getAllStrings();\n            const stringsByLine = groupArrayByLineNumber(strings);\n\n            const templateLiterals = getAllTemplateLiterals();\n            const templateLiteralsByLine = groupArrayByLineNumber(templateLiterals);\n\n            const regExpLiterals = getAllRegExpLiterals();\n            const regExpLiteralsByLine = groupArrayByLineNumber(regExpLiterals);\n\n            lines.forEach((line, i) => {\n\n                // i is zero-indexed, line numbers are one-indexed\n                const lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                let lineIsComment = false;\n                let textToMeasure;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n                    let comment = null;\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                        textToMeasure = line;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        textToMeasure = stripTrailingComment(line, comment);\n\n                        // ignore multiple trailing comments in the same line\n                        let lastIndex = commentsIndex;\n\n                        while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n                            textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n                        }\n                    } else {\n                        textToMeasure = line;\n                    }\n                } else {\n                    textToMeasure = line;\n                }\n                if (ignorePattern && ignorePattern.test(textToMeasure) ||\n                    ignoreUrls && URL_REGEXP.test(textToMeasure) ||\n                    ignoreStrings && stringsByLine[lineNumber] ||\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\n                ) {\n\n                    // ignore this line\n                    return;\n                }\n\n                const lineLength = computeLineLength(textToMeasure, tabWidth);\n                const commentLengthApplies = lineIsComment && maxCommentLength;\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                const loc = {\n                    start: {\n                        line: lineNumber,\n                        column: 0\n                    },\n                    end: {\n                        line: lineNumber,\n                        column: textToMeasure.length\n                    }\n                };\n\n                if (commentLengthApplies) {\n                    if (lineLength > maxCommentLength) {\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"maxComment\",\n                            data: {\n                                lineLength,\n                                maxCommentLength\n                            }\n                        });\n                    }\n                } else if (lineLength > maxLength) {\n                    context.report({\n                        node,\n                        loc,\n                        messageId: \"max\",\n                        data: {\n                            lineLength,\n                            maxLength\n                        }\n                    });\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}