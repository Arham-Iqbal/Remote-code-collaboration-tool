{"ast":null,"code":"/**\n * @fileoverview Rule to disallow returning values from Promise executor functions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  findVariable\n} = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst functionTypesToCheck = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\n\n/**\n * Determines whether the given identifier node is a reference to a global variable.\n * @param {ASTNode} node `Identifier` node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} True if the identifier is a reference to a global variable.\n */\nfunction isGlobalReference(node, scope) {\n  const variable = findVariable(scope, node);\n  return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\n/**\n * Finds function's outer scope.\n * @param {Scope} scope Function's own scope.\n * @returns {Scope} Function's outer scope.\n */\nfunction getOuterScope(scope) {\n  const upper = scope.upper;\n  if (upper.type === \"function-expression-name\") {\n    return upper.upper;\n  }\n  return upper;\n}\n\n/**\n * Determines whether the given function node is used as a Promise executor.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Function's own scope.\n * @returns {boolean} `true` if the node is a Promise executor.\n */\nfunction isPromiseExecutor(node, scope) {\n  const parent = node.parent;\n  return parent.type === \"NewExpression\" && parent.arguments[0] === node && parent.callee.type === \"Identifier\" && parent.callee.name === \"Promise\" && isGlobalReference(parent.callee, getOuterScope(scope));\n}\n\n/**\n * Checks if the given node is a void expression.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} - `true` if the node is a void expression\n */\nfunction expressionIsVoid(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Fixes the linting error by prepending \"void \" to the given node\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction voidPrependFixer(sourceCode, node, fixer) {\n  const requiresParens =\n  // prepending `void ` will fail if the node has a lower precedence than void\n  astUtils.getPrecedence(node) < astUtils.getPrecedence({\n    type: \"UnaryExpression\",\n    operator: \"void\"\n  }) &&\n  // check if there are parentheses around the node to avoid redundant parentheses\n  !astUtils.isParenthesised(sourceCode, node);\n\n  // avoid parentheses issues\n  const returnOrArrowToken = sourceCode.getTokenBefore(node, node.parent.type === \"ArrowFunctionExpression\" ? astUtils.isArrowToken\n\n  // isReturnToken\n  : token => token.type === \"Keyword\" && token.value === \"return\");\n  const firstToken = sourceCode.getTokenAfter(returnOrArrowToken);\n  const prependSpace =\n  // is return token, as => allows void to be adjacent\n  returnOrArrowToken.value === \"return\" &&\n  // If two tokens (return and \"(\") are adjacent\n  returnOrArrowToken.range[1] === firstToken.range[0];\n  return [fixer.insertTextBefore(firstToken, `${prependSpace ? \" \" : \"\"}void ${requiresParens ? \"(\" : \"\"}`), fixer.insertTextAfter(node, requiresParens ? \")\" : \"\")];\n}\n\n/**\n * Fixes the linting error by `wrapping {}` around the given node's body.\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction curlyWrapFixer(sourceCode, node, fixer) {\n  // https://github.com/eslint/eslint/pull/17282#issuecomment-1592795923\n  const arrowToken = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n  const firstToken = sourceCode.getTokenAfter(arrowToken);\n  const lastToken = sourceCode.getLastToken(node);\n  return [fixer.insertTextBefore(firstToken, \"{\"), fixer.insertTextAfter(lastToken, \"}\")];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow returning values from Promise executor functions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-promise-executor-return\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowVoid: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      returnsValue: \"Return values from promise executor functions cannot be read.\",\n      // arrow and function suggestions\n      prependVoid: \"Prepend `void` to the expression.\",\n      // only arrow suggestions\n      wrapBraces: \"Wrap the expression in `{}`.\"\n    }\n  },\n  create(context) {\n    let funcInfo = null;\n    const sourceCode = context.sourceCode;\n    const {\n      allowVoid = false\n    } = context.options[0] || {};\n    return {\n      onCodePathStart(_, node) {\n        funcInfo = {\n          upper: funcInfo,\n          shouldCheck: functionTypesToCheck.has(node.type) && isPromiseExecutor(node, sourceCode.getScope(node))\n        };\n        if (\n        // Is a Promise executor\n        funcInfo.shouldCheck && node.type === \"ArrowFunctionExpression\" && node.expression &&\n        // Except void\n        !(allowVoid && expressionIsVoid(node.body))) {\n          const suggest = [];\n\n          // prevent useless refactors\n          if (allowVoid) {\n            suggest.push({\n              messageId: \"prependVoid\",\n              fix(fixer) {\n                return voidPrependFixer(sourceCode, node.body, fixer);\n              }\n            });\n          }\n\n          // Do not suggest wrapping an unnamed FunctionExpression in braces as that would be invalid syntax.\n          if (!(node.body.type === \"FunctionExpression\" && !node.body.id)) {\n            suggest.push({\n              messageId: \"wrapBraces\",\n              fix(fixer) {\n                return curlyWrapFixer(sourceCode, node, fixer);\n              }\n            });\n          }\n          context.report({\n            node: node.body,\n            messageId: \"returnsValue\",\n            suggest\n          });\n        }\n      },\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n      ReturnStatement(node) {\n        if (!(funcInfo.shouldCheck && node.argument)) {\n          return;\n        }\n\n        // node is `return <expression>`\n        if (!allowVoid) {\n          context.report({\n            node,\n            messageId: \"returnsValue\"\n          });\n          return;\n        }\n        if (expressionIsVoid(node.argument)) {\n          return;\n        }\n\n        // allowVoid && !expressionIsVoid\n        context.report({\n          node,\n          messageId: \"returnsValue\",\n          suggest: [{\n            messageId: \"prependVoid\",\n            fix(fixer) {\n              return voidPrependFixer(sourceCode, node.argument, fixer);\n            }\n          }]\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["findVariable","require","astUtils","functionTypesToCheck","Set","isGlobalReference","node","scope","variable","type","defs","length","getOuterScope","upper","isPromiseExecutor","parent","arguments","callee","name","expressionIsVoid","operator","voidPrependFixer","sourceCode","fixer","requiresParens","getPrecedence","isParenthesised","returnOrArrowToken","getTokenBefore","isArrowToken","token","value","firstToken","getTokenAfter","prependSpace","range","insertTextBefore","insertTextAfter","curlyWrapFixer","arrowToken","body","lastToken","getLastToken","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","allowVoid","default","additionalProperties","messages","returnsValue","prependVoid","wrapBraces","create","context","funcInfo","options","onCodePathStart","_","shouldCheck","has","getScope","expression","suggest","push","messageId","fix","id","report","onCodePathEnd","ReturnStatement","argument"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-promise-executor-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow returning values from Promise executor functions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst functionTypesToCheck = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\n\n/**\n * Determines whether the given identifier node is a reference to a global variable.\n * @param {ASTNode} node `Identifier` node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} True if the identifier is a reference to a global variable.\n */\nfunction isGlobalReference(node, scope) {\n    const variable = findVariable(scope, node);\n\n    return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\n/**\n * Finds function's outer scope.\n * @param {Scope} scope Function's own scope.\n * @returns {Scope} Function's outer scope.\n */\nfunction getOuterScope(scope) {\n    const upper = scope.upper;\n\n    if (upper.type === \"function-expression-name\") {\n        return upper.upper;\n    }\n    return upper;\n}\n\n/**\n * Determines whether the given function node is used as a Promise executor.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Function's own scope.\n * @returns {boolean} `true` if the node is a Promise executor.\n */\nfunction isPromiseExecutor(node, scope) {\n    const parent = node.parent;\n\n    return parent.type === \"NewExpression\" &&\n        parent.arguments[0] === node &&\n        parent.callee.type === \"Identifier\" &&\n        parent.callee.name === \"Promise\" &&\n        isGlobalReference(parent.callee, getOuterScope(scope));\n}\n\n/**\n * Checks if the given node is a void expression.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} - `true` if the node is a void expression\n */\nfunction expressionIsVoid(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Fixes the linting error by prepending \"void \" to the given node\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction voidPrependFixer(sourceCode, node, fixer) {\n\n    const requiresParens =\n\n        // prepending `void ` will fail if the node has a lower precedence than void\n        astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\", operator: \"void\" }) &&\n\n        // check if there are parentheses around the node to avoid redundant parentheses\n        !astUtils.isParenthesised(sourceCode, node);\n\n    // avoid parentheses issues\n    const returnOrArrowToken = sourceCode.getTokenBefore(\n        node,\n        node.parent.type === \"ArrowFunctionExpression\"\n            ? astUtils.isArrowToken\n\n            // isReturnToken\n            : token => token.type === \"Keyword\" && token.value === \"return\"\n    );\n\n    const firstToken = sourceCode.getTokenAfter(returnOrArrowToken);\n\n    const prependSpace =\n\n        // is return token, as => allows void to be adjacent\n        returnOrArrowToken.value === \"return\" &&\n\n        // If two tokens (return and \"(\") are adjacent\n        returnOrArrowToken.range[1] === firstToken.range[0];\n\n    return [\n        fixer.insertTextBefore(firstToken, `${prependSpace ? \" \" : \"\"}void ${requiresParens ? \"(\" : \"\"}`),\n        fixer.insertTextAfter(node, requiresParens ? \")\" : \"\")\n    ];\n}\n\n/**\n * Fixes the linting error by `wrapping {}` around the given node's body.\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction curlyWrapFixer(sourceCode, node, fixer) {\n\n    // https://github.com/eslint/eslint/pull/17282#issuecomment-1592795923\n    const arrowToken = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n    const firstToken = sourceCode.getTokenAfter(arrowToken);\n    const lastToken = sourceCode.getLastToken(node);\n\n    return [\n        fixer.insertTextBefore(firstToken, \"{\"),\n        fixer.insertTextAfter(lastToken, \"}\")\n    ];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow returning values from Promise executor functions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-promise-executor-return\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowVoid: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            returnsValue: \"Return values from promise executor functions cannot be read.\",\n\n            // arrow and function suggestions\n            prependVoid: \"Prepend `void` to the expression.\",\n\n            // only arrow suggestions\n            wrapBraces: \"Wrap the expression in `{}`.\"\n        }\n    },\n\n    create(context) {\n\n        let funcInfo = null;\n        const sourceCode = context.sourceCode;\n        const {\n            allowVoid = false\n        } = context.options[0] || {};\n\n        return {\n\n            onCodePathStart(_, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    shouldCheck:\n                        functionTypesToCheck.has(node.type) &&\n                        isPromiseExecutor(node, sourceCode.getScope(node))\n                };\n\n                if (// Is a Promise executor\n                    funcInfo.shouldCheck &&\n                    node.type === \"ArrowFunctionExpression\" &&\n                    node.expression &&\n\n                    // Except void\n                    !(allowVoid && expressionIsVoid(node.body))\n                ) {\n                    const suggest = [];\n\n                    // prevent useless refactors\n                    if (allowVoid) {\n                        suggest.push({\n                            messageId: \"prependVoid\",\n                            fix(fixer) {\n                                return voidPrependFixer(sourceCode, node.body, fixer);\n                            }\n                        });\n                    }\n\n                    // Do not suggest wrapping an unnamed FunctionExpression in braces as that would be invalid syntax.\n                    if (!(node.body.type === \"FunctionExpression\" && !node.body.id)) {\n                        suggest.push({\n                            messageId: \"wrapBraces\",\n                            fix(fixer) {\n                                return curlyWrapFixer(sourceCode, node, fixer);\n                            }\n                        });\n                    }\n\n                    context.report({\n                        node: node.body,\n                        messageId: \"returnsValue\",\n                        suggest\n                    });\n                }\n            },\n\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            ReturnStatement(node) {\n                if (!(funcInfo.shouldCheck && node.argument)) {\n                    return;\n                }\n\n                // node is `return <expression>`\n                if (!allowVoid) {\n                    context.report({ node, messageId: \"returnsValue\" });\n                    return;\n                }\n\n                if (expressionIsVoid(node.argument)) {\n                    return;\n                }\n\n                // allowVoid && !expressionIsVoid\n                context.report({\n                    node,\n                    messageId: \"returnsValue\",\n                    suggest: [{\n                        messageId: \"prependVoid\",\n                        fix(fixer) {\n                            return voidPrependFixer(sourceCode, node.argument, fixer);\n                        }\n                    }]\n                });\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}