{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n  let allowNamedExports = false;\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n    allowNamedExports = !!options.allowNamedExports;\n  }\n  return {\n    functions,\n    classes,\n    variables,\n    allowNamedExports\n  };\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {ASTNode} node `ClassBody` node to check static initializers.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of a class static initializer.\n */\nfunction isInClassStaticInitializerRange(node, location) {\n  return node.body.some(classMember => classMember.type === \"StaticBlock\" && isInRange(classMember, location) || classMember.type === \"PropertyDefinition\" && classMember.static && classMember.value && isInRange(classMember.value, location));\n}\n\n/**\n * Checks whether a given scope is the scope of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {eslint-scope.Scope} scope A scope to check.\n * @returns {boolean} `true` if the scope is a class static initializer scope.\n */\nfunction isClassStaticInitializerScope(scope) {\n  if (scope.type === \"class-static-block\") {\n    return true;\n  }\n  if (scope.type === \"class-field-initializer\") {\n    // `scope.block` is PropertyDefinition#value node\n    const propertyDefinition = scope.block.parent;\n    return propertyDefinition.static;\n  }\n  return false;\n}\n\n/**\n * Checks whether a given reference is evaluated in an execution context\n * that isn't the one where the variable it refers to is defined.\n * Execution contexts are:\n * - top-level\n * - functions\n * - class field initializers (implicit functions)\n * - class static blocks (implicit functions)\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\n * and therefore we'll consider them as a part of the parent execution context.\n * Example:\n *\n *   const x = 1;\n *\n *   x; // returns `false`\n *   () => x; // returns `true`\n *\n *   class C {\n *       field = x; // returns `true`\n *       static field = x; // returns `false`\n *\n *       method() {\n *           x; // returns `true`\n *       }\n *\n *       static method() {\n *           x; // returns `true`\n *       }\n *\n *       static {\n *           x; // returns `false`\n *       }\n *   }\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is from a separate execution context.\n */\nfunction isFromSeparateExecutionContext(reference) {\n  const variable = reference.resolved;\n  let scope = reference.from;\n\n  // Scope#variableScope represents execution context\n  while (variable.scope.variableScope !== scope.variableScope) {\n    if (isClassStaticInitializerScope(scope.variableScope)) {\n      scope = scope.variableScope.upper;\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *     var C = class { [C]; };\n *     var C = class { static foo = C; };\n *     var C = class { static { foo = C; } };\n *     class C extends C {}\n *     class C extends (class { static foo = C; }) {}\n *     class C { [C]; }\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\n */\nfunction isEvaluatedDuringInitialization(reference) {\n  if (isFromSeparateExecutionContext(reference)) {\n    /*\n     * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\n     * For example, `const x = () => x;` is valid.\n     */\n    return false;\n  }\n  const location = reference.identifier.range[1];\n  const definition = reference.resolved.defs[0];\n  if (definition.type === \"ClassName\") {\n    // `ClassDeclaration` or `ClassExpression`\n    const classDefinition = definition.node;\n    return isInRange(classDefinition, location) &&\n    /*\n     * Class binding is initialized before running static initializers.\n     * For example, `class C { static foo = C; static { bar = C; } }` is valid.\n     */\n    !isInClassStaticInitializerRange(classDefinition.body, location);\n  }\n  let node = definition.name.parent;\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n    node = node.parent;\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow the use of variables before they are defined\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          },\n          allowNamedExports: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n    }\n  },\n  create(context) {\n    const options = parseOptions(context.options[0]);\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Determines whether a given reference should be checked.\n     *\n     * Returns `false` if the reference is:\n     * - initialization's (e.g., `let a = 1`).\n     * - referring to an undefined variable (i.e., if it's an unresolved reference).\n     * - referring to a variable that is defined, but not in the given source code\n     *   (e.g., global environment variable or `arguments` in functions).\n     * - allowed by options.\n     * @param {eslint-scope.Reference} reference The reference\n     * @returns {boolean} `true` if the reference should be checked\n     */\n    function shouldCheck(reference) {\n      if (reference.init) {\n        return false;\n      }\n      const {\n        identifier\n      } = reference;\n      if (options.allowNamedExports && identifier.parent.type === \"ExportSpecifier\" && identifier.parent.local === identifier) {\n        return false;\n      }\n      const variable = reference.resolved;\n      if (!variable || variable.defs.length === 0) {\n        return false;\n      }\n      const definitionType = variable.defs[0].type;\n      if (!options.functions && definitionType === \"FunctionName\") {\n        return false;\n      }\n      if ((!options.variables && definitionType === \"Variable\" || !options.classes && definitionType === \"ClassName\") &&\n      // don't skip checking the reference if it's in the same execution context, because of TDZ\n      isFromSeparateExecutionContext(reference)) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Finds and validates all references in a given scope and its child scopes.\n     * @param {eslint-scope.Scope} scope The scope object.\n     * @returns {void}\n     */\n    function checkReferencesInScope(scope) {\n      scope.references.filter(shouldCheck).forEach(reference => {\n        const variable = reference.resolved;\n        const definitionIdentifier = variable.defs[0].name;\n        if (reference.identifier.range[1] < definitionIdentifier.range[1] || isEvaluatedDuringInitialization(reference)) {\n          context.report({\n            node: reference.identifier,\n            messageId: \"usedBeforeDefined\",\n            data: reference.identifier\n          });\n        }\n      });\n      scope.childScopes.forEach(checkReferencesInScope);\n    }\n    return {\n      Program(node) {\n        checkReferencesInScope(sourceCode.getScope(node));\n      }\n    };\n  }\n};","map":{"version":3,"names":["SENTINEL_TYPE","FOR_IN_OF_TYPE","parseOptions","options","functions","classes","variables","allowNamedExports","isInRange","node","location","range","isInClassStaticInitializerRange","body","some","classMember","type","static","value","isClassStaticInitializerScope","scope","propertyDefinition","block","parent","isFromSeparateExecutionContext","reference","variable","resolved","from","variableScope","upper","isEvaluatedDuringInitialization","identifier","definition","defs","classDefinition","name","init","test","right","module","exports","meta","docs","description","recommended","url","schema","oneOf","enum","properties","additionalProperties","messages","usedBeforeDefined","create","context","sourceCode","shouldCheck","local","length","definitionType","checkReferencesInScope","references","filter","forEach","definitionIdentifier","report","messageId","data","childScopes","Program","getScope"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-use-before-define.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n    let allowNamedExports = false;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n        allowNamedExports = !!options.allowNamedExports;\n    }\n\n    return { functions, classes, variables, allowNamedExports };\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {ASTNode} node `ClassBody` node to check static initializers.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of a class static initializer.\n */\nfunction isInClassStaticInitializerRange(node, location) {\n    return node.body.some(classMember => (\n        (\n            classMember.type === \"StaticBlock\" &&\n            isInRange(classMember, location)\n        ) ||\n        (\n            classMember.type === \"PropertyDefinition\" &&\n            classMember.static &&\n            classMember.value &&\n            isInRange(classMember.value, location)\n        )\n    ));\n}\n\n/**\n * Checks whether a given scope is the scope of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {eslint-scope.Scope} scope A scope to check.\n * @returns {boolean} `true` if the scope is a class static initializer scope.\n */\nfunction isClassStaticInitializerScope(scope) {\n    if (scope.type === \"class-static-block\") {\n        return true;\n    }\n\n    if (scope.type === \"class-field-initializer\") {\n\n        // `scope.block` is PropertyDefinition#value node\n        const propertyDefinition = scope.block.parent;\n\n        return propertyDefinition.static;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether a given reference is evaluated in an execution context\n * that isn't the one where the variable it refers to is defined.\n * Execution contexts are:\n * - top-level\n * - functions\n * - class field initializers (implicit functions)\n * - class static blocks (implicit functions)\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\n * and therefore we'll consider them as a part of the parent execution context.\n * Example:\n *\n *   const x = 1;\n *\n *   x; // returns `false`\n *   () => x; // returns `true`\n *\n *   class C {\n *       field = x; // returns `true`\n *       static field = x; // returns `false`\n *\n *       method() {\n *           x; // returns `true`\n *       }\n *\n *       static method() {\n *           x; // returns `true`\n *       }\n *\n *       static {\n *           x; // returns `false`\n *       }\n *   }\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is from a separate execution context.\n */\nfunction isFromSeparateExecutionContext(reference) {\n    const variable = reference.resolved;\n    let scope = reference.from;\n\n    // Scope#variableScope represents execution context\n    while (variable.scope.variableScope !== scope.variableScope) {\n        if (isClassStaticInitializerScope(scope.variableScope)) {\n            scope = scope.variableScope.upper;\n        } else {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *     var C = class { [C]; };\n *     var C = class { static foo = C; };\n *     var C = class { static { foo = C; } };\n *     class C extends C {}\n *     class C extends (class { static foo = C; }) {}\n *     class C { [C]; }\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\n */\nfunction isEvaluatedDuringInitialization(reference) {\n    if (isFromSeparateExecutionContext(reference)) {\n\n        /*\n         * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\n         * For example, `const x = () => x;` is valid.\n         */\n        return false;\n    }\n\n    const location = reference.identifier.range[1];\n    const definition = reference.resolved.defs[0];\n\n    if (definition.type === \"ClassName\") {\n\n        // `ClassDeclaration` or `ClassExpression`\n        const classDefinition = definition.node;\n\n        return (\n            isInRange(classDefinition, location) &&\n\n            /*\n             * Class binding is initialized before running static initializers.\n             * For example, `class C { static foo = C; static { bar = C; } }` is valid.\n             */\n            !isInClassStaticInitializerRange(classDefinition.body, location)\n        );\n    }\n\n    let node = definition.name.parent;\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow the use of variables before they are defined\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" },\n                            allowNamedExports: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether a given reference should be checked.\n         *\n         * Returns `false` if the reference is:\n         * - initialization's (e.g., `let a = 1`).\n         * - referring to an undefined variable (i.e., if it's an unresolved reference).\n         * - referring to a variable that is defined, but not in the given source code\n         *   (e.g., global environment variable or `arguments` in functions).\n         * - allowed by options.\n         * @param {eslint-scope.Reference} reference The reference\n         * @returns {boolean} `true` if the reference should be checked\n         */\n        function shouldCheck(reference) {\n            if (reference.init) {\n                return false;\n            }\n\n            const { identifier } = reference;\n\n            if (\n                options.allowNamedExports &&\n                identifier.parent.type === \"ExportSpecifier\" &&\n                identifier.parent.local === identifier\n            ) {\n                return false;\n            }\n\n            const variable = reference.resolved;\n\n            if (!variable || variable.defs.length === 0) {\n                return false;\n            }\n\n            const definitionType = variable.defs[0].type;\n\n            if (!options.functions && definitionType === \"FunctionName\") {\n                return false;\n            }\n\n            if (\n                (\n                    !options.variables && definitionType === \"Variable\" ||\n                    !options.classes && definitionType === \"ClassName\"\n                ) &&\n\n                // don't skip checking the reference if it's in the same execution context, because of TDZ\n                isFromSeparateExecutionContext(reference)\n            ) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Finds and validates all references in a given scope and its child scopes.\n         * @param {eslint-scope.Scope} scope The scope object.\n         * @returns {void}\n         */\n        function checkReferencesInScope(scope) {\n            scope.references.filter(shouldCheck).forEach(reference => {\n                const variable = reference.resolved;\n                const definitionIdentifier = variable.defs[0].name;\n\n                if (\n                    reference.identifier.range[1] < definitionIdentifier.range[1] ||\n                    isEvaluatedDuringInitialization(reference)\n                ) {\n                    context.report({\n                        node: reference.identifier,\n                        messageId: \"usedBeforeDefined\",\n                        data: reference.identifier\n                    });\n                }\n            });\n\n            scope.childScopes.forEach(checkReferencesInScope);\n        }\n\n        return {\n            Program(node) {\n                checkReferencesInScope(sourceCode.getScope(node));\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}