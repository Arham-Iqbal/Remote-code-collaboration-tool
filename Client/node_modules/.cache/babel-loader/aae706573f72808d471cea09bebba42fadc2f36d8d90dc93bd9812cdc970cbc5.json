{"ast":null,"code":"/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce the use of variables within the scope they are defined\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/block-scoped-var\"\n    },\n    schema: [],\n    messages: {\n      outOfScope: \"'{{name}}' declared on line {{definitionLine}} column {{definitionColumn}} is used outside of binding context.\"\n    }\n  },\n  create(context) {\n    let stack = [];\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Makes a block scope.\n     * @param {ASTNode} node A node of a scope.\n     * @returns {void}\n     */\n    function enterScope(node) {\n      stack.push(node.range);\n    }\n\n    /**\n     * Pops the last block scope.\n     * @returns {void}\n     */\n    function exitScope() {\n      stack.pop();\n    }\n\n    /**\n     * Reports a given reference.\n     * @param {eslint-scope.Reference} reference A reference to report.\n     * @param {eslint-scope.Definition} definition A definition for which to report reference.\n     * @returns {void}\n     */\n    function report(reference, definition) {\n      const identifier = reference.identifier;\n      const definitionPosition = definition.name.loc.start;\n      context.report({\n        node: identifier,\n        messageId: \"outOfScope\",\n        data: {\n          name: identifier.name,\n          definitionLine: definitionPosition.line,\n          definitionColumn: definitionPosition.column + 1\n        }\n      });\n    }\n\n    /**\n     * Finds and reports references which are outside of valid scopes.\n     * @param {ASTNode} node A node to get variables.\n     * @returns {void}\n     */\n    function checkForVariables(node) {\n      if (node.kind !== \"var\") {\n        return;\n      }\n\n      // Defines a predicate to check whether or not a given reference is outside of valid scope.\n      const scopeRange = stack[stack.length - 1];\n\n      /**\n       * Check if a reference is out of scope\n       * @param {ASTNode} reference node to examine\n       * @returns {boolean} True is its outside the scope\n       * @private\n       */\n      function isOutsideOfScope(reference) {\n        const idRange = reference.identifier.range;\n        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n      }\n\n      // Gets declared variables, and checks its references.\n      const variables = sourceCode.getDeclaredVariables(node);\n      for (let i = 0; i < variables.length; ++i) {\n        // Reports.\n        variables[i].references.filter(isOutsideOfScope).forEach(ref => report(ref, variables[i].defs.find(def => def.parent === node)));\n      }\n    }\n    return {\n      Program(node) {\n        stack = [node.range];\n      },\n      // Manages scopes.\n      BlockStatement: enterScope,\n      \"BlockStatement:exit\": exitScope,\n      ForStatement: enterScope,\n      \"ForStatement:exit\": exitScope,\n      ForInStatement: enterScope,\n      \"ForInStatement:exit\": exitScope,\n      ForOfStatement: enterScope,\n      \"ForOfStatement:exit\": exitScope,\n      SwitchStatement: enterScope,\n      \"SwitchStatement:exit\": exitScope,\n      CatchClause: enterScope,\n      \"CatchClause:exit\": exitScope,\n      StaticBlock: enterScope,\n      \"StaticBlock:exit\": exitScope,\n      // Finds and reports references which are outside of valid scope.\n      VariableDeclaration: checkForVariables\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","outOfScope","create","context","stack","sourceCode","enterScope","node","push","range","exitScope","pop","report","reference","definition","identifier","definitionPosition","name","loc","start","messageId","data","definitionLine","line","definitionColumn","column","checkForVariables","kind","scopeRange","length","isOutsideOfScope","idRange","variables","getDeclaredVariables","i","references","filter","forEach","ref","defs","find","def","parent","Program","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","CatchClause","StaticBlock","VariableDeclaration"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/block-scoped-var.js"],"sourcesContent":["/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce the use of variables within the scope they are defined\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/block-scoped-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            outOfScope: \"'{{name}}' declared on line {{definitionLine}} column {{definitionColumn}} is used outside of binding context.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference A reference to report.\n         * @param {eslint-scope.Definition} definition A definition for which to report reference.\n         * @returns {void}\n         */\n        function report(reference, definition) {\n            const identifier = reference.identifier;\n            const definitionPosition = definition.name.loc.start;\n\n            context.report({\n                node: identifier,\n                messageId: \"outOfScope\",\n                data: {\n                    name: identifier.name,\n                    definitionLine: definitionPosition.line,\n                    definitionColumn: definitionPosition.column + 1\n                }\n            });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = sourceCode.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(ref => report(ref, variables[i].defs.find(def => def.parent === node)));\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n            StaticBlock: enterScope,\n            \"StaticBlock:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACAA,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YAAY;IAElBC,IAAI,EAAE;MACFC,WAAW,EAAE,gEAAgE;MAC7EC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,EAAE;IAEVC,QAAQ,EAAE;MACNC,UAAU,EAAE;IAChB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,IAAIC,KAAK,GAAG,EAAE;IACd,MAAMC,UAAU,GAAGF,OAAO,CAACE,UAAU;;IAErC;AACR;AACA;AACA;AACA;IACQ,SAASC,UAAUA,CAACC,IAAI,EAAE;MACtBH,KAAK,CAACI,IAAI,CAACD,IAAI,CAACE,KAAK,CAAC;IAC1B;;IAEA;AACR;AACA;AACA;IACQ,SAASC,SAASA,CAAA,EAAG;MACjBN,KAAK,CAACO,GAAG,CAAC,CAAC;IACf;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASC,MAAMA,CAACC,SAAS,EAAEC,UAAU,EAAE;MACnC,MAAMC,UAAU,GAAGF,SAAS,CAACE,UAAU;MACvC,MAAMC,kBAAkB,GAAGF,UAAU,CAACG,IAAI,CAACC,GAAG,CAACC,KAAK;MAEpDhB,OAAO,CAACS,MAAM,CAAC;QACXL,IAAI,EAAEQ,UAAU;QAChBK,SAAS,EAAE,YAAY;QACvBC,IAAI,EAAE;UACFJ,IAAI,EAAEF,UAAU,CAACE,IAAI;UACrBK,cAAc,EAAEN,kBAAkB,CAACO,IAAI;UACvCC,gBAAgB,EAAER,kBAAkB,CAACS,MAAM,GAAG;QAClD;MACJ,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASC,iBAAiBA,CAACnB,IAAI,EAAE;MAC7B,IAAIA,IAAI,CAACoB,IAAI,KAAK,KAAK,EAAE;QACrB;MACJ;;MAEA;MACA,MAAMC,UAAU,GAAGxB,KAAK,CAACA,KAAK,CAACyB,MAAM,GAAG,CAAC,CAAC;;MAE1C;AACZ;AACA;AACA;AACA;AACA;MACY,SAASC,gBAAgBA,CAACjB,SAAS,EAAE;QACjC,MAAMkB,OAAO,GAAGlB,SAAS,CAACE,UAAU,CAACN,KAAK;QAE1C,OAAOsB,OAAO,CAAC,CAAC,CAAC,GAAGH,UAAU,CAAC,CAAC,CAAC,IAAIG,OAAO,CAAC,CAAC,CAAC,GAAGH,UAAU,CAAC,CAAC,CAAC;MACnE;;MAEA;MACA,MAAMI,SAAS,GAAG3B,UAAU,CAAC4B,oBAAoB,CAAC1B,IAAI,CAAC;MAEvD,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACH,MAAM,EAAE,EAAEK,CAAC,EAAE;QAEvC;QACAF,SAAS,CAACE,CAAC,CAAC,CACPC,UAAU,CACVC,MAAM,CAACN,gBAAgB,CAAC,CACxBO,OAAO,CAACC,GAAG,IAAI1B,MAAM,CAAC0B,GAAG,EAAEN,SAAS,CAACE,CAAC,CAAC,CAACK,IAAI,CAACC,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAKnC,IAAI,CAAC,CAAC,CAAC;MACxF;IACJ;IAEA,OAAO;MACHoC,OAAOA,CAACpC,IAAI,EAAE;QACVH,KAAK,GAAG,CAACG,IAAI,CAACE,KAAK,CAAC;MACxB,CAAC;MAED;MACAmC,cAAc,EAAEtC,UAAU;MAC1B,qBAAqB,EAAEI,SAAS;MAChCmC,YAAY,EAAEvC,UAAU;MACxB,mBAAmB,EAAEI,SAAS;MAC9BoC,cAAc,EAAExC,UAAU;MAC1B,qBAAqB,EAAEI,SAAS;MAChCqC,cAAc,EAAEzC,UAAU;MAC1B,qBAAqB,EAAEI,SAAS;MAChCsC,eAAe,EAAE1C,UAAU;MAC3B,sBAAsB,EAAEI,SAAS;MACjCuC,WAAW,EAAE3C,UAAU;MACvB,kBAAkB,EAAEI,SAAS;MAC7BwC,WAAW,EAAE5C,UAAU;MACvB,kBAAkB,EAAEI,SAAS;MAE7B;MACAyC,mBAAmB,EAAEzB;IACzB,CAAC;EAEL;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}