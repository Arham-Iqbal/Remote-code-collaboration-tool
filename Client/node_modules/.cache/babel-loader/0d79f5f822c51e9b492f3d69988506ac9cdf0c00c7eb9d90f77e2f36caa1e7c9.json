{"ast":null,"code":"/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n * @deprecated in ESLint v8.46.0\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    hasSuggestions: true,\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unnecessary `return await`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-return-await\"\n    },\n    fixable: null,\n    deprecated: true,\n    replacedBy: [],\n    schema: [],\n    messages: {\n      removeAwait: \"Remove redundant `await`.\",\n      redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\n    }\n  },\n  create(context) {\n    /**\n     * Reports a found unnecessary `await` expression.\n     * @param {ASTNode} node The node representing the `await` expression to report\n     * @returns {void}\n     */\n    function reportUnnecessaryAwait(node) {\n      context.report({\n        node: context.sourceCode.getFirstToken(node),\n        loc: node.loc,\n        messageId: \"redundantUseOfAwait\",\n        suggest: [{\n          messageId: \"removeAwait\",\n          fix(fixer) {\n            const sourceCode = context.sourceCode;\n            const [awaitToken, tokenAfterAwait] = sourceCode.getFirstTokens(node, 2);\n            const areAwaitAndAwaitedExpressionOnTheSameLine = awaitToken.loc.start.line === tokenAfterAwait.loc.start.line;\n            if (!areAwaitAndAwaitedExpressionOnTheSameLine) {\n              return null;\n            }\n            const [startOfAwait, endOfAwait] = awaitToken.range;\n            const characterAfterAwait = sourceCode.text[endOfAwait];\n            const trimLength = characterAfterAwait === \" \" ? 1 : 0;\n            const range = [startOfAwait, endOfAwait + trimLength];\n            return fixer.removeRange(range);\n          }\n        }]\n      });\n    }\n\n    /**\n     * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n     * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n     * a `catch` block will only have an error handler if there is also a `finally` block.\n     * @param {ASTNode} node A node representing a location where an could be thrown\n     * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n     */\n    function hasErrorHandler(node) {\n      let ancestor = node;\n      while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n        if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n          return true;\n        }\n        ancestor = ancestor.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n     * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n     * @param {ASTNode} node A node representing the `await` expression to check\n     * @returns {boolean} The checking result\n     */\n    function isInTailCallPosition(node) {\n      if (node.parent.type === \"ArrowFunctionExpression\") {\n        return true;\n      }\n      if (node.parent.type === \"ReturnStatement\") {\n        return !hasErrorHandler(node.parent);\n      }\n      if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n        return isInTailCallPosition(node.parent);\n      }\n      if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n        return isInTailCallPosition(node.parent);\n      }\n      if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n        return isInTailCallPosition(node.parent);\n      }\n      return false;\n    }\n    return {\n      AwaitExpression(node) {\n        if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n          reportUnnecessaryAwait(node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","hasSuggestions","type","docs","description","recommended","url","fixable","deprecated","replacedBy","schema","messages","removeAwait","redundantUseOfAwait","create","context","reportUnnecessaryAwait","node","report","sourceCode","getFirstToken","loc","messageId","suggest","fix","fixer","awaitToken","tokenAfterAwait","getFirstTokens","areAwaitAndAwaitedExpressionOnTheSameLine","start","line","startOfAwait","endOfAwait","range","characterAfterAwait","text","trimLength","removeRange","hasErrorHandler","ancestor","isFunction","parent","block","handler","finalizer","isInTailCallPosition","consequent","alternate","right","expressions","length","AwaitExpression"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-return-await.js"],"sourcesContent":["/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n * @deprecated in ESLint v8.46.0\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        hasSuggestions: true,\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary `return await`\",\n\n            recommended: false,\n\n            url: \"https://eslint.org/docs/latest/rules/no-return-await\"\n        },\n\n        fixable: null,\n\n        deprecated: true,\n\n        replacedBy: [],\n\n        schema: [\n        ],\n\n        messages: {\n            removeAwait: \"Remove redundant `await`.\",\n            redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports a found unnecessary `await` expression.\n         * @param {ASTNode} node The node representing the `await` expression to report\n         * @returns {void}\n         */\n        function reportUnnecessaryAwait(node) {\n            context.report({\n                node: context.sourceCode.getFirstToken(node),\n                loc: node.loc,\n                messageId: \"redundantUseOfAwait\",\n                suggest: [\n                    {\n                        messageId: \"removeAwait\",\n                        fix(fixer) {\n                            const sourceCode = context.sourceCode;\n                            const [awaitToken, tokenAfterAwait] = sourceCode.getFirstTokens(node, 2);\n\n                            const areAwaitAndAwaitedExpressionOnTheSameLine = awaitToken.loc.start.line === tokenAfterAwait.loc.start.line;\n\n                            if (!areAwaitAndAwaitedExpressionOnTheSameLine) {\n                                return null;\n                            }\n\n                            const [startOfAwait, endOfAwait] = awaitToken.range;\n\n                            const characterAfterAwait = sourceCode.text[endOfAwait];\n                            const trimLength = characterAfterAwait === \" \" ? 1 : 0;\n\n                            const range = [startOfAwait, endOfAwait + trimLength];\n\n                            return fixer.removeRange(range);\n                        }\n                    }\n                ]\n\n            });\n        }\n\n        /**\n         * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n         * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n         * a `catch` block will only have an error handler if there is also a `finally` block.\n         * @param {ASTNode} node A node representing a location where an could be thrown\n         * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n         */\n        function hasErrorHandler(node) {\n            let ancestor = node;\n\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n         * @param {ASTNode} node A node representing the `await` expression to check\n         * @returns {boolean} The checking result\n         */\n        function isInTailCallPosition(node) {\n            if (node.parent.type === \"ArrowFunctionExpression\") {\n                return true;\n            }\n            if (node.parent.type === \"ReturnStatement\") {\n                return !hasErrorHandler(node.parent);\n            }\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n                return isInTailCallPosition(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            AwaitExpression(node) {\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n                    reportUnnecessaryAwait(node);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}