{"ast":null,"code":"/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Enforce comparing `typeof` expressions against valid strings\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/valid-typeof\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        requireStringLiterals: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalidValue: \"Invalid typeof comparison value.\",\n      notString: \"Typeof comparisons should be to string literals.\",\n      suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\n    }\n  },\n  create(context) {\n    const VALID_TYPES = new Set([\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"]),\n      OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\"]);\n    const sourceCode = context.sourceCode;\n    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n    let globalScope;\n\n    /**\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a reference to a global variable.\n     */\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n\n    /**\n     * Determines whether a node is a typeof expression.\n     * @param {ASTNode} node The node\n     * @returns {boolean} `true` if the node is a typeof expression\n     */\n    function isTypeofExpression(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program(node) {\n        globalScope = sourceCode.getScope(node);\n      },\n      UnaryExpression(node) {\n        if (isTypeofExpression(node)) {\n          const {\n            parent\n          } = node;\n          if (parent.type === \"BinaryExpression\" && OPERATORS.has(parent.operator)) {\n            const sibling = parent.left === node ? parent.right : parent.left;\n            if (sibling.type === \"Literal\" || astUtils.isStaticTemplateLiteral(sibling)) {\n              const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n              if (!VALID_TYPES.has(value)) {\n                context.report({\n                  node: sibling,\n                  messageId: \"invalidValue\"\n                });\n              }\n            } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\n                suggest: [{\n                  messageId: \"suggestString\",\n                  data: {\n                    type: \"undefined\"\n                  },\n                  fix(fixer) {\n                    return fixer.replaceText(sibling, '\"undefined\"');\n                  }\n                }]\n              });\n            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: \"notString\"\n              });\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","hasSuggestions","schema","properties","requireStringLiterals","default","additionalProperties","messages","invalidValue","notString","suggestString","create","context","VALID_TYPES","Set","OPERATORS","sourceCode","options","globalScope","isReferenceToGlobalVariable","node","variable","set","get","name","defs","length","references","some","ref","identifier","isTypeofExpression","operator","Program","getScope","UnaryExpression","parent","has","sibling","left","right","isStaticTemplateLiteral","value","quasis","cooked","report","messageId","suggest","data","fix","fixer","replaceText"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/valid-typeof.js"],"sourcesContent":["/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Enforce comparing `typeof` expressions against valid strings\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/valid-typeof\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\",\n            suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\n        }\n    },\n\n    create(context) {\n\n        const VALID_TYPES = new Set([\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"]),\n            OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\"]);\n        const sourceCode = context.sourceCode;\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        let globalScope;\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program(node) {\n                globalScope = sourceCode.getScope(node);\n            },\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const { parent } = node;\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.has(parent.operator)) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || astUtils.isStaticTemplateLiteral(sibling)) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (!VALID_TYPES.has(value)) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\n                            context.report({\n                                node: sibling,\n                                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\n                                suggest: [\n                                    {\n                                        messageId: \"suggestString\",\n                                        data: { type: \"undefined\" },\n                                        fix(fixer) {\n                                            return fixer.replaceText(sibling, '\"undefined\"');\n                                        }\n                                    }\n                                ]\n                            });\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}