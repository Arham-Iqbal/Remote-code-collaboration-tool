{"ast":null,"code":"/**\n * @fileoverview Rule to flag dangling underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow dangling underscores in identifiers\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-underscore-dangle\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        allowAfterThis: {\n          type: \"boolean\",\n          default: false\n        },\n        allowAfterSuper: {\n          type: \"boolean\",\n          default: false\n        },\n        allowAfterThisConstructor: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceInMethodNames: {\n          type: \"boolean\",\n          default: false\n        },\n        allowFunctionParams: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceInClassFields: {\n          type: \"boolean\",\n          default: false\n        },\n        allowInArrayDestructuring: {\n          type: \"boolean\",\n          default: true\n        },\n        allowInObjectDestructuring: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n    const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n    const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n    const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== \"undefined\" ? options.allowAfterThisConstructor : false;\n    const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n    const enforceInClassFields = typeof options.enforceInClassFields !== \"undefined\" ? options.enforceInClassFields : false;\n    const allowFunctionParams = typeof options.allowFunctionParams !== \"undefined\" ? options.allowFunctionParams : true;\n    const allowInArrayDestructuring = typeof options.allowInArrayDestructuring !== \"undefined\" ? options.allowInArrayDestructuring : true;\n    const allowInObjectDestructuring = typeof options.allowInObjectDestructuring !== \"undefined\" ? options.allowInObjectDestructuring : true;\n    const sourceCode = context.sourceCode;\n\n    //-------------------------------------------------------------------------\n    // Helpers\n    //-------------------------------------------------------------------------\n\n    /**\n     * Check if identifier is present inside the allowed option\n     * @param {string} identifier name of the node\n     * @returns {boolean} true if its is present\n     * @private\n     */\n    function isAllowed(identifier) {\n      return ALLOWED_VARIABLES.includes(identifier);\n    }\n\n    /**\n     * Check if identifier has a dangling underscore\n     * @param {string} identifier name of the node\n     * @returns {boolean} true if its is present\n     * @private\n     */\n    function hasDanglingUnderscore(identifier) {\n      const len = identifier.length;\n      return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n    }\n\n    /**\n     * Check if identifier is a special case member expression\n     * @param {string} identifier name of the node\n     * @returns {boolean} true if its is a special case\n     * @private\n     */\n    function isSpecialCaseIdentifierForMemberExpression(identifier) {\n      return identifier === \"__proto__\";\n    }\n\n    /**\n     * Check if identifier is a special case variable expression\n     * @param {string} identifier name of the node\n     * @returns {boolean} true if its is a special case\n     * @private\n     */\n    function isSpecialCaseIdentifierInVariableExpression(identifier) {\n      // Checks for the underscore library usage here\n      return identifier === \"_\";\n    }\n\n    /**\n     * Check if a node is a member reference of this.constructor\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} true if it is a reference on this.constructor\n     * @private\n     */\n    function isThisConstructorReference(node) {\n      return node.object.type === \"MemberExpression\" && node.object.property.name === \"constructor\" && node.object.object.type === \"ThisExpression\";\n    }\n\n    /**\n     * Check if function parameter has a dangling underscore.\n     * @param {ASTNode} node function node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkForDanglingUnderscoreInFunctionParameters(node) {\n      if (!allowFunctionParams) {\n        node.params.forEach(param => {\n          const {\n            type\n          } = param;\n          let nodeToCheck;\n          if (type === \"RestElement\") {\n            nodeToCheck = param.argument;\n          } else if (type === \"AssignmentPattern\") {\n            nodeToCheck = param.left;\n          } else {\n            nodeToCheck = param;\n          }\n          if (nodeToCheck.type === \"Identifier\") {\n            const identifier = nodeToCheck.name;\n            if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n              context.report({\n                node: param,\n                messageId: \"unexpectedUnderscore\",\n                data: {\n                  identifier\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n\n    /**\n     * Check if function has a dangling underscore\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkForDanglingUnderscoreInFunction(node) {\n      if (node.type === \"FunctionDeclaration\" && node.id) {\n        const identifier = node.id.name;\n        if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n          context.report({\n            node,\n            messageId: \"unexpectedUnderscore\",\n            data: {\n              identifier\n            }\n          });\n        }\n      }\n      checkForDanglingUnderscoreInFunctionParameters(node);\n    }\n\n    /**\n     * Check if variable expression has a dangling underscore\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkForDanglingUnderscoreInVariableExpression(node) {\n      sourceCode.getDeclaredVariables(node).forEach(variable => {\n        const definition = variable.defs.find(def => def.node === node);\n        const identifierNode = definition.name;\n        const identifier = identifierNode.name;\n        let parent = identifierNode.parent;\n        while (![\"VariableDeclarator\", \"ArrayPattern\", \"ObjectPattern\"].includes(parent.type)) {\n          parent = parent.parent;\n        }\n        if (hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier) && !(allowInArrayDestructuring && parent.type === \"ArrayPattern\") && !(allowInObjectDestructuring && parent.type === \"ObjectPattern\")) {\n          context.report({\n            node,\n            messageId: \"unexpectedUnderscore\",\n            data: {\n              identifier\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Check if member expression has a dangling underscore\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkForDanglingUnderscoreInMemberExpression(node) {\n      const identifier = node.property.name,\n        isMemberOfThis = node.object.type === \"ThisExpression\",\n        isMemberOfSuper = node.object.type === \"Super\",\n        isMemberOfThisConstructor = isThisConstructorReference(node);\n      if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier\n          }\n        });\n      }\n    }\n\n    /**\n     * Check if method declaration or method property has a dangling underscore\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkForDanglingUnderscoreInMethod(node) {\n      const identifier = node.key.name;\n      const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n      if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier: node.key.type === \"PrivateIdentifier\" ? `#${identifier}` : identifier\n          }\n        });\n      }\n    }\n\n    /**\n     * Check if a class field has a dangling underscore\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkForDanglingUnderscoreInClassField(node) {\n      const identifier = node.key.name;\n      if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && enforceInClassFields && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier: node.key.type === \"PrivateIdentifier\" ? `#${identifier}` : identifier\n          }\n        });\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      FunctionDeclaration: checkForDanglingUnderscoreInFunction,\n      VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,\n      MemberExpression: checkForDanglingUnderscoreInMemberExpression,\n      MethodDefinition: checkForDanglingUnderscoreInMethod,\n      PropertyDefinition: checkForDanglingUnderscoreInClassField,\n      Property: checkForDanglingUnderscoreInMethod,\n      FunctionExpression: checkForDanglingUnderscoreInFunction,\n      ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","allow","items","allowAfterThis","default","allowAfterSuper","allowAfterThisConstructor","enforceInMethodNames","allowFunctionParams","enforceInClassFields","allowInArrayDestructuring","allowInObjectDestructuring","additionalProperties","messages","unexpectedUnderscore","create","context","options","ALLOWED_VARIABLES","sourceCode","isAllowed","identifier","includes","hasDanglingUnderscore","len","length","isSpecialCaseIdentifierForMemberExpression","isSpecialCaseIdentifierInVariableExpression","isThisConstructorReference","node","object","property","name","checkForDanglingUnderscoreInFunctionParameters","params","forEach","param","nodeToCheck","argument","left","report","messageId","data","checkForDanglingUnderscoreInFunction","id","checkForDanglingUnderscoreInVariableExpression","getDeclaredVariables","variable","definition","defs","find","def","identifierNode","parent","checkForDanglingUnderscoreInMemberExpression","isMemberOfThis","isMemberOfSuper","isMemberOfThisConstructor","checkForDanglingUnderscoreInMethod","key","isMethod","method","checkForDanglingUnderscoreInClassField","FunctionDeclaration","VariableDeclarator","MemberExpression","MethodDefinition","PropertyDefinition","Property","FunctionExpression","ArrowFunctionExpression"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-underscore-dangle.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag dangling underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow dangling underscores in identifiers\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-underscore-dangle\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowAfterThis: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowAfterSuper: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowAfterThisConstructor: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceInMethodNames: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowFunctionParams: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    enforceInClassFields: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowInArrayDestructuring: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    allowInObjectDestructuring: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n        const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n        const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n        const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== \"undefined\" ? options.allowAfterThisConstructor : false;\n        const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n        const enforceInClassFields = typeof options.enforceInClassFields !== \"undefined\" ? options.enforceInClassFields : false;\n        const allowFunctionParams = typeof options.allowFunctionParams !== \"undefined\" ? options.allowFunctionParams : true;\n        const allowInArrayDestructuring = typeof options.allowInArrayDestructuring !== \"undefined\" ? options.allowInArrayDestructuring : true;\n        const allowInObjectDestructuring = typeof options.allowInObjectDestructuring !== \"undefined\" ? options.allowInObjectDestructuring : true;\n        const sourceCode = context.sourceCode;\n\n        //-------------------------------------------------------------------------\n        // Helpers\n        //-------------------------------------------------------------------------\n\n        /**\n         * Check if identifier is present inside the allowed option\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function isAllowed(identifier) {\n            return ALLOWED_VARIABLES.includes(identifier);\n        }\n\n        /**\n         * Check if identifier has a dangling underscore\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function hasDanglingUnderscore(identifier) {\n            const len = identifier.length;\n\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n        }\n\n        /**\n         * Check if identifier is a special case member expression\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\n            return identifier === \"__proto__\";\n        }\n\n        /**\n         * Check if identifier is a special case variable expression\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\n\n            // Checks for the underscore library usage here\n            return identifier === \"_\";\n        }\n\n        /**\n         * Check if a node is a member reference of this.constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} true if it is a reference on this.constructor\n         * @private\n         */\n        function isThisConstructorReference(node) {\n            return node.object.type === \"MemberExpression\" &&\n                node.object.property.name === \"constructor\" &&\n                node.object.object.type === \"ThisExpression\";\n        }\n\n        /**\n         * Check if function parameter has a dangling underscore.\n         * @param {ASTNode} node function node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInFunctionParameters(node) {\n            if (!allowFunctionParams) {\n                node.params.forEach(param => {\n                    const { type } = param;\n                    let nodeToCheck;\n\n                    if (type === \"RestElement\") {\n                        nodeToCheck = param.argument;\n                    } else if (type === \"AssignmentPattern\") {\n                        nodeToCheck = param.left;\n                    } else {\n                        nodeToCheck = param;\n                    }\n\n                    if (nodeToCheck.type === \"Identifier\") {\n                        const identifier = nodeToCheck.name;\n\n                        if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                            context.report({\n                                node: param,\n                                messageId: \"unexpectedUnderscore\",\n                                data: {\n                                    identifier\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if function has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInFunction(node) {\n            if (node.type === \"FunctionDeclaration\" && node.id) {\n                const identifier = node.id.name;\n\n                if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedUnderscore\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            }\n            checkForDanglingUnderscoreInFunctionParameters(node);\n        }\n\n\n        /**\n         * Check if variable expression has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInVariableExpression(node) {\n            sourceCode.getDeclaredVariables(node).forEach(variable => {\n                const definition = variable.defs.find(def => def.node === node);\n                const identifierNode = definition.name;\n                const identifier = identifierNode.name;\n                let parent = identifierNode.parent;\n\n                while (![\"VariableDeclarator\", \"ArrayPattern\", \"ObjectPattern\"].includes(parent.type)) {\n                    parent = parent.parent;\n                }\n\n                if (\n                    hasDanglingUnderscore(identifier) &&\n                    !isSpecialCaseIdentifierInVariableExpression(identifier) &&\n                    !isAllowed(identifier) &&\n                    !(allowInArrayDestructuring && parent.type === \"ArrayPattern\") &&\n                    !(allowInObjectDestructuring && parent.type === \"ObjectPattern\")\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedUnderscore\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Check if member expression has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInMemberExpression(node) {\n            const identifier = node.property.name,\n                isMemberOfThis = node.object.type === \"ThisExpression\",\n                isMemberOfSuper = node.object.type === \"Super\",\n                isMemberOfThisConstructor = isThisConstructorReference(node);\n\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\n                !(isMemberOfThis && allowAfterThis) &&\n                !(isMemberOfSuper && allowAfterSuper) &&\n                !(isMemberOfThisConstructor && allowAfterThisConstructor) &&\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if method declaration or method property has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInMethod(node) {\n            const identifier = node.key.name;\n            const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n            if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier: node.key.type === \"PrivateIdentifier\"\n                            ? `#${identifier}`\n                            : identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if a class field has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInClassField(node) {\n            const identifier = node.key.name;\n\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\n                enforceInClassFields &&\n                !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier: node.key.type === \"PrivateIdentifier\"\n                            ? `#${identifier}`\n                            : identifier\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkForDanglingUnderscoreInFunction,\n            VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,\n            MemberExpression: checkForDanglingUnderscoreInMemberExpression,\n            MethodDefinition: checkForDanglingUnderscoreInMethod,\n            PropertyDefinition: checkForDanglingUnderscoreInClassField,\n            Property: checkForDanglingUnderscoreInMethod,\n            FunctionExpression: checkForDanglingUnderscoreInFunction,\n            ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}