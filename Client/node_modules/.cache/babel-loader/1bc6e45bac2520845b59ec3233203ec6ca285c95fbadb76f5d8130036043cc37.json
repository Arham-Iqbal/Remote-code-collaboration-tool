{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n  return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n  return [\"<\", \"<=\"].includes(operator);\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.prefix && astUtils.isNumericLiteral(node.argument);\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n  return isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n  if (node.type === \"Literal\") {\n    return node;\n  }\n  if (isNegativeNumericLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: -node.argument.value,\n      raw: `-${node.argument.value}`\n    };\n  }\n  if (astUtils.isStaticTemplateLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: node.quasis[0].value.cooked,\n      raw: node.quasis[0].value.raw\n    };\n  }\n  return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: 'Require or disallow \"Yoda\" conditions',\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/yoda\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptRange: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyEquality: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n    }\n  },\n  create(context) {\n    // Default to \"never\" (!always) if no option\n    const always = context.options[0] === \"always\";\n    const exceptRange = context.options[1] && context.options[1].exceptRange;\n    const onlyEquality = context.options[1] && context.options[1].onlyEquality;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Determines whether node represents a range test.\n     * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n     * both operators must be `<` or `<=`. Finally, the literal on the left side\n     * must be less than or equal to the literal on the right side so that the\n     * test makes any sense.\n     * @param {ASTNode} node LogicalExpression node to test.\n     * @returns {boolean} Whether node is a range test.\n     */\n    function isRangeTest(node) {\n      const left = node.left,\n        right = node.right;\n\n      /**\n       * Determines whether node is of the form `0 <= x && x < 1`.\n       * @returns {boolean} Whether node is a \"between\" range test.\n       */\n      function isBetweenTest() {\n        if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n          const leftLiteral = getNormalizedLiteral(left.left);\n          const rightLiteral = getNormalizedLiteral(right.right);\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Determines whether node is of the form `x < 0 || 1 <= x`.\n       * @returns {boolean} Whether node is an \"outside\" range test.\n       */\n      function isOutsideTest() {\n        if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n          const leftLiteral = getNormalizedLiteral(left.right);\n          const rightLiteral = getNormalizedLiteral(right.left);\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Determines whether node is wrapped in parentheses.\n       * @returns {boolean} Whether node is preceded immediately by an open\n       *                    paren token and followed immediately by a close\n       *                    paren token.\n       */\n      function isParenWrapped() {\n        return astUtils.isParenthesised(sourceCode, node);\n      }\n      return node.type === \"LogicalExpression\" && left.type === \"BinaryExpression\" && right.type === \"BinaryExpression\" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();\n    }\n    const OPERATOR_FLIP_MAP = {\n      \"===\": \"===\",\n      \"!==\": \"!==\",\n      \"==\": \"==\",\n      \"!=\": \"!=\",\n      \"<\": \">\",\n      \">\": \"<\",\n      \"<=\": \">=\",\n      \">=\": \"<=\"\n    };\n\n    /**\n     * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n     * @param {ASTNode} node The BinaryExpression node\n     * @returns {string} A string representation of the node with the sides and operator flipped\n     */\n    function getFlippedString(node) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n      const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n      const source = sourceCode.getText();\n      const leftText = source.slice(node.range[0], lastLeftToken.range[1]);\n      const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);\n      const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);\n      const rightText = source.slice(firstRightToken.range[0], node.range[1]);\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      let prefix = \"\";\n      let suffix = \"\";\n      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n        prefix = \" \";\n      }\n      if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {\n        suffix = \" \";\n      }\n      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      BinaryExpression(node) {\n        const expectedLiteral = always ? node.left : node.right;\n        const expectedNonLiteral = always ? node.right : node.left;\n\n        // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n        if ((expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(node.parent))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              operator: node.operator,\n              expectedSide: always ? \"left\" : \"right\"\n            },\n            fix: fixer => fixer.replaceText(node, getFlippedString(node))\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isComparisonOperator","operator","test","isEqualityOperator","isRangeTestOperator","includes","isNegativeNumericLiteral","node","type","prefix","isNumericLiteral","argument","looksLikeLiteral","isStaticTemplateLiteral","getNormalizedLiteral","value","raw","quasis","cooked","module","exports","meta","docs","description","recommended","url","schema","enum","properties","exceptRange","default","onlyEquality","additionalProperties","fixable","messages","expected","create","context","always","options","sourceCode","isRangeTest","left","right","isBetweenTest","isSameReference","leftLiteral","rightLiteral","isOutsideTest","isParenWrapped","isParenthesised","OPERATOR_FLIP_MAP","getFlippedString","operatorToken","getFirstTokenBetween","token","lastLeftToken","getTokenBefore","firstRightToken","getTokenAfter","source","getText","leftText","slice","range","textBeforeOperator","textAfterOperator","rightText","tokenBefore","tokenAfter","suffix","canTokensBeAdjacent","BinaryExpression","expectedLiteral","expectedNonLiteral","parent","report","messageId","data","expectedSide","fix","fixer","replaceText"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/yoda.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].includes(operator);\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n    return (\n        node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        astUtils.isNumericLiteral(node.argument)\n    );\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n    return isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (isNegativeNumericLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (astUtils.isStaticTemplateLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: node.quasis[0].value.cooked,\n            raw: node.quasis[0].value.raw\n        };\n    }\n\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: 'Require or disallow \"Yoda\" conditions',\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyEquality: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected:\n                \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = context.options[0] === \"always\";\n        const exceptRange =\n            context.options[1] && context.options[1].exceptRange;\n        const onlyEquality =\n            context.options[1] && context.options[1].onlyEquality;\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n                    const leftLiteral = getNormalizedLiteral(left.left);\n                    const rightLiteral = getNormalizedLiteral(right.right);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n                    const leftLiteral = getNormalizedLiteral(left.right);\n                    const rightLiteral = getNormalizedLiteral(right.left);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (\n                node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped()\n            );\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n\n            const source = sourceCode.getText();\n\n            const leftText = source.slice(\n                node.range[0],\n                lastLeftToken.range[1]\n            );\n            const textBeforeOperator = source.slice(\n                lastLeftToken.range[1],\n                operatorToken.range[0]\n            );\n            const textAfterOperator = source.slice(\n                operatorToken.range[1],\n                firstRightToken.range[0]\n            );\n            const rightText = source.slice(\n                firstRightToken.range[0],\n                node.range[1]\n            );\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n            let prefix = \"\";\n            let suffix = \"\";\n\n            if (\n                tokenBefore &&\n                tokenBefore.range[1] === node.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)\n            ) {\n                prefix = \" \";\n            }\n\n            if (\n                tokenAfter &&\n                node.range[1] === tokenAfter.range[0] &&\n                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)\n            ) {\n                suffix = \" \";\n            }\n\n            return (\n                prefix +\n                rightText +\n                textBeforeOperator +\n                OPERATOR_FLIP_MAP[operatorToken.value] +\n                textAfterOperator +\n                leftText +\n                suffix\n            );\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedNonLiteral)) &&\n                    !(\n                        expectedLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedLiteral)\n                    ) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(node.parent))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer =>\n                            fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}