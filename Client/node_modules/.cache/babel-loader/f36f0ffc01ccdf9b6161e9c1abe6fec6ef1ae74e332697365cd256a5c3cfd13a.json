{"ast":null,"code":"/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  findVariable\n} = require(\"@eslint-community/eslint-utils\");\nconst {\n  RegExpValidator,\n  visitRegExpAST,\n  RegExpParser\n} = require(\"@eslint-community/regexpp\");\nconst {\n  canTokensBeAdjacent\n} = require(\"./utils/ast-utils\");\nconst {\n  REGEXPP_LATEST_ECMA_VERSION\n} = require(\"./utils/regular-expressions\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n  return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\nconst validPrecedingTokens = new Set([\"(\", \";\", \"[\", \",\", \"=\", \"+\", \"*\", \"-\", \"?\", \"~\", \"%\", \"**\", \"!\", \"typeof\", \"instanceof\", \"&&\", \"||\", \"??\", \"return\", \"...\", \"delete\", \"void\", \"in\", \"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\", \"<<\", \">>\", \">>>\", \"&\", \"|\", \"^\", \":\", \"{\", \"=>\", \"*=\", \"<<=\", \">>=\", \">>>=\", \"^=\", \"|=\", \"&=\", \"??=\", \"||=\", \"&&=\", \"**=\", \"+=\", \"-=\", \"/=\", \"%=\", \"/\", \"do\", \"break\", \"continue\", \"debugger\", \"case\", \"throw\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/prefer-regex-literals\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowRedundantWrapping: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n      replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\n      replaceWithLiteralAndFlags: \"Replace with an equivalent regular expression literal with flags '{{ flags }}'.\",\n      replaceWithIntendedLiteralAndFlags: \"Replace with a regular expression literal with flags '{{ flags }}'.\",\n      unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n      unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n    }\n  },\n  create(context) {\n    const [{\n      disallowRedundantWrapping = false\n    } = {}] = context.options;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Determines whether the given identifier node is a reference to a global variable.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} True if the identifier is a reference to a global variable.\n     */\n    function isGlobalReference(node) {\n      const scope = sourceCode.getScope(node);\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n\n    /**\n     * Determines whether the given node is a String.raw`` tagged template expression\n     * with a static template literal.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is String.raw`` with a static template.\n     */\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && astUtils.isStaticTemplateLiteral(node.quasi);\n    }\n\n    /**\n     * Gets the value of a string\n     * @param {ASTNode} node The node to get the string of.\n     * @returns {string|null} The value of the node.\n     */\n    function getStringValue(node) {\n      if (isStringLiteral(node)) {\n        return node.value;\n      }\n      if (astUtils.isStaticTemplateLiteral(node)) {\n        return node.quasis[0].value.cooked;\n      }\n      if (isStringRawTaggedStaticTemplateLiteral(node)) {\n        return node.quasi.quasis[0].value.raw;\n      }\n      return null;\n    }\n\n    /**\n     * Determines whether the given node is considered to be a static string by the logic of this rule.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is a static string.\n     */\n    function isStaticString(node) {\n      return isStringLiteral(node) || astUtils.isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n\n    /**\n     * Determines whether the relevant arguments of the given are all static string literals.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if all arguments are static strings.\n     */\n    function hasOnlyStaticStringArguments(node) {\n      const args = node.arguments;\n      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node already contains a regex literal argument.\n     */\n    function isUnnecessarilyWrappedRegexLiteral(node) {\n      const args = node.arguments;\n      if (args.length === 1 && isRegexLiteral(args[0])) {\n        return true;\n      }\n      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns a ecmaVersion compatible for regexpp.\n     * @param {number} ecmaVersion The ecmaVersion to convert.\n     * @returns {import(\"@eslint-community/regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\n     */\n    function getRegexppEcmaVersion(ecmaVersion) {\n      if (ecmaVersion <= 5) {\n        return 5;\n      }\n      return Math.min(ecmaVersion, REGEXPP_LATEST_ECMA_VERSION);\n    }\n    const regexppEcmaVersion = getRegexppEcmaVersion(context.languageOptions.ecmaVersion);\n\n    /**\n     * Makes a character escaped or else returns null.\n     * @param {string} character The character to escape.\n     * @returns {string} The resulting escaped character.\n     */\n    function resolveEscapes(character) {\n      switch (character) {\n        case \"\\n\":\n        case \"\\\\\\n\":\n          return \"\\\\n\";\n        case \"\\r\":\n        case \"\\\\\\r\":\n          return \"\\\\r\";\n        case \"\\t\":\n        case \"\\\\\\t\":\n          return \"\\\\t\";\n        case \"\\v\":\n        case \"\\\\\\v\":\n          return \"\\\\v\";\n        case \"\\f\":\n        case \"\\\\\\f\":\n          return \"\\\\f\";\n        case \"/\":\n          return \"\\\\/\";\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Checks whether the given regex and flags are valid for the ecma version or not.\n     * @param {string} pattern The regex pattern to check.\n     * @param {string | undefined} flags The regex flags to check.\n     * @returns {boolean} True if the given regex pattern and flags are valid for the ecma version.\n     */\n    function isValidRegexForEcmaVersion(pattern, flags) {\n      const validator = new RegExpValidator({\n        ecmaVersion: regexppEcmaVersion\n      });\n      try {\n        validator.validatePattern(pattern, 0, pattern.length, {\n          unicode: flags ? flags.includes(\"u\") : false,\n          unicodeSets: flags ? flags.includes(\"v\") : false\n        });\n        if (flags) {\n          validator.validateFlags(flags);\n        }\n        return true;\n      } catch {\n        return false;\n      }\n    }\n\n    /**\n     * Checks whether two given regex flags contain the same flags or not.\n     * @param {string} flagsA The regex flags.\n     * @param {string} flagsB The regex flags.\n     * @returns {boolean} True if two regex flags contain same flags.\n     */\n    function areFlagsEqual(flagsA, flagsB) {\n      return [...flagsA].sort().join(\"\") === [...flagsB].sort().join(\"\");\n    }\n\n    /**\n     * Merges two regex flags.\n     * @param {string} flagsA The regex flags.\n     * @param {string} flagsB The regex flags.\n     * @returns {string} The merged regex flags.\n     */\n    function mergeRegexFlags(flagsA, flagsB) {\n      const flagsSet = new Set([...flagsA, ...flagsB]);\n      return [...flagsSet].join(\"\");\n    }\n\n    /**\n     * Checks whether a give node can be fixed to the given regex pattern and flags.\n     * @param {ASTNode} node The node to check.\n     * @param {string} pattern The regex pattern to check.\n     * @param {string} flags The regex flags\n     * @returns {boolean} True if a node can be fixed to the given regex pattern and flags.\n     */\n    function canFixTo(node, pattern, flags) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      return sourceCode.getCommentsInside(node).length === 0 && (!tokenBefore || validPrecedingTokens.has(tokenBefore.value)) && isValidRegexForEcmaVersion(pattern, flags);\n    }\n\n    /**\n     * Returns a safe output code considering the before and after tokens.\n     * @param {ASTNode} node The regex node.\n     * @param {string} newRegExpValue The new regex expression value.\n     * @returns {string} The output code.\n     */\n    function getSafeOutput(node, newRegExpValue) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      return (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") + newRegExpValue + (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\");\n    }\n    return {\n      Program(node) {\n        const scope = sourceCode.getScope(node);\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n        for (const {\n          node: refNode\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(refNode)) {\n            const regexNode = refNode.arguments[0];\n            if (refNode.arguments.length === 2) {\n              const suggests = [];\n              const argFlags = getStringValue(refNode.arguments[1]) || \"\";\n              if (canFixTo(refNode, regexNode.regex.pattern, argFlags)) {\n                suggests.push({\n                  messageId: \"replaceWithLiteralAndFlags\",\n                  pattern: regexNode.regex.pattern,\n                  flags: argFlags\n                });\n              }\n              const literalFlags = regexNode.regex.flags || \"\";\n              const mergedFlags = mergeRegexFlags(literalFlags, argFlags);\n              if (!areFlagsEqual(mergedFlags, argFlags) && canFixTo(refNode, regexNode.regex.pattern, mergedFlags)) {\n                suggests.push({\n                  messageId: \"replaceWithIntendedLiteralAndFlags\",\n                  pattern: regexNode.regex.pattern,\n                  flags: mergedFlags\n                });\n              }\n              context.report({\n                node: refNode,\n                messageId: \"unexpectedRedundantRegExpWithFlags\",\n                suggest: suggests.map(({\n                  flags,\n                  pattern,\n                  messageId\n                }) => ({\n                  messageId,\n                  data: {\n                    flags\n                  },\n                  fix(fixer) {\n                    return fixer.replaceText(refNode, getSafeOutput(refNode, `/${pattern}/${flags}`));\n                  }\n                }))\n              });\n            } else {\n              const outputs = [];\n              if (canFixTo(refNode, regexNode.regex.pattern, regexNode.regex.flags)) {\n                outputs.push(sourceCode.getText(regexNode));\n              }\n              context.report({\n                node: refNode,\n                messageId: \"unexpectedRedundantRegExp\",\n                suggest: outputs.map(output => ({\n                  messageId: \"replaceWithLiteral\",\n                  fix(fixer) {\n                    return fixer.replaceText(refNode, getSafeOutput(refNode, output));\n                  }\n                }))\n              });\n            }\n          } else if (hasOnlyStaticStringArguments(refNode)) {\n            let regexContent = getStringValue(refNode.arguments[0]);\n            let noFix = false;\n            let flags;\n            if (refNode.arguments[1]) {\n              flags = getStringValue(refNode.arguments[1]);\n            }\n            if (!canFixTo(refNode, regexContent, flags)) {\n              noFix = true;\n            }\n            if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\n              noFix = true;\n            }\n            if (regexContent && !noFix) {\n              let charIncrease = 0;\n              const ast = new RegExpParser({\n                ecmaVersion: regexppEcmaVersion\n              }).parsePattern(regexContent, 0, regexContent.length, {\n                unicode: flags ? flags.includes(\"u\") : false,\n                unicodeSets: flags ? flags.includes(\"v\") : false\n              });\n              visitRegExpAST(ast, {\n                onCharacterEnter(characterNode) {\n                  const escaped = resolveEscapes(characterNode.raw);\n                  if (escaped) {\n                    regexContent = regexContent.slice(0, characterNode.start + charIncrease) + escaped + regexContent.slice(characterNode.end + charIncrease);\n                    if (characterNode.raw.length === 1) {\n                      charIncrease += 1;\n                    }\n                  }\n                }\n              });\n            }\n            const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\n            context.report({\n              node: refNode,\n              messageId: \"unexpectedRegExp\",\n              suggest: noFix ? [] : [{\n                messageId: \"replaceWithLiteral\",\n                fix(fixer) {\n                  return fixer.replaceText(refNode, getSafeOutput(refNode, newRegExpValue));\n                }\n              }]\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","CALL","CONSTRUCT","ReferenceTracker","findVariable","RegExpValidator","visitRegExpAST","RegExpParser","canTokensBeAdjacent","REGEXPP_LATEST_ECMA_VERSION","isStringLiteral","node","type","value","isRegexLiteral","Object","prototype","hasOwnProperty","call","validPrecedingTokens","Set","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","disallowRedundantWrapping","default","additionalProperties","messages","unexpectedRegExp","replaceWithLiteral","replaceWithLiteralAndFlags","replaceWithIntendedLiteralAndFlags","unexpectedRedundantRegExp","unexpectedRedundantRegExpWithFlags","create","context","options","sourceCode","isGlobalReference","scope","getScope","variable","defs","length","isStringRawTaggedStaticTemplateLiteral","isSpecificMemberAccess","tag","skipChainExpression","object","isStaticTemplateLiteral","quasi","getStringValue","quasis","cooked","raw","isStaticString","hasOnlyStaticStringArguments","args","arguments","every","isUnnecessarilyWrappedRegexLiteral","getRegexppEcmaVersion","ecmaVersion","Math","min","regexppEcmaVersion","languageOptions","resolveEscapes","character","isValidRegexForEcmaVersion","pattern","flags","validator","validatePattern","unicode","includes","unicodeSets","validateFlags","areFlagsEqual","flagsA","flagsB","sort","join","mergeRegexFlags","flagsSet","canFixTo","tokenBefore","getTokenBefore","getCommentsInside","has","getSafeOutput","newRegExpValue","tokenAfter","getTokenAfter","range","Program","tracker","traceMap","RegExp","refNode","iterateGlobalReferences","regexNode","suggests","argFlags","regex","push","messageId","literalFlags","mergedFlags","report","suggest","map","data","fix","fixer","replaceText","outputs","getText","output","regexContent","noFix","test","charIncrease","ast","parsePattern","onCharacterEnter","characterNode","escaped","slice","start","end"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/prefer-regex-literals.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"@eslint-community/eslint-utils\");\nconst { RegExpValidator, visitRegExpAST, RegExpParser } = require(\"@eslint-community/regexpp\");\nconst { canTokensBeAdjacent } = require(\"./utils/ast-utils\");\nconst { REGEXPP_LATEST_ECMA_VERSION } = require(\"./utils/regular-expressions\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n    return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\nconst validPrecedingTokens = new Set([\n    \"(\",\n    \";\",\n    \"[\",\n    \",\",\n    \"=\",\n    \"+\",\n    \"*\",\n    \"-\",\n    \"?\",\n    \"~\",\n    \"%\",\n    \"**\",\n    \"!\",\n    \"typeof\",\n    \"instanceof\",\n    \"&&\",\n    \"||\",\n    \"??\",\n    \"return\",\n    \"...\",\n    \"delete\",\n    \"void\",\n    \"in\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"<<\",\n    \">>\",\n    \">>>\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \":\",\n    \"{\",\n    \"=>\",\n    \"*=\",\n    \"<<=\",\n    \">>=\",\n    \">>>=\",\n    \"^=\",\n    \"|=\",\n    \"&=\",\n    \"??=\",\n    \"||=\",\n    \"&&=\",\n    \"**=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"%=\",\n    \"/\",\n    \"do\",\n    \"break\",\n    \"continue\",\n    \"debugger\",\n    \"case\",\n    \"throw\"\n]);\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-regex-literals\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    disallowRedundantWrapping: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n            replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\n            replaceWithLiteralAndFlags: \"Replace with an equivalent regular expression literal with flags '{{ flags }}'.\",\n            replaceWithIntendedLiteralAndFlags: \"Replace with a regular expression literal with flags '{{ flags }}'.\",\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowRedundantWrapping = false } = {}] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = sourceCode.getScope(node);\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\n                astUtils.isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Gets the value of a string\n         * @param {ASTNode} node The node to get the string of.\n         * @returns {string|null} The value of the node.\n         */\n        function getStringValue(node) {\n            if (isStringLiteral(node)) {\n                return node.value;\n            }\n\n            if (astUtils.isStaticTemplateLiteral(node)) {\n                return node.quasis[0].value.cooked;\n            }\n\n            if (isStringRawTaggedStaticTemplateLiteral(node)) {\n                return node.quasi.quasis[0].value.raw;\n            }\n\n            return null;\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                astUtils.isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        /**\n         * Determines whether the relevant arguments of the given are all static string literals.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if all arguments are static strings.\n         */\n        function hasOnlyStaticStringArguments(node) {\n            const args = node.arguments;\n\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node already contains a regex literal argument.\n         */\n        function isUnnecessarilyWrappedRegexLiteral(node) {\n            const args = node.arguments;\n\n            if (args.length === 1 && isRegexLiteral(args[0])) {\n                return true;\n            }\n\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns a ecmaVersion compatible for regexpp.\n         * @param {number} ecmaVersion The ecmaVersion to convert.\n         * @returns {import(\"@eslint-community/regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\n         */\n        function getRegexppEcmaVersion(ecmaVersion) {\n            if (ecmaVersion <= 5) {\n                return 5;\n            }\n            return Math.min(ecmaVersion, REGEXPP_LATEST_ECMA_VERSION);\n        }\n\n        const regexppEcmaVersion = getRegexppEcmaVersion(context.languageOptions.ecmaVersion);\n\n        /**\n         * Makes a character escaped or else returns null.\n         * @param {string} character The character to escape.\n         * @returns {string} The resulting escaped character.\n         */\n        function resolveEscapes(character) {\n            switch (character) {\n                case \"\\n\":\n                case \"\\\\\\n\":\n                    return \"\\\\n\";\n\n                case \"\\r\":\n                case \"\\\\\\r\":\n                    return \"\\\\r\";\n\n                case \"\\t\":\n                case \"\\\\\\t\":\n                    return \"\\\\t\";\n\n                case \"\\v\":\n                case \"\\\\\\v\":\n                    return \"\\\\v\";\n\n                case \"\\f\":\n                case \"\\\\\\f\":\n                    return \"\\\\f\";\n\n                case \"/\":\n                    return \"\\\\/\";\n\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Checks whether the given regex and flags are valid for the ecma version or not.\n         * @param {string} pattern The regex pattern to check.\n         * @param {string | undefined} flags The regex flags to check.\n         * @returns {boolean} True if the given regex pattern and flags are valid for the ecma version.\n         */\n        function isValidRegexForEcmaVersion(pattern, flags) {\n            const validator = new RegExpValidator({ ecmaVersion: regexppEcmaVersion });\n\n            try {\n                validator.validatePattern(pattern, 0, pattern.length, {\n                    unicode: flags ? flags.includes(\"u\") : false,\n                    unicodeSets: flags ? flags.includes(\"v\") : false\n                });\n                if (flags) {\n                    validator.validateFlags(flags);\n                }\n                return true;\n            } catch {\n                return false;\n            }\n        }\n\n        /**\n         * Checks whether two given regex flags contain the same flags or not.\n         * @param {string} flagsA The regex flags.\n         * @param {string} flagsB The regex flags.\n         * @returns {boolean} True if two regex flags contain same flags.\n         */\n        function areFlagsEqual(flagsA, flagsB) {\n            return [...flagsA].sort().join(\"\") === [...flagsB].sort().join(\"\");\n        }\n\n\n        /**\n         * Merges two regex flags.\n         * @param {string} flagsA The regex flags.\n         * @param {string} flagsB The regex flags.\n         * @returns {string} The merged regex flags.\n         */\n        function mergeRegexFlags(flagsA, flagsB) {\n            const flagsSet = new Set([\n                ...flagsA,\n                ...flagsB\n            ]);\n\n            return [...flagsSet].join(\"\");\n        }\n\n        /**\n         * Checks whether a give node can be fixed to the given regex pattern and flags.\n         * @param {ASTNode} node The node to check.\n         * @param {string} pattern The regex pattern to check.\n         * @param {string} flags The regex flags\n         * @returns {boolean} True if a node can be fixed to the given regex pattern and flags.\n         */\n        function canFixTo(node, pattern, flags) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return sourceCode.getCommentsInside(node).length === 0 &&\n                (!tokenBefore || validPrecedingTokens.has(tokenBefore.value)) &&\n                isValidRegexForEcmaVersion(pattern, flags);\n        }\n\n        /**\n         * Returns a safe output code considering the before and after tokens.\n         * @param {ASTNode} node The regex node.\n         * @param {string} newRegExpValue The new regex expression value.\n         * @returns {string} The output code.\n         */\n        function getSafeOutput(node, newRegExpValue) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n\n            return (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") +\n                newRegExpValue +\n            (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\");\n\n        }\n\n        return {\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(refNode)) {\n                        const regexNode = refNode.arguments[0];\n\n                        if (refNode.arguments.length === 2) {\n                            const suggests = [];\n\n                            const argFlags = getStringValue(refNode.arguments[1]) || \"\";\n\n                            if (canFixTo(refNode, regexNode.regex.pattern, argFlags)) {\n                                suggests.push({\n                                    messageId: \"replaceWithLiteralAndFlags\",\n                                    pattern: regexNode.regex.pattern,\n                                    flags: argFlags\n                                });\n                            }\n\n                            const literalFlags = regexNode.regex.flags || \"\";\n                            const mergedFlags = mergeRegexFlags(literalFlags, argFlags);\n\n                            if (\n                                !areFlagsEqual(mergedFlags, argFlags) &&\n                                canFixTo(refNode, regexNode.regex.pattern, mergedFlags)\n                            ) {\n                                suggests.push({\n                                    messageId: \"replaceWithIntendedLiteralAndFlags\",\n                                    pattern: regexNode.regex.pattern,\n                                    flags: mergedFlags\n                                });\n                            }\n\n                            context.report({\n                                node: refNode,\n                                messageId: \"unexpectedRedundantRegExpWithFlags\",\n                                suggest: suggests.map(({ flags, pattern, messageId }) => ({\n                                    messageId,\n                                    data: {\n                                        flags\n                                    },\n                                    fix(fixer) {\n                                        return fixer.replaceText(refNode, getSafeOutput(refNode, `/${pattern}/${flags}`));\n                                    }\n                                }))\n                            });\n                        } else {\n                            const outputs = [];\n\n                            if (canFixTo(refNode, regexNode.regex.pattern, regexNode.regex.flags)) {\n                                outputs.push(sourceCode.getText(regexNode));\n                            }\n\n\n                            context.report({\n                                node: refNode,\n                                messageId: \"unexpectedRedundantRegExp\",\n                                suggest: outputs.map(output => ({\n                                    messageId: \"replaceWithLiteral\",\n                                    fix(fixer) {\n                                        return fixer.replaceText(\n                                            refNode,\n                                            getSafeOutput(refNode, output)\n                                        );\n                                    }\n                                }))\n                            });\n                        }\n                    } else if (hasOnlyStaticStringArguments(refNode)) {\n                        let regexContent = getStringValue(refNode.arguments[0]);\n                        let noFix = false;\n                        let flags;\n\n                        if (refNode.arguments[1]) {\n                            flags = getStringValue(refNode.arguments[1]);\n                        }\n\n                        if (!canFixTo(refNode, regexContent, flags)) {\n                            noFix = true;\n                        }\n\n                        if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\n                            noFix = true;\n                        }\n\n                        if (regexContent && !noFix) {\n                            let charIncrease = 0;\n\n                            const ast = new RegExpParser({ ecmaVersion: regexppEcmaVersion }).parsePattern(regexContent, 0, regexContent.length, {\n                                unicode: flags ? flags.includes(\"u\") : false,\n                                unicodeSets: flags ? flags.includes(\"v\") : false\n                            });\n\n                            visitRegExpAST(ast, {\n                                onCharacterEnter(characterNode) {\n                                    const escaped = resolveEscapes(characterNode.raw);\n\n                                    if (escaped) {\n                                        regexContent =\n                                            regexContent.slice(0, characterNode.start + charIncrease) +\n                                            escaped +\n                                            regexContent.slice(characterNode.end + charIncrease);\n\n                                        if (characterNode.raw.length === 1) {\n                                            charIncrease += 1;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n\n                        const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\n\n                        context.report({\n                            node: refNode,\n                            messageId: \"unexpectedRegExp\",\n                            suggest: noFix ? [] : [{\n                                messageId: \"replaceWithLiteral\",\n                                fix(fixer) {\n                                    return fixer.replaceText(refNode, getSafeOutput(refNode, newRegExpValue));\n                                }\n                            }]\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}