{"ast":null,"code":"/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst assert = require(\"assert\"),\n  CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether or not a given segment is reachable.\n * @param {CodePathSegment} segment The segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n/**\n * Creates a new segment for each fork in the given context and appends it\n * to the end of the specified range of segments. Ultimately, this ends up calling\n * `new CodePathSegment()` for each of the forks using the `create` argument\n * as a wrapper around special behavior.\n *\n * The `startIndex` and `endIndex` arguments specify a range of segments in\n * `context` that should become `allPrevSegments` for the newly created\n * `CodePathSegment` objects.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates two new segments, `[g, h]`. This `g` is appended to\n * the end of the path from `a`, `c`, and `e`. This `h` is appended to the end of\n * `b`, `d`, and `f`.\n * @param {ForkContext} context An instance from which the previous segments\n *      will be obtained.\n * @param {number} startIndex The index of the first segment in the context\n *      that should be specified as previous segments for the newly created segments.\n * @param {number} endIndex The index of the last segment in the context\n *      that should be specified as previous segments for the newly created segments.\n * @param {Function} create A function that creates new `CodePathSegment`\n *      instances in a particular way. See the `CodePathSegment.new*` methods.\n * @returns {Array<CodePathSegment>} An array of the newly-created segments.\n */\nfunction createSegments(context, startIndex, endIndex, create) {\n  /** @type {Array<Array<CodePathSegment>>} */\n  const list = context.segmentsList;\n\n  /*\n   * Both `startIndex` and `endIndex` work the same way: if the number is zero\n   * or more, then the number is used as-is. If the number is negative,\n   * then that number is added to the length of the segments list to\n   * determine the index to use. That means -1 for either argument\n   * is the last element, -2 is the second to last, and so on.\n   *\n   * So if `startIndex` is 0, `endIndex` is -1, and `list.length` is 3, the\n   * effective `startIndex` is 0 and the effective `endIndex` is 2, so this function\n   * will include items at indices 0, 1, and 2.\n   *\n   * Therefore, if `startIndex` is -1 and `endIndex` is -1, that means we'll only\n   * be using the last segment in `list`.\n   */\n  const normalizedBegin = startIndex >= 0 ? startIndex : list.length + startIndex;\n  const normalizedEnd = endIndex >= 0 ? endIndex : list.length + endIndex;\n\n  /** @type {Array<CodePathSegment>} */\n  const segments = [];\n  for (let i = 0; i < context.count; ++i) {\n    // this is passed into `new CodePathSegment` to add to code path.\n    const allPrevSegments = [];\n    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n      allPrevSegments.push(list[j][i]);\n    }\n\n    // note: `create` is just a wrapper that augments `new CodePathSegment`.\n    segments.push(create(context.idGenerator.next(), allPrevSegments));\n  }\n  return segments;\n}\n\n/**\n * Inside of a `finally` block we end up with two parallel paths. If the code path\n * exits by a control statement (such as `break` or `continue`) from the `finally`\n * block, then we need to merge the remaining parallel paths back into one.\n * @param {ForkContext} context The fork context to work on.\n * @param {Array<CodePathSegment>} segments Segments to merge.\n * @returns {Array<CodePathSegment>} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n  let currentSegments = segments;\n\n  /*\n   * We need to ensure that the array returned from this function contains no more\n   * than the number of segments that the context allows. `context.count` indicates\n   * how many items should be in the returned array to ensure that the new segment\n   * entries will line up with the already existing segment entries.\n   */\n  while (currentSegments.length > context.count) {\n    const merged = [];\n\n    /*\n     * Because `context.count` is a factor of 2 inside of a `finally` block,\n     * we can divide the segment count by 2 to merge the paths together.\n     * This loops through each segment in the list and creates a new `CodePathSegment`\n     * that has the segment and the segment two slots away as previous segments.\n     *\n     * If `currentSegments` is [a,b,c,d], this will create new segments e and f, such\n     * that:\n     *\n     * When `i` is 0:\n     * a->e\n     * c->e\n     *\n     * When `i` is 1:\n     * b->f\n     * d->f\n     */\n    for (let i = 0, length = Math.floor(currentSegments.length / 2); i < length; ++i) {\n      merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));\n    }\n\n    /*\n     * Go through the loop condition one more time to see if we have the\n     * number of segments for the context. If not, we'll keep merging paths\n     * of the merged segments until we get there.\n     */\n    currentSegments = merged;\n  }\n  return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Manages the forking of code paths.\n */\nclass ForkContext {\n  /**\n   * Creates a new instance.\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @param {ForkContext|null} upper The preceding fork context.\n   * @param {number} count The number of parallel segments in each element\n   *      of `segmentsList`.\n   */\n  constructor(idGenerator, upper, count) {\n    /**\n     * The ID generator that will generate segment IDs for any new\n     * segments that are created.\n     * @type {IdGenerator}\n     */\n    this.idGenerator = idGenerator;\n\n    /**\n     * The preceding fork context.\n     * @type {ForkContext|null}\n     */\n    this.upper = upper;\n\n    /**\n     * The number of elements in each element of `segmentsList`. In most\n     * cases, this is 1 but can be 2 when there is a `finally` present,\n     * which forks the code path outside of normal flow. In the case of nested\n     * `finally` blocks, this can be a multiple of 2.\n     * @type {number}\n     */\n    this.count = count;\n\n    /**\n     * The segments within this context. Each element in this array has\n     * `count` elements that represent one step in each fork. For example,\n     * when `segmentsList` is `[[a, b], [c, d], [e, f]]`, there is one path\n     * a->c->e and one path b->d->f, and `count` is 2 because each element\n     * is an array with two elements.\n     * @type {Array<Array<CodePathSegment>>}\n     */\n    this.segmentsList = [];\n  }\n\n  /**\n   * The segments that begin this fork context.\n   * @type {Array<CodePathSegment>}\n   */\n  get head() {\n    const list = this.segmentsList;\n    return list.length === 0 ? [] : list[list.length - 1];\n  }\n\n  /**\n   * Indicates if the context contains no segments.\n   * @type {boolean}\n   */\n  get empty() {\n    return this.segmentsList.length === 0;\n  }\n\n  /**\n   * Indicates if there are any segments that are reachable.\n   * @type {boolean}\n   */\n  get reachable() {\n    const segments = this.head;\n    return segments.length > 0 && segments.some(isReachable);\n  }\n\n  /**\n   * Creates new segments in this context and appends them to the end of the\n   * already existing `CodePathSegment`s specified by `startIndex` and\n   * `endIndex`.\n   * @param {number} startIndex The index of the first segment in the context\n   *      that should be specified as previous segments for the newly created segments.\n   * @param {number} endIndex The index of the last segment in the context\n   *      that should be specified as previous segments for the newly created segments.\n   * @returns {Array<CodePathSegment>} An array of the newly created segments.\n   */\n  makeNext(startIndex, endIndex) {\n    return createSegments(this, startIndex, endIndex, CodePathSegment.newNext);\n  }\n\n  /**\n   * Creates new unreachable segments in this context and appends them to the end of the\n   * already existing `CodePathSegment`s specified by `startIndex` and\n   * `endIndex`.\n   * @param {number} startIndex The index of the first segment in the context\n   *      that should be specified as previous segments for the newly created segments.\n   * @param {number} endIndex The index of the last segment in the context\n   *      that should be specified as previous segments for the newly created segments.\n   * @returns {Array<CodePathSegment>} An array of the newly created segments.\n   */\n  makeUnreachable(startIndex, endIndex) {\n    return createSegments(this, startIndex, endIndex, CodePathSegment.newUnreachable);\n  }\n\n  /**\n   * Creates new segments in this context and does not append them to the end\n   *  of the already existing `CodePathSegment`s specified by `startIndex` and\n   * `endIndex`. The `startIndex` and `endIndex` are only used to determine if\n   * the new segments should be reachable. If any of the segments in this range\n   * are reachable then the new segments are also reachable; otherwise, the new\n   * segments are unreachable.\n   * @param {number} startIndex The index of the first segment in the context\n   *      that should be considered for reachability.\n   * @param {number} endIndex The index of the last segment in the context\n   *      that should be considered for reachability.\n   * @returns {Array<CodePathSegment>} An array of the newly created segments.\n   */\n  makeDisconnected(startIndex, endIndex) {\n    return createSegments(this, startIndex, endIndex, CodePathSegment.newDisconnected);\n  }\n\n  /**\n   * Adds segments to the head of this context.\n   * @param {Array<CodePathSegment>} segments The segments to add.\n   * @returns {void}\n   */\n  add(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.push(mergeExtraSegments(this, segments));\n  }\n\n  /**\n   * Replaces the head segments with the given segments.\n   * The current head segments are removed.\n   * @param {Array<CodePathSegment>} replacementHeadSegments The new head segments.\n   * @returns {void}\n   */\n  replaceHead(replacementHeadSegments) {\n    assert(replacementHeadSegments.length >= this.count, `${replacementHeadSegments.length} >= ${this.count}`);\n    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, replacementHeadSegments));\n  }\n\n  /**\n   * Adds all segments of a given fork context into this context.\n   * @param {ForkContext} otherForkContext The fork context to add from.\n   * @returns {void}\n   */\n  addAll(otherForkContext) {\n    assert(otherForkContext.count === this.count);\n    this.segmentsList.push(...otherForkContext.segmentsList);\n  }\n\n  /**\n   * Clears all segments in this context.\n   * @returns {void}\n   */\n  clear() {\n    this.segmentsList = [];\n  }\n\n  /**\n   * Creates a new root context, meaning that there are no parent\n   * fork contexts.\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @returns {ForkContext} New fork context.\n   */\n  static newRoot(idGenerator) {\n    const context = new ForkContext(idGenerator, null, 1);\n    context.add([CodePathSegment.newRoot(idGenerator.next())]);\n    return context;\n  }\n\n  /**\n   * Creates an empty fork context preceded by a given context.\n   * @param {ForkContext} parentContext The parent fork context.\n   * @param {boolean} shouldForkLeavingPath Indicates that we are inside of\n   *      a `finally` block and should therefore fork the path that leaves\n   *      `finally`.\n   * @returns {ForkContext} New fork context.\n   */\n  static newEmpty(parentContext, shouldForkLeavingPath) {\n    return new ForkContext(parentContext.idGenerator, parentContext, (shouldForkLeavingPath ? 2 : 1) * parentContext.count);\n  }\n}\nmodule.exports = ForkContext;","map":{"version":3,"names":["assert","require","CodePathSegment","isReachable","segment","reachable","createSegments","context","startIndex","endIndex","create","list","segmentsList","normalizedBegin","length","normalizedEnd","segments","i","count","allPrevSegments","j","push","idGenerator","next","mergeExtraSegments","currentSegments","merged","Math","floor","newNext","ForkContext","constructor","upper","head","empty","some","makeNext","makeUnreachable","newUnreachable","makeDisconnected","newDisconnected","add","replaceHead","replacementHeadSegments","splice","addAll","otherForkContext","clear","newRoot","newEmpty","parentContext","shouldForkLeavingPath","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/code-path-analysis/fork-context.js"],"sourcesContent":["/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether or not a given segment is reachable.\n * @param {CodePathSegment} segment The segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates a new segment for each fork in the given context and appends it\n * to the end of the specified range of segments. Ultimately, this ends up calling\n * `new CodePathSegment()` for each of the forks using the `create` argument\n * as a wrapper around special behavior.\n *\n * The `startIndex` and `endIndex` arguments specify a range of segments in\n * `context` that should become `allPrevSegments` for the newly created\n * `CodePathSegment` objects.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates two new segments, `[g, h]`. This `g` is appended to\n * the end of the path from `a`, `c`, and `e`. This `h` is appended to the end of\n * `b`, `d`, and `f`.\n * @param {ForkContext} context An instance from which the previous segments\n *      will be obtained.\n * @param {number} startIndex The index of the first segment in the context\n *      that should be specified as previous segments for the newly created segments.\n * @param {number} endIndex The index of the last segment in the context\n *      that should be specified as previous segments for the newly created segments.\n * @param {Function} create A function that creates new `CodePathSegment`\n *      instances in a particular way. See the `CodePathSegment.new*` methods.\n * @returns {Array<CodePathSegment>} An array of the newly-created segments.\n */\nfunction createSegments(context, startIndex, endIndex, create) {\n\n    /** @type {Array<Array<CodePathSegment>>} */\n    const list = context.segmentsList;\n\n    /*\n     * Both `startIndex` and `endIndex` work the same way: if the number is zero\n     * or more, then the number is used as-is. If the number is negative,\n     * then that number is added to the length of the segments list to\n     * determine the index to use. That means -1 for either argument\n     * is the last element, -2 is the second to last, and so on.\n     *\n     * So if `startIndex` is 0, `endIndex` is -1, and `list.length` is 3, the\n     * effective `startIndex` is 0 and the effective `endIndex` is 2, so this function\n     * will include items at indices 0, 1, and 2.\n     *\n     * Therefore, if `startIndex` is -1 and `endIndex` is -1, that means we'll only\n     * be using the last segment in `list`.\n     */\n    const normalizedBegin = startIndex >= 0 ? startIndex : list.length + startIndex;\n    const normalizedEnd = endIndex >= 0 ? endIndex : list.length + endIndex;\n\n    /** @type {Array<CodePathSegment>} */\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n\n        // this is passed into `new CodePathSegment` to add to code path.\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        // note: `create` is just a wrapper that augments `new CodePathSegment`.\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * Inside of a `finally` block we end up with two parallel paths. If the code path\n * exits by a control statement (such as `break` or `continue`) from the `finally`\n * block, then we need to merge the remaining parallel paths back into one.\n * @param {ForkContext} context The fork context to work on.\n * @param {Array<CodePathSegment>} segments Segments to merge.\n * @returns {Array<CodePathSegment>} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    /*\n     * We need to ensure that the array returned from this function contains no more\n     * than the number of segments that the context allows. `context.count` indicates\n     * how many items should be in the returned array to ensure that the new segment\n     * entries will line up with the already existing segment entries.\n     */\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        /*\n         * Because `context.count` is a factor of 2 inside of a `finally` block,\n         * we can divide the segment count by 2 to merge the paths together.\n         * This loops through each segment in the list and creates a new `CodePathSegment`\n         * that has the segment and the segment two slots away as previous segments.\n         *\n         * If `currentSegments` is [a,b,c,d], this will create new segments e and f, such\n         * that:\n         *\n         * When `i` is 0:\n         * a->e\n         * c->e\n         *\n         * When `i` is 1:\n         * b->f\n         * d->f\n         */\n        for (let i = 0, length = Math.floor(currentSegments.length / 2); i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n\n        /*\n         * Go through the loop condition one more time to see if we have the\n         * number of segments for the context. If not, we'll keep merging paths\n         * of the merged segments until we get there.\n         */\n        currentSegments = merged;\n    }\n\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Manages the forking of code paths.\n */\nclass ForkContext {\n\n    /**\n     * Creates a new instance.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @param {ForkContext|null} upper The preceding fork context.\n     * @param {number} count The number of parallel segments in each element\n     *      of `segmentsList`.\n     */\n    constructor(idGenerator, upper, count) {\n\n        /**\n         * The ID generator that will generate segment IDs for any new\n         * segments that are created.\n         * @type {IdGenerator}\n         */\n        this.idGenerator = idGenerator;\n\n        /**\n         * The preceding fork context.\n         * @type {ForkContext|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The number of elements in each element of `segmentsList`. In most\n         * cases, this is 1 but can be 2 when there is a `finally` present,\n         * which forks the code path outside of normal flow. In the case of nested\n         * `finally` blocks, this can be a multiple of 2.\n         * @type {number}\n         */\n        this.count = count;\n\n        /**\n         * The segments within this context. Each element in this array has\n         * `count` elements that represent one step in each fork. For example,\n         * when `segmentsList` is `[[a, b], [c, d], [e, f]]`, there is one path\n         * a->c->e and one path b->d->f, and `count` is 2 because each element\n         * is an array with two elements.\n         * @type {Array<Array<CodePathSegment>>}\n         */\n        this.segmentsList = [];\n    }\n\n    /**\n     * The segments that begin this fork context.\n     * @type {Array<CodePathSegment>}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * Indicates if the context contains no segments.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * Indicates if there are any segments that are reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments in this context and appends them to the end of the\n     * already existing `CodePathSegment`s specified by `startIndex` and\n     * `endIndex`.\n     * @param {number} startIndex The index of the first segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @param {number} endIndex The index of the last segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @returns {Array<CodePathSegment>} An array of the newly created segments.\n     */\n    makeNext(startIndex, endIndex) {\n        return createSegments(this, startIndex, endIndex, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new unreachable segments in this context and appends them to the end of the\n     * already existing `CodePathSegment`s specified by `startIndex` and\n     * `endIndex`.\n     * @param {number} startIndex The index of the first segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @param {number} endIndex The index of the last segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @returns {Array<CodePathSegment>} An array of the newly created segments.\n     */\n    makeUnreachable(startIndex, endIndex) {\n        return createSegments(this, startIndex, endIndex, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments in this context and does not append them to the end\n     *  of the already existing `CodePathSegment`s specified by `startIndex` and\n     * `endIndex`. The `startIndex` and `endIndex` are only used to determine if\n     * the new segments should be reachable. If any of the segments in this range\n     * are reachable then the new segments are also reachable; otherwise, the new\n     * segments are unreachable.\n     * @param {number} startIndex The index of the first segment in the context\n     *      that should be considered for reachability.\n     * @param {number} endIndex The index of the last segment in the context\n     *      that should be considered for reachability.\n     * @returns {Array<CodePathSegment>} An array of the newly created segments.\n     */\n    makeDisconnected(startIndex, endIndex) {\n        return createSegments(this, startIndex, endIndex, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments to the head of this context.\n     * @param {Array<CodePathSegment>} segments The segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with the given segments.\n     * The current head segments are removed.\n     * @param {Array<CodePathSegment>} replacementHeadSegments The new head segments.\n     * @returns {void}\n     */\n    replaceHead(replacementHeadSegments) {\n        assert(\n            replacementHeadSegments.length >= this.count,\n            `${replacementHeadSegments.length} >= ${this.count}`\n        );\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, replacementHeadSegments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     * @param {ForkContext} otherForkContext The fork context to add from.\n     * @returns {void}\n     */\n    addAll(otherForkContext) {\n        assert(otherForkContext.count === this.count);\n        this.segmentsList.push(...otherForkContext.segmentsList);\n    }\n\n    /**\n     * Clears all segments in this context.\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates a new root context, meaning that there are no parent\n     * fork contexts.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     * @param {ForkContext} parentContext The parent fork context.\n     * @param {boolean} shouldForkLeavingPath Indicates that we are inside of\n     *      a `finally` block and should therefore fork the path that leaves\n     *      `finally`.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, shouldForkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (shouldForkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}