{"ast":null,"code":"/**\n * @fileoverview The CodePathSegment class.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n *\n * Each segment is arranged in a series of linked lists (implemented by arrays)\n * that keep track of the previous and next segments in a code path. In this way,\n * you can navigate between all segments in any code path so long as you have a\n * reference to any segment in that code path.\n *\n * When first created, the segment is in a detached state, meaning that it knows the\n * segments that came before it but those segments don't know that this new segment\n * follows it. Only when `CodePathSegment#markUsed()` is called on a segment does it\n * officially become part of the code path by updating the previous segments to know\n * that this new segment follows.\n */\nclass CodePathSegment {\n  /**\n   * Creates a new instance.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   *   This array includes unreachable segments.\n   * @param {boolean} reachable A flag which shows this is reachable.\n   */\n  constructor(id, allPrevSegments, reachable) {\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * An array of the next reachable segments.\n     * @type {CodePathSegment[]}\n     */\n    this.nextSegments = [];\n\n    /**\n     * An array of the previous reachable segments.\n     * @type {CodePathSegment[]}\n     */\n    this.prevSegments = allPrevSegments.filter(isReachable);\n\n    /**\n     * An array of all next segments including reachable and unreachable.\n     * @type {CodePathSegment[]}\n     */\n    this.allNextSegments = [];\n\n    /**\n     * An array of all previous segments including reachable and unreachable.\n     * @type {CodePathSegment[]}\n     */\n    this.allPrevSegments = allPrevSegments;\n\n    /**\n     * A flag which shows this is reachable.\n     * @type {boolean}\n     */\n    this.reachable = reachable;\n\n    // Internal data.\n    Object.defineProperty(this, \"internal\", {\n      value: {\n        // determines if the segment has been attached to the code path\n        used: false,\n        // array of previous segments coming from the end of a loop\n        loopedPrevSegments: []\n      }\n    });\n\n    /* c8 ignore start */\n    if (debug.enabled) {\n      this.internal.nodes = [];\n    } /* c8 ignore stop */\n  }\n\n  /**\n   * Checks a given previous segment is coming from the end of a loop.\n   * @param {CodePathSegment} segment A previous segment to check.\n   * @returns {boolean} `true` if the segment is coming from the end of a loop.\n   */\n  isLoopedPrevSegment(segment) {\n    return this.internal.loopedPrevSegments.includes(segment);\n  }\n\n  /**\n   * Creates the root segment.\n   * @param {string} id An identifier.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newRoot(id) {\n    return new CodePathSegment(id, [], true);\n  }\n\n  /**\n   * Creates a new segment and appends it after the given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments\n   *      to append to.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newNext(id, allPrevSegments) {\n    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));\n  }\n\n  /**\n   * Creates an unreachable segment and appends it after the given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newUnreachable(id, allPrevSegments) {\n    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n    /*\n     * In `if (a) return a; foo();` case, the unreachable segment preceded by\n     * the return statement is not used but must not be removed.\n     */\n    CodePathSegment.markUsed(segment);\n    return segment;\n  }\n\n  /**\n   * Creates a segment that follows given segments.\n   * This factory method does not connect with `allPrevSegments`.\n   * But this inherits `reachable` flag.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newDisconnected(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n  }\n\n  /**\n   * Marks a given segment as used.\n   *\n   * And this function registers the segment into the previous segments as a next.\n   * @param {CodePathSegment} segment A segment to mark.\n   * @returns {void}\n   */\n  static markUsed(segment) {\n    if (segment.internal.used) {\n      return;\n    }\n    segment.internal.used = true;\n    let i;\n    if (segment.reachable) {\n      /*\n       * If the segment is reachable, then it's officially part of the\n       * code path. This loops through all previous segments to update\n       * their list of next segments. Because the segment is reachable,\n       * it's added to both `nextSegments` and `allNextSegments`.\n       */\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        const prevSegment = segment.allPrevSegments[i];\n        prevSegment.allNextSegments.push(segment);\n        prevSegment.nextSegments.push(segment);\n      }\n    } else {\n      /*\n       * If the segment is not reachable, then it's not officially part of the\n       * code path. This loops through all previous segments to update\n       * their list of next segments. Because the segment is not reachable,\n       * it's added only to `allNextSegments`.\n       */\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        segment.allPrevSegments[i].allNextSegments.push(segment);\n      }\n    }\n  }\n\n  /**\n   * Marks a previous segment as looped.\n   * @param {CodePathSegment} segment A segment.\n   * @param {CodePathSegment} prevSegment A previous segment to mark.\n   * @returns {void}\n   */\n  static markPrevSegmentAsLooped(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n  }\n\n  /**\n   * Creates a new array based on an array of segments. If any segment in the\n   * array is unused, then it is replaced by all of its previous segments.\n   * All used segments are returned as-is without replacement.\n   * @param {CodePathSegment[]} segments The array of segments to flatten.\n   * @returns {CodePathSegment[]} The flattened array.\n   */\n  static flattenUnusedSegments(segments) {\n    const done = new Set();\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i];\n\n      // Ignores duplicated.\n      if (done.has(segment)) {\n        continue;\n      }\n\n      // Use previous segments if unused.\n      if (!segment.internal.used) {\n        for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n          const prevSegment = segment.allPrevSegments[j];\n          if (!done.has(prevSegment)) {\n            done.add(prevSegment);\n          }\n        }\n      } else {\n        done.add(segment);\n      }\n    }\n    return [...done];\n  }\n}\nmodule.exports = CodePathSegment;","map":{"version":3,"names":["debug","require","isReachable","segment","reachable","CodePathSegment","constructor","id","allPrevSegments","nextSegments","prevSegments","filter","allNextSegments","Object","defineProperty","value","used","loopedPrevSegments","enabled","internal","nodes","isLoopedPrevSegment","includes","newRoot","newNext","flattenUnusedSegments","some","newUnreachable","markUsed","newDisconnected","i","length","prevSegment","push","markPrevSegmentAsLooped","segments","done","Set","has","j","add","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js"],"sourcesContent":["/**\n * @fileoverview The CodePathSegment class.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n *\n * Each segment is arranged in a series of linked lists (implemented by arrays)\n * that keep track of the previous and next segments in a code path. In this way,\n * you can navigate between all segments in any code path so long as you have a\n * reference to any segment in that code path.\n *\n * When first created, the segment is in a detached state, meaning that it knows the\n * segments that came before it but those segments don't know that this new segment\n * follows it. Only when `CodePathSegment#markUsed()` is called on a segment does it\n * officially become part of the code path by updating the previous segments to know\n * that this new segment follows.\n */\nclass CodePathSegment {\n\n    /**\n     * Creates a new instance.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of all next segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of all previous segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n\n                // determines if the segment has been attached to the code path\n                used: false,\n\n                // array of previous segments coming from the end of a loop\n                loopedPrevSegments: []\n            }\n        });\n\n        /* c8 ignore start */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }/* c8 ignore stop */\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.includes(segment);\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a new segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments\n     *      to append to.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be removed.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Marks a given segment as used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n\n            /*\n             * If the segment is reachable, then it's officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is reachable,\n             * it's added to both `nextSegments` and `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n\n            /*\n             * If the segment is not reachable, then it's not officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is not reachable,\n             * it's added only to `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Creates a new array based on an array of segments. If any segment in the\n     * array is unused, then it is replaced by all of its previous segments.\n     * All used segments are returned as-is without replacement.\n     * @param {CodePathSegment[]} segments The array of segments to flatten.\n     * @returns {CodePathSegment[]} The flattened array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = new Set();\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done.has(segment)) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done.has(prevSegment)) {\n                        done.add(prevSegment);\n                    }\n                }\n            } else {\n                done.add(segment);\n            }\n        }\n\n        return [...done];\n    }\n}\n\nmodule.exports = CodePathSegment;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}