{"ast":null,"code":"/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n  double: {\n    quote: \"\\\"\",\n    alternateQuote: \"'\",\n    description: \"doublequote\"\n  },\n  single: {\n    quote: \"'\",\n    alternateQuote: \"\\\"\",\n    description: \"singlequote\"\n  },\n  backtick: {\n    quote: \"`\",\n    alternateQuote: \"\\\"\",\n    description: \"backtick\"\n  }\n};\n\n// An unescaped newline is a newline preceded by an even number of backslashes.\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {\n  const newQuote = this.quote;\n  const oldQuote = str[0];\n  if (newQuote === oldQuote) {\n    return str;\n  }\n  return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\n    if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n      return escaped; // unescape\n    }\n    if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n      return `\\\\${match}`; // escape\n    }\n    if (newline && oldQuote === \"`\") {\n      return \"\\\\n\"; // escape newlines\n    }\n    return match;\n  }) + newQuote;\n};\nconst AVOID_ESCAPE = \"avoid-escape\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce the consistent use of either backticks, double, or single quotes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/quotes\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"single\", \"double\", \"backtick\"]\n    }, {\n      anyOf: [{\n        enum: [\"avoid-escape\"]\n      }, {\n        type: \"object\",\n        properties: {\n          avoidEscape: {\n            type: \"boolean\"\n          },\n          allowTemplateLiterals: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      wrongQuotes: \"Strings must use {{description}}.\"\n    }\n  },\n  create(context) {\n    const quoteOption = context.options[0],\n      settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n      options = context.options[1],\n      allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n      sourceCode = context.sourceCode;\n    let avoidEscape = options && options.avoidEscape === true;\n\n    // deprecated\n    if (options === AVOID_ESCAPE) {\n      avoidEscape = true;\n    }\n\n    /**\n     * Determines if a given node is part of JSX syntax.\n     *\n     * This function returns `true` in the following cases:\n     *\n     * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\n     * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\n     * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.\n     *\n     * In particular, this function returns `false` in the following cases:\n     *\n     * - `<div className={\"foo\"}></div>`\n     * - `<div>{\"foo\"}</div>`\n     *\n     * In both cases, inside of the braces is handled as normal JavaScript.\n     * The braces are `JSXExpressionContainer` nodes.\n     * @param {ASTNode} node The Literal node to check.\n     * @returns {boolean} True if the node is a part of JSX, false if not.\n     * @private\n     */\n    function isJSXLiteral(node) {\n      return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\n    }\n\n    /**\n     * Checks whether or not a given node is a directive.\n     * The directive is a `ExpressionStatement` which has only a string literal not surrounded by\n     * parentheses.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} Whether or not the node is a directive.\n     * @private\n     */\n    function isDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\" && !astUtils.isParenthesised(sourceCode, node.expression);\n    }\n\n    /**\n     * Checks whether a specified node is either part of, or immediately follows a (possibly empty) directive prologue.\n     * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive}\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} Whether a specified node is either part of, or immediately follows a (possibly empty) directive prologue.\n     * @private\n     */\n    function isExpressionInOrJustAfterDirectivePrologue(node) {\n      if (!astUtils.isTopLevelExpressionStatement(node.parent)) {\n        return false;\n      }\n      const block = node.parent.parent;\n\n      // Check the node is at a prologue.\n      for (let i = 0; i < block.body.length; ++i) {\n        const statement = block.body[i];\n        if (statement === node.parent) {\n          return true;\n        }\n        if (!isDirective(statement)) {\n          break;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether or not a given node is allowed as non backtick.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} Whether or not the node is allowed as non backtick.\n     * @private\n     */\n    function isAllowedAsNonBacktick(node) {\n      const parent = node.parent;\n      switch (parent.type) {\n        // Directive Prologues.\n        case \"ExpressionStatement\":\n          return !astUtils.isParenthesised(sourceCode, node) && isExpressionInOrJustAfterDirectivePrologue(node);\n\n        // LiteralPropertyName.\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n          return parent.key === node && !parent.computed;\n\n        // ModuleSpecifier.\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return parent.source === node;\n\n        // ModuleExportName or ModuleSpecifier.\n        case \"ExportAllDeclaration\":\n          return parent.exported === node || parent.source === node;\n\n        // ModuleExportName.\n        case \"ImportSpecifier\":\n          return parent.imported === node;\n\n        // ModuleExportName.\n        case \"ExportSpecifier\":\n          return parent.local === node || parent.exported === node;\n\n        // Others don't allow.\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.\n     * @param {ASTNode} node A TemplateLiteral node to check.\n     * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.\n     * @private\n     */\n    function isUsingFeatureOfTemplateLiteral(node) {\n      const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\n      if (hasTag) {\n        return true;\n      }\n      const hasStringInterpolation = node.expressions.length > 0;\n      if (hasStringInterpolation) {\n        return true;\n      }\n      const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n      if (isMultilineString) {\n        return true;\n      }\n      return false;\n    }\n    return {\n      Literal(node) {\n        const val = node.value,\n          rawVal = node.raw;\n        if (settings && typeof val === \"string\") {\n          let isValid = quoteOption === \"backtick\" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);\n          if (!isValid && avoidEscape) {\n            isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.includes(settings.quote);\n          }\n          if (!isValid) {\n            context.report({\n              node,\n              messageId: \"wrongQuotes\",\n              data: {\n                description: settings.description\n              },\n              fix(fixer) {\n                if (quoteOption === \"backtick\" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {\n                  /*\n                   * An octal or non-octal decimal escape sequence in a template literal would\n                   * produce syntax error, even in non-strict mode.\n                   */\n                  return null;\n                }\n                return fixer.replaceText(node, settings.convert(node.raw));\n              }\n            });\n          }\n        }\n      },\n      TemplateLiteral(node) {\n        // Don't throw an error if backticks are expected or a template literal feature is in use.\n        if (allowTemplateLiterals || quoteOption === \"backtick\" || isUsingFeatureOfTemplateLiteral(node)) {\n          return;\n        }\n        context.report({\n          node,\n          messageId: \"wrongQuotes\",\n          data: {\n            description: settings.description\n          },\n          fix(fixer) {\n            if (astUtils.isTopLevelExpressionStatement(node.parent) && !astUtils.isParenthesised(sourceCode, node)) {\n              /*\n               * TemplateLiterals aren't actually directives, but fixing them might turn\n               * them into directives and change the behavior of the code.\n               */\n              return null;\n            }\n            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n          }\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","QUOTE_SETTINGS","double","quote","alternateQuote","description","single","backtick","UNESCAPED_LINEBREAK_PATTERN","RegExp","String","raw","Array","from","LINEBREAKS","join","convert","str","newQuote","oldQuote","slice","replace","match","escaped","newline","AVOID_ESCAPE","module","exports","meta","deprecated","replacedBy","type","docs","recommended","url","fixable","schema","enum","anyOf","properties","avoidEscape","allowTemplateLiterals","additionalProperties","messages","wrongQuotes","create","context","quoteOption","options","settings","sourceCode","isJSXLiteral","node","parent","isDirective","expression","value","isParenthesised","isExpressionInOrJustAfterDirectivePrologue","isTopLevelExpressionStatement","block","i","body","length","statement","isAllowedAsNonBacktick","key","computed","source","exported","imported","local","isUsingFeatureOfTemplateLiteral","hasTag","quasi","hasStringInterpolation","expressions","isMultilineString","quasis","test","Literal","val","rawVal","isValid","isSurroundedBy","includes","report","messageId","data","fix","fixer","hasOctalOrNonOctalDecimalEscapeSequence","replaceText","TemplateLiteral","getText"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/quotes.js"],"sourcesContent":["/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    double: {\n        quote: \"\\\"\",\n        alternateQuote: \"'\",\n        description: \"doublequote\"\n    },\n    single: {\n        quote: \"'\",\n        alternateQuote: \"\\\"\",\n        description: \"singlequote\"\n    },\n    backtick: {\n        quote: \"`\",\n        alternateQuote: \"\\\"\",\n        description: \"backtick\"\n    }\n};\n\n// An unescaped newline is a newline preceded by an even number of backslashes.\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert =\nQUOTE_SETTINGS.single.convert =\nQUOTE_SETTINGS.backtick.convert = function(str) {\n    const newQuote = this.quote;\n    const oldQuote = str[0];\n\n    if (newQuote === oldQuote) {\n        return str;\n    }\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n            return escaped; // unescape\n        }\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n            return `\\\\${match}`; // escape\n        }\n        if (newline && oldQuote === \"`\") {\n            return \"\\\\n\"; // escape newlines\n        }\n        return match;\n    }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce the consistent use of either backticks, double, or single quotes\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/quotes\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"single\", \"double\", \"backtick\"]\n            },\n            {\n                anyOf: [\n                    {\n                        enum: [\"avoid-escape\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            avoidEscape: {\n                                type: \"boolean\"\n                            },\n                            allowTemplateLiterals: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            wrongQuotes: \"Strings must use {{description}}.\"\n        }\n    },\n\n    create(context) {\n\n        const quoteOption = context.options[0],\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n            options = context.options[1],\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n            sourceCode = context.sourceCode;\n        let avoidEscape = options && options.avoidEscape === true;\n\n        // deprecated\n        if (options === AVOID_ESCAPE) {\n            avoidEscape = true;\n        }\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         *\n         * This function returns `true` in the following cases:\n         *\n         * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\n         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\n         * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.\n         *\n         * In particular, this function returns `false` in the following cases:\n         *\n         * - `<div className={\"foo\"}></div>`\n         * - `<div>{\"foo\"}</div>`\n         *\n         * In both cases, inside of the braces is handled as normal JavaScript.\n         * The braces are `JSXExpressionContainer` nodes.\n         * @param {ASTNode} node The Literal node to check.\n         * @returns {boolean} True if the node is a part of JSX, false if not.\n         * @private\n         */\n        function isJSXLiteral(node) {\n            return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\n        }\n\n        /**\n         * Checks whether or not a given node is a directive.\n         * The directive is a `ExpressionStatement` which has only a string literal not surrounded by\n         * parentheses.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} Whether or not the node is a directive.\n         * @private\n         */\n        function isDirective(node) {\n            return (\n                node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" &&\n                typeof node.expression.value === \"string\" &&\n                !astUtils.isParenthesised(sourceCode, node.expression)\n            );\n        }\n\n        /**\n         * Checks whether a specified node is either part of, or immediately follows a (possibly empty) directive prologue.\n         * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive}\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} Whether a specified node is either part of, or immediately follows a (possibly empty) directive prologue.\n         * @private\n         */\n        function isExpressionInOrJustAfterDirectivePrologue(node) {\n            if (!astUtils.isTopLevelExpressionStatement(node.parent)) {\n                return false;\n            }\n            const block = node.parent.parent;\n\n            // Check the node is at a prologue.\n            for (let i = 0; i < block.body.length; ++i) {\n                const statement = block.body[i];\n\n                if (statement === node.parent) {\n                    return true;\n                }\n                if (!isDirective(statement)) {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether or not a given node is allowed as non backtick.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\n         * @private\n         */\n        function isAllowedAsNonBacktick(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                // Directive Prologues.\n                case \"ExpressionStatement\":\n                    return !astUtils.isParenthesised(sourceCode, node) && isExpressionInOrJustAfterDirectivePrologue(node);\n\n                // LiteralPropertyName.\n                case \"Property\":\n                case \"PropertyDefinition\":\n                case \"MethodDefinition\":\n                    return parent.key === node && !parent.computed;\n\n                // ModuleSpecifier.\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return parent.source === node;\n\n                // ModuleExportName or ModuleSpecifier.\n                case \"ExportAllDeclaration\":\n                    return parent.exported === node || parent.source === node;\n\n                // ModuleExportName.\n                case \"ImportSpecifier\":\n                    return parent.imported === node;\n\n                // ModuleExportName.\n                case \"ExportSpecifier\":\n                    return parent.local === node || parent.exported === node;\n\n                // Others don't allow.\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.\n         * @param {ASTNode} node A TemplateLiteral node to check.\n         * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.\n         * @private\n         */\n        function isUsingFeatureOfTemplateLiteral(node) {\n            const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\n\n            if (hasTag) {\n                return true;\n            }\n\n            const hasStringInterpolation = node.expressions.length > 0;\n\n            if (hasStringInterpolation) {\n                return true;\n            }\n\n            const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n            if (isMultilineString) {\n                return true;\n            }\n\n            return false;\n        }\n\n        return {\n\n            Literal(node) {\n                const val = node.value,\n                    rawVal = node.raw;\n\n                if (settings && typeof val === \"string\") {\n                    let isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\n                        isJSXLiteral(node) ||\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\n\n                    if (!isValid && avoidEscape) {\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.includes(settings.quote);\n                    }\n\n                    if (!isValid) {\n                        context.report({\n                            node,\n                            messageId: \"wrongQuotes\",\n                            data: {\n                                description: settings.description\n                            },\n                            fix(fixer) {\n                                if (quoteOption === \"backtick\" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {\n\n                                    /*\n                                     * An octal or non-octal decimal escape sequence in a template literal would\n                                     * produce syntax error, even in non-strict mode.\n                                     */\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, settings.convert(node.raw));\n                            }\n                        });\n                    }\n                }\n            },\n\n            TemplateLiteral(node) {\n\n                // Don't throw an error if backticks are expected or a template literal feature is in use.\n                if (\n                    allowTemplateLiterals ||\n                    quoteOption === \"backtick\" ||\n                    isUsingFeatureOfTemplateLiteral(node)\n                ) {\n                    return;\n                }\n\n                context.report({\n                    node,\n                    messageId: \"wrongQuotes\",\n                    data: {\n                        description: settings.description\n                    },\n                    fix(fixer) {\n                        if (astUtils.isTopLevelExpressionStatement(node.parent) && !astUtils.isParenthesised(sourceCode, node)) {\n\n                            /*\n                             * TemplateLiterals aren't actually directives, but fixing them might turn\n                             * them into directives and change the behavior of the code.\n                             */\n                            return null;\n                        }\n                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n                    }\n                });\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}