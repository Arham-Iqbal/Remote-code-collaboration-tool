{"ast":null,"code":"/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n  return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n  return false;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unused expressions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-unused-expressions\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowShortCircuit: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTernary: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTaggedTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceForJSX: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || {},\n      allowShortCircuit = config.allowShortCircuit || false,\n      allowTernary = config.allowTernary || false,\n      allowTaggedTemplates = config.allowTaggedTemplates || false,\n      enforceForJSX = config.enforceForJSX || false;\n\n    /**\n     * Has AST suggesting a directive.\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node structurally represents a directive\n     */\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n\n    /**\n     * Gets the leading sequence of members in a list that pass the predicate.\n     * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n     * @param {a[]} list the input list\n     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n     */\n    function takeWhile(predicate, list) {\n      for (let i = 0; i < list.length; ++i) {\n        if (!predicate(list[i])) {\n          return list.slice(0, i);\n        }\n      }\n      return list.slice();\n    }\n\n    /**\n     * Gets leading directives nodes in a Node body.\n     * @param {ASTNode} node a Program or BlockStatement node\n     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n     */\n    function directives(node) {\n      return takeWhile(looksLikeDirective, node.body);\n    }\n\n    /**\n     * Detect if a Node is a directive.\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node is considered a directive in its current position\n     */\n    function isDirective(node) {\n      /**\n       * https://tc39.es/ecma262/#directive-prologue\n       *\n       * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\n       * Class static blocks do not have directive prologue.\n       */\n      return astUtils.isTopLevelExpressionStatement(node) && directives(node.parent).includes(node);\n    }\n\n    /**\n     * The member functions return `true` if the type has no side-effects.\n     * Unknown nodes are handled as `false`, then this rule ignores those.\n     */\n    const Checker = Object.assign(Object.create(null), {\n      isDisallowed(node) {\n        return (Checker[node.type] || alwaysFalse)(node);\n      },\n      ArrayExpression: alwaysTrue,\n      ArrowFunctionExpression: alwaysTrue,\n      BinaryExpression: alwaysTrue,\n      ChainExpression(node) {\n        return Checker.isDisallowed(node.expression);\n      },\n      ClassExpression: alwaysTrue,\n      ConditionalExpression(node) {\n        if (allowTernary) {\n          return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n        }\n        return true;\n      },\n      FunctionExpression: alwaysTrue,\n      Identifier: alwaysTrue,\n      JSXElement() {\n        return enforceForJSX;\n      },\n      JSXFragment() {\n        return enforceForJSX;\n      },\n      Literal: alwaysTrue,\n      LogicalExpression(node) {\n        if (allowShortCircuit) {\n          return Checker.isDisallowed(node.right);\n        }\n        return true;\n      },\n      MemberExpression: alwaysTrue,\n      MetaProperty: alwaysTrue,\n      ObjectExpression: alwaysTrue,\n      SequenceExpression: alwaysTrue,\n      TaggedTemplateExpression() {\n        return !allowTaggedTemplates;\n      },\n      TemplateLiteral: alwaysTrue,\n      ThisExpression: alwaysTrue,\n      UnaryExpression(node) {\n        return node.operator !== \"void\" && node.operator !== \"delete\";\n      }\n    });\n    return {\n      ExpressionStatement(node) {\n        if (Checker.isDisallowed(node.expression) && !isDirective(node)) {\n          context.report({\n            node,\n            messageId: \"unusedExpression\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","alwaysTrue","alwaysFalse","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowShortCircuit","default","allowTernary","allowTaggedTemplates","enforceForJSX","additionalProperties","messages","unusedExpression","create","context","config","options","looksLikeDirective","node","expression","value","takeWhile","predicate","list","i","length","slice","directives","body","isDirective","isTopLevelExpressionStatement","parent","includes","Checker","Object","assign","isDisallowed","ArrayExpression","ArrowFunctionExpression","BinaryExpression","ChainExpression","ClassExpression","ConditionalExpression","consequent","alternate","FunctionExpression","Identifier","JSXElement","JSXFragment","Literal","LogicalExpression","right","MemberExpression","MetaProperty","ObjectExpression","SequenceExpression","TaggedTemplateExpression","TemplateLiteral","ThisExpression","UnaryExpression","operator","ExpressionStatement","report","messageId"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-unused-expressions.js"],"sourcesContent":["/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n    return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n    return false;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unused expressions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTernary: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceForJSX: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false,\n            enforceForJSX = config.enforceForJSX || false;\n\n        /**\n         * Has AST suggesting a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Gets the leading sequence of members in a list that pass the predicate.\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        /**\n         * Gets leading directives nodes in a Node body.\n         * @param {ASTNode} node a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * Detect if a Node is a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node) {\n\n            /**\n             * https://tc39.es/ecma262/#directive-prologue\n             *\n             * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\n             * Class static blocks do not have directive prologue.\n             */\n            return astUtils.isTopLevelExpressionStatement(node) && directives(node.parent).includes(node);\n        }\n\n        /**\n         * The member functions return `true` if the type has no side-effects.\n         * Unknown nodes are handled as `false`, then this rule ignores those.\n         */\n        const Checker = Object.assign(Object.create(null), {\n            isDisallowed(node) {\n                return (Checker[node.type] || alwaysFalse)(node);\n            },\n\n            ArrayExpression: alwaysTrue,\n            ArrowFunctionExpression: alwaysTrue,\n            BinaryExpression: alwaysTrue,\n            ChainExpression(node) {\n                return Checker.isDisallowed(node.expression);\n            },\n            ClassExpression: alwaysTrue,\n            ConditionalExpression(node) {\n                if (allowTernary) {\n                    return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n                }\n                return true;\n            },\n            FunctionExpression: alwaysTrue,\n            Identifier: alwaysTrue,\n            JSXElement() {\n                return enforceForJSX;\n            },\n            JSXFragment() {\n                return enforceForJSX;\n            },\n            Literal: alwaysTrue,\n            LogicalExpression(node) {\n                if (allowShortCircuit) {\n                    return Checker.isDisallowed(node.right);\n                }\n                return true;\n            },\n            MemberExpression: alwaysTrue,\n            MetaProperty: alwaysTrue,\n            ObjectExpression: alwaysTrue,\n            SequenceExpression: alwaysTrue,\n            TaggedTemplateExpression() {\n                return !allowTaggedTemplates;\n            },\n            TemplateLiteral: alwaysTrue,\n            ThisExpression: alwaysTrue,\n            UnaryExpression(node) {\n                return node.operator !== \"void\" && node.operator !== \"delete\";\n            }\n        });\n\n        return {\n            ExpressionStatement(node) {\n                if (Checker.isDisallowed(node.expression) && !isDirective(node)) {\n                    context.report({ node, messageId: \"unusedExpression\" });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}