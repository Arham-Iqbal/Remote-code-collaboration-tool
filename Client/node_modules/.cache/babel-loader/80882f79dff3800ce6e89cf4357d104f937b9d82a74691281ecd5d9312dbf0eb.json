{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n  MODE_AS_NEEDED = \"as-needed\";\nconst validRadixValues = new Set(Array.from({\n  length: 37 - 2\n}, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n  return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n  return node.type === \"MemberExpression\" && !node.computed && node.property.type === \"Identifier\" && node.property.name === \"parseInt\";\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n  return !(radix.type === \"Literal\" && !validRadixValues.has(radix.value) || radix.type === \"Identifier\" && radix.name === \"undefined\");\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n  return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce the consistent use of the radix argument when using `parseInt()`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/radix\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }],\n    messages: {\n      missingParameters: \"Missing parameters.\",\n      redundantRadix: \"Redundant radix parameter.\",\n      missingRadix: \"Missing radix parameter.\",\n      invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n      addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n    }\n  },\n  create(context) {\n    const mode = context.options[0] || MODE_ALWAYS;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Checks the arguments of a given CallExpression node and reports it if it\n     * offends this rule.\n     * @param {ASTNode} node A CallExpression node to check.\n     * @returns {void}\n     */\n    function checkArguments(node) {\n      const args = node.arguments;\n      switch (args.length) {\n        case 0:\n          context.report({\n            node,\n            messageId: \"missingParameters\"\n          });\n          break;\n        case 1:\n          if (mode === MODE_ALWAYS) {\n            context.report({\n              node,\n              messageId: \"missingRadix\",\n              suggest: [{\n                messageId: \"addRadixParameter10\",\n                fix(fixer) {\n                  const tokens = sourceCode.getTokens(node);\n                  const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n                  const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n                  const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n                  return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                }\n              }]\n            });\n          }\n          break;\n        default:\n          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"redundantRadix\"\n            });\n          } else if (!isValidRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"invalidRadix\"\n            });\n          }\n          break;\n      }\n    }\n    return {\n      \"Program:exit\"(node) {\n        const scope = sourceCode.getScope(node);\n        let variable;\n\n        // Check `parseInt()`\n        variable = astUtils.getVariableByName(scope, \"parseInt\");\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const idNode = reference.identifier;\n            if (astUtils.isCallee(idNode)) {\n              checkArguments(idNode.parent);\n            }\n          });\n        }\n\n        // Check `Number.parseInt()`\n        variable = astUtils.getVariableByName(scope, \"Number\");\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const parentNode = reference.identifier.parent;\n            const maybeCallee = parentNode.parent.type === \"ChainExpression\" ? parentNode.parent : parentNode;\n            if (isParseIntMethod(parentNode) && astUtils.isCallee(maybeCallee)) {\n              checkArguments(maybeCallee.parent);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","MODE_ALWAYS","MODE_AS_NEEDED","validRadixValues","Set","Array","from","length","_","index","isShadowed","variable","defs","isParseIntMethod","node","type","computed","property","name","isValidRadix","radix","has","value","isDefaultRadix","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","enum","messages","missingParameters","redundantRadix","missingRadix","invalidRadix","addRadixParameter10","create","context","mode","options","sourceCode","checkArguments","args","arguments","report","messageId","suggest","fix","fixer","tokens","getTokens","lastToken","secondToLastToken","hasTrailingComma","insertTextBefore","Program:exit","scope","getScope","getVariableByName","references","forEach","reference","idNode","identifier","isCallee","parent","parentNode","maybeCallee"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/radix.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\nconst validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && !validRadixValues.has(radix.value)) ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce the consistent use of the radix argument when using `parseInt()`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/radix\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ],\n\n        messages: {\n            missingParameters: \"Missing parameters.\",\n            redundantRadix: \"Redundant radix parameter.\",\n            missingRadix: \"Missing radix parameter.\",\n            invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n            addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n        }\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        messageId: \"missingParameters\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            messageId: \"missingRadix\",\n                            suggest: [\n                                {\n                                    messageId: \"addRadixParameter10\",\n                                    fix(fixer) {\n                                        const tokens = sourceCode.getTokens(node);\n                                        const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n                                        const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n                                        const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n\n                                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                                    }\n                                }\n                            ]\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"redundantRadix\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"invalidRadix\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"(node) {\n                const scope = sourceCode.getScope(node);\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const idNode = reference.identifier;\n\n                        if (astUtils.isCallee(idNode)) {\n                            checkArguments(idNode.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const parentNode = reference.identifier.parent;\n                        const maybeCallee = parentNode.parent.type === \"ChainExpression\"\n                            ? parentNode.parent\n                            : parentNode;\n\n                        if (isParseIntMethod(parentNode) && astUtils.isCallee(maybeCallee)) {\n                            checkArguments(maybeCallee.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}