{"ast":null,"code":"/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FUNC_EXPR_NODE_TYPES = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\nconst CALL_EXPR_NODE_TYPE = new Set([\"CallExpression\"]);\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow variable declarations from shadowing variables declared in the outer scope\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-shadow\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        builtinGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        hoist: {\n          enum: [\"all\", \"functions\", \"never\"],\n          default: \"functions\"\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        ignoreOnInitialization: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n      noShadowGlobal: \"'{{name}}' is already a global variable.\"\n    }\n  },\n  create(context) {\n    const options = {\n      builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n      hoist: context.options[0] && context.options[0].hoist || \"functions\",\n      allow: context.options[0] && context.options[0].allow || [],\n      ignoreOnInitialization: context.options[0] && context.options[0].ignoreOnInitialization\n    };\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Checks whether or not a given location is inside of the range of a given node.\n     * @param {ASTNode} node An node to check.\n     * @param {number} location A location to check.\n     * @returns {boolean} `true` if the location is inside of the range of the node.\n     */\n    function isInRange(node, location) {\n      return node && node.range[0] <= location && location <= node.range[1];\n    }\n\n    /**\n     * Searches from the current node through its ancestry to find a matching node.\n     * @param {ASTNode} node a node to get.\n     * @param {(node: ASTNode) => boolean} match a callback that checks whether or not the node verifies its condition or not.\n     * @returns {ASTNode|null} the matching node.\n     */\n    function findSelfOrAncestor(node, match) {\n      let currentNode = node;\n      while (currentNode && !match(currentNode)) {\n        currentNode = currentNode.parent;\n      }\n      return currentNode;\n    }\n\n    /**\n     * Finds function's outer scope.\n     * @param {Scope} scope Function's own scope.\n     * @returns {Scope} Function's outer scope.\n     */\n    function getOuterScope(scope) {\n      const upper = scope.upper;\n      if (upper.type === \"function-expression-name\") {\n        return upper.upper;\n      }\n      return upper;\n    }\n\n    /**\n     * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\n     * @param {Object} variable a variable to check.\n     * @param {Object} shadowedVariable a shadowedVariable to check.\n     * @returns {boolean} Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\n     */\n    function isInitPatternNode(variable, shadowedVariable) {\n      const outerDef = shadowedVariable.defs[0];\n      if (!outerDef) {\n        return false;\n      }\n      const {\n        variableScope\n      } = variable.scope;\n      if (!(FUNC_EXPR_NODE_TYPES.has(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {\n        return false;\n      }\n      const fun = variableScope.block;\n      const {\n        parent\n      } = fun;\n      const callExpression = findSelfOrAncestor(parent, node => CALL_EXPR_NODE_TYPE.has(node.type));\n      if (!callExpression) {\n        return false;\n      }\n      let node = outerDef.name;\n      const location = callExpression.range[1];\n      while (node) {\n        if (node.type === \"VariableDeclarator\") {\n          if (isInRange(node.init, location)) {\n            return true;\n          }\n          if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n            return true;\n          }\n          break;\n        } else if (node.type === \"AssignmentPattern\") {\n          if (isInRange(node.right, location)) {\n            return true;\n          }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n          break;\n        }\n        node = node.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Check if variable name is allowed.\n     * @param {ASTNode} variable The variable to check.\n     * @returns {boolean} Whether or not the variable name is allowed.\n     */\n    function isAllowed(variable) {\n      return options.allow.includes(variable.name);\n    }\n\n    /**\n     * Checks if a variable of the class name in the class scope of ClassDeclaration.\n     *\n     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n     * So we should ignore the variable in the class scope.\n     * @param {Object} variable The variable to check.\n     * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n     */\n    function isDuplicatedClassNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n    }\n\n    /**\n     * Checks if a variable is inside the initializer of scopeVar.\n     *\n     * To avoid reporting at declarations such as `var a = function a() {};`.\n     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n     * @param {Object} variable The variable to check.\n     * @param {Object} scopeVar The scope variable to look for.\n     * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n     */\n    function isOnInitializer(variable, scopeVar) {\n      const outerScope = scopeVar.scope;\n      const outerDef = scopeVar.defs[0];\n      const outer = outerDef && outerDef.parent && outerDef.parent.range;\n      const innerScope = variable.scope;\n      const innerDef = variable.defs[0];\n      const inner = innerDef && innerDef.name.range;\n      return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\" || innerDef.node.type === \"ClassExpression\") && outerScope === innerScope.upper;\n    }\n\n    /**\n     * Get a range of a variable's identifier node.\n     * @param {Object} variable The variable to get.\n     * @returns {Array|undefined} The range of the variable's identifier node.\n     */\n    function getNameRange(variable) {\n      const def = variable.defs[0];\n      return def && def.name.range;\n    }\n\n    /**\n     * Get declared line and column of a variable.\n     * @param {eslint-scope.Variable} variable The variable to get.\n     * @returns {Object} The declared line and column of the variable.\n     */\n    function getDeclaredLocation(variable) {\n      const identifier = variable.identifiers[0];\n      let obj;\n      if (identifier) {\n        obj = {\n          global: false,\n          line: identifier.loc.start.line,\n          column: identifier.loc.start.column + 1\n        };\n      } else {\n        obj = {\n          global: true\n        };\n      }\n      return obj;\n    }\n\n    /**\n     * Checks if a variable is in TDZ of scopeVar.\n     * @param {Object} variable The variable to check.\n     * @param {Object} scopeVar The variable of TDZ.\n     * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n     */\n    function isInTdz(variable, scopeVar) {\n      const outerDef = scopeVar.defs[0];\n      const inner = getNameRange(variable);\n      const outer = getNameRange(scopeVar);\n      return inner && outer && inner[1] < outer[0] && (\n      // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n      options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\");\n    }\n\n    /**\n     * Checks the current context for shadowed variables.\n     * @param {Scope} scope Fixme\n     * @returns {void}\n     */\n    function checkForShadows(scope) {\n      const variables = scope.variables;\n      for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n        if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {\n          continue;\n        }\n\n        // Gets shadowed variable.\n        const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n        if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && \"writeable\" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) && !(options.hoist !== \"all\" && isInTdz(variable, shadowed))) {\n          const location = getDeclaredLocation(shadowed);\n          const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\n          const data = {\n            name: variable.name\n          };\n          if (!location.global) {\n            data.shadowedLine = location.line;\n            data.shadowedColumn = location.column;\n          }\n          context.report({\n            node: variable.identifiers[0],\n            messageId,\n            data\n          });\n        }\n      }\n    }\n    return {\n      \"Program:exit\"(node) {\n        const globalScope = sourceCode.getScope(node);\n        const stack = globalScope.childScopes.slice();\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkForShadows(scope);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","FUNC_EXPR_NODE_TYPES","Set","CALL_EXPR_NODE_TYPE","FOR_IN_OF_TYPE","SENTINEL_TYPE","module","exports","meta","type","docs","description","recommended","url","schema","properties","builtinGlobals","default","hoist","enum","allow","items","ignoreOnInitialization","additionalProperties","messages","noShadow","noShadowGlobal","create","context","options","sourceCode","isInRange","node","location","range","findSelfOrAncestor","match","currentNode","parent","getOuterScope","scope","upper","isInitPatternNode","variable","shadowedVariable","outerDef","defs","variableScope","has","block","fun","callExpression","name","init","test","right","isAllowed","includes","isDuplicatedClassNameVariable","id","identifiers","isOnInitializer","scopeVar","outerScope","outer","innerScope","innerDef","inner","getNameRange","def","getDeclaredLocation","identifier","obj","global","line","loc","start","column","isInTdz","checkForShadows","variables","i","length","shadowed","getVariableByName","messageId","data","shadowedLine","shadowedColumn","report","Program:exit","globalScope","getScope","stack","childScopes","slice","pop","push"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-shadow.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FUNC_EXPR_NODE_TYPES = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\nconst CALL_EXPR_NODE_TYPE = new Set([\"CallExpression\"]);\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow variable declarations from shadowing variables declared in the outer scope\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-shadow\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\", default: false },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"], default: \"functions\" },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    ignoreOnInitialization: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n            noShadowGlobal: \"'{{name}}' is already a global variable.\"\n        }\n    },\n\n    create(context) {\n\n        const options = {\n            builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\n            allow: (context.options[0] && context.options[0].allow) || [],\n            ignoreOnInitialization: context.options[0] && context.options[0].ignoreOnInitialization\n        };\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks whether or not a given location is inside of the range of a given node.\n         * @param {ASTNode} node An node to check.\n         * @param {number} location A location to check.\n         * @returns {boolean} `true` if the location is inside of the range of the node.\n         */\n        function isInRange(node, location) {\n            return node && node.range[0] <= location && location <= node.range[1];\n        }\n\n        /**\n         * Searches from the current node through its ancestry to find a matching node.\n         * @param {ASTNode} node a node to get.\n         * @param {(node: ASTNode) => boolean} match a callback that checks whether or not the node verifies its condition or not.\n         * @returns {ASTNode|null} the matching node.\n         */\n        function findSelfOrAncestor(node, match) {\n            let currentNode = node;\n\n            while (currentNode && !match(currentNode)) {\n                currentNode = currentNode.parent;\n            }\n            return currentNode;\n        }\n\n        /**\n         * Finds function's outer scope.\n         * @param {Scope} scope Function's own scope.\n         * @returns {Scope} Function's outer scope.\n         */\n        function getOuterScope(scope) {\n            const upper = scope.upper;\n\n            if (upper.type === \"function-expression-name\") {\n                return upper.upper;\n            }\n            return upper;\n        }\n\n        /**\n         * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\n         * @param {Object} variable a variable to check.\n         * @param {Object} shadowedVariable a shadowedVariable to check.\n         * @returns {boolean} Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\n         */\n        function isInitPatternNode(variable, shadowedVariable) {\n            const outerDef = shadowedVariable.defs[0];\n\n            if (!outerDef) {\n                return false;\n            }\n\n            const { variableScope } = variable.scope;\n\n\n            if (!(FUNC_EXPR_NODE_TYPES.has(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {\n                return false;\n            }\n\n            const fun = variableScope.block;\n            const { parent } = fun;\n\n            const callExpression = findSelfOrAncestor(\n                parent,\n                node => CALL_EXPR_NODE_TYPE.has(node.type)\n            );\n\n            if (!callExpression) {\n                return false;\n            }\n\n            let node = outerDef.name;\n            const location = callExpression.range[1];\n\n            while (node) {\n                if (node.type === \"VariableDeclarator\") {\n                    if (isInRange(node.init, location)) {\n                        return true;\n                    }\n                    if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                        isInRange(node.parent.parent.right, location)\n                    ) {\n                        return true;\n                    }\n                    break;\n                } else if (node.type === \"AssignmentPattern\") {\n                    if (isInRange(node.right, location)) {\n                        return true;\n                    }\n                } else if (SENTINEL_TYPE.test(node.type)) {\n                    break;\n                }\n\n                node = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if variable name is allowed.\n         * @param {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return options.allow.includes(variable.name);\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                 inner &&\n                 outer[0] < inner[0] &&\n                 inner[1] < outer[1] &&\n                 ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                 outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Get declared line and column of a variable.\n         * @param {eslint-scope.Variable} variable The variable to get.\n         * @returns {Object} The declared line and column of the variable.\n         */\n        function getDeclaredLocation(variable) {\n            const identifier = variable.identifiers[0];\n            let obj;\n\n            if (identifier) {\n                obj = {\n                    global: false,\n                    line: identifier.loc.start.line,\n                    column: identifier.loc.start.column + 1\n                };\n            } else {\n                obj = {\n                    global: true\n                };\n            }\n            return obj;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                 outer &&\n                 inner[1] < outer[0] &&\n\n                 // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                 (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                     isDuplicatedClassNameVariable(variable) ||\n                     isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                      (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\n                      !isOnInitializer(variable, shadowed) &&\n                      !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) &&\n                      !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    const location = getDeclaredLocation(shadowed);\n                    const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\n                    const data = { name: variable.name };\n\n                    if (!location.global) {\n                        data.shadowedLine = location.line;\n                        data.shadowedColumn = location.column;\n                    }\n                    context.report({\n                        node: variable.identifiers[0],\n                        messageId,\n                        data\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"(node) {\n                const globalScope = sourceCode.getScope(node);\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}