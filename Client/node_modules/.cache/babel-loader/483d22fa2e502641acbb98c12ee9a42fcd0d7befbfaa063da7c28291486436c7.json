{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, \"u\");\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n  if (node.type === \"ExpressionStatement\") {\n    let call = astUtils.skipChainExpression(node.expression);\n    if (call.type === \"UnaryExpression\") {\n      call = astUtils.skipChainExpression(call.argument);\n    }\n    return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n  }\n  return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n  // do-while with a block is a block-like statement.\n  if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n    return true;\n  }\n\n  /*\n   * IIFE is a block-like statement specially from\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\n   */\n  if (isIIFEStatement(node)) {\n    return true;\n  }\n\n  // Checks the last token is a closing brace of blocks.\n  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return Boolean(belongingNode) && (belongingNode.type === \"BlockStatement\" || belongingNode.type === \"SwitchStatement\");\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n  context.report({\n    node: nextNode,\n    messageId: \"unexpectedBlankLine\",\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.sourceCode.text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n  });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n  context.report({\n    node: nextNode,\n    messageId: \"expectedBlankLine\",\n    fix(fixer) {\n      const sourceCode = context.sourceCode;\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n        /**\n         * Skip the trailing comments of the previous node.\n         * This inserts a blank line after the last trailing comment.\n         *\n         * For example:\n         *\n         *     foo(); // trailing comment.\n         *     // comment.\n         *     bar();\n         *\n         * Get fixed to:\n         *\n         *     foo(); // trailing comment.\n         *\n         *     // comment.\n         *     bar();\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is not a trailing comment.\n         * @private\n         */\n        filter(token) {\n          if (astUtils.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n          return true;\n        }\n      }) || nextNode;\n      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? \"\\n\\n\" : \"\\n\";\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n  });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n  \"*\": {\n    test: () => true\n  },\n  \"block-like\": {\n    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n  },\n  \"cjs-export\": {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n  },\n  \"cjs-import\": {\n    test: (node, sourceCode) => node.type === \"VariableDeclaration\" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n  },\n  directive: {\n    test: astUtils.isDirective\n  },\n  expression: {\n    test: node => node.type === \"ExpressionStatement\" && !astUtils.isDirective(node)\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  \"multiline-block-like\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)\n  },\n  \"multiline-expression\": {\n    test: node => node.loc.start.line !== node.loc.end.line && node.type === \"ExpressionStatement\" && !astUtils.isDirective(node)\n  },\n  \"multiline-const\": newMultilineKeywordTester(\"const\"),\n  \"multiline-let\": newMultilineKeywordTester(\"let\"),\n  \"multiline-var\": newMultilineKeywordTester(\"var\"),\n  \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n  \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n  \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n  block: newNodeTypeTester(\"BlockStatement\"),\n  empty: newNodeTypeTester(\"EmptyStatement\"),\n  function: newNodeTypeTester(\"FunctionDeclaration\"),\n  break: newKeywordTester(\"break\"),\n  case: newKeywordTester(\"case\"),\n  class: newKeywordTester(\"class\"),\n  const: newKeywordTester(\"const\"),\n  continue: newKeywordTester(\"continue\"),\n  debugger: newKeywordTester(\"debugger\"),\n  default: newKeywordTester(\"default\"),\n  do: newKeywordTester(\"do\"),\n  export: newKeywordTester(\"export\"),\n  for: newKeywordTester(\"for\"),\n  if: newKeywordTester(\"if\"),\n  import: newKeywordTester(\"import\"),\n  let: newKeywordTester(\"let\"),\n  return: newKeywordTester(\"return\"),\n  switch: newKeywordTester(\"switch\"),\n  throw: newKeywordTester(\"throw\"),\n  try: newKeywordTester(\"try\"),\n  var: newKeywordTester(\"var\"),\n  while: newKeywordTester(\"while\"),\n  with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Require or disallow padding lines between statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/padding-line-between-statements\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: \"array\",\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true\n          }]\n        }\n      },\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          blankLine: {\n            $ref: \"#/definitions/paddingType\"\n          },\n          prev: {\n            $ref: \"#/definitions/statementType\"\n          },\n          next: {\n            $ref: \"#/definitions/statementType\"\n          }\n        },\n        additionalProperties: false,\n        required: [\"blankLine\", \"prev\", \"next\"]\n      }\n    },\n    messages: {\n      unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n      expectedBlankLine: \"Expected blank line before this statement.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const configureList = context.options || [];\n    let scopeInfo = null;\n\n    /**\n     * Processes to enter to new scope.\n     * This manages the current previous statement.\n     * @returns {void}\n     * @private\n     */\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n\n    /**\n     * Processes to exit from the current scope.\n     * @returns {void}\n     * @private\n     */\n    function exitScope() {\n      scopeInfo = scopeInfo.upper;\n    }\n\n    /**\n     * Checks whether the given node matches the given type.\n     * @param {ASTNode} node The statement node to check.\n     * @param {string|string[]} type The statement type to check.\n     * @returns {boolean} `true` if the statement node matched the type.\n     * @private\n     */\n    function match(node, type) {\n      let innerStatementNode = node;\n      while (innerStatementNode.type === \"LabeledStatement\") {\n        innerStatementNode = innerStatementNode.body;\n      }\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n\n    /**\n     * Finds the last matched configure from configureList.\n     * @param {ASTNode} prevNode The previous statement to match.\n     * @param {ASTNode} nextNode The current statement to match.\n     * @returns {Object} The tester of the last matched configure.\n     * @private\n     */\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n        if (matched) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n      return PaddingTypes.any;\n    }\n\n    /**\n     * Gets padding line sequences between the given 2 statements.\n     * Comments are separators of the padding line sequences.\n     * @param {ASTNode} prevNode The previous statement to count.\n     * @param {ASTNode} nextNode The current statement to count.\n     * @returns {Array<Token[]>} The array of token pairs.\n     * @private\n     */\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n      return pairs;\n    }\n\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n    function verify(node) {\n      const parentType = node.parent.type;\n      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === \"SwitchStatement\";\n      if (!validParent) {\n        return;\n      }\n\n      // Save this node as the current previous statement.\n      const prevNode = scopeInfo.prevNode;\n\n      // Verify.\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n      scopeInfo.prevNode = node;\n    }\n\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * Then process to enter to new scope.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      StaticBlock: enterScope,\n      \"Program:exit\": exitScope,\n      \"BlockStatement:exit\": exitScope,\n      \"SwitchStatement:exit\": exitScope,\n      \"StaticBlock:exit\": exitScope,\n      \":statement\": verify,\n      SwitchCase: verifyThenEnterScope,\n      \"SwitchCase:exit\": exitScope\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","LT","Array","from","LINEBREAKS","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","CJS_EXPORT","CJS_IMPORT","newKeywordTester","keyword","test","node","sourceCode","getFirstToken","value","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","type","isIIFEStatement","call","skipChainExpression","expression","argument","isFunction","callee","isBlockLikeStatement","body","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","Boolean","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","length","report","messageId","fix","fixer","text","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","getText","left","declarations","init","directive","isDirective","iife","block","empty","function","break","case","class","const","continue","debugger","default","do","export","for","if","import","let","return","switch","throw","try","var","while","with","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","fixable","schema","definitions","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","properties","blankLine","$ref","prev","next","additionalProperties","required","messages","unexpectedBlankLine","expectedBlankLine","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","isArray","some","bind","getPaddingType","i","configure","matched","getPaddingLineSequences","pairs","push","parentType","parent","validParent","STATEMENT_LIST_PARENTS","has","verifyThenEnterScope","Program","BlockStatement","SwitchStatement","StaticBlock","SwitchCase"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/padding-line-between-statements.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\n    \"u\"\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line === node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = astUtils.skipChainExpression(node.expression);\n\n        if (call.type === \"UnaryExpression\") {\n            call = astUtils.skipChainExpression(call.argument);\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    /*\n     * IIFE is a block-like statement specially from\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\n     */\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"unexpectedBlankLine\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.sourceCode.text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"expectedBlankLine\",\n        fix(fixer) {\n            const sourceCode = context.sourceCode;\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: astUtils.isDirective\n    },\n    expression: {\n        test: node => node.type === \"ExpressionStatement\" && !astUtils.isDirective(node)\n    },\n    iife: {\n        test: isIIFEStatement\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n    \"multiline-expression\": {\n        test: node =>\n            node.loc.start.line !== node.loc.end.line &&\n            node.type === \"ExpressionStatement\" &&\n            !astUtils.isDirective(node)\n    },\n\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow padding lines between statements\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/padding-line-between-statements\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            }\n        },\n\n        messages: {\n            unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n            expectedBlankLine: \"Expected blank line before this statement.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            let innerStatementNode = node;\n\n            while (innerStatementNode.type === \"LabeledStatement\") {\n                innerStatementNode = innerStatementNode.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, innerStatementNode));\n            }\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            StaticBlock: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n            \"StaticBlock:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}