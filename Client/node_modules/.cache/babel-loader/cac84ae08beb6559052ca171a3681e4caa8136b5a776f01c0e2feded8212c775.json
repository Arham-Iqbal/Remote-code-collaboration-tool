{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"@eslint-community/eslint-utils\");\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"@eslint-community/regexpp\");\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = require(\"./utils/unicode\");\nconst astUtils = require(\"./utils/ast-utils.js\");\nconst {\n  isValidWithUnicodeFlag\n} = require(\"./utils/regular-expressions\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @typedef {import('@eslint-community/regexpp').AST.Character} Character\n * @typedef {import('@eslint-community/regexpp').AST.CharacterClassElement} CharacterClassElement\n */\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<Character[]>} The list of character sequences.\n */\nfunction* iterateCharacterSequence(nodes) {\n  /** @type {Character[]} */\n  let seq = [];\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node);\n        break;\n      case \"CharacterClassRange\":\n        seq.push(node.min);\n        yield seq;\n        seq = [node.max];\n        break;\n      case \"CharacterSet\":\n      case \"CharacterClass\": // [[]] nesting character class\n      case \"ClassStringDisjunction\": // \\q{...}\n      case \"ExpressionCharacterClass\":\n        // [A--B]\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n        break;\n\n      // no default\n    }\n  }\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\n\n/**\n * Checks whether the given character node is a Unicode code point escape or not.\n * @param {Character} char the character node to check.\n * @returns {boolean} `true` if the character node is a Unicode code point escape.\n */\nfunction isUnicodeCodePointEscape(char) {\n  return /^\\\\u\\{[\\da-f]+\\}$/iu.test(char.raw);\n}\n\n/**\n * Each function returns `true` if it detects that kind of problem.\n * @type {Record<string, (chars: Character[]) => boolean>}\n */\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => {\n      if (i === 0) {\n        return false;\n      }\n      const c1 = chars[i - 1];\n      return isSurrogatePair(c1.value, c.value) && !isUnicodeCodePointEscape(c1) && !isUnicodeCodePointEscape(c);\n    });\n  },\n  surrogatePair(chars) {\n    return chars.some((c, i) => {\n      if (i === 0) {\n        return false;\n      }\n      const c1 = chars[i - 1];\n      return isSurrogatePair(c1.value, c.value) && (isUnicodeCodePointEscape(c1) || isUnicodeCodePointEscape(c));\n    });\n  },\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c.value) && !isCombiningCharacter(chars[i - 1].value));\n  },\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c.value) && !isEmojiModifier(chars[i - 1].value));\n  },\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c.value) && isRegionalIndicatorSymbol(chars[i - 1].value));\n  },\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c.value === 0x200d && chars[i - 1].value !== 0x200d && chars[i + 1].value !== 0x200d);\n  }\n};\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow characters which are made with multiple code points in character class syntax\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-misleading-character-class\"\n    },\n    hasSuggestions: true,\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      surrogatePair: \"Unexpected surrogate pair in character class.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\",\n      suggestUnicodeFlag: \"Add unicode 'u' flag to regex.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const parser = new RegExpParser();\n\n    /**\n     * Verify a given regular expression.\n     * @param {Node} node The node to report.\n     * @param {string} pattern The regular expression pattern to verify.\n     * @param {string} flags The flags of the regular expression.\n     * @param {Function} unicodeFixer Fixer for missing \"u\" flag.\n     * @returns {void}\n     */\n    function verify(node, pattern, flags, unicodeFixer) {\n      let patternNode;\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, {\n          unicode: flags.includes(\"u\"),\n          unicodeSets: flags.includes(\"v\")\n        });\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n      const foundKinds = new Set();\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              if (hasCharacterSequence[kind](chars)) {\n                foundKinds.add(kind);\n              }\n            }\n          }\n        }\n      });\n      for (const kind of foundKinds) {\n        let suggest;\n        if (kind === \"surrogatePairWithoutUFlag\") {\n          suggest = [{\n            messageId: \"suggestUnicodeFlag\",\n            fix: unicodeFixer\n          }];\n        }\n        context.report({\n          node,\n          messageId: kind,\n          suggest\n        });\n      }\n    }\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags, fixer => {\n          if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, node.regex.pattern)) {\n            return null;\n          }\n          return fixer.insertTextAfter(node, \"u\");\n        });\n      },\n      \"Program\"(node) {\n        const scope = sourceCode.getScope(node);\n        const tracker = new ReferenceTracker(scope);\n\n        /*\n         * Iterate calls of RegExp.\n         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n         *       `const {RegExp: a} = window; new a()`, etc...\n         */\n        for (const {\n          node: refNode\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = refNode.arguments;\n          const pattern = getStringIfConstant(patternNode, scope);\n          const flags = getStringIfConstant(flagsNode, scope);\n          if (typeof pattern === \"string\") {\n            verify(refNode, pattern, flags || \"\", fixer => {\n              if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, pattern)) {\n                return null;\n              }\n              if (refNode.arguments.length === 1) {\n                const penultimateToken = sourceCode.getLastToken(refNode, {\n                  skip: 1\n                }); // skip closing parenthesis\n\n                return fixer.insertTextAfter(penultimateToken, astUtils.isCommaToken(penultimateToken) ? ' \"u\",' : ', \"u\"');\n              }\n              if (flagsNode.type === \"Literal\" && typeof flagsNode.value === \"string\" || flagsNode.type === \"TemplateLiteral\") {\n                const range = [flagsNode.range[0], flagsNode.range[1] - 1];\n                return fixer.insertTextAfterRange(range, \"u\");\n              }\n              return null;\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpParser","visitRegExpAST","isCombiningCharacter","isEmojiModifier","isRegionalIndicatorSymbol","isSurrogatePair","astUtils","isValidWithUnicodeFlag","iterateCharacterSequence","nodes","seq","node","type","push","min","max","length","isUnicodeCodePointEscape","char","test","raw","hasCharacterSequence","surrogatePairWithoutUFlag","chars","some","c","i","c1","value","surrogatePair","combiningClass","emojiModifier","regionalIndicatorSymbol","zwj","lastIndex","kinds","Object","keys","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","messages","suggestUnicodeFlag","create","context","sourceCode","parser","verify","pattern","flags","unicodeFixer","patternNode","parsePattern","unicode","includes","unicodeSets","foundKinds","Set","onCharacterClassEnter","ccNode","elements","kind","add","suggest","messageId","fix","report","Literal[regex]","regex","fixer","languageOptions","ecmaVersion","insertTextAfter","Program","scope","getScope","tracker","refNode","iterateGlobalReferences","RegExp","flagsNode","arguments","penultimateToken","getLastToken","skip","isCommaToken","range","insertTextAfterRange"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-misleading-character-class.js"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"@eslint-community/eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"@eslint-community/regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\nconst astUtils = require(\"./utils/ast-utils.js\");\nconst { isValidWithUnicodeFlag } = require(\"./utils/regular-expressions\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @typedef {import('@eslint-community/regexpp').AST.Character} Character\n * @typedef {import('@eslint-community/regexpp').AST.CharacterClassElement} CharacterClassElement\n */\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<Character[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n\n    /** @type {Character[]} */\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min);\n                yield seq;\n                seq = [node.max];\n                break;\n\n            case \"CharacterSet\":\n            case \"CharacterClass\": // [[]] nesting character class\n            case \"ClassStringDisjunction\": // \\q{...}\n            case \"ExpressionCharacterClass\": // [A--B]\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\n\n/**\n * Checks whether the given character node is a Unicode code point escape or not.\n * @param {Character} char the character node to check.\n * @returns {boolean} `true` if the character node is a Unicode code point escape.\n */\nfunction isUnicodeCodePointEscape(char) {\n    return /^\\\\u\\{[\\da-f]+\\}$/iu.test(char.raw);\n}\n\n/**\n * Each function returns `true` if it detects that kind of problem.\n * @type {Record<string, (chars: Character[]) => boolean>}\n */\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => {\n            if (i === 0) {\n                return false;\n            }\n            const c1 = chars[i - 1];\n\n            return (\n                isSurrogatePair(c1.value, c.value) &&\n                !isUnicodeCodePointEscape(c1) &&\n                !isUnicodeCodePointEscape(c)\n            );\n        });\n    },\n\n    surrogatePair(chars) {\n        return chars.some((c, i) => {\n            if (i === 0) {\n                return false;\n            }\n            const c1 = chars[i - 1];\n\n            return (\n                isSurrogatePair(c1.value, c.value) &&\n                (\n                    isUnicodeCodePointEscape(c1) ||\n                    isUnicodeCodePointEscape(c)\n                )\n            );\n        });\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c.value) &&\n            !isCombiningCharacter(chars[i - 1].value)\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c.value) &&\n            !isEmojiModifier(chars[i - 1].value)\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c.value) &&\n            isRegionalIndicatorSymbol(chars[i - 1].value)\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c.value === 0x200d &&\n            chars[i - 1].value !== 0x200d &&\n            chars[i + 1].value !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow characters which are made with multiple code points in character class syntax\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-misleading-character-class\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            surrogatePair: \"Unexpected surrogate pair in character class.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\",\n            suggestUnicodeFlag: \"Add unicode 'u' flag to regex.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @param {Function} unicodeFixer Fixer for missing \"u\" flag.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags, unicodeFixer) {\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    {\n                        unicode: flags.includes(\"u\"),\n                        unicodeSets: flags.includes(\"v\")\n                    }\n                );\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            const foundKinds = new Set();\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            if (hasCharacterSequence[kind](chars)) {\n                                foundKinds.add(kind);\n                            }\n                        }\n                    }\n                }\n            });\n\n            for (const kind of foundKinds) {\n                let suggest;\n\n                if (kind === \"surrogatePairWithoutUFlag\") {\n                    suggest = [{\n                        messageId: \"suggestUnicodeFlag\",\n                        fix: unicodeFixer\n                    }];\n                }\n\n                context.report({\n                    node,\n                    messageId: kind,\n                    suggest\n                });\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags, fixer => {\n                    if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, node.regex.pattern)) {\n                        return null;\n                    }\n\n                    return fixer.insertTextAfter(node, \"u\");\n                });\n            },\n            \"Program\"(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node: refNode } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = refNode.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(refNode, pattern, flags || \"\", fixer => {\n\n                            if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, pattern)) {\n                                return null;\n                            }\n\n                            if (refNode.arguments.length === 1) {\n                                const penultimateToken = sourceCode.getLastToken(refNode, { skip: 1 }); // skip closing parenthesis\n\n                                return fixer.insertTextAfter(\n                                    penultimateToken,\n                                    astUtils.isCommaToken(penultimateToken)\n                                        ? ' \"u\",'\n                                        : ', \"u\"'\n                                );\n                            }\n\n                            if ((flagsNode.type === \"Literal\" && typeof flagsNode.value === \"string\") || flagsNode.type === \"TemplateLiteral\") {\n                                const range = [flagsNode.range[0], flagsNode.range[1] - 1];\n\n                                return fixer.insertTextAfterRange(range, \"u\");\n                            }\n\n                            return null;\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}