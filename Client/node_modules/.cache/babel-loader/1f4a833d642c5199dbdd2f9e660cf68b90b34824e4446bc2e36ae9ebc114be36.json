{"ast":null,"code":"/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Enforce `return` statements in getters\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/getter-return\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected to return a value in {{name}}.\",\n      expectedAlways: \"Expected {{name}} to always return a value.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    const sourceCode = context.sourceCode;\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null,\n      currentSegments: []\n    };\n\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && isAnySegmentReachable(funcInfo.currentSegments)) {\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n\n    /**\n     * Checks whether a node means a getter function.\n     * @param {ASTNode} node a node to check.\n     * @returns {boolean} if node means a getter, return true; else return false.\n     */\n    function isGetter(node) {\n      const parent = node.parent;\n      if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n        if (parent.kind === \"get\") {\n          return true;\n        }\n        if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n          // Object.defineProperty() or Reflect.defineProperty()\n          if (parent.parent.parent.type === \"CallExpression\") {\n            const callNode = parent.parent.parent.callee;\n            if (astUtils.isSpecificMemberAccess(callNode, \"Object\", \"defineProperty\") || astUtils.isSpecificMemberAccess(callNode, \"Reflect\", \"defineProperty\")) {\n              return true;\n            }\n          }\n\n          // Object.defineProperties() or Object.create()\n          if (parent.parent.parent.type === \"Property\" && parent.parent.parent.parent.type === \"ObjectExpression\" && parent.parent.parent.parent.parent.type === \"CallExpression\") {\n            const callNode = parent.parent.parent.parent.parent.callee;\n            return astUtils.isSpecificMemberAccess(callNode, \"Object\", \"defineProperties\") || astUtils.isSpecificMemberAccess(callNode, \"Object\", \"create\");\n          }\n        }\n      }\n      return false;\n    }\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: isGetter(node),\n          node,\n          currentSegments: new Set()\n        };\n      },\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      onCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true;\n\n          // if allowImplicit: false, should also check node.argument\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expected\",\n              data: {\n                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n              }\n            });\n          }\n        }\n      },\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","TARGET_NODE_TYPE","isAnySegmentReachable","segments","segment","reachable","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","allowImplicit","default","additionalProperties","messages","expected","expectedAlways","create","context","options","sourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","node","currentSegments","checkLastSegment","report","loc","getFunctionHeadLoc","messageId","data","name","getFunctionNameWithKind","isGetter","parent","test","body","kind","getStaticPropertyName","callNode","callee","isSpecificMemberAccess","onCodePathStart","Set","onCodePathEnd","onUnreachableCodePathSegmentStart","add","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentStart","onCodePathSegmentEnd","ReturnStatement","argument"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/getter-return.js"],"sourcesContent":["/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Enforce `return` statements in getters\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/getter-return\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expected: \"Expected to return a value in {{name}}.\",\n            expectedAlways: \"Expected {{name}} to always return a value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n        const sourceCode = context.sourceCode;\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null,\n            currentSegments: []\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                isAnySegmentReachable(funcInfo.currentSegments)\n            ) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks whether a node means a getter function.\n         * @param {ASTNode} node a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty() or Reflect.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\") {\n                        const callNode = parent.parent.parent.callee;\n\n                        if (astUtils.isSpecificMemberAccess(callNode, \"Object\", \"defineProperty\") ||\n                            astUtils.isSpecificMemberAccess(callNode, \"Reflect\", \"defineProperty\")) {\n                            return true;\n                        }\n                    }\n\n                    // Object.defineProperties() or Object.create()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\") {\n                        const callNode = parent.parent.parent.parent.parent.callee;\n\n                        return astUtils.isSpecificMemberAccess(callNode, \"Object\", \"defineProperties\") ||\n                               astUtils.isSpecificMemberAccess(callNode, \"Object\", \"create\");\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node,\n                    currentSegments: new Set()\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expected\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}