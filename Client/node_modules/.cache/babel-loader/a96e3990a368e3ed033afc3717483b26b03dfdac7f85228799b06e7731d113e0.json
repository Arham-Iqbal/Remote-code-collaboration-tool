{"ast":null,"code":"/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent brace style for blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/brace-style\"\n    },\n    schema: [{\n      enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n      sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n      blockSameLine: \"Statement inside of curly braces should be on next line.\",\n      nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n      singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n      sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n    }\n  },\n  create(context) {\n    const style = context.options[0] || \"1tbs\",\n      params = context.options[1] || {},\n      sourceCode = context.sourceCode;\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Fixes a place where a newline unexpectedly appears\n     * @param {Token} firstToken The token before the unexpected newline\n     * @param {Token} secondToken The token after the unexpected newline\n     * @returns {Function} A fixer function to remove the newlines between the tokens\n     */\n    function removeNewlineBetween(firstToken, secondToken) {\n      const textRange = [firstToken.range[1], secondToken.range[0]];\n      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n      // Don't do a fix if there is a comment between the tokens\n      if (textBetween.trim()) {\n        return null;\n      }\n      return fixer => fixer.replaceTextRange(textRange, \" \");\n    }\n\n    /**\n     * Validates a pair of curly brackets based on the user's config\n     * @param {Token} openingCurly The opening curly bracket\n     * @param {Token} closingCurly The closing curly bracket\n     * @returns {void}\n     */\n    function validateCurlyPair(openingCurly, closingCurly) {\n      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n      if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n        context.report({\n          node: openingCurly,\n          messageId: \"nextLineOpen\",\n          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n        });\n      }\n      if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"sameLineOpen\",\n          fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n        });\n      }\n      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"blockSameLine\",\n          fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n        });\n      }\n      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n        context.report({\n          node: closingCurly,\n          messageId: \"singleLineClose\",\n          fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n        });\n      }\n    }\n\n    /**\n     * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n     * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n     * @returns {void}\n     */\n    function validateCurlyBeforeKeyword(curlyToken) {\n      const keywordToken = sourceCode.getTokenAfter(curlyToken);\n      if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"nextLineClose\",\n          fix: removeNewlineBetween(curlyToken, keywordToken)\n        });\n      }\n      if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"sameLineClose\",\n          fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n        });\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      BlockStatement(node) {\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n        }\n      },\n      StaticBlock(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node, {\n          skip: 1\n        }),\n        // skip the `static` token\n        sourceCode.getLastToken(node));\n      },\n      ClassBody(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n      },\n      SwitchStatement(node) {\n        const closingCurly = sourceCode.getLastToken(node);\n        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n        validateCurlyPair(openingCurly, closingCurly);\n      },\n      IfStatement(node) {\n        if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n          // Handle the keyword after the `if` block (before `else`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n        }\n      },\n      TryStatement(node) {\n        // Handle the keyword after the `try` block (before `catch` or `finally`)\n        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n        if (node.handler && node.finalizer) {\n          // Handle the keyword after the `catch` block (before `finally`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","schema","enum","properties","allowSingleLine","default","additionalProperties","fixable","messages","nextLineOpen","sameLineOpen","blockSameLine","nextLineClose","singleLineClose","sameLineClose","create","context","style","options","params","sourceCode","removeNewlineBetween","firstToken","secondToken","textRange","range","textBetween","text","slice","trim","fixer","replaceTextRange","validateCurlyPair","openingCurly","closingCurly","tokenBeforeOpeningCurly","getTokenBefore","tokenAfterOpeningCurly","getTokenAfter","tokenBeforeClosingCurly","singleLineException","isTokenOnSameLine","report","node","messageId","fix","insertTextBefore","insertTextAfter","validateCurlyBeforeKeyword","curlyToken","keywordToken","BlockStatement","STATEMENT_LIST_PARENTS","has","parent","getFirstToken","getLastToken","StaticBlock","skip","ClassBody","SwitchStatement","cases","length","IfStatement","consequent","alternate","TryStatement","block","handler","finalizer","body"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/brace-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent brace style for blocks\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/brace-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Fixes a place where a newline unexpectedly appears\n         * @param {Token} firstToken The token before the unexpected newline\n         * @param {Token} secondToken The token after the unexpected newline\n         * @returns {Function} A fixer function to remove the newlines between the tokens\n         */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n         * Validates a pair of curly brackets based on the user's config\n         * @param {Token} openingCurly The opening curly bracket\n         * @param {Token} closingCurly The closing curly bracket\n         * @returns {void}\n         */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"nextLineOpen\",\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"sameLineOpen\",\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"blockSameLine\",\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    messageId: \"singleLineClose\",\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n         * @returns {void}\n         */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"nextLineClose\",\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"sameLineClose\",\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            StaticBlock(node) {\n                validateCurlyPair(\n                    sourceCode.getFirstToken(node, { skip: 1 }), // skip the `static` token\n                    sourceCode.getLastToken(node)\n                );\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}