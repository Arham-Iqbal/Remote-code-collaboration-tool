{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce camelcase naming convention\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/camelcase\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImports: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        },\n        allow: {\n          type: \"array\",\n          items: [{\n            type: \"string\"\n          }],\n          minItems: 0,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\n      notCamelCasePrivate: \"#{{name}} is not in camel case.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const properties = options.properties === \"never\" ? \"never\" : \"always\";\n    const ignoreDestructuring = options.ignoreDestructuring;\n    const ignoreImports = options.ignoreImports;\n    const ignoreGlobals = options.ignoreGlobals;\n    const allow = options.allow || [];\n    const sourceCode = context.sourceCode;\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n    const reported = new Set();\n\n    /**\n     * Checks if a string contains an underscore and isn't all upper-case\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is underscored\n     * @private\n     */\n    function isUnderscored(name) {\n      const nameBody = name.replace(/^_+|_+$/gu, \"\");\n\n      // if there's an underscore, it might be A_CONSTANT, which is okay\n      return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\n    }\n\n    /**\n     * Checks if a string match the ignore list\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is ignored\n     * @private\n     */\n    function isAllowed(name) {\n      return allow.some(entry => name === entry || name.match(new RegExp(entry, \"u\")));\n    }\n\n    /**\n     * Checks if a given name is good or not.\n     * @param {string} name The name to check.\n     * @returns {boolean} `true` if the name is good.\n     * @private\n     */\n    function isGoodName(name) {\n      return !isUnderscored(name) || isAllowed(name);\n    }\n\n    /**\n     * Checks if a given identifier reference or member expression is an assignment\n     * target.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is an assignment target.\n     */\n    function isAssignmentTarget(node) {\n      const parent = node.parent;\n      switch (parent.type) {\n        case \"AssignmentExpression\":\n        case \"AssignmentPattern\":\n          return parent.left === node;\n        case \"Property\":\n          return parent.parent.type === \"ObjectPattern\" && parent.value === node;\n        case \"ArrayPattern\":\n        case \"RestElement\":\n          return true;\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Checks if a given binding identifier uses the original name as-is.\n     * - If it's in object destructuring or object expression, the original name is its property name.\n     * - If it's in import declaration, the original name is its exported name.\n     * @param {ASTNode} node The `Identifier` node to check.\n     * @returns {boolean} `true` if the identifier uses the original name as-is.\n     */\n    function equalsToOriginalName(node) {\n      const localName = node.name;\n      const valueNode = node.parent.type === \"AssignmentPattern\" ? node.parent : node;\n      const parent = valueNode.parent;\n      switch (parent.type) {\n        case \"Property\":\n          return (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") && parent.value === valueNode && !parent.computed && parent.key.type === \"Identifier\" && parent.key.name === localName;\n        case \"ImportSpecifier\":\n          return parent.local === node && astUtils.getModuleExportName(parent.imported) === localName;\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n    function report(node) {\n      if (reported.has(node.range[0])) {\n        return;\n      }\n      reported.add(node.range[0]);\n\n      // Report it.\n      context.report({\n        node,\n        messageId: node.type === \"PrivateIdentifier\" ? \"notCamelCasePrivate\" : \"notCamelCase\",\n        data: {\n          name: node.name\n        }\n      });\n    }\n\n    /**\n     * Reports an identifier reference or a binding identifier.\n     * @param {ASTNode} node The `Identifier` node to report.\n     * @returns {void}\n     */\n    function reportReferenceId(node) {\n      /*\n       * For backward compatibility, if it's in callings then ignore it.\n       * Not sure why it is.\n       */\n      if (node.parent.type === \"CallExpression\" || node.parent.type === \"NewExpression\") {\n        return;\n      }\n\n      /*\n       * For backward compatibility, if it's a default value of\n       * destructuring/parameters then ignore it.\n       * Not sure why it is.\n       */\n      if (node.parent.type === \"AssignmentPattern\" && node.parent.right === node) {\n        return;\n      }\n\n      /*\n       * The `ignoreDestructuring` flag skips the identifiers that uses\n       * the property name as-is.\n       */\n      if (ignoreDestructuring && equalsToOriginalName(node)) {\n        return;\n      }\n      report(node);\n    }\n    return {\n      // Report camelcase of global variable references ------------------\n      Program(node) {\n        const scope = sourceCode.getScope(node);\n        if (!ignoreGlobals) {\n          // Defined globals in config files or directive comments.\n          for (const variable of scope.variables) {\n            if (variable.identifiers.length > 0 || isGoodName(variable.name)) {\n              continue;\n            }\n            for (const reference of variable.references) {\n              /*\n               * For backward compatibility, this rule reports read-only\n               * references as well.\n               */\n              reportReferenceId(reference.identifier);\n            }\n          }\n        }\n\n        // Undefined globals.\n        for (const reference of scope.through) {\n          const id = reference.identifier;\n          if (isGoodName(id.name)) {\n            continue;\n          }\n\n          /*\n           * For backward compatibility, this rule reports read-only\n           * references as well.\n           */\n          reportReferenceId(id);\n        }\n      },\n      // Report camelcase of declared variables --------------------------\n      [[\"VariableDeclaration\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\", \"ClassDeclaration\", \"ClassExpression\", \"CatchClause\"]](node) {\n        for (const variable of sourceCode.getDeclaredVariables(node)) {\n          if (isGoodName(variable.name)) {\n            continue;\n          }\n          const id = variable.identifiers[0];\n\n          // Report declaration.\n          if (!(ignoreDestructuring && equalsToOriginalName(id))) {\n            report(id);\n          }\n\n          /*\n           * For backward compatibility, report references as well.\n           * It looks unnecessary because declarations are reported.\n           */\n          for (const reference of variable.references) {\n            if (reference.init) {\n              continue; // Skip the write references of initializers.\n            }\n            reportReferenceId(reference.identifier);\n          }\n        }\n      },\n      // Report camelcase in properties ----------------------------------\n      [[\"ObjectExpression > Property[computed!=true] > Identifier.key\", \"MethodDefinition[computed!=true] > Identifier.key\", \"PropertyDefinition[computed!=true] > Identifier.key\", \"MethodDefinition > PrivateIdentifier.key\", \"PropertyDefinition > PrivateIdentifier.key\"]](node) {\n        if (properties === \"never\" || isGoodName(node.name)) {\n          return;\n        }\n        report(node);\n      },\n      \"MemberExpression[computed!=true] > Identifier.property\"(node) {\n        if (properties === \"never\" || !isAssignmentTarget(node.parent) ||\n        // ← ignore read-only references.\n        isGoodName(node.name)) {\n          return;\n        }\n        report(node);\n      },\n      // Report camelcase in import --------------------------------------\n      ImportDeclaration(node) {\n        for (const variable of sourceCode.getDeclaredVariables(node)) {\n          if (isGoodName(variable.name)) {\n            continue;\n          }\n          const id = variable.identifiers[0];\n\n          // Report declaration.\n          if (!(ignoreImports && equalsToOriginalName(id))) {\n            report(id);\n          }\n\n          /*\n           * For backward compatibility, report references as well.\n           * It looks unnecessary because declarations are reported.\n           */\n          for (const reference of variable.references) {\n            reportReferenceId(reference.identifier);\n          }\n        }\n      },\n      // Report camelcase in re-export -----------------------------------\n      [[\"ExportAllDeclaration > Identifier.exported\", \"ExportSpecifier > Identifier.exported\"]](node) {\n        if (isGoodName(node.name)) {\n          return;\n        }\n        report(node);\n      },\n      // Report camelcase in labels --------------------------------------\n      [[\"LabeledStatement > Identifier.label\",\n      /*\n       * For backward compatibility, report references as well.\n       * It looks unnecessary because declarations are reported.\n       */\n      \"BreakStatement > Identifier.label\", \"ContinueStatement > Identifier.label\"]](node) {\n        if (isGoodName(node.name)) {\n          return;\n        }\n        report(node);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","ignoreDestructuring","default","ignoreImports","ignoreGlobals","enum","allow","items","minItems","uniqueItems","additionalProperties","messages","notCamelCase","notCamelCasePrivate","create","context","options","sourceCode","reported","Set","isUnderscored","name","nameBody","replace","includes","toUpperCase","isAllowed","some","entry","match","RegExp","isGoodName","isAssignmentTarget","node","parent","left","value","equalsToOriginalName","localName","valueNode","computed","key","local","getModuleExportName","imported","report","has","range","add","messageId","data","reportReferenceId","right","Program","scope","getScope","variable","variables","identifiers","length","reference","references","identifier","through","id","getDeclaredVariables","init","MemberExpression[computed!=true] > Identifier.property","ImportDeclaration"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/camelcase.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce camelcase naming convention\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreImports: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreGlobals: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: [\n                            {\n                                type: \"string\"\n                            }\n                        ],\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\n            notCamelCasePrivate: \"#{{name}} is not in camel case.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const properties = options.properties === \"never\" ? \"never\" : \"always\";\n        const ignoreDestructuring = options.ignoreDestructuring;\n        const ignoreImports = options.ignoreImports;\n        const ignoreGlobals = options.ignoreGlobals;\n        const allow = options.allow || [];\n        const sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = new Set();\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n            const nameBody = name.replace(/^_+|_+$/gu, \"\");\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.some(\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\n            );\n        }\n\n        /**\n         * Checks if a given name is good or not.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is good.\n         * @private\n         */\n        function isGoodName(name) {\n            return !isUnderscored(name) || isAllowed(name);\n        }\n\n        /**\n         * Checks if a given identifier reference or member expression is an assignment\n         * target.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is an assignment target.\n         */\n        function isAssignmentTarget(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    return parent.left === node;\n\n                case \"Property\":\n                    return (\n                        parent.parent.type === \"ObjectPattern\" &&\n                        parent.value === node\n                    );\n                case \"ArrayPattern\":\n                case \"RestElement\":\n                    return true;\n\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Checks if a given binding identifier uses the original name as-is.\n         * - If it's in object destructuring or object expression, the original name is its property name.\n         * - If it's in import declaration, the original name is its exported name.\n         * @param {ASTNode} node The `Identifier` node to check.\n         * @returns {boolean} `true` if the identifier uses the original name as-is.\n         */\n        function equalsToOriginalName(node) {\n            const localName = node.name;\n            const valueNode = node.parent.type === \"AssignmentPattern\"\n                ? node.parent\n                : node;\n            const parent = valueNode.parent;\n\n            switch (parent.type) {\n                case \"Property\":\n                    return (\n                        (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") &&\n                        parent.value === valueNode &&\n                        !parent.computed &&\n                        parent.key.type === \"Identifier\" &&\n                        parent.key.name === localName\n                    );\n\n                case \"ImportSpecifier\":\n                    return (\n                        parent.local === node &&\n                        astUtils.getModuleExportName(parent.imported) === localName\n                    );\n\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.has(node.range[0])) {\n                return;\n            }\n            reported.add(node.range[0]);\n\n            // Report it.\n            context.report({\n                node,\n                messageId: node.type === \"PrivateIdentifier\"\n                    ? \"notCamelCasePrivate\"\n                    : \"notCamelCase\",\n                data: { name: node.name }\n            });\n        }\n\n        /**\n         * Reports an identifier reference or a binding identifier.\n         * @param {ASTNode} node The `Identifier` node to report.\n         * @returns {void}\n         */\n        function reportReferenceId(node) {\n\n            /*\n             * For backward compatibility, if it's in callings then ignore it.\n             * Not sure why it is.\n             */\n            if (\n                node.parent.type === \"CallExpression\" ||\n                node.parent.type === \"NewExpression\"\n            ) {\n                return;\n            }\n\n            /*\n             * For backward compatibility, if it's a default value of\n             * destructuring/parameters then ignore it.\n             * Not sure why it is.\n             */\n            if (\n                node.parent.type === \"AssignmentPattern\" &&\n                node.parent.right === node\n            ) {\n                return;\n            }\n\n            /*\n             * The `ignoreDestructuring` flag skips the identifiers that uses\n             * the property name as-is.\n             */\n            if (ignoreDestructuring && equalsToOriginalName(node)) {\n                return;\n            }\n\n            report(node);\n        }\n\n        return {\n\n            // Report camelcase of global variable references ------------------\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n\n                if (!ignoreGlobals) {\n\n                    // Defined globals in config files or directive comments.\n                    for (const variable of scope.variables) {\n                        if (\n                            variable.identifiers.length > 0 ||\n                            isGoodName(variable.name)\n                        ) {\n                            continue;\n                        }\n                        for (const reference of variable.references) {\n\n                            /*\n                             * For backward compatibility, this rule reports read-only\n                             * references as well.\n                             */\n                            reportReferenceId(reference.identifier);\n                        }\n                    }\n                }\n\n                // Undefined globals.\n                for (const reference of scope.through) {\n                    const id = reference.identifier;\n\n                    if (isGoodName(id.name)) {\n                        continue;\n                    }\n\n                    /*\n                     * For backward compatibility, this rule reports read-only\n                     * references as well.\n                     */\n                    reportReferenceId(id);\n                }\n            },\n\n            // Report camelcase of declared variables --------------------------\n            [[\n                \"VariableDeclaration\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ArrowFunctionExpression\",\n                \"ClassDeclaration\",\n                \"ClassExpression\",\n                \"CatchClause\"\n            ]](node) {\n                for (const variable of sourceCode.getDeclaredVariables(node)) {\n                    if (isGoodName(variable.name)) {\n                        continue;\n                    }\n                    const id = variable.identifiers[0];\n\n                    // Report declaration.\n                    if (!(ignoreDestructuring && equalsToOriginalName(id))) {\n                        report(id);\n                    }\n\n                    /*\n                     * For backward compatibility, report references as well.\n                     * It looks unnecessary because declarations are reported.\n                     */\n                    for (const reference of variable.references) {\n                        if (reference.init) {\n                            continue; // Skip the write references of initializers.\n                        }\n                        reportReferenceId(reference.identifier);\n                    }\n                }\n            },\n\n            // Report camelcase in properties ----------------------------------\n            [[\n                \"ObjectExpression > Property[computed!=true] > Identifier.key\",\n                \"MethodDefinition[computed!=true] > Identifier.key\",\n                \"PropertyDefinition[computed!=true] > Identifier.key\",\n                \"MethodDefinition > PrivateIdentifier.key\",\n                \"PropertyDefinition > PrivateIdentifier.key\"\n            ]](node) {\n                if (properties === \"never\" || isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            },\n            \"MemberExpression[computed!=true] > Identifier.property\"(node) {\n                if (\n                    properties === \"never\" ||\n                    !isAssignmentTarget(node.parent) || // ← ignore read-only references.\n                    isGoodName(node.name)\n                ) {\n                    return;\n                }\n                report(node);\n            },\n\n            // Report camelcase in import --------------------------------------\n            ImportDeclaration(node) {\n                for (const variable of sourceCode.getDeclaredVariables(node)) {\n                    if (isGoodName(variable.name)) {\n                        continue;\n                    }\n                    const id = variable.identifiers[0];\n\n                    // Report declaration.\n                    if (!(ignoreImports && equalsToOriginalName(id))) {\n                        report(id);\n                    }\n\n                    /*\n                     * For backward compatibility, report references as well.\n                     * It looks unnecessary because declarations are reported.\n                     */\n                    for (const reference of variable.references) {\n                        reportReferenceId(reference.identifier);\n                    }\n                }\n            },\n\n            // Report camelcase in re-export -----------------------------------\n            [[\n                \"ExportAllDeclaration > Identifier.exported\",\n                \"ExportSpecifier > Identifier.exported\"\n            ]](node) {\n                if (isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            },\n\n            // Report camelcase in labels --------------------------------------\n            [[\n                \"LabeledStatement > Identifier.label\",\n\n                /*\n                 * For backward compatibility, report references as well.\n                 * It looks unnecessary because declarations are reported.\n                 */\n                \"BreakStatement > Identifier.label\",\n                \"ContinueStatement > Identifier.label\"\n            ]](node) {\n                if (isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}