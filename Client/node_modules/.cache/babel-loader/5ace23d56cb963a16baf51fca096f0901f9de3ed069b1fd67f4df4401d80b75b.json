{"ast":null,"code":"/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n  /**\n   * Creates a new instance.\n   * @param {Object} options Options for the function (see below).\n   * @param {string} options.id An identifier.\n   * @param {string} options.origin The type of code path origin.\n   * @param {CodePath|null} options.upper The code path of the upper function scope.\n   * @param {Function} options.onLooped A callback function to notify looping.\n   */\n  constructor({\n    id,\n    origin,\n    upper,\n    onLooped\n  }) {\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * The reason that this code path was started. May be \"program\",\n     * \"function\", \"class-field-initializer\", or \"class-static-block\".\n     * @type {string}\n     */\n    this.origin = origin;\n\n    /**\n     * The code path of the upper function scope.\n     * @type {CodePath|null}\n     */\n    this.upper = upper;\n\n    /**\n     * The code paths of nested function scopes.\n     * @type {CodePath[]}\n     */\n    this.childCodePaths = [];\n\n    // Initializes internal state.\n    Object.defineProperty(this, \"internal\", {\n      value: new CodePathState(new IdGenerator(`${id}_`), onLooped)\n    });\n\n    // Adds this into `childCodePaths` of `upper`.\n    if (upper) {\n      upper.childCodePaths.push(this);\n    }\n  }\n\n  /**\n   * Gets the state of a given code path.\n   * @param {CodePath} codePath A code path to get.\n   * @returns {CodePathState} The state of the code path.\n   */\n  static getState(codePath) {\n    return codePath.internal;\n  }\n\n  /**\n   * The initial code path segment. This is the segment that is at the head\n   * of the code path.\n   * This is a passthrough to the underlying `CodePathState`.\n   * @type {CodePathSegment}\n   */\n  get initialSegment() {\n    return this.internal.initialSegment;\n  }\n\n  /**\n   * Final code path segments. These are the terminal (tail) segments in the\n   * code path, which is the combination of `returnedSegments` and `thrownSegments`.\n   * All segments in this array are reachable.\n   * This is a passthrough to the underlying `CodePathState`.\n   * @type {CodePathSegment[]}\n   */\n  get finalSegments() {\n    return this.internal.finalSegments;\n  }\n\n  /**\n   * Final code path segments that represent normal completion of the code path.\n   * For functions, this means both explicit `return` statements and implicit returns,\n   * such as the last reachable segment in a function that does not have an\n   * explicit `return` as this implicitly returns `undefined`. For scripts,\n   * modules, class field initializers, and class static blocks, this means\n   * all lines of code have been executed.\n   * These segments are also present in `finalSegments`.\n   * This is a passthrough to the underlying `CodePathState`.\n   * @type {CodePathSegment[]}\n   */\n  get returnedSegments() {\n    return this.internal.returnedForkContext;\n  }\n\n  /**\n   * Final code path segments that represent `throw` statements.\n   * This is a passthrough to the underlying `CodePathState`.\n   * These segments are also present in `finalSegments`.\n   * @type {CodePathSegment[]}\n   */\n  get thrownSegments() {\n    return this.internal.thrownForkContext;\n  }\n\n  /**\n   * Tracks the traversal of the code path through each segment. This array\n   * starts empty and segments are added or removed as the code path is\n   * traversed. This array always ends up empty at the end of a code path\n   * traversal. The `CodePathState` uses this to track its progress through\n   * the code path.\n   * This is a passthrough to the underlying `CodePathState`.\n   * @type {CodePathSegment[]}\n   * @deprecated\n   */\n  get currentSegments() {\n    return this.internal.currentSegments;\n  }\n\n  /**\n   * Traverses all segments in this code path.\n   *\n   *     codePath.traverseSegments((segment, controller) => {\n   *         // do something.\n   *     });\n   *\n   * This method enumerates segments in order from the head.\n   *\n   * The `controller` argument has two methods:\n   *\n   * - `skip()` - skips the following segments in this branch\n   * - `break()` - skips all following segments in the traversal\n   *\n   * A note on the parameters: the `options` argument is optional. This means\n   * the first argument might be an options object or the callback function.\n   * @param {Object} [optionsOrCallback] Optional first and last segments to traverse.\n   * @param {CodePathSegment} [optionsOrCallback.first] The first segment to traverse.\n   * @param {CodePathSegment} [optionsOrCallback.last] The last segment to traverse.\n   * @param {Function} callback A callback function.\n   * @returns {void}\n   */\n  traverseSegments(optionsOrCallback, callback) {\n    // normalize the arguments into a callback and options\n    let resolvedOptions;\n    let resolvedCallback;\n    if (typeof optionsOrCallback === \"function\") {\n      resolvedCallback = optionsOrCallback;\n      resolvedOptions = {};\n    } else {\n      resolvedOptions = optionsOrCallback || {};\n      resolvedCallback = callback;\n    }\n\n    // determine where to start traversing from based on the options\n    const startSegment = resolvedOptions.first || this.internal.initialSegment;\n    const lastSegment = resolvedOptions.last;\n\n    // set up initial location information\n    let record = null;\n    let index = 0;\n    let end = 0;\n    let segment = null;\n\n    // segments that have already been visited during traversal\n    const visited = new Set();\n\n    // tracks the traversal steps\n    const stack = [[startSegment, 0]];\n\n    // tracks the last skipped segment during traversal\n    let skippedSegment = null;\n\n    // indicates if we exited early from the traversal\n    let broken = false;\n\n    /**\n     * Maintains traversal state.\n     */\n    const controller = {\n      /**\n       * Skip the following segments in this branch.\n       * @returns {void}\n       */\n      skip() {\n        if (stack.length <= 1) {\n          broken = true;\n        } else {\n          skippedSegment = stack[stack.length - 2][0];\n        }\n      },\n      /**\n       * Stop traversal completely - do not traverse to any\n       * other segments.\n       * @returns {void}\n       */\n      break() {\n        broken = true;\n      }\n    };\n\n    /**\n     * Checks if a given previous segment has been visited.\n     * @param {CodePathSegment} prevSegment A previous segment to check.\n     * @returns {boolean} `true` if the segment has been visited.\n     */\n    function isVisited(prevSegment) {\n      return visited.has(prevSegment) || segment.isLoopedPrevSegment(prevSegment);\n    }\n\n    // the traversal\n    while (stack.length > 0) {\n      /*\n       * This isn't a pure stack. We use the top record all the time\n       * but don't always pop it off. The record is popped only if\n       * one of the following is true:\n       *\n       * 1) We have already visited the segment.\n       * 2) We have not visited *all* of the previous segments.\n       * 3) We have traversed past the available next segments.\n       *\n       * Otherwise, we just read the value and sometimes modify the\n       * record as we traverse.\n       */\n      record = stack[stack.length - 1];\n      segment = record[0];\n      index = record[1];\n      if (index === 0) {\n        // Skip if this segment has been visited already.\n        if (visited.has(segment)) {\n          stack.pop();\n          continue;\n        }\n\n        // Skip if all previous segments have not been visited.\n        if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {\n          stack.pop();\n          continue;\n        }\n\n        // Reset the skipping flag if all branches have been skipped.\n        if (skippedSegment && segment.prevSegments.includes(skippedSegment)) {\n          skippedSegment = null;\n        }\n        visited.add(segment);\n\n        /*\n         * If the most recent segment hasn't been skipped, then we call\n         * the callback, passing in the segment and the controller.\n         */\n        if (!skippedSegment) {\n          resolvedCallback.call(this, segment, controller);\n\n          // exit if we're at the last segment\n          if (segment === lastSegment) {\n            controller.skip();\n          }\n\n          /*\n           * If the previous statement was executed, or if the callback\n           * called a method on the controller, we might need to exit the\n           * loop, so check for that and break accordingly.\n           */\n          if (broken) {\n            break;\n          }\n        }\n      }\n\n      // Update the stack.\n      end = segment.nextSegments.length - 1;\n      if (index < end) {\n        /*\n         * If we haven't yet visited all of the next segments, update\n         * the current top record on the stack to the next index to visit\n         * and then push a record for the current segment on top.\n         *\n         * Setting the current top record's index lets us know how many\n         * times we've been here and ensures that the segment won't be\n         * reprocessed (because we only process segments with an index\n         * of 0).\n         */\n        record[1] += 1;\n        stack.push([segment.nextSegments[index], 0]);\n      } else if (index === end) {\n        /*\n         * If we are at the last next segment, then reset the top record\n         * in the stack to next segment and set its index to 0 so it will\n         * be processed next.\n         */\n        record[0] = segment.nextSegments[index];\n        record[1] = 0;\n      } else {\n        /*\n         * If index > end, that means we have no more segments that need\n         * processing. So, we pop that record off of the stack in order to\n         * continue traversing at the next level up.\n         */\n        stack.pop();\n      }\n    }\n  }\n}\nmodule.exports = CodePath;","map":{"version":3,"names":["CodePathState","require","IdGenerator","CodePath","constructor","id","origin","upper","onLooped","childCodePaths","Object","defineProperty","value","push","getState","codePath","internal","initialSegment","finalSegments","returnedSegments","returnedForkContext","thrownSegments","thrownForkContext","currentSegments","traverseSegments","optionsOrCallback","callback","resolvedOptions","resolvedCallback","startSegment","first","lastSegment","last","record","index","end","segment","visited","Set","stack","skippedSegment","broken","controller","skip","length","break","isVisited","prevSegment","has","isLoopedPrevSegment","pop","prevSegments","every","includes","add","call","nextSegments","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/code-path-analysis/code-path.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} options Options for the function (see below).\n     * @param {string} options.id An identifier.\n     * @param {string} options.origin The type of code path origin.\n     * @param {CodePath|null} options.upper The code path of the upper function scope.\n     * @param {Function} options.onLooped A callback function to notify looping.\n     */\n    constructor({ id, origin, upper, onLooped }) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The reason that this code path was started. May be \"program\",\n         * \"function\", \"class-field-initializer\", or \"class-static-block\".\n         * @type {string}\n         */\n        this.origin = origin;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }\n        );\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     * @param {CodePath} codePath A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment. This is the segment that is at the head\n     * of the code path.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments. These are the terminal (tail) segments in the\n     * code path, which is the combination of `returnedSegments` and `thrownSegments`.\n     * All segments in this array are reachable.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments that represent normal completion of the code path.\n     * For functions, this means both explicit `return` statements and implicit returns,\n     * such as the last reachable segment in a function that does not have an\n     * explicit `return` as this implicitly returns `undefined`. For scripts,\n     * modules, class field initializers, and class static blocks, this means\n     * all lines of code have been executed.\n     * These segments are also present in `finalSegments`.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments that represent `throw` statements.\n     * This is a passthrough to the underlying `CodePathState`.\n     * These segments are also present in `finalSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Tracks the traversal of the code path through each segment. This array\n     * starts empty and segments are added or removed as the code path is\n     * traversed. This array always ends up empty at the end of a code path\n     * traversal. The `CodePathState` uses this to track its progress through\n     * the code path.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     * @deprecated\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments((segment, controller) => {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` argument has two methods:\n     *\n     * - `skip()` - skips the following segments in this branch\n     * - `break()` - skips all following segments in the traversal\n     *\n     * A note on the parameters: the `options` argument is optional. This means\n     * the first argument might be an options object or the callback function.\n     * @param {Object} [optionsOrCallback] Optional first and last segments to traverse.\n     * @param {CodePathSegment} [optionsOrCallback.first] The first segment to traverse.\n     * @param {CodePathSegment} [optionsOrCallback.last] The last segment to traverse.\n     * @param {Function} callback A callback function.\n     * @returns {void}\n     */\n    traverseSegments(optionsOrCallback, callback) {\n\n        // normalize the arguments into a callback and options\n        let resolvedOptions;\n        let resolvedCallback;\n\n        if (typeof optionsOrCallback === \"function\") {\n            resolvedCallback = optionsOrCallback;\n            resolvedOptions = {};\n        } else {\n            resolvedOptions = optionsOrCallback || {};\n            resolvedCallback = callback;\n        }\n\n        // determine where to start traversing from based on the options\n        const startSegment = resolvedOptions.first || this.internal.initialSegment;\n        const lastSegment = resolvedOptions.last;\n\n        // set up initial location information\n        let record = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n\n        // segments that have already been visited during traversal\n        const visited = new Set();\n\n        // tracks the traversal steps\n        const stack = [[startSegment, 0]];\n\n        // tracks the last skipped segment during traversal\n        let skippedSegment = null;\n\n        // indicates if we exited early from the traversal\n        let broken = false;\n\n        /**\n         * Maintains traversal state.\n         */\n        const controller = {\n\n            /**\n             * Skip the following segments in this branch.\n             * @returns {void}\n             */\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n\n            /**\n             * Stop traversal completely - do not traverse to any\n             * other segments.\n             * @returns {void}\n             */\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks if a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited.has(prevSegment) ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        // the traversal\n        while (stack.length > 0) {\n\n            /*\n             * This isn't a pure stack. We use the top record all the time\n             * but don't always pop it off. The record is popped only if\n             * one of the following is true:\n             *\n             * 1) We have already visited the segment.\n             * 2) We have not visited *all* of the previous segments.\n             * 3) We have traversed past the available next segments.\n             *\n             * Otherwise, we just read the value and sometimes modify the\n             * record as we traverse.\n             */\n            record = stack[stack.length - 1];\n            segment = record[0];\n            index = record[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited.has(segment)) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the skipping flag if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.includes(skippedSegment)) {\n                    skippedSegment = null;\n                }\n                visited.add(segment);\n\n                /*\n                 * If the most recent segment hasn't been skipped, then we call\n                 * the callback, passing in the segment and the controller.\n                 */\n                if (!skippedSegment) {\n                    resolvedCallback.call(this, segment, controller);\n\n                    // exit if we're at the last segment\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n\n                    /*\n                     * If the previous statement was executed, or if the callback\n                     * called a method on the controller, we might need to exit the\n                     * loop, so check for that and break accordingly.\n                     */\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n\n                /*\n                 * If we haven't yet visited all of the next segments, update\n                 * the current top record on the stack to the next index to visit\n                 * and then push a record for the current segment on top.\n                 *\n                 * Setting the current top record's index lets us know how many\n                 * times we've been here and ensures that the segment won't be\n                 * reprocessed (because we only process segments with an index\n                 * of 0).\n                 */\n                record[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n\n                /*\n                 * If we are at the last next segment, then reset the top record\n                 * in the stack to next segment and set its index to 0 so it will\n                 * be processed next.\n                 */\n                record[0] = segment.nextSegments[index];\n                record[1] = 0;\n            } else {\n\n                /*\n                 * If index > end, that means we have no more segments that need\n                 * processing. So, we pop that record off of the stack in order to\n                 * continue traversing at the next level up.\n                 */\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}