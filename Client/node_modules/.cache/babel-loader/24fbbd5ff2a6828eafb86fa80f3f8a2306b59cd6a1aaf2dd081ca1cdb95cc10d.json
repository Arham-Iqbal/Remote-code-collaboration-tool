{"ast":null,"code":"/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unnecessary nested blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-lone-blocks\"\n    },\n    schema: [],\n    messages: {\n      redundantBlock: \"Block is redundant.\",\n      redundantNestedBlock: \"Nested block is redundant.\"\n    }\n  },\n  create(context) {\n    // A stack of lone blocks to be checked for block-level bindings\n    const loneBlocks = [];\n    let ruleDef;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Reports a node as invalid.\n     * @param {ASTNode} node The node to be reported.\n     * @returns {void}\n     */\n    function report(node) {\n      const messageId = node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\" ? \"redundantNestedBlock\" : \"redundantBlock\";\n      context.report({\n        node,\n        messageId\n      });\n    }\n\n    /**\n     * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} True if the node is a lone block.\n     */\n    function isLoneBlock(node) {\n      return node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\" || node.parent.type === \"Program\" ||\n      // Don't report blocks in switch cases if the block is the only statement of the case.\n      node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n    }\n\n    /**\n     * Checks the enclosing block of the current node for block-level bindings,\n     * and \"marks it\" as valid if any.\n     * @param {ASTNode} node The current node to check.\n     * @returns {void}\n     */\n    function markLoneBlock(node) {\n      if (loneBlocks.length === 0) {\n        return;\n      }\n      const block = node.parent;\n      if (loneBlocks[loneBlocks.length - 1] === block) {\n        loneBlocks.pop();\n      }\n    }\n\n    // Default rule definition: report all lone blocks\n    ruleDef = {\n      BlockStatement(node) {\n        if (isLoneBlock(node)) {\n          report(node);\n        }\n      }\n    };\n\n    // ES6: report blocks without block-level bindings, or that's only child of another block\n    if (context.languageOptions.ecmaVersion >= 2015) {\n      ruleDef = {\n        BlockStatement(node) {\n          if (isLoneBlock(node)) {\n            loneBlocks.push(node);\n          }\n        },\n        \"BlockStatement:exit\"(node) {\n          if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n            loneBlocks.pop();\n            report(node);\n          } else if ((node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\") && node.parent.body.length === 1) {\n            report(node);\n          }\n        }\n      };\n      ruleDef.VariableDeclaration = function (node) {\n        if (node.kind === \"let\" || node.kind === \"const\") {\n          markLoneBlock(node);\n        }\n      };\n      ruleDef.FunctionDeclaration = function (node) {\n        if (sourceCode.getScope(node).isStrict) {\n          markLoneBlock(node);\n        }\n      };\n      ruleDef.ClassDeclaration = markLoneBlock;\n    }\n    return ruleDef;\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","redundantBlock","redundantNestedBlock","create","context","loneBlocks","ruleDef","sourceCode","report","node","messageId","parent","isLoneBlock","consequent","length","markLoneBlock","block","pop","BlockStatement","languageOptions","ecmaVersion","push","BlockStatement:exit","body","VariableDeclaration","kind","FunctionDeclaration","getScope","isStrict","ClassDeclaration"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-lone-blocks.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary nested blocks\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-lone-blocks\"\n        },\n\n        schema: [],\n\n        messages: {\n            redundantBlock: \"Block is redundant.\",\n            redundantNestedBlock: \"Nested block is redundant.\"\n        }\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node The node to be reported.\n         * @returns {void}\n         */\n        function report(node) {\n            const messageId = node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\"\n                ? \"redundantNestedBlock\"\n                : \"redundantBlock\";\n\n            context.report({\n                node,\n                messageId\n            });\n        }\n\n        /**\n         * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n         */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"StaticBlock\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @param {ASTNode} node The current node to check.\n         * @returns {void}\n         */\n        function markLoneBlock(node) {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = node.parent;\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings, or that's only child of another block\n        if (context.languageOptions.ecmaVersion >= 2015) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    } else if (\n                        (\n                            node.parent.type === \"BlockStatement\" ||\n                            node.parent.type === \"StaticBlock\"\n                        ) &&\n                        node.parent.body.length === 1\n                    ) {\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function(node) {\n                if (sourceCode.getScope(node).isStrict) {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}