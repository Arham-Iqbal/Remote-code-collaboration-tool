{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n  return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow the use of `eval()`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-eval\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndirect: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"eval can be harmful.\"\n    }\n  },\n  create(context) {\n    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);\n    const sourceCode = context.sourceCode;\n    let funcInfo = null;\n\n    /**\n     * Pushes a `this` scope (non-arrow function, class static block, or class field initializer) information to the stack.\n     * Top-level scopes are handled separately.\n     *\n     * This is used in order to check whether or not `this` binding is a\n     * reference to the global object.\n     * @param {ASTNode} node A node of the scope.\n     *      For functions, this is one of FunctionDeclaration, FunctionExpression.\n     *      For class static blocks, this is StaticBlock.\n     *      For class field initializers, this can be any node that is PropertyDefinition#value.\n     * @returns {void}\n     */\n    function enterThisScope(node) {\n      const strict = sourceCode.getScope(node).isStrict;\n      funcInfo = {\n        upper: funcInfo,\n        node,\n        strict,\n        isTopLevelOfScript: false,\n        defaultThis: false,\n        initialized: strict\n      };\n    }\n\n    /**\n     * Pops a variable scope from the stack.\n     * @returns {void}\n     */\n    function exitThisScope() {\n      funcInfo = funcInfo.upper;\n    }\n\n    /**\n     * Reports a given node.\n     *\n     * `node` is `Identifier` or `MemberExpression`.\n     * The parent of `node` might be `CallExpression`.\n     *\n     * The location of the report is always `eval` `Identifier` (or possibly\n     * `Literal`). The type of the report is `CallExpression` if the parent is\n     * `CallExpression`. Otherwise, it's the given node type.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      const parent = node.parent;\n      const locationNode = node.type === \"MemberExpression\" ? node.property : node;\n      const reportNode = parent.type === \"CallExpression\" && parent.callee === node ? parent : node;\n      context.report({\n        node: reportNode,\n        loc: locationNode.loc,\n        messageId: \"unexpected\"\n      });\n    }\n\n    /**\n     * Reports accesses of `eval` via the global object.\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n    function reportAccessingEvalViaGlobalObject(globalScope) {\n      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n        const name = candidatesOfGlobalObject[i];\n        const variable = astUtils.getVariableByName(globalScope, name);\n        if (!variable) {\n          continue;\n        }\n        const references = variable.references;\n        for (let j = 0; j < references.length; ++j) {\n          const identifier = references[j].identifier;\n          let node = identifier.parent;\n\n          // To detect code like `window.window.eval`.\n          while (isMember(node, name)) {\n            node = node.parent;\n          }\n\n          // Reports.\n          if (isMember(node, \"eval\")) {\n            report(node);\n          }\n        }\n      }\n    }\n\n    /**\n     * Reports all accesses of `eval` (excludes direct calls to eval).\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n    function reportAccessingEval(globalScope) {\n      const variable = astUtils.getVariableByName(globalScope, \"eval\");\n      if (!variable) {\n        return;\n      }\n      const references = variable.references;\n      for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n        const id = reference.identifier;\n        if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n          // Is accessing to eval (excludes direct calls to eval)\n          report(id);\n        }\n      }\n    }\n    if (allowIndirect) {\n      // Checks only direct calls to eval. It's simple!\n      return {\n        \"CallExpression:exit\"(node) {\n          const callee = node.callee;\n\n          /*\n           * Optional call (`eval?.(\"code\")`) is not direct eval.\n           * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n           * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n           */\n          if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n            report(callee);\n          }\n        }\n      };\n    }\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = node.callee;\n        if (astUtils.isSpecificId(callee, \"eval\")) {\n          report(callee);\n        }\n      },\n      Program(node) {\n        const scope = sourceCode.getScope(node),\n          features = context.parserOptions.ecmaFeatures || {},\n          strict = scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict,\n          isTopLevelOfScript = node.sourceType !== \"module\" && !features.globalReturn;\n        funcInfo = {\n          upper: null,\n          node,\n          strict,\n          isTopLevelOfScript,\n          defaultThis: true,\n          initialized: true\n        };\n      },\n      \"Program:exit\"(node) {\n        const globalScope = sourceCode.getScope(node);\n        exitThisScope();\n        reportAccessingEval(globalScope);\n        reportAccessingEvalViaGlobalObject(globalScope);\n      },\n      FunctionDeclaration: enterThisScope,\n      \"FunctionDeclaration:exit\": exitThisScope,\n      FunctionExpression: enterThisScope,\n      \"FunctionExpression:exit\": exitThisScope,\n      \"PropertyDefinition > *.value\": enterThisScope,\n      \"PropertyDefinition > *.value:exit\": exitThisScope,\n      StaticBlock: enterThisScope,\n      \"StaticBlock:exit\": exitThisScope,\n      ThisExpression(node) {\n        if (!isMember(node.parent, \"eval\")) {\n          return;\n        }\n\n        /*\n         * `this.eval` is found.\n         * Checks whether or not the value of `this` is the global object.\n         */\n        if (!funcInfo.initialized) {\n          funcInfo.initialized = true;\n          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);\n        }\n\n        // `this` at the top level of scripts always refers to the global object\n        if (funcInfo.isTopLevelOfScript || !funcInfo.strict && funcInfo.defaultThis) {\n          // `this.eval` is possible built-in `eval`.\n          report(node.parent);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","candidatesOfGlobalObject","Object","freeze","isMember","node","name","isSpecificMemberAccess","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowIndirect","default","additionalProperties","messages","unexpected","create","context","Boolean","options","sourceCode","funcInfo","enterThisScope","strict","getScope","isStrict","upper","isTopLevelOfScript","defaultThis","initialized","exitThisScope","report","parent","locationNode","property","reportNode","callee","loc","messageId","reportAccessingEvalViaGlobalObject","globalScope","i","length","variable","getVariableByName","references","j","identifier","reportAccessingEval","reference","id","isCallee","CallExpression:exit","optional","isSpecificId","Program","scope","features","parserOptions","ecmaFeatures","sourceType","globalReturn","childScopes","Program:exit","FunctionDeclaration","FunctionExpression","StaticBlock","ThisExpression","isDefaultThisBinding"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-eval.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\",\n    \"globalThis\"\n]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow the use of `eval()`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.sourceCode;\n        let funcInfo = null;\n\n        /**\n         * Pushes a `this` scope (non-arrow function, class static block, or class field initializer) information to the stack.\n         * Top-level scopes are handled separately.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         * @param {ASTNode} node A node of the scope.\n         *      For functions, this is one of FunctionDeclaration, FunctionExpression.\n         *      For class static blocks, this is StaticBlock.\n         *      For class field initializers, this can be any node that is PropertyDefinition#value.\n         * @returns {void}\n         */\n        function enterThisScope(node) {\n            const strict = sourceCode.getScope(node).isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                isTopLevelOfScript: false,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         * @returns {void}\n         */\n        function exitThisScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    /*\n                     * Optional call (`eval?.(\"code\")`) is not direct eval.\n                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n                     */\n                    if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (astUtils.isSpecificId(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = sourceCode.getScope(node),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict),\n                    isTopLevelOfScript = node.sourceType !== \"module\" && !features.globalReturn;\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    isTopLevelOfScript,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"(node) {\n                const globalScope = sourceCode.getScope(node);\n\n                exitThisScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterThisScope,\n            \"FunctionDeclaration:exit\": exitThisScope,\n            FunctionExpression: enterThisScope,\n            \"FunctionExpression:exit\": exitThisScope,\n            \"PropertyDefinition > *.value\": enterThisScope,\n            \"PropertyDefinition > *.value:exit\": exitThisScope,\n            StaticBlock: enterThisScope,\n            \"StaticBlock:exit\": exitThisScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                // `this` at the top level of scripts always refers to the global object\n                if (funcInfo.isTopLevelOfScript || (!funcInfo.strict && funcInfo.defaultThis)) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}