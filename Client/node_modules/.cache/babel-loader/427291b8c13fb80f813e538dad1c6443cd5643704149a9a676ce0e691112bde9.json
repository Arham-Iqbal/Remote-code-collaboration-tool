{"ast":null,"code":"/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\nfunction isAssignmentTarget(node) {\n  const parent = node.parent;\n  return (\n    // normal assignment\n    parent.type === \"AssignmentExpression\" && parent.left === node ||\n    // destructuring\n    parent.type === \"ArrayPattern\" || parent.type === \"RestElement\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"AssignmentPattern\" && parent.left === node\n  );\n}\n\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\nfunction isRenamedImport(node) {\n  const parent = node.parent;\n  return parent.type === \"ImportSpecifier\" && parent.imported !== parent.local && parent.imported === node || parent.type === \"ExportSpecifier\" && parent.parent.source &&\n  // re-export\n  parent.local !== parent.exported && parent.local === node;\n}\n\n/**\n * Checks whether the given node is an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo;\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is in an ObjectPattern destructuring.\n */\nfunction isPropertyNameInDestructuring(node) {\n  const parent = node.parent;\n  return !parent.computed && parent.type === \"Property\" && parent.parent.type === \"ObjectPattern\" && parent.key === node;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow specified identifiers\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/id-denylist\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\"\n      },\n      uniqueItems: true\n    },\n    messages: {\n      restricted: \"Identifier '{{name}}' is restricted.\",\n      restrictedPrivate: \"Identifier '#{{name}}' is restricted.\"\n    }\n  },\n  create(context) {\n    const denyList = new Set(context.options);\n    const reportedNodes = new Set();\n    const sourceCode = context.sourceCode;\n    let globalScope;\n\n    /**\n     * Checks whether the given name is restricted.\n     * @param {string} name The name to check.\n     * @returns {boolean} `true` if the name is restricted.\n     * @private\n     */\n    function isRestricted(name) {\n      return denyList.has(name);\n    }\n\n    /**\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a reference to a global variable.\n     */\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n\n    /**\n     * Determines whether the given node should be checked.\n     * @param {ASTNode} node `Identifier` node.\n     * @returns {boolean} `true` if the node should be checked.\n     */\n    function shouldCheck(node) {\n      const parent = node.parent;\n\n      /*\n       * Member access has special rules for checking property names.\n       * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n       * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n       */\n      if (parent.type === \"MemberExpression\" && parent.property === node && !parent.computed) {\n        return isAssignmentTarget(parent);\n      }\n      return parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\" && !isRenamedImport(node) && !isPropertyNameInDestructuring(node) && !isReferenceToGlobalVariable(node);\n    }\n\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n    function report(node) {\n      /*\n       * We used the range instead of the node because it's possible\n       * for the same identifier to be represented by two different\n       * nodes, with the most clear example being shorthand properties:\n       * { foo }\n       * In this case, \"foo\" is represented by one node for the name\n       * and one for the value. The only way to know they are the same\n       * is to look at the range.\n       */\n      if (!reportedNodes.has(node.range.toString())) {\n        const isPrivate = node.type === \"PrivateIdentifier\";\n        context.report({\n          node,\n          messageId: isPrivate ? \"restrictedPrivate\" : \"restricted\",\n          data: {\n            name: node.name\n          }\n        });\n        reportedNodes.add(node.range.toString());\n      }\n    }\n    return {\n      Program(node) {\n        globalScope = sourceCode.getScope(node);\n      },\n      [[\"Identifier\", \"PrivateIdentifier\"]](node) {\n        if (isRestricted(node.name) && shouldCheck(node)) {\n          report(node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["isAssignmentTarget","node","parent","type","left","value","isRenamedImport","imported","local","source","exported","isPropertyNameInDestructuring","computed","key","module","exports","meta","docs","description","recommended","url","schema","items","uniqueItems","messages","restricted","restrictedPrivate","create","context","denyList","Set","options","reportedNodes","sourceCode","globalScope","isRestricted","name","has","isReferenceToGlobalVariable","variable","set","get","defs","length","references","some","ref","identifier","shouldCheck","property","report","range","toString","isPrivate","messageId","data","add","Program","getScope"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/id-denylist.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\nfunction isAssignmentTarget(node) {\n    const parent = node.parent;\n\n    return (\n\n        // normal assignment\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // destructuring\n        parent.type === \"ArrayPattern\" ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\nfunction isRenamedImport(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            parent.type === \"ImportSpecifier\" &&\n            parent.imported !== parent.local &&\n            parent.imported === node\n        ) ||\n        (\n            parent.type === \"ExportSpecifier\" &&\n            parent.parent.source && // re-export\n            parent.local !== parent.exported &&\n            parent.local === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node is an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo;\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is in an ObjectPattern destructuring.\n */\nfunction isPropertyNameInDestructuring(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            !parent.computed &&\n            parent.type === \"Property\" &&\n            parent.parent.type === \"ObjectPattern\" &&\n            parent.key === node\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified identifiers\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/id-denylist\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        messages: {\n            restricted: \"Identifier '{{name}}' is restricted.\",\n            restrictedPrivate: \"Identifier '#{{name}}' is restricted.\"\n        }\n    },\n\n    create(context) {\n\n        const denyList = new Set(context.options);\n        const reportedNodes = new Set();\n        const sourceCode = context.sourceCode;\n\n        let globalScope;\n\n        /**\n         * Checks whether the given name is restricted.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is restricted.\n         * @private\n         */\n        function isRestricted(name) {\n            return denyList.has(name);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether the given node should be checked.\n         * @param {ASTNode} node `Identifier` node.\n         * @returns {boolean} `true` if the node should be checked.\n         */\n        function shouldCheck(node) {\n            const parent = node.parent;\n\n            /*\n             * Member access has special rules for checking property names.\n             * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n             * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n             */\n            if (\n                parent.type === \"MemberExpression\" &&\n                parent.property === node &&\n                !parent.computed\n            ) {\n                return isAssignmentTarget(parent);\n            }\n\n            return (\n                parent.type !== \"CallExpression\" &&\n                parent.type !== \"NewExpression\" &&\n                !isRenamedImport(node) &&\n                !isPropertyNameInDestructuring(node) &&\n                !isReferenceToGlobalVariable(node)\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n\n            /*\n             * We used the range instead of the node because it's possible\n             * for the same identifier to be represented by two different\n             * nodes, with the most clear example being shorthand properties:\n             * { foo }\n             * In this case, \"foo\" is represented by one node for the name\n             * and one for the value. The only way to know they are the same\n             * is to look at the range.\n             */\n            if (!reportedNodes.has(node.range.toString())) {\n                const isPrivate = node.type === \"PrivateIdentifier\";\n\n                context.report({\n                    node,\n                    messageId: isPrivate ? \"restrictedPrivate\" : \"restricted\",\n                    data: {\n                        name: node.name\n                    }\n                });\n                reportedNodes.add(node.range.toString());\n            }\n        }\n\n        return {\n\n            Program(node) {\n                globalScope = sourceCode.getScope(node);\n            },\n\n            [[\n                \"Identifier\",\n                \"PrivateIdentifier\"\n            ]](node) {\n                if (isRestricted(node.name) && shouldCheck(node)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}