{"ast":null,"code":"/**\n * @fileoverview Flat config schema\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\n/*\n * Note: This can be removed in ESLint v9 because structuredClone is available globally\n * starting in Node.js v17.\n */\nconst structuredClone = require(\"@ungap/structured-clone\").default;\nconst {\n  normalizeSeverityToNumber\n} = require(\"../shared/severity\");\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef ObjectPropertySchema\n * @property {Function|string} merge The function or name of the function to call\n *      to merge multiple objects with this property.\n * @property {Function|string} validate The function or name of the function to call\n *      to validate the value of this property.\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleSeverities = new Map([[0, 0], [\"off\", 0], [1, 1], [\"warn\", 1], [2, 2], [\"error\", 2]]);\nconst globalVariablesValues = new Set([true, \"true\", \"writable\", \"writeable\", false, \"false\", \"readonly\", \"readable\", null, \"off\"]);\n\n/**\n * Check if a value is a non-null object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Check if a value is a non-null non-array object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null non-array object.\n */\nfunction isNonArrayObject(value) {\n  return isNonNullObject(value) && !Array.isArray(value);\n}\n\n/**\n * Check if a value is undefined.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is undefined.\n */\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n\n/**\n * Deeply merges two non-array objects.\n * @param {Object} first The base object.\n * @param {Object} second The overrides object.\n * @param {Map<string, Map<string, Object>>} [mergeMap] Maps the combination of first and second arguments to a merged result.\n * @returns {Object} An object with properties from both first and second.\n */\nfunction deepMerge(first, second, mergeMap = new Map()) {\n  let secondMergeMap = mergeMap.get(first);\n  if (secondMergeMap) {\n    const result = secondMergeMap.get(second);\n    if (result) {\n      // If this combination of first and second arguments has been already visited, return the previously created result.\n      return result;\n    }\n  } else {\n    secondMergeMap = new Map();\n    mergeMap.set(first, secondMergeMap);\n  }\n\n  /*\n   * First create a result object where properties from the second object\n   * overwrite properties from the first. This sets up a baseline to use\n   * later rather than needing to inspect and change every property\n   * individually.\n   */\n  const result = {\n    ...first,\n    ...second\n  };\n  delete result.__proto__; // eslint-disable-line no-proto -- don't merge own property \"__proto__\"\n\n  // Store the pending result for this combination of first and second arguments.\n  secondMergeMap.set(second, result);\n  for (const key of Object.keys(second)) {\n    // avoid hairy edge case\n    if (key === \"__proto__\" || !Object.prototype.propertyIsEnumerable.call(first, key)) {\n      continue;\n    }\n    const firstValue = first[key];\n    const secondValue = second[key];\n    if (isNonArrayObject(firstValue) && isNonArrayObject(secondValue)) {\n      result[key] = deepMerge(firstValue, secondValue, mergeMap);\n    } else if (isUndefined(secondValue)) {\n      result[key] = firstValue;\n    }\n  }\n  return result;\n}\n\n/**\n * Normalizes the rule options config for a given rule by ensuring that\n * it is an array and that the first item is 0, 1, or 2.\n * @param {Array|string|number} ruleOptions The rule options config.\n * @returns {Array} An array of rule options.\n */\nfunction normalizeRuleOptions(ruleOptions) {\n  const finalOptions = Array.isArray(ruleOptions) ? ruleOptions.slice(0) : [ruleOptions];\n  finalOptions[0] = ruleSeverities.get(finalOptions[0]);\n  return structuredClone(finalOptions);\n}\n\n//-----------------------------------------------------------------------------\n// Assertions\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when a rule's options are configured with an invalid type.\n */\nclass InvalidRuleOptionsError extends Error {\n  /**\n   * @param {string} ruleId Rule name being configured.\n   * @param {any} value The invalid value.\n   */\n  constructor(ruleId, value) {\n    super(`Key \"${ruleId}\": Expected severity of \"off\", 0, \"warn\", 1, \"error\", or 2.`);\n    this.messageTemplate = \"invalid-rule-options\";\n    this.messageData = {\n      ruleId,\n      value\n    };\n  }\n}\n\n/**\n * Validates that a value is a valid rule options entry.\n * @param {string} ruleId Rule name being configured.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {InvalidRuleOptionsError} If the value isn't a valid rule options.\n */\nfunction assertIsRuleOptions(ruleId, value) {\n  if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\n    throw new InvalidRuleOptionsError(ruleId, value);\n  }\n}\n\n/**\n * The error type when a rule's severity is invalid.\n */\nclass InvalidRuleSeverityError extends Error {\n  /**\n   * @param {string} ruleId Rule name being configured.\n   * @param {any} value The invalid value.\n   */\n  constructor(ruleId, value) {\n    super(`Key \"${ruleId}\": Expected severity of \"off\", 0, \"warn\", 1, \"error\", or 2.`);\n    this.messageTemplate = \"invalid-rule-severity\";\n    this.messageData = {\n      ruleId,\n      value\n    };\n  }\n}\n\n/**\n * Validates that a value is valid rule severity.\n * @param {string} ruleId Rule name being configured.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {InvalidRuleSeverityError} If the value isn't a valid rule severity.\n */\nfunction assertIsRuleSeverity(ruleId, value) {\n  const severity = ruleSeverities.get(value);\n  if (typeof severity === \"undefined\") {\n    throw new InvalidRuleSeverityError(ruleId, value);\n  }\n}\n\n/**\n * Validates that a given string is the form pluginName/objectName.\n * @param {string} value The string to check.\n * @returns {void}\n * @throws {TypeError} If the string isn't in the correct format.\n */\nfunction assertIsPluginMemberName(value) {\n  if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\n    throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\n  }\n}\n\n/**\n * Validates that a value is an object.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object.\n */\nfunction assertIsObject(value) {\n  if (!isNonNullObject(value)) {\n    throw new TypeError(\"Expected an object.\");\n  }\n}\n\n/**\n * The error type when there's an eslintrc-style options in a flat config.\n */\nclass IncompatibleKeyError extends Error {\n  /**\n   * @param {string} key The invalid key.\n   */\n  constructor(key) {\n    super(\"This appears to be in eslintrc format rather than flat config format.\");\n    this.messageTemplate = \"eslintrc-incompat\";\n    this.messageData = {\n      key\n    };\n  }\n}\n\n/**\n * The error type when there's an eslintrc-style plugins array found.\n */\nclass IncompatiblePluginsError extends Error {\n  /**\n   * Creates a new instance.\n   * @param {Array<string>} plugins The plugins array.\n   */\n  constructor(plugins) {\n    super(\"This appears to be in eslintrc format (array of strings) rather than flat config format (object).\");\n    this.messageTemplate = \"eslintrc-plugins\";\n    this.messageData = {\n      plugins\n    };\n  }\n}\n\n//-----------------------------------------------------------------------------\n// Low-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst booleanSchema = {\n  merge: \"replace\",\n  validate: \"boolean\"\n};\nconst ALLOWED_SEVERITIES = new Set([\"error\", \"warn\", \"off\", 2, 1, 0]);\n\n/** @type {ObjectPropertySchema} */\nconst disableDirectiveSeveritySchema = {\n  merge(first, second) {\n    const value = second === void 0 ? first : second;\n    if (typeof value === \"boolean\") {\n      return value ? \"warn\" : \"off\";\n    }\n    return normalizeSeverityToNumber(value);\n  },\n  validate(value) {\n    if (!(ALLOWED_SEVERITIES.has(value) || typeof value === \"boolean\")) {\n      throw new TypeError(\"Expected one of: \\\"error\\\", \\\"warn\\\", \\\"off\\\", 0, 1, 2, or a boolean.\");\n    }\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst deepObjectAssignSchema = {\n  merge(first = {}, second = {}) {\n    return deepMerge(first, second);\n  },\n  validate: \"object\"\n};\n\n//-----------------------------------------------------------------------------\n// High-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst globalsSchema = {\n  merge: \"assign\",\n  validate(value) {\n    assertIsObject(value);\n    for (const key of Object.keys(value)) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n      if (key !== key.trim()) {\n        throw new TypeError(`Global \"${key}\" has leading or trailing whitespace.`);\n      }\n      if (!globalVariablesValues.has(value[key])) {\n        throw new TypeError(`Key \"${key}\": Expected \"readonly\", \"writable\", or \"off\".`);\n      }\n    }\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst parserSchema = {\n  merge: \"replace\",\n  validate(value) {\n    if (!value || typeof value !== \"object\" || typeof value.parse !== \"function\" && typeof value.parseForESLint !== \"function\") {\n      throw new TypeError(\"Expected object with parse() or parseForESLint() method.\");\n    }\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst pluginsSchema = {\n  merge(first = {}, second = {}) {\n    const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\n    const result = {};\n\n    // manually validate that plugins are not redefined\n    for (const key of keys) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n      if (key in first && key in second && first[key] !== second[key]) {\n        throw new TypeError(`Cannot redefine plugin \"${key}\".`);\n      }\n      result[key] = second[key] || first[key];\n    }\n    return result;\n  },\n  validate(value) {\n    // first check the value to be sure it's an object\n    if (value === null || typeof value !== \"object\") {\n      throw new TypeError(\"Expected an object.\");\n    }\n\n    // make sure it's not an array, which would mean eslintrc-style is used\n    if (Array.isArray(value)) {\n      throw new IncompatiblePluginsError(value);\n    }\n\n    // second check the keys to make sure they are objects\n    for (const key of Object.keys(value)) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n      if (value[key] === null || typeof value[key] !== \"object\") {\n        throw new TypeError(`Key \"${key}\": Expected an object.`);\n      }\n    }\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst processorSchema = {\n  merge: \"replace\",\n  validate(value) {\n    if (typeof value === \"string\") {\n      assertIsPluginMemberName(value);\n    } else if (value && typeof value === \"object\") {\n      if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\n        throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\n      }\n    } else {\n      throw new TypeError(\"Expected an object or a string.\");\n    }\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst rulesSchema = {\n  merge(first = {}, second = {}) {\n    const result = {\n      ...first,\n      ...second\n    };\n    for (const ruleId of Object.keys(result)) {\n      try {\n        // avoid hairy edge case\n        if (ruleId === \"__proto__\") {\n          /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\n          delete result.__proto__;\n          continue;\n        }\n        result[ruleId] = normalizeRuleOptions(result[ruleId]);\n\n        /*\n         * If either rule config is missing, then the correct\n         * config is already present and we just need to normalize\n         * the severity.\n         */\n        if (!(ruleId in first) || !(ruleId in second)) {\n          continue;\n        }\n        const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\n        const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\n\n        /*\n         * If the second rule config only has a severity (length of 1),\n         * then use that severity and keep the rest of the options from\n         * the first rule config.\n         */\n        if (secondRuleOptions.length === 1) {\n          result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\n          continue;\n        }\n\n        /*\n         * In any other situation, then the second rule config takes\n         * precedence. That means the value at `result[ruleId]` is\n         * already correct and no further work is necessary.\n         */\n      } catch (ex) {\n        throw new Error(`Key \"${ruleId}\": ${ex.message}`, {\n          cause: ex\n        });\n      }\n    }\n    return result;\n  },\n  validate(value) {\n    assertIsObject(value);\n\n    /*\n     * We are not checking the rule schema here because there is no\n     * guarantee that the rule definition is present at this point. Instead\n     * we wait and check the rule schema during the finalization step\n     * of calculating a config.\n     */\n    for (const ruleId of Object.keys(value)) {\n      // avoid hairy edge case\n      if (ruleId === \"__proto__\") {\n        continue;\n      }\n      const ruleOptions = value[ruleId];\n      assertIsRuleOptions(ruleId, ruleOptions);\n      if (Array.isArray(ruleOptions)) {\n        assertIsRuleSeverity(ruleId, ruleOptions[0]);\n      } else {\n        assertIsRuleSeverity(ruleId, ruleOptions);\n      }\n    }\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst ecmaVersionSchema = {\n  merge: \"replace\",\n  validate(value) {\n    if (typeof value === \"number\" || value === \"latest\") {\n      return;\n    }\n    throw new TypeError(\"Expected a number or \\\"latest\\\".\");\n  }\n};\n\n/** @type {ObjectPropertySchema} */\nconst sourceTypeSchema = {\n  merge: \"replace\",\n  validate(value) {\n    if (typeof value !== \"string\" || !/^(?:script|module|commonjs)$/u.test(value)) {\n      throw new TypeError(\"Expected \\\"script\\\", \\\"module\\\", or \\\"commonjs\\\".\");\n    }\n  }\n};\n\n/**\n * Creates a schema that always throws an error. Useful for warning\n * about eslintrc-style keys.\n * @param {string} key The eslintrc key to create a schema for.\n * @returns {ObjectPropertySchema} The schema.\n */\nfunction createEslintrcErrorSchema(key) {\n  return {\n    merge: \"replace\",\n    validate() {\n      throw new IncompatibleKeyError(key);\n    }\n  };\n}\nconst eslintrcKeys = [\"env\", \"extends\", \"globals\", \"ignorePatterns\", \"noInlineConfig\", \"overrides\", \"parser\", \"parserOptions\", \"reportUnusedDisableDirectives\", \"root\"];\n\n//-----------------------------------------------------------------------------\n// Full schema\n//-----------------------------------------------------------------------------\n\nconst flatConfigSchema = {\n  // eslintrc-style keys that should always error\n  ...Object.fromEntries(eslintrcKeys.map(key => [key, createEslintrcErrorSchema(key)])),\n  // flat config keys\n  settings: deepObjectAssignSchema,\n  linterOptions: {\n    schema: {\n      noInlineConfig: booleanSchema,\n      reportUnusedDisableDirectives: disableDirectiveSeveritySchema\n    }\n  },\n  languageOptions: {\n    schema: {\n      ecmaVersion: ecmaVersionSchema,\n      sourceType: sourceTypeSchema,\n      globals: globalsSchema,\n      parser: parserSchema,\n      parserOptions: deepObjectAssignSchema\n    }\n  },\n  processor: processorSchema,\n  plugins: pluginsSchema,\n  rules: rulesSchema\n};\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n  flatConfigSchema,\n  assertIsRuleSeverity,\n  assertIsRuleOptions\n};","map":{"version":3,"names":["structuredClone","require","default","normalizeSeverityToNumber","ruleSeverities","Map","globalVariablesValues","Set","isNonNullObject","value","isNonArrayObject","Array","isArray","isUndefined","deepMerge","first","second","mergeMap","secondMergeMap","get","result","set","__proto__","key","Object","keys","prototype","propertyIsEnumerable","call","firstValue","secondValue","normalizeRuleOptions","ruleOptions","finalOptions","slice","InvalidRuleOptionsError","Error","constructor","ruleId","messageTemplate","messageData","assertIsRuleOptions","InvalidRuleSeverityError","assertIsRuleSeverity","severity","assertIsPluginMemberName","test","TypeError","assertIsObject","IncompatibleKeyError","IncompatiblePluginsError","plugins","booleanSchema","merge","validate","ALLOWED_SEVERITIES","disableDirectiveSeveritySchema","has","deepObjectAssignSchema","globalsSchema","trim","parserSchema","parse","parseForESLint","pluginsSchema","processorSchema","preprocess","postprocess","rulesSchema","firstRuleOptions","secondRuleOptions","length","ex","message","cause","ecmaVersionSchema","sourceTypeSchema","createEslintrcErrorSchema","eslintrcKeys","flatConfigSchema","fromEntries","map","settings","linterOptions","schema","noInlineConfig","reportUnusedDisableDirectives","languageOptions","ecmaVersion","sourceType","globals","parser","parserOptions","processor","rules","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/config/flat-config-schema.js"],"sourcesContent":["/**\n * @fileoverview Flat config schema\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\n/*\n * Note: This can be removed in ESLint v9 because structuredClone is available globally\n * starting in Node.js v17.\n */\nconst structuredClone = require(\"@ungap/structured-clone\").default;\nconst { normalizeSeverityToNumber } = require(\"../shared/severity\");\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef ObjectPropertySchema\n * @property {Function|string} merge The function or name of the function to call\n *      to merge multiple objects with this property.\n * @property {Function|string} validate The function or name of the function to call\n *      to validate the value of this property.\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleSeverities = new Map([\n    [0, 0], [\"off\", 0],\n    [1, 1], [\"warn\", 1],\n    [2, 2], [\"error\", 2]\n]);\n\nconst globalVariablesValues = new Set([\n    true, \"true\", \"writable\", \"writeable\",\n    false, \"false\", \"readonly\", \"readable\", null,\n    \"off\"\n]);\n\n/**\n * Check if a value is a non-null object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Check if a value is a non-null non-array object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null non-array object.\n */\nfunction isNonArrayObject(value) {\n    return isNonNullObject(value) && !Array.isArray(value);\n}\n\n/**\n * Check if a value is undefined.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is undefined.\n */\nfunction isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n\n/**\n * Deeply merges two non-array objects.\n * @param {Object} first The base object.\n * @param {Object} second The overrides object.\n * @param {Map<string, Map<string, Object>>} [mergeMap] Maps the combination of first and second arguments to a merged result.\n * @returns {Object} An object with properties from both first and second.\n */\nfunction deepMerge(first, second, mergeMap = new Map()) {\n\n    let secondMergeMap = mergeMap.get(first);\n\n    if (secondMergeMap) {\n        const result = secondMergeMap.get(second);\n\n        if (result) {\n\n            // If this combination of first and second arguments has been already visited, return the previously created result.\n            return result;\n        }\n    } else {\n        secondMergeMap = new Map();\n        mergeMap.set(first, secondMergeMap);\n    }\n\n    /*\n     * First create a result object where properties from the second object\n     * overwrite properties from the first. This sets up a baseline to use\n     * later rather than needing to inspect and change every property\n     * individually.\n     */\n    const result = {\n        ...first,\n        ...second\n    };\n\n    delete result.__proto__; // eslint-disable-line no-proto -- don't merge own property \"__proto__\"\n\n    // Store the pending result for this combination of first and second arguments.\n    secondMergeMap.set(second, result);\n\n    for (const key of Object.keys(second)) {\n\n        // avoid hairy edge case\n        if (key === \"__proto__\" || !Object.prototype.propertyIsEnumerable.call(first, key)) {\n            continue;\n        }\n\n        const firstValue = first[key];\n        const secondValue = second[key];\n\n        if (isNonArrayObject(firstValue) && isNonArrayObject(secondValue)) {\n            result[key] = deepMerge(firstValue, secondValue, mergeMap);\n        } else if (isUndefined(secondValue)) {\n            result[key] = firstValue;\n        }\n    }\n\n    return result;\n\n}\n\n/**\n * Normalizes the rule options config for a given rule by ensuring that\n * it is an array and that the first item is 0, 1, or 2.\n * @param {Array|string|number} ruleOptions The rule options config.\n * @returns {Array} An array of rule options.\n */\nfunction normalizeRuleOptions(ruleOptions) {\n\n    const finalOptions = Array.isArray(ruleOptions)\n        ? ruleOptions.slice(0)\n        : [ruleOptions];\n\n    finalOptions[0] = ruleSeverities.get(finalOptions[0]);\n    return structuredClone(finalOptions);\n}\n\n//-----------------------------------------------------------------------------\n// Assertions\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when a rule's options are configured with an invalid type.\n */\nclass InvalidRuleOptionsError extends Error {\n\n    /**\n     * @param {string} ruleId Rule name being configured.\n     * @param {any} value The invalid value.\n     */\n    constructor(ruleId, value) {\n        super(`Key \"${ruleId}\": Expected severity of \"off\", 0, \"warn\", 1, \"error\", or 2.`);\n        this.messageTemplate = \"invalid-rule-options\";\n        this.messageData = { ruleId, value };\n    }\n}\n\n/**\n * Validates that a value is a valid rule options entry.\n * @param {string} ruleId Rule name being configured.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {InvalidRuleOptionsError} If the value isn't a valid rule options.\n */\nfunction assertIsRuleOptions(ruleId, value) {\n    if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\n        throw new InvalidRuleOptionsError(ruleId, value);\n    }\n}\n\n/**\n * The error type when a rule's severity is invalid.\n */\nclass InvalidRuleSeverityError extends Error {\n\n    /**\n     * @param {string} ruleId Rule name being configured.\n     * @param {any} value The invalid value.\n     */\n    constructor(ruleId, value) {\n        super(`Key \"${ruleId}\": Expected severity of \"off\", 0, \"warn\", 1, \"error\", or 2.`);\n        this.messageTemplate = \"invalid-rule-severity\";\n        this.messageData = { ruleId, value };\n    }\n}\n\n/**\n * Validates that a value is valid rule severity.\n * @param {string} ruleId Rule name being configured.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {InvalidRuleSeverityError} If the value isn't a valid rule severity.\n */\nfunction assertIsRuleSeverity(ruleId, value) {\n    const severity = ruleSeverities.get(value);\n\n    if (typeof severity === \"undefined\") {\n        throw new InvalidRuleSeverityError(ruleId, value);\n    }\n}\n\n/**\n * Validates that a given string is the form pluginName/objectName.\n * @param {string} value The string to check.\n * @returns {void}\n * @throws {TypeError} If the string isn't in the correct format.\n */\nfunction assertIsPluginMemberName(value) {\n    if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\n        throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\n    }\n}\n\n/**\n * Validates that a value is an object.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object.\n */\nfunction assertIsObject(value) {\n    if (!isNonNullObject(value)) {\n        throw new TypeError(\"Expected an object.\");\n    }\n}\n\n/**\n * The error type when there's an eslintrc-style options in a flat config.\n */\nclass IncompatibleKeyError extends Error {\n\n    /**\n     * @param {string} key The invalid key.\n     */\n    constructor(key) {\n        super(\"This appears to be in eslintrc format rather than flat config format.\");\n        this.messageTemplate = \"eslintrc-incompat\";\n        this.messageData = { key };\n    }\n}\n\n/**\n * The error type when there's an eslintrc-style plugins array found.\n */\nclass IncompatiblePluginsError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {Array<string>} plugins The plugins array.\n     */\n    constructor(plugins) {\n        super(\"This appears to be in eslintrc format (array of strings) rather than flat config format (object).\");\n        this.messageTemplate = \"eslintrc-plugins\";\n        this.messageData = { plugins };\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// Low-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst booleanSchema = {\n    merge: \"replace\",\n    validate: \"boolean\"\n};\n\nconst ALLOWED_SEVERITIES = new Set([\"error\", \"warn\", \"off\", 2, 1, 0]);\n\n/** @type {ObjectPropertySchema} */\nconst disableDirectiveSeveritySchema = {\n    merge(first, second) {\n        const value = second === void 0 ? first : second;\n\n        if (typeof value === \"boolean\") {\n            return value ? \"warn\" : \"off\";\n        }\n\n        return normalizeSeverityToNumber(value);\n    },\n    validate(value) {\n        if (!(ALLOWED_SEVERITIES.has(value) || typeof value === \"boolean\")) {\n            throw new TypeError(\"Expected one of: \\\"error\\\", \\\"warn\\\", \\\"off\\\", 0, 1, 2, or a boolean.\");\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst deepObjectAssignSchema = {\n    merge(first = {}, second = {}) {\n        return deepMerge(first, second);\n    },\n    validate: \"object\"\n};\n\n//-----------------------------------------------------------------------------\n// High-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst globalsSchema = {\n    merge: \"assign\",\n    validate(value) {\n\n        assertIsObject(value);\n\n        for (const key of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (key !== key.trim()) {\n                throw new TypeError(`Global \"${key}\" has leading or trailing whitespace.`);\n            }\n\n            if (!globalVariablesValues.has(value[key])) {\n                throw new TypeError(`Key \"${key}\": Expected \"readonly\", \"writable\", or \"off\".`);\n            }\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst parserSchema = {\n    merge: \"replace\",\n    validate(value) {\n\n        if (!value || typeof value !== \"object\" ||\n            (typeof value.parse !== \"function\" && typeof value.parseForESLint !== \"function\")\n        ) {\n            throw new TypeError(\"Expected object with parse() or parseForESLint() method.\");\n        }\n\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst pluginsSchema = {\n    merge(first = {}, second = {}) {\n        const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\n        const result = {};\n\n        // manually validate that plugins are not redefined\n        for (const key of keys) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (key in first && key in second && first[key] !== second[key]) {\n                throw new TypeError(`Cannot redefine plugin \"${key}\".`);\n            }\n\n            result[key] = second[key] || first[key];\n        }\n\n        return result;\n    },\n    validate(value) {\n\n        // first check the value to be sure it's an object\n        if (value === null || typeof value !== \"object\") {\n            throw new TypeError(\"Expected an object.\");\n        }\n\n        // make sure it's not an array, which would mean eslintrc-style is used\n        if (Array.isArray(value)) {\n            throw new IncompatiblePluginsError(value);\n        }\n\n        // second check the keys to make sure they are objects\n        for (const key of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (value[key] === null || typeof value[key] !== \"object\") {\n                throw new TypeError(`Key \"${key}\": Expected an object.`);\n            }\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst processorSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value === \"string\") {\n            assertIsPluginMemberName(value);\n        } else if (value && typeof value === \"object\") {\n            if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\n                throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\n            }\n        } else {\n            throw new TypeError(\"Expected an object or a string.\");\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst rulesSchema = {\n    merge(first = {}, second = {}) {\n\n        const result = {\n            ...first,\n            ...second\n        };\n\n\n        for (const ruleId of Object.keys(result)) {\n\n            try {\n\n                // avoid hairy edge case\n                if (ruleId === \"__proto__\") {\n\n                    /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\n                    delete result.__proto__;\n                    continue;\n                }\n\n                result[ruleId] = normalizeRuleOptions(result[ruleId]);\n\n                /*\n                 * If either rule config is missing, then the correct\n                 * config is already present and we just need to normalize\n                 * the severity.\n                 */\n                if (!(ruleId in first) || !(ruleId in second)) {\n                    continue;\n                }\n\n                const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\n                const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\n\n                /*\n                 * If the second rule config only has a severity (length of 1),\n                 * then use that severity and keep the rest of the options from\n                 * the first rule config.\n                 */\n                if (secondRuleOptions.length === 1) {\n                    result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\n                    continue;\n                }\n\n                /*\n                 * In any other situation, then the second rule config takes\n                 * precedence. That means the value at `result[ruleId]` is\n                 * already correct and no further work is necessary.\n                 */\n            } catch (ex) {\n                throw new Error(`Key \"${ruleId}\": ${ex.message}`, { cause: ex });\n            }\n\n        }\n\n        return result;\n\n\n    },\n\n    validate(value) {\n        assertIsObject(value);\n\n        /*\n         * We are not checking the rule schema here because there is no\n         * guarantee that the rule definition is present at this point. Instead\n         * we wait and check the rule schema during the finalization step\n         * of calculating a config.\n         */\n        for (const ruleId of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (ruleId === \"__proto__\") {\n                continue;\n            }\n\n            const ruleOptions = value[ruleId];\n\n            assertIsRuleOptions(ruleId, ruleOptions);\n\n            if (Array.isArray(ruleOptions)) {\n                assertIsRuleSeverity(ruleId, ruleOptions[0]);\n            } else {\n                assertIsRuleSeverity(ruleId, ruleOptions);\n            }\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst ecmaVersionSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value === \"number\" || value === \"latest\") {\n            return;\n        }\n\n        throw new TypeError(\"Expected a number or \\\"latest\\\".\");\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst sourceTypeSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value !== \"string\" || !/^(?:script|module|commonjs)$/u.test(value)) {\n            throw new TypeError(\"Expected \\\"script\\\", \\\"module\\\", or \\\"commonjs\\\".\");\n        }\n    }\n};\n\n/**\n * Creates a schema that always throws an error. Useful for warning\n * about eslintrc-style keys.\n * @param {string} key The eslintrc key to create a schema for.\n * @returns {ObjectPropertySchema} The schema.\n */\nfunction createEslintrcErrorSchema(key) {\n    return {\n        merge: \"replace\",\n        validate() {\n            throw new IncompatibleKeyError(key);\n        }\n    };\n}\n\nconst eslintrcKeys = [\n    \"env\",\n    \"extends\",\n    \"globals\",\n    \"ignorePatterns\",\n    \"noInlineConfig\",\n    \"overrides\",\n    \"parser\",\n    \"parserOptions\",\n    \"reportUnusedDisableDirectives\",\n    \"root\"\n];\n\n//-----------------------------------------------------------------------------\n// Full schema\n//-----------------------------------------------------------------------------\n\nconst flatConfigSchema = {\n\n    // eslintrc-style keys that should always error\n    ...Object.fromEntries(eslintrcKeys.map(key => [key, createEslintrcErrorSchema(key)])),\n\n    // flat config keys\n    settings: deepObjectAssignSchema,\n    linterOptions: {\n        schema: {\n            noInlineConfig: booleanSchema,\n            reportUnusedDisableDirectives: disableDirectiveSeveritySchema\n        }\n    },\n    languageOptions: {\n        schema: {\n            ecmaVersion: ecmaVersionSchema,\n            sourceType: sourceTypeSchema,\n            globals: globalsSchema,\n            parser: parserSchema,\n            parserOptions: deepObjectAssignSchema\n        }\n    },\n    processor: processorSchema,\n    plugins: pluginsSchema,\n    rules: rulesSchema\n};\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    flatConfigSchema,\n    assertIsRuleSeverity,\n    assertIsRuleOptions\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}