{"ast":null,"code":"/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Disallow multiple spaces\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-multi-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          patternProperties: {\n            \"^([A-Z][a-z]*)+$\": {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        },\n        ignoreEOLComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      multipleSpaces: \"Multiple spaces found before '{{displayValue}}'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const options = context.options[0] || {};\n    const ignoreEOLComments = options.ignoreEOLComments;\n    const exceptions = Object.assign({\n      Property: true\n    }, options.exceptions);\n    const hasExceptions = Object.keys(exceptions).some(key => exceptions[key]);\n\n    /**\n     * Formats value of given comment token for error message by truncating its length.\n     * @param {Token} token comment token\n     * @returns {string} formatted value\n     * @private\n     */\n    function formatReportedCommentValue(token) {\n      const valueLines = token.value.split(\"\\n\");\n      const value = valueLines[0];\n      const formattedValue = `${value.slice(0, 12)}...`;\n      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program() {\n        sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n          if (leftIndex === tokensAndComments.length - 1) {\n            return;\n          }\n          const rightToken = tokensAndComments[leftIndex + 1];\n\n          // Ignore tokens that don't have 2 spaces between them or are on different lines\n          if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") || leftToken.loc.end.line < rightToken.loc.start.line) {\n            return;\n          }\n\n          // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n          if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {\n            return;\n          }\n\n          // Ignore tokens that are in a node in the \"exceptions\" object\n          if (hasExceptions) {\n            const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n            if (parentNode && exceptions[parentNode.type]) {\n              return;\n            }\n          }\n          let displayValue;\n          if (rightToken.type === \"Block\") {\n            displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n          } else if (rightToken.type === \"Line\") {\n            displayValue = `//${formatReportedCommentValue(rightToken)}`;\n          } else {\n            displayValue = rightToken.value;\n          }\n          context.report({\n            node: rightToken,\n            loc: {\n              start: leftToken.loc.end,\n              end: rightToken.loc.start\n            },\n            messageId: \"multipleSpaces\",\n            data: {\n              displayValue\n            },\n            fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n          });\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","properties","exceptions","patternProperties","additionalProperties","ignoreEOLComments","default","messages","multipleSpaces","create","context","sourceCode","options","Object","assign","Property","hasExceptions","keys","some","key","formatReportedCommentValue","token","valueLines","value","split","formattedValue","slice","length","Program","tokensAndComments","forEach","leftToken","leftIndex","rightToken","text","range","includes","loc","end","line","start","isCommentToken","parentNode","getNodeByRangeIndex","displayValue","report","node","messageId","data","fix","fixer","replaceTextRange"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-multi-spaces.js"],"sourcesContent":["/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Disallow multiple spaces\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-multi-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    ignoreEOLComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            multipleSpaces: \"Multiple spaces found before '{{displayValue}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const options = context.options[0] || {};\n        const ignoreEOLComments = options.ignoreEOLComments;\n        const exceptions = Object.assign({ Property: true }, options.exceptions);\n        const hasExceptions = Object.keys(exceptions).some(key => exceptions[key]);\n\n        /**\n         * Formats value of given comment token for error message by truncating its length.\n         * @param {Token} token comment token\n         * @returns {string} formatted value\n         * @private\n         */\n        function formatReportedCommentValue(token) {\n            const valueLines = token.value.split(\"\\n\");\n            const value = valueLines[0];\n            const formattedValue = `${value.slice(0, 12)}...`;\n\n            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n                    if (leftIndex === tokensAndComments.length - 1) {\n                        return;\n                    }\n                    const rightToken = tokensAndComments[leftIndex + 1];\n\n                    // Ignore tokens that don't have 2 spaces between them or are on different lines\n                    if (\n                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") ||\n                        leftToken.loc.end.line < rightToken.loc.start.line\n                    ) {\n                        return;\n                    }\n\n                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n                    if (\n                        ignoreEOLComments &&\n                        astUtils.isCommentToken(rightToken) &&\n                        (\n                            leftIndex === tokensAndComments.length - 2 ||\n                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line\n                        )\n                    ) {\n                        return;\n                    }\n\n                    // Ignore tokens that are in a node in the \"exceptions\" object\n                    if (hasExceptions) {\n                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n                        if (parentNode && exceptions[parentNode.type]) {\n                            return;\n                        }\n                    }\n\n                    let displayValue;\n\n                    if (rightToken.type === \"Block\") {\n                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n                    } else if (rightToken.type === \"Line\") {\n                        displayValue = `//${formatReportedCommentValue(rightToken)}`;\n                    } else {\n                        displayValue = rightToken.value;\n                    }\n\n                    context.report({\n                        node: rightToken,\n                        loc: { start: leftToken.loc.end, end: rightToken.loc.start },\n                        messageId: \"multipleSpaces\",\n                        data: { displayValue },\n                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n                    });\n                });\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}