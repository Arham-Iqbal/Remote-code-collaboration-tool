{"ast":null,"code":"/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow `this`/`super` before calling `super()` in constructors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-this-before-super\"\n    },\n    schema: [],\n    messages: {\n      noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\n    }\n  },\n  create(context) {\n    /*\n     * Information for each constructor.\n     * - upper:      Information of the upper constructor.\n     * - hasExtends: A flag which shows whether the owner class has a valid\n     *   `extends` part.\n     * - scope:      The scope of the owner class.\n     * - codePath:   The code path of this constructor.\n     */\n    let funcInfo = null;\n\n    /*\n     * Information for each code path segment.\n     * Each key is the id of a code path segment.\n     * Each value is an object:\n     * - superCalled:  The flag which shows `super()` called in all code paths.\n     * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n     */\n    let segInfoMap = Object.create(null);\n\n    /**\n     * Gets whether or not `super()` is called in a given code path segment.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} `true` if `super()` is called.\n     */\n    function isCalled(segment) {\n      return !segment.reachable || segInfoMap[segment.id].superCalled;\n    }\n\n    /**\n     * Checks whether or not this is in a constructor.\n     * @returns {boolean} `true` if this is in a constructor.\n     */\n    function isInConstructorOfDerivedClass() {\n      return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n    }\n\n    /**\n     * Determines if every segment in a set has been called.\n     * @param {Set<CodePathSegment>} segments The segments to search.\n     * @returns {boolean} True if every segment has been called; false otherwise.\n     */\n    function isEverySegmentCalled(segments) {\n      for (const segment of segments) {\n        if (!isCalled(segment)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Checks whether or not this is before `super()` is called.\n     * @returns {boolean} `true` if this is before `super()` is called.\n     */\n    function isBeforeCallOfSuper() {\n      return isInConstructorOfDerivedClass() && !isEverySegmentCalled(funcInfo.currentSegments);\n    }\n\n    /**\n     * Sets a given node as invalid.\n     * @param {ASTNode} node A node to set as invalid. This is one of\n     *      a ThisExpression and a Super.\n     * @returns {void}\n     */\n    function setInvalid(node) {\n      const segments = funcInfo.currentSegments;\n      for (const segment of segments) {\n        if (segment.reachable) {\n          segInfoMap[segment.id].invalidNodes.push(node);\n        }\n      }\n    }\n\n    /**\n     * Sets the current segment as `super` was called.\n     * @returns {void}\n     */\n    function setSuperCalled() {\n      const segments = funcInfo.currentSegments;\n      for (const segment of segments) {\n        if (segment.reachable) {\n          segInfoMap[segment.id].superCalled = true;\n        }\n      }\n    }\n    return {\n      /**\n       * Adds information of a constructor into the stack.\n       * @param {CodePath} codePath A code path which was started.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          // Class > ClassBody > MethodDefinition > FunctionExpression\n          const classNode = node.parent.parent.parent;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),\n            codePath,\n            currentSegments: new Set()\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            codePath,\n            currentSegments: new Set()\n          };\n        }\n      },\n      /**\n       * Removes the top of stack item.\n       *\n       * And this traverses all segments of this code path then reports every\n       * invalid node.\n       * @param {CodePath} codePath A code path which was ended.\n       * @returns {void}\n       */\n      onCodePathEnd(codePath) {\n        const isDerivedClass = funcInfo.hasExtends;\n        funcInfo = funcInfo.upper;\n        if (!isDerivedClass) {\n          return;\n        }\n        codePath.traverseSegments((segment, controller) => {\n          const info = segInfoMap[segment.id];\n          for (let i = 0; i < info.invalidNodes.length; ++i) {\n            const invalidNode = info.invalidNodes[i];\n            context.report({\n              messageId: \"noBeforeSuper\",\n              node: invalidNode,\n              data: {\n                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n              }\n            });\n          }\n          if (info.superCalled) {\n            controller.skip();\n          }\n        });\n      },\n      /**\n       * Initialize information of a given code path segment.\n       * @param {CodePathSegment} segment A code path segment to initialize.\n       * @returns {void}\n       */\n      onCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n        if (!isInConstructorOfDerivedClass()) {\n          return;\n        }\n\n        // Initialize info.\n        segInfoMap[segment.id] = {\n          superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),\n          invalidNodes: []\n        };\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      /**\n       * Update information of the code path segment when a code path was\n       * looped.\n       * @param {CodePathSegment} fromSegment The code path segment of the\n       *      end of a loop.\n       * @param {CodePathSegment} toSegment A code path segment of the head\n       *      of a loop.\n       * @returns {void}\n       */\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!isInConstructorOfDerivedClass()) {\n          return;\n        }\n\n        // Update information inside of the loop.\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, (segment, controller) => {\n          const info = segInfoMap[segment.id];\n          if (info.superCalled) {\n            info.invalidNodes = [];\n            controller.skip();\n          } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {\n            info.superCalled = true;\n            info.invalidNodes = [];\n          }\n        });\n      },\n      /**\n       * Reports if this is before `super()`.\n       * @param {ASTNode} node A target node.\n       * @returns {void}\n       */\n      ThisExpression(node) {\n        if (isBeforeCallOfSuper()) {\n          setInvalid(node);\n        }\n      },\n      /**\n       * Reports if this is before `super()`.\n       * @param {ASTNode} node A target node.\n       * @returns {void}\n       */\n      Super(node) {\n        if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n          setInvalid(node);\n        }\n      },\n      /**\n       * Marks `super()` called.\n       * @param {ASTNode} node A target node.\n       * @returns {void}\n       */\n      \"CallExpression:exit\"(node) {\n        if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n          setSuperCalled();\n        }\n      },\n      /**\n       * Resets state.\n       * @returns {void}\n       */\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isConstructorFunction","node","type","parent","kind","module","exports","meta","docs","description","recommended","url","schema","messages","noBeforeSuper","create","context","funcInfo","segInfoMap","Object","isCalled","segment","reachable","id","superCalled","isInConstructorOfDerivedClass","Boolean","isConstructor","hasExtends","isEverySegmentCalled","segments","isBeforeCallOfSuper","currentSegments","setInvalid","invalidNodes","push","setSuperCalled","onCodePathStart","codePath","classNode","upper","superClass","isNullOrUndefined","Set","onCodePathEnd","isDerivedClass","traverseSegments","controller","info","i","length","invalidNode","report","messageId","data","skip","onCodePathSegmentStart","add","prevSegments","every","onUnreachableCodePathSegmentStart","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentEnd","onCodePathSegmentLoop","fromSegment","toSegment","first","last","ThisExpression","Super","isCallee","CallExpression:exit","callee","Program:exit"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-this-before-super.js"],"sourcesContent":["/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow `this`/`super` before calling `super()` in constructors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-this-before-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * Information for each code path segment.\n         * Each key is the id of a code path segment.\n         * Each value is an object:\n         * - superCalled:  The flag which shows `super()` called in all code paths.\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Determines if every segment in a set has been called.\n         * @param {Set<CodePathSegment>} segments The segments to search.\n         * @returns {boolean} True if every segment has been called; false otherwise.\n         */\n        function isEverySegmentCalled(segments) {\n            for (const segment of segments) {\n                if (!isCalled(segment)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass() &&\n                !isEverySegmentCalled(funcInfo.currentSegments)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            const segments = funcInfo.currentSegments;\n\n            for (const segment of segments) {\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            const segments = funcInfo.currentSegments;\n\n            for (const segment of segments) {\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath,\n                        currentSegments: new Set()\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath,\n                        currentSegments: new Set()\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this traverses all segments of this code path then reports every\n             * invalid node.\n             * @param {CodePath} codePath A code path which was ended.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath) {\n                const isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                codePath.traverseSegments((segment, controller) => {\n                    const info = segInfoMap[segment.id];\n\n                    for (let i = 0; i < info.invalidNodes.length; ++i) {\n                        const invalidNode = info.invalidNodes[i];\n\n                        context.report({\n                            messageId: \"noBeforeSuper\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id];\n\n                        if (info.superCalled) {\n                            info.invalidNodes = [];\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                            info.invalidNodes = [];\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            ThisExpression(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            Super(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}