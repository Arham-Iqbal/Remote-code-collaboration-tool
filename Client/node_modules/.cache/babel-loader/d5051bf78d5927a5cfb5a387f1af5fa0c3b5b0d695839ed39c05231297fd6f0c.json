{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the computed key syntax is unnecessarily used for the given node.\n * In particular, it determines whether removing the square brackets and using the content between them\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\n * Valid non-computed keys are only: identifiers, number literals and string literals.\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\n * Property\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\n *     { \"__proto__\": foo } defines object's prototype\n * PropertyDefinition\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\n *     class C { \"constructor\"; } produces a parsing error\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\n *     class C { static \"constructor\"; } produces a parsing error\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\n * MethodDefinition\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\n *     class C { \"constructor\"() {} } defines the constructor\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\n * @throws {Error} (Unreachable.)\n * @returns {void} `true` if the node has useless computed key.\n */\nfunction hasUselessComputedKey(node) {\n  if (!node.computed) {\n    return false;\n  }\n  const {\n    key\n  } = node;\n  if (key.type !== \"Literal\") {\n    return false;\n  }\n  const {\n    value\n  } = key;\n  if (typeof value !== \"number\" && typeof value !== \"string\") {\n    return false;\n  }\n  switch (node.type) {\n    case \"Property\":\n      return value !== \"__proto__\";\n    case \"PropertyDefinition\":\n      if (node.static) {\n        return value !== \"constructor\" && value !== \"prototype\";\n      }\n      return value !== \"constructor\";\n    case \"MethodDefinition\":\n      if (node.static) {\n        return value !== \"prototype\";\n      }\n      return value !== \"constructor\";\n\n    /* c8 ignore next */\n    default:\n      throw new Error(`Unexpected node type: ${node.type}`);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unnecessary computed property keys in objects and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function check(node) {\n      if (hasUselessComputedKey(node)) {\n        const {\n          key\n        } = node;\n        context.report({\n          node,\n          messageId: \"unnecessarilyComputedProperty\",\n          data: {\n            property: sourceCode.getText(key)\n          },\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n            // If there are comments between the brackets and the property name, don't do a fix.\n            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n              return null;\n            }\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n            // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n        });\n      }\n    }\n\n    /**\n     * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n     * @returns {void}\n     * @private\n     */\n    function noop() {}\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : noop,\n      PropertyDefinition: enforceForClassMembers ? check : noop\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","hasUselessComputedKey","node","computed","key","type","value","static","Error","module","exports","meta","docs","description","recommended","url","schema","properties","enforceForClassMembers","default","additionalProperties","fixable","messages","unnecessarilyComputedProperty","create","context","sourceCode","options","check","report","messageId","data","property","getText","fix","fixer","leftSquareBracket","getTokenBefore","isOpeningBracketToken","rightSquareBracket","getTokenAfter","isClosingBracketToken","commentsExistBetween","tokenBeforeLeftBracket","needsSpaceBeforeKey","range","canTokensBeAdjacent","getFirstToken","replacementKey","raw","replaceTextRange","noop","Property","MethodDefinition","PropertyDefinition"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-useless-computed-key.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the computed key syntax is unnecessarily used for the given node.\n * In particular, it determines whether removing the square brackets and using the content between them\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\n * Valid non-computed keys are only: identifiers, number literals and string literals.\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\n * Property\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\n *     { \"__proto__\": foo } defines object's prototype\n * PropertyDefinition\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\n *     class C { \"constructor\"; } produces a parsing error\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\n *     class C { static \"constructor\"; } produces a parsing error\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\n * MethodDefinition\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\n *     class C { \"constructor\"() {} } defines the constructor\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\n * @throws {Error} (Unreachable.)\n * @returns {void} `true` if the node has useless computed key.\n */\nfunction hasUselessComputedKey(node) {\n    if (!node.computed) {\n        return false;\n    }\n\n    const { key } = node;\n\n    if (key.type !== \"Literal\") {\n        return false;\n    }\n\n    const { value } = key;\n\n    if (typeof value !== \"number\" && typeof value !== \"string\") {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"Property\":\n            return value !== \"__proto__\";\n\n        case \"PropertyDefinition\":\n            if (node.static) {\n                return value !== \"constructor\" && value !== \"prototype\";\n            }\n\n            return value !== \"constructor\";\n\n        case \"MethodDefinition\":\n            if (node.static) {\n                return value !== \"prototype\";\n            }\n\n            return value !== \"constructor\";\n\n        /* c8 ignore next */\n        default:\n            throw new Error(`Unexpected node type: ${node.type}`);\n    }\n\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary computed property keys in objects and classes\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (hasUselessComputedKey(node)) {\n                const { key } = node;\n\n                context.report({\n                    node,\n                    messageId: \"unnecessarilyComputedProperty\",\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n                        // If there are comments between the brackets and the property name, don't do a fix.\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : noop,\n            PropertyDefinition: enforceForClassMembers ? check : noop\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}