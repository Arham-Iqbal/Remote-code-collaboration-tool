{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unnecessary semicolons\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-extra-semi\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unexpected: \"Unnecessary semicolon.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Checks if a node or token is fixable.\n     * A node is fixable if it can be removed without turning a subsequent statement into a directive after fixing other nodes.\n     * @param {Token} nodeOrToken The node or token to check.\n     * @returns {boolean} Whether or not the node is fixable.\n     */\n    function isFixable(nodeOrToken) {\n      const nextToken = sourceCode.getTokenAfter(nodeOrToken);\n      if (!nextToken || nextToken.type !== \"String\") {\n        return true;\n      }\n      const stringNode = sourceCode.getNodeByRangeIndex(nextToken.range[0]);\n      return !astUtils.isTopLevelExpressionStatement(stringNode.parent);\n    }\n\n    /**\n     * Reports an unnecessary semicolon error.\n     * @param {Node|Token} nodeOrToken A node or a token to be reported.\n     * @returns {void}\n     */\n    function report(nodeOrToken) {\n      context.report({\n        node: nodeOrToken,\n        messageId: \"unexpected\",\n        fix: isFixable(nodeOrToken) ? fixer =>\n        /*\n         * Expand the replacement range to include the surrounding\n         * tokens to avoid conflicting with semi.\n         * https://github.com/eslint/eslint/issues/7928\n         */\n        new FixTracker(fixer, context.sourceCode).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken) : null\n      });\n    }\n\n    /**\n     * Checks for a part of a class body.\n     * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n     * @param {Token} firstToken The first token to check.\n     * @returns {void}\n     */\n    function checkForPartOfClassBody(firstToken) {\n      for (let token = firstToken; token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {\n        if (astUtils.isSemicolonToken(token)) {\n          report(token);\n        }\n      }\n    }\n    return {\n      /**\n       * Reports this empty statement, except if the parent node is a loop.\n       * @param {Node} node A EmptyStatement node to be reported.\n       * @returns {void}\n       */\n      EmptyStatement(node) {\n        const parent = node.parent,\n          allowedParentTypes = [\"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"IfStatement\", \"LabeledStatement\", \"WithStatement\"];\n        if (!allowedParentTypes.includes(parent.type)) {\n          report(node);\n        }\n      },\n      /**\n       * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n       * @param {Node} node A ClassBody node to check.\n       * @returns {void}\n       */\n      ClassBody(node) {\n        checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n      },\n      /**\n       * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n       * @param {Node} node A MethodDefinition node of the start point.\n       * @returns {void}\n       */\n      \"MethodDefinition, PropertyDefinition, StaticBlock\"(node) {\n        checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n      }\n    };\n  }\n};","map":{"version":3,"names":["FixTracker","require","astUtils","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","messages","unexpected","create","context","sourceCode","isFixable","nodeOrToken","nextToken","getTokenAfter","stringNode","getNodeByRangeIndex","range","isTopLevelExpressionStatement","parent","report","node","messageId","fix","fixer","retainSurroundingTokens","remove","checkForPartOfClassBody","firstToken","token","isClosingBraceToken","isSemicolonToken","EmptyStatement","allowedParentTypes","includes","ClassBody","getFirstToken","MethodDefinition, PropertyDefinition, StaticBlock"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-extra-semi.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary semicolons\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-semi\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unexpected: \"Unnecessary semicolon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks if a node or token is fixable.\n         * A node is fixable if it can be removed without turning a subsequent statement into a directive after fixing other nodes.\n         * @param {Token} nodeOrToken The node or token to check.\n         * @returns {boolean} Whether or not the node is fixable.\n         */\n        function isFixable(nodeOrToken) {\n            const nextToken = sourceCode.getTokenAfter(nodeOrToken);\n\n            if (!nextToken || nextToken.type !== \"String\") {\n                return true;\n            }\n            const stringNode = sourceCode.getNodeByRangeIndex(nextToken.range[0]);\n\n            return !astUtils.isTopLevelExpressionStatement(stringNode.parent);\n        }\n\n        /**\n         * Reports an unnecessary semicolon error.\n         * @param {Node|Token} nodeOrToken A node or a token to be reported.\n         * @returns {void}\n         */\n        function report(nodeOrToken) {\n            context.report({\n                node: nodeOrToken,\n                messageId: \"unexpected\",\n                fix: isFixable(nodeOrToken)\n                    ? fixer =>\n\n                        /*\n                         * Expand the replacement range to include the surrounding\n                         * tokens to avoid conflicting with semi.\n                         * https://github.com/eslint/eslint/issues/7928\n                         */\n                        new FixTracker(fixer, context.sourceCode)\n                            .retainSurroundingTokens(nodeOrToken)\n                            .remove(nodeOrToken)\n                    : null\n            });\n        }\n\n        /**\n         * Checks for a part of a class body.\n         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n         * @param {Token} firstToken The first token to check.\n         * @returns {void}\n         */\n        function checkForPartOfClassBody(firstToken) {\n            for (let token = firstToken;\n                token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token);\n                token = sourceCode.getTokenAfter(token)\n            ) {\n                if (astUtils.isSemicolonToken(token)) {\n                    report(token);\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Reports this empty statement, except if the parent node is a loop.\n             * @param {Node} node A EmptyStatement node to be reported.\n             * @returns {void}\n             */\n            EmptyStatement(node) {\n                const parent = node.parent,\n                    allowedParentTypes = [\n                        \"ForStatement\",\n                        \"ForInStatement\",\n                        \"ForOfStatement\",\n                        \"WhileStatement\",\n                        \"DoWhileStatement\",\n                        \"IfStatement\",\n                        \"LabeledStatement\",\n                        \"WithStatement\"\n                    ];\n\n                if (!allowedParentTypes.includes(parent.type)) {\n                    report(node);\n                }\n            },\n\n            /**\n             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n             * @param {Node} node A ClassBody node to check.\n             * @returns {void}\n             */\n            ClassBody(node) {\n                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n            },\n\n            /**\n             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n             * @param {Node} node A MethodDefinition node of the start point.\n             * @returns {void}\n             */\n            \"MethodDefinition, PropertyDefinition, StaticBlock\"(node) {\n                checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}