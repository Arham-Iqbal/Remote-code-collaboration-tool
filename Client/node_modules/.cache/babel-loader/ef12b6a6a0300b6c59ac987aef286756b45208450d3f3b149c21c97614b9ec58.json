{"ast":null,"code":"/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n    isCommentToken\n  } = require(\"@eslint-community/eslint-utils\"),\n  TokenStore = require(\"./token-store\"),\n  astUtils = require(\"../shared/ast-utils\"),\n  Traverser = require(\"../shared/traverser\"),\n  globals = require(\"../../conf/globals\"),\n  {\n    directivesPattern\n  } = require(\"../shared/directives\"),\n  /* eslint-disable-next-line n/no-restricted-require -- Too messy to figure out right now. */\n  ConfigCommentParser = require(\"../linter/config-comment-parser\"),\n  eslintScope = require(\"eslint-scope\");\n\n//------------------------------------------------------------------------------\n// Type Definitions\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst commentParser = new ConfigCommentParser();\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n  if (!ast.tokens) {\n    throw new Error(\"AST is missing the tokens array.\");\n  }\n  if (!ast.comments) {\n    throw new Error(\"AST is missing the comments array.\");\n  }\n  if (!ast.loc) {\n    throw new Error(\"AST is missing location information.\");\n  }\n  if (!ast.range) {\n    throw new Error(\"AST is missing range information\");\n  }\n}\n\n/**\n * Retrieves globals for the given ecmaVersion.\n * @param {number} ecmaVersion The version to retrieve globals for.\n * @returns {Object} The globals for the given ecmaVersion.\n */\nfunction getGlobalsForEcmaVersion(ecmaVersion) {\n  switch (ecmaVersion) {\n    case 3:\n      return globals.es3;\n    case 5:\n      return globals.es5;\n    default:\n      if (ecmaVersion < 2015) {\n        return globals[`es${ecmaVersion + 2009}`];\n      }\n      return globals[`es${ecmaVersion}`];\n  }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n  return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" || astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n  const result = [];\n  let tokenIndex = 0;\n  let commentIndex = 0;\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n      result.push(tokens[tokenIndex++]);\n    } else {\n      result.push(comments[commentIndex++]);\n    }\n  }\n  return result;\n}\n\n/**\n * Normalizes a value for a global in a config\n * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n * a global directive comment\n * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n * @throws Error if global value is invalid\n */\nfunction normalizeConfigGlobal(configuredValue) {\n  switch (configuredValue) {\n    case \"off\":\n      return \"off\";\n    case true:\n    case \"true\":\n    case \"writeable\":\n    case \"writable\":\n      return \"writable\";\n    case null:\n    case false:\n    case \"false\":\n    case \"readable\":\n    case \"readonly\":\n      return \"readonly\";\n    default:\n      throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);\n  }\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n  if (nodesOrTokensOverlap(first, second)) {\n    return false;\n  }\n  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];\n  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n  let currentToken = firstToken;\n  while (currentToken !== finalToken) {\n    const nextToken = sourceCode.getTokenAfter(currentToken, {\n      includeComments: true\n    });\n    if (currentToken.range[1] !== nextToken.range[0] || (\n    /*\n     * For backward compatibility, check spaces in JSXText.\n     * https://github.com/eslint/eslint/issues/12614\n     */\n\n    checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === \"JSXText\" && /\\s/u.test(nextToken.value))) {\n      return true;\n    }\n    currentToken = nextToken;\n  }\n  return false;\n}\n\n//-----------------------------------------------------------------------------\n// Directive Comments\n//-----------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object|undefined} configGlobals The globals declared in configuration\n * @param {Object|undefined} inlineGlobals The globals declared in the source code\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals = {}, inlineGlobals = {}) {\n  // Define configured global variables.\n  for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(inlineGlobals)])) {\n    /*\n     * `normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n     * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n     */\n    const configValue = configGlobals[id] === void 0 ? void 0 : normalizeConfigGlobal(configGlobals[id]);\n    const commentValue = inlineGlobals[id] && inlineGlobals[id].value;\n    const value = commentValue || configValue;\n    const sourceComments = inlineGlobals[id] && inlineGlobals[id].comments;\n    if (value === \"off\") {\n      continue;\n    }\n    let variable = globalScope.set.get(id);\n    if (!variable) {\n      variable = new eslintScope.Variable(id, globalScope);\n      globalScope.variables.push(variable);\n      globalScope.set.set(id, variable);\n    }\n    variable.eslintImplicitGlobalSetting = configValue;\n    variable.eslintExplicitGlobal = sourceComments !== void 0;\n    variable.eslintExplicitGlobalComments = sourceComments;\n    variable.writeable = value === \"writable\";\n  }\n\n  /*\n   * \"through\" contains all references which definitions cannot be found.\n   * Since we augment the global scope using configuration, we need to update\n   * references and remove the ones that were added by configuration.\n   */\n  globalScope.through = globalScope.through.filter(reference => {\n    const name = reference.identifier.name;\n    const variable = globalScope.set.get(name);\n    if (variable) {\n      /*\n       * Links the variable and the reference.\n       * And this reference is removed from `Scope#through`.\n       */\n      reference.resolved = variable;\n      variable.references.push(reference);\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * Sets the given variable names as exported so they won't be triggered by\n * the `no-unused-vars` rule.\n * @param {eslint.Scope} globalScope The global scope to define exports in.\n * @param {Record<string,string>} variables An object whose keys are the variable\n *      names to export.\n * @returns {void}\n */\nfunction markExportedVariables(globalScope, variables) {\n  Object.keys(variables).forEach(name => {\n    const variable = globalScope.set.get(name);\n    if (variable) {\n      variable.eslintUsed = true;\n      variable.eslintExported = true;\n    }\n  });\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst caches = Symbol(\"caches\");\n\n/**\n * Represents parsed source code.\n */\nclass SourceCode extends TokenStore {\n  /**\n   * @param {string|Object} textOrConfig The source code text or config object.\n   * @param {string} textOrConfig.text The source code text.\n   * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   * @param {Object|null} textOrConfig.parserServices The parser services.\n   * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n   * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n   * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   */\n  constructor(textOrConfig, astIfNoConfig) {\n    let text, ast, parserServices, scopeManager, visitorKeys;\n\n    // Process overloading.\n    if (typeof textOrConfig === \"string\") {\n      text = textOrConfig;\n      ast = astIfNoConfig;\n    } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n      text = textOrConfig.text;\n      ast = textOrConfig.ast;\n      parserServices = textOrConfig.parserServices;\n      scopeManager = textOrConfig.scopeManager;\n      visitorKeys = textOrConfig.visitorKeys;\n    }\n    validate(ast);\n    super(ast.tokens, ast.comments);\n\n    /**\n     * General purpose caching for the class.\n     */\n    this[caches] = new Map([[\"scopes\", new WeakMap()], [\"vars\", new Map()], [\"configNodes\", void 0]]);\n\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type {boolean}\n     */\n    this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type {string}\n     */\n    this.text = this.hasBOM ? text.slice(1) : text;\n\n    /**\n     * The parsed AST for the source code.\n     * @type {ASTNode}\n     */\n    this.ast = ast;\n\n    /**\n     * The parser services of this source code.\n     * @type {Object}\n     */\n    this.parserServices = parserServices || {};\n\n    /**\n     * The scope of this source code.\n     * @type {ScopeManager|null}\n     */\n    this.scopeManager = scopeManager || null;\n\n    /**\n     * The visitor keys to traverse AST.\n     * @type {Object}\n     */\n    this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n    // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n    const shebangMatched = this.text.match(astUtils.shebangPattern);\n    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n    if (hasShebang) {\n      ast.comments[0].type = \"Shebang\";\n    }\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type {string[]}\n     */\n    this.lines = [];\n    this.lineStartIndices = [0];\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n\n    /*\n     * Previously, this was implemented using a regex that\n     * matched a sequence of non-linebreak characters followed by a\n     * linebreak, then adding the lengths of the matches. However,\n     * this caused a catastrophic backtracking issue when the end\n     * of a file contained a large number of non-newline characters.\n     * To avoid this, the current implementation just matches newlines\n     * and uses match.index to get the correct line start indices.\n     */\n    while (match = lineEndingPattern.exec(this.text)) {\n      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n      this.lineStartIndices.push(match.index + match[0].length);\n    }\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n    // Cache for comments found using getComments().\n    this._commentCache = new WeakMap();\n\n    // don't allow further modification of this object\n    Object.freeze(this);\n    Object.freeze(this.lines);\n  }\n\n  /**\n   * Split the source code into multiple lines based on the line delimiters.\n   * @param {string} text Source code as a string.\n   * @returns {string[]} Array of source code lines.\n   * @public\n   */\n  static splitLines(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n  }\n\n  /**\n   * Gets the source code for the given node.\n   * @param {ASTNode} [node] The AST node to get the text for.\n   * @param {int} [beforeCount] The number of characters before the node to retrieve.\n   * @param {int} [afterCount] The number of characters after the node to retrieve.\n   * @returns {string} The text representing the AST node.\n   * @public\n   */\n  getText(node, beforeCount, afterCount) {\n    if (node) {\n      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));\n    }\n    return this.text;\n  }\n\n  /**\n   * Gets the entire source text split into an array of lines.\n   * @returns {Array} The source text as an array of lines.\n   * @public\n   */\n  getLines() {\n    return this.lines;\n  }\n\n  /**\n   * Retrieves an array containing all comments in the source code.\n   * @returns {ASTNode[]} An array of comment nodes.\n   * @public\n   */\n  getAllComments() {\n    return this.ast.comments;\n  }\n\n  /**\n   * Gets all comments for the given node.\n   * @param {ASTNode} node The AST node to get the comments for.\n   * @returns {Object} An object containing a leading and trailing array\n   *      of comments indexed by their position.\n   * @public\n   * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n   */\n  getComments(node) {\n    if (this._commentCache.has(node)) {\n      return this._commentCache.get(node);\n    }\n    const comments = {\n      leading: [],\n      trailing: []\n    };\n\n    /*\n     * Return all comments as leading comments of the Program node when\n     * there is no executable code.\n     */\n    if (node.type === \"Program\") {\n      if (node.body.length === 0) {\n        comments.leading = node.comments;\n      }\n    } else {\n      /*\n       * Return comments as trailing comments of nodes that only contain\n       * comments (to mimic the comment attachment behavior present in Espree).\n       */\n      if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 || node.type === \"ObjectExpression\" && node.properties.length === 0 || node.type === \"ArrayExpression\" && node.elements.length === 0 || node.type === \"SwitchStatement\" && node.cases.length === 0) {\n        comments.trailing = this.getTokens(node, {\n          includeComments: true,\n          filter: isCommentToken\n        });\n      }\n\n      /*\n       * Iterate over tokens before and after node and collect comment tokens.\n       * Do not include comments that exist outside of the parent node\n       * to avoid duplication.\n       */\n      let currentToken = this.getTokenBefore(node, {\n        includeComments: true\n      });\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.start < node.parent.start) {\n          break;\n        }\n        comments.leading.push(currentToken);\n        currentToken = this.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      }\n      comments.leading.reverse();\n      currentToken = this.getTokenAfter(node, {\n        includeComments: true\n      });\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.end > node.parent.end) {\n          break;\n        }\n        comments.trailing.push(currentToken);\n        currentToken = this.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      }\n    }\n    this._commentCache.set(node, comments);\n    return comments;\n  }\n\n  /**\n   * Retrieves the JSDoc comment for a given node.\n   * @param {ASTNode} node The AST node to get the comment for.\n   * @returns {Token|null} The Block comment token containing the JSDoc comment\n   *      for the given node or null if not found.\n   * @public\n   * @deprecated\n   */\n  getJSDocComment(node) {\n    /**\n     * Checks for the presence of a JSDoc comment for the given node and returns it.\n     * @param {ASTNode} astNode The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @private\n     */\n    const findJSDocComment = astNode => {\n      const tokenBefore = this.getTokenBefore(astNode, {\n        includeComments: true\n      });\n      if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === \"Block\" && tokenBefore.value.charAt(0) === \"*\" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {\n        return tokenBefore;\n      }\n      return null;\n    };\n    let parent = node.parent;\n    switch (node.type) {\n      case \"ClassDeclaration\":\n      case \"FunctionDeclaration\":\n        return findJSDocComment(looksLikeExport(parent) ? parent : node);\n      case \"ClassExpression\":\n        return findJSDocComment(parent.parent);\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n            parent = parent.parent;\n            if (!parent) {\n              break;\n            }\n          }\n          if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n            return findJSDocComment(parent);\n          }\n        }\n        return findJSDocComment(node);\n\n      // falls through\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Gets the deepest node containing a range index.\n   * @param {int} index Range index of the desired node.\n   * @returns {ASTNode} The node if found or null if not found.\n   * @public\n   */\n  getNodeByRangeIndex(index) {\n    let result = null;\n    Traverser.traverse(this.ast, {\n      visitorKeys: this.visitorKeys,\n      enter(node) {\n        if (node.range[0] <= index && index < node.range[1]) {\n          result = node;\n        } else {\n          this.skip();\n        }\n      },\n      leave(node) {\n        if (node === result) {\n          this.break();\n        }\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @public\n   */\n  isSpaceBetween(first, second) {\n    return isSpaceBetween(this, first, second, false);\n  }\n\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * For backward compatibility, this method returns true if there are\n   * `JSXText` tokens that contain whitespaces between the two.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @deprecated in favor of isSpaceBetween().\n   * @public\n   */\n  isSpaceBetweenTokens(first, second) {\n    return isSpaceBetween(this, first, second, true);\n  }\n\n  /**\n   * Converts a source text index into a (line, column) pair.\n   * @param {number} index The index of a character in a file\n   * @throws {TypeError} If non-numeric index or index out of range.\n   * @returns {Object} A {line, column} location object with a 0-indexed column\n   * @public\n   */\n  getLocFromIndex(index) {\n    if (typeof index !== \"number\") {\n      throw new TypeError(\"Expected `index` to be a number.\");\n    }\n    if (index < 0 || index > this.text.length) {\n      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n    }\n\n    /*\n     * For an argument of this.text.length, return the location one \"spot\" past the last character\n     * of the file. If the last character is a linebreak, the location will be column 0 of the next\n     * line; otherwise, the location will be in the next column on the same line.\n     *\n     * See getIndexFromLoc for the motivation for this special case.\n     */\n    if (index === this.text.length) {\n      return {\n        line: this.lines.length,\n        column: this.lines[this.lines.length - 1].length\n      };\n    }\n\n    /*\n     * To figure out which line index is on, determine the last place at which index could\n     * be inserted into lineStartIndices to keep the list sorted.\n     */\n    const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex(el => index < el);\n    return {\n      line: lineNumber,\n      column: index - this.lineStartIndices[lineNumber - 1]\n    };\n  }\n\n  /**\n   * Converts a (line, column) pair into a range index.\n   * @param {Object} loc A line/column location\n   * @param {number} loc.line The line number of the location (1-indexed)\n   * @param {number} loc.column The column number of the location (0-indexed)\n   * @throws {TypeError|RangeError} If `loc` is not an object with a numeric\n   *   `line` and `column`, if the `line` is less than or equal to zero or\n   *   the line or column is out of the expected range.\n   * @returns {number} The range index of the location in the file.\n   * @public\n   */\n  getIndexFromLoc(loc) {\n    if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n      throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n    }\n    if (loc.line <= 0) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n    }\n    if (loc.line > this.lineStartIndices.length) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n    }\n    const lineStartIndex = this.lineStartIndices[loc.line - 1];\n    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n    const positionIndex = lineStartIndex + loc.column;\n\n    /*\n     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n     * the given line, provided that the line number is valid element of this.lines. Since the\n     * last element of this.lines is an empty string for files with trailing newlines, add a\n     * special case where getting the index for the first location after the end of the file\n     * will return the length of the file, rather than throwing an error. This allows rules to\n     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n     */\n    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {\n      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n    }\n    return positionIndex;\n  }\n\n  /**\n   * Gets the scope for the given node\n   * @param {ASTNode} currentNode The node to get the scope of\n   * @returns {eslint-scope.Scope} The scope information for this node\n   * @throws {TypeError} If the `currentNode` argument is missing.\n   */\n  getScope(currentNode) {\n    if (!currentNode) {\n      throw new TypeError(\"Missing required argument: node.\");\n    }\n\n    // check cache first\n    const cache = this[caches].get(\"scopes\");\n    const cachedScope = cache.get(currentNode);\n    if (cachedScope) {\n      return cachedScope;\n    }\n\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n    const inner = currentNode.type !== \"Program\";\n    for (let node = currentNode; node; node = node.parent) {\n      const scope = this.scopeManager.acquire(node, inner);\n      if (scope) {\n        if (scope.type === \"function-expression-name\") {\n          cache.set(currentNode, scope.childScopes[0]);\n          return scope.childScopes[0];\n        }\n        cache.set(currentNode, scope);\n        return scope;\n      }\n    }\n    cache.set(currentNode, this.scopeManager.scopes[0]);\n    return this.scopeManager.scopes[0];\n  }\n\n  /**\n   * Get the variables that `node` defines.\n   * This is a convenience method that passes through\n   * to the same method on the `scopeManager`.\n   * @param {ASTNode} node The node for which the variables are obtained.\n   * @returns {Array<Variable>} An array of variable nodes representing\n   *      the variables that `node` defines.\n   */\n  getDeclaredVariables(node) {\n    return this.scopeManager.getDeclaredVariables(node);\n  }\n\n  /* eslint-disable class-methods-use-this -- node is owned by SourceCode */\n  /**\n   * Gets all the ancestors of a given node\n   * @param {ASTNode} node The node\n   * @returns {Array<ASTNode>} All the ancestor nodes in the AST, not including the provided node, starting\n   * from the root node at index 0 and going inwards to the parent node.\n   * @throws {TypeError} When `node` is missing.\n   */\n  getAncestors(node) {\n    if (!node) {\n      throw new TypeError(\"Missing required argument: node.\");\n    }\n    const ancestorsStartingAtParent = [];\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n      ancestorsStartingAtParent.push(ancestor);\n    }\n    return ancestorsStartingAtParent.reverse();\n  }\n  /* eslint-enable class-methods-use-this -- node is owned by SourceCode */\n\n  /**\n   * Marks a variable as used in the current scope\n   * @param {string} name The name of the variable to mark as used.\n   * @param {ASTNode} [refNode] The closest node to the variable reference.\n   * @returns {boolean} True if the variable was found and marked as used, false if not.\n   */\n  markVariableAsUsed(name, refNode = this.ast) {\n    const currentScope = this.getScope(refNode);\n    let initialScope = currentScope;\n\n    /*\n     * When we are in an ESM or CommonJS module, we need to start searching\n     * from the top-level scope, not the global scope. For ESM the top-level\n     * scope is the module scope; for CommonJS the top-level scope is the\n     * outer function scope.\n     *\n     * Without this check, we might miss a variable declared with `var` at\n     * the top-level because it won't exist in the global scope.\n     */\n    if (currentScope.type === \"global\" && currentScope.childScopes.length > 0 &&\n    // top-level scopes refer to a `Program` node\n    currentScope.childScopes[0].block === this.ast) {\n      initialScope = currentScope.childScopes[0];\n    }\n    for (let scope = initialScope; scope; scope = scope.upper) {\n      const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n      if (variable) {\n        variable.eslintUsed = true;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns an array of all inline configuration nodes found in the\n   * source code.\n   * @returns {Array<Token>} An array of all inline configuration nodes.\n   */\n  getInlineConfigNodes() {\n    // check the cache first\n    let configNodes = this[caches].get(\"configNodes\");\n    if (configNodes) {\n      return configNodes;\n    }\n\n    // calculate fresh config nodes\n    configNodes = this.ast.comments.filter(comment => {\n      // shebang comments are never directives\n      if (comment.type === \"Shebang\") {\n        return false;\n      }\n      const {\n        directivePart\n      } = commentParser.extractDirectiveComment(comment.value);\n      const directiveMatch = directivesPattern.exec(directivePart);\n      if (!directiveMatch) {\n        return false;\n      }\n\n      // only certain comment types are supported as line comments\n      return comment.type !== \"Line\" || !!/^eslint-disable-(next-)?line$/u.test(directiveMatch[1]);\n    });\n    this[caches].set(\"configNodes\", configNodes);\n    return configNodes;\n  }\n\n  /**\n   * Applies language options sent in from the core.\n   * @param {Object} languageOptions The language options for this run.\n   * @returns {void}\n   */\n  applyLanguageOptions(languageOptions) {\n    /*\n     * Add configured globals and language globals\n     *\n     * Using Object.assign instead of object spread for performance reasons\n     * https://github.com/eslint/eslint/issues/16302\n     */\n    const configGlobals = Object.assign(Object.create(null),\n    // https://github.com/eslint/eslint/issues/18363\n    getGlobalsForEcmaVersion(languageOptions.ecmaVersion), languageOptions.sourceType === \"commonjs\" ? globals.commonjs : void 0, languageOptions.globals);\n    const varsCache = this[caches].get(\"vars\");\n    varsCache.set(\"configGlobals\", configGlobals);\n  }\n\n  /**\n   * Applies configuration found inside of the source code. This method is only\n   * called when ESLint is running with inline configuration allowed.\n   * @returns {{problems:Array<Problem>,configs:{config:FlatConfigArray,node:ASTNode}}} Information\n   *      that ESLint needs to further process the inline configuration.\n   */\n  applyInlineConfig() {\n    const problems = [];\n    const configs = [];\n    const exportedVariables = {};\n    const inlineGlobals = Object.create(null);\n    this.getInlineConfigNodes().forEach(comment => {\n      const {\n        directiveText,\n        directiveValue\n      } = commentParser.parseDirective(comment);\n      switch (directiveText) {\n        case \"exported\":\n          Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n          break;\n        case \"globals\":\n        case \"global\":\n          for (const [id, {\n            value\n          }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n            let normalizedValue;\n            try {\n              normalizedValue = normalizeConfigGlobal(value);\n            } catch (err) {\n              problems.push({\n                ruleId: null,\n                loc: comment.loc,\n                message: err.message\n              });\n              continue;\n            }\n            if (inlineGlobals[id]) {\n              inlineGlobals[id].comments.push(comment);\n              inlineGlobals[id].value = normalizedValue;\n            } else {\n              inlineGlobals[id] = {\n                comments: [comment],\n                value: normalizedValue\n              };\n            }\n          }\n          break;\n        case \"eslint\":\n          {\n            const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n            if (parseResult.success) {\n              configs.push({\n                config: {\n                  rules: parseResult.config\n                },\n                node: comment\n              });\n            } else {\n              problems.push(parseResult.error);\n            }\n            break;\n          }\n\n        // no default\n      }\n    });\n\n    // save all the new variables for later\n    const varsCache = this[caches].get(\"vars\");\n    varsCache.set(\"inlineGlobals\", inlineGlobals);\n    varsCache.set(\"exportedVariables\", exportedVariables);\n    return {\n      configs,\n      problems\n    };\n  }\n\n  /**\n   * Called by ESLint core to indicate that it has finished providing\n   * information. We now add in all the missing variables and ensure that\n   * state-changing methods cannot be called by rules.\n   * @returns {void}\n   */\n  finalize() {\n    // Step 1: ensure that all of the necessary variables are up to date\n    const varsCache = this[caches].get(\"vars\");\n    const globalScope = this.scopeManager.scopes[0];\n    const configGlobals = varsCache.get(\"configGlobals\");\n    const inlineGlobals = varsCache.get(\"inlineGlobals\");\n    const exportedVariables = varsCache.get(\"exportedVariables\");\n    addDeclaredGlobals(globalScope, configGlobals, inlineGlobals);\n    if (exportedVariables) {\n      markExportedVariables(globalScope, exportedVariables);\n    }\n  }\n}\nmodule.exports = SourceCode;","map":{"version":3,"names":["isCommentToken","require","TokenStore","astUtils","Traverser","globals","directivesPattern","ConfigCommentParser","eslintScope","commentParser","validate","ast","tokens","Error","comments","loc","range","getGlobalsForEcmaVersion","ecmaVersion","es3","es5","looksLikeExport","astNode","type","sortedMerge","result","tokenIndex","commentIndex","length","push","normalizeConfigGlobal","configuredValue","nodesOrTokensOverlap","first","second","isSpaceBetween","sourceCode","checkInsideOfJSXText","startingNodeOrToken","endingNodeOrToken","firstToken","getLastToken","finalToken","getFirstToken","currentToken","nextToken","getTokenAfter","includeComments","test","value","addDeclaredGlobals","globalScope","configGlobals","inlineGlobals","id","Set","Object","keys","configValue","commentValue","sourceComments","variable","set","get","Variable","variables","eslintImplicitGlobalSetting","eslintExplicitGlobal","eslintExplicitGlobalComments","writeable","through","filter","reference","name","identifier","resolved","references","markExportedVariables","forEach","eslintUsed","eslintExported","caches","Symbol","SourceCode","constructor","textOrConfig","astIfNoConfig","text","parserServices","scopeManager","visitorKeys","Map","WeakMap","hasBOM","charCodeAt","slice","DEFAULT_VISITOR_KEYS","shebangMatched","match","shebangPattern","hasShebang","tokensAndComments","lines","lineStartIndices","lineEndingPattern","createGlobalLinebreakMatcher","exec","index","_commentCache","freeze","splitLines","split","getText","node","beforeCount","afterCount","Math","max","getLines","getAllComments","getComments","has","leading","trailing","body","properties","elements","cases","getTokens","getTokenBefore","parent","start","reverse","end","getJSDocComment","findJSDocComment","tokenBefore","charAt","line","getCommentsBefore","getNodeByRangeIndex","traverse","enter","skip","leave","break","isSpaceBetweenTokens","getLocFromIndex","TypeError","RangeError","column","lineNumber","findIndex","el","getIndexFromLoc","lineStartIndex","lineEndIndex","positionIndex","getScope","currentNode","cache","cachedScope","inner","scope","acquire","childScopes","scopes","getDeclaredVariables","getAncestors","ancestorsStartingAtParent","ancestor","markVariableAsUsed","refNode","currentScope","initialScope","block","upper","find","scopeVar","getInlineConfigNodes","configNodes","comment","directivePart","extractDirectiveComment","directiveMatch","applyLanguageOptions","languageOptions","assign","create","sourceType","commonjs","varsCache","applyInlineConfig","problems","configs","exportedVariables","directiveText","directiveValue","parseDirective","parseStringConfig","entries","normalizedValue","err","ruleId","message","parseResult","parseJsonConfig","success","config","rules","error","finalize","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/source-code/source-code.js"],"sourcesContent":["/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    { isCommentToken } = require(\"@eslint-community/eslint-utils\"),\n    TokenStore = require(\"./token-store\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    Traverser = require(\"../shared/traverser\"),\n    globals = require(\"../../conf/globals\"),\n    {\n        directivesPattern\n    } = require(\"../shared/directives\"),\n\n    /* eslint-disable-next-line n/no-restricted-require -- Too messy to figure out right now. */\n    ConfigCommentParser = require(\"../linter/config-comment-parser\"),\n    eslintScope = require(\"eslint-scope\");\n\n//------------------------------------------------------------------------------\n// Type Definitions\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst commentParser = new ConfigCommentParser();\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Retrieves globals for the given ecmaVersion.\n * @param {number} ecmaVersion The version to retrieve globals for.\n * @returns {Object} The globals for the given ecmaVersion.\n */\nfunction getGlobalsForEcmaVersion(ecmaVersion) {\n\n    switch (ecmaVersion) {\n        case 3:\n            return globals.es3;\n\n        case 5:\n            return globals.es5;\n\n        default:\n            if (ecmaVersion < 2015) {\n                return globals[`es${ecmaVersion + 2009}`];\n            }\n\n            return globals[`es${ecmaVersion}`];\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Normalizes a value for a global in a config\n * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n * a global directive comment\n * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n * @throws Error if global value is invalid\n */\nfunction normalizeConfigGlobal(configuredValue) {\n    switch (configuredValue) {\n        case \"off\":\n            return \"off\";\n\n        case true:\n        case \"true\":\n        case \"writeable\":\n        case \"writable\":\n            return \"writable\";\n\n        case null:\n        case false:\n        case \"false\":\n        case \"readable\":\n        case \"readonly\":\n            return \"readonly\";\n\n        default:\n            throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);\n    }\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n    if (nodesOrTokensOverlap(first, second)) {\n        return false;\n    }\n\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\n        ? [first, second]\n        : [second, first];\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n    let currentToken = firstToken;\n\n    while (currentToken !== finalToken) {\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n\n        if (\n            currentToken.range[1] !== nextToken.range[0] ||\n\n                /*\n                 * For backward compatibility, check spaces in JSXText.\n                 * https://github.com/eslint/eslint/issues/12614\n                 */\n                (\n                    checkInsideOfJSXText &&\n                    nextToken !== finalToken &&\n                    nextToken.type === \"JSXText\" &&\n                    /\\s/u.test(nextToken.value)\n                )\n        ) {\n            return true;\n        }\n\n        currentToken = nextToken;\n    }\n\n    return false;\n}\n\n//-----------------------------------------------------------------------------\n// Directive Comments\n//-----------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object|undefined} configGlobals The globals declared in configuration\n * @param {Object|undefined} inlineGlobals The globals declared in the source code\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals = {}, inlineGlobals = {}) {\n\n    // Define configured global variables.\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(inlineGlobals)])) {\n\n        /*\n         * `normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n        const configValue = configGlobals[id] === void 0 ? void 0 : normalizeConfigGlobal(configGlobals[id]);\n        const commentValue = inlineGlobals[id] && inlineGlobals[id].value;\n        const value = commentValue || configValue;\n        const sourceComments = inlineGlobals[id] && inlineGlobals[id].comments;\n\n        if (value === \"off\") {\n            continue;\n        }\n\n        let variable = globalScope.set.get(id);\n\n        if (!variable) {\n            variable = new eslintScope.Variable(id, globalScope);\n\n            globalScope.variables.push(variable);\n            globalScope.set.set(id, variable);\n        }\n\n        variable.eslintImplicitGlobalSetting = configValue;\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\n        variable.eslintExplicitGlobalComments = sourceComments;\n        variable.writeable = (value === \"writable\");\n    }\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * Sets the given variable names as exported so they won't be triggered by\n * the `no-unused-vars` rule.\n * @param {eslint.Scope} globalScope The global scope to define exports in.\n * @param {Record<string,string>} variables An object whose keys are the variable\n *      names to export.\n * @returns {void}\n */\nfunction markExportedVariables(globalScope, variables) {\n\n    Object.keys(variables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            variable.eslintExported = true;\n        }\n    });\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst caches = Symbol(\"caches\");\n\n/**\n * Represents parsed source code.\n */\nclass SourceCode extends TokenStore {\n\n    /**\n     * @param {string|Object} textOrConfig The source code text or config object.\n     * @param {string} textOrConfig.text The source code text.\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {Object|null} textOrConfig.parserServices The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading.\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * General purpose caching for the class.\n         */\n        this[caches] = new Map([\n            [\"scopes\", new WeakMap()],\n            [\"vars\", new Map()],\n            [\"configNodes\", void 0]\n        ]);\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type {boolean}\n         */\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type {string}\n         */\n        this.text = (this.hasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type {ASTNode}\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type {string[]}\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n        // Cache for comments found using getComments().\n        this._commentCache = new WeakMap();\n\n        // don't allow further modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode} [node] The AST node to get the text for.\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} An object containing a leading and trailing array\n     *      of comments indexed by their position.\n     * @public\n     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n     */\n    getComments(node) {\n        if (this._commentCache.has(node)) {\n            return this._commentCache.get(node);\n        }\n\n        const comments = {\n            leading: [],\n            trailing: []\n        };\n\n        /*\n         * Return all comments as leading comments of the Program node when\n         * there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                comments.leading = node.comments;\n            }\n        } else {\n\n            /*\n             * Return comments as trailing comments of nodes that only contain\n             * comments (to mimic the comment attachment behavior present in Espree).\n             */\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\n                node.type === \"SwitchStatement\" && node.cases.length === 0\n            ) {\n                comments.trailing = this.getTokens(node, {\n                    includeComments: true,\n                    filter: isCommentToken\n                });\n            }\n\n            /*\n             * Iterate over tokens before and after node and collect comment tokens.\n             * Do not include comments that exist outside of the parent node\n             * to avoid duplication.\n             */\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.start < node.parent.start)) {\n                    break;\n                }\n                comments.leading.push(currentToken);\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\n            }\n\n            comments.leading.reverse();\n\n            currentToken = this.getTokenAfter(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.end > node.parent.end)) {\n                    break;\n                }\n                comments.trailing.push(currentToken);\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\n            }\n        }\n\n        this._commentCache.set(node, comments);\n        return comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @public\n     */\n    isSpaceBetween(first, second) {\n        return isSpaceBetween(this, first, second, false);\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespaces between the two.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween().\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        return isSpaceBetween(this, first, second, true);\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @throws {TypeError} If non-numeric index or index out of range.\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line index is on, determine the last place at which index could\n         * be inserted into lineStartIndices to keep the list sorted.\n         */\n        const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1]\n            ? this.lineStartIndices.length\n            : this.lineStartIndices.findIndex(el => index < el);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric\n     *   `line` and `column`, if the `line` is less than or equal to zero or\n     *   the line or column is out of the expected range.\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n\n    /**\n     * Gets the scope for the given node\n     * @param {ASTNode} currentNode The node to get the scope of\n     * @returns {eslint-scope.Scope} The scope information for this node\n     * @throws {TypeError} If the `currentNode` argument is missing.\n     */\n    getScope(currentNode) {\n\n        if (!currentNode) {\n            throw new TypeError(\"Missing required argument: node.\");\n        }\n\n        // check cache first\n        const cache = this[caches].get(\"scopes\");\n        const cachedScope = cache.get(currentNode);\n\n        if (cachedScope) {\n            return cachedScope;\n        }\n\n        // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n        const inner = currentNode.type !== \"Program\";\n\n        for (let node = currentNode; node; node = node.parent) {\n            const scope = this.scopeManager.acquire(node, inner);\n\n            if (scope) {\n                if (scope.type === \"function-expression-name\") {\n                    cache.set(currentNode, scope.childScopes[0]);\n                    return scope.childScopes[0];\n                }\n\n                cache.set(currentNode, scope);\n                return scope;\n            }\n        }\n\n        cache.set(currentNode, this.scopeManager.scopes[0]);\n        return this.scopeManager.scopes[0];\n    }\n\n    /**\n     * Get the variables that `node` defines.\n     * This is a convenience method that passes through\n     * to the same method on the `scopeManager`.\n     * @param {ASTNode} node The node for which the variables are obtained.\n     * @returns {Array<Variable>} An array of variable nodes representing\n     *      the variables that `node` defines.\n     */\n    getDeclaredVariables(node) {\n        return this.scopeManager.getDeclaredVariables(node);\n    }\n\n    /* eslint-disable class-methods-use-this -- node is owned by SourceCode */\n    /**\n     * Gets all the ancestors of a given node\n     * @param {ASTNode} node The node\n     * @returns {Array<ASTNode>} All the ancestor nodes in the AST, not including the provided node, starting\n     * from the root node at index 0 and going inwards to the parent node.\n     * @throws {TypeError} When `node` is missing.\n     */\n    getAncestors(node) {\n\n        if (!node) {\n            throw new TypeError(\"Missing required argument: node.\");\n        }\n\n        const ancestorsStartingAtParent = [];\n\n        for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            ancestorsStartingAtParent.push(ancestor);\n        }\n\n        return ancestorsStartingAtParent.reverse();\n    }\n    /* eslint-enable class-methods-use-this -- node is owned by SourceCode */\n\n    /**\n     * Marks a variable as used in the current scope\n     * @param {string} name The name of the variable to mark as used.\n     * @param {ASTNode} [refNode] The closest node to the variable reference.\n     * @returns {boolean} True if the variable was found and marked as used, false if not.\n     */\n    markVariableAsUsed(name, refNode = this.ast) {\n\n        const currentScope = this.getScope(refNode);\n        let initialScope = currentScope;\n\n        /*\n         * When we are in an ESM or CommonJS module, we need to start searching\n         * from the top-level scope, not the global scope. For ESM the top-level\n         * scope is the module scope; for CommonJS the top-level scope is the\n         * outer function scope.\n         *\n         * Without this check, we might miss a variable declared with `var` at\n         * the top-level because it won't exist in the global scope.\n         */\n        if (\n            currentScope.type === \"global\" &&\n            currentScope.childScopes.length > 0 &&\n\n            // top-level scopes refer to a `Program` node\n            currentScope.childScopes[0].block === this.ast\n        ) {\n            initialScope = currentScope.childScopes[0];\n        }\n\n        for (let scope = initialScope; scope; scope = scope.upper) {\n            const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n            if (variable) {\n                variable.eslintUsed = true;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Returns an array of all inline configuration nodes found in the\n     * source code.\n     * @returns {Array<Token>} An array of all inline configuration nodes.\n     */\n    getInlineConfigNodes() {\n\n        // check the cache first\n        let configNodes = this[caches].get(\"configNodes\");\n\n        if (configNodes) {\n            return configNodes;\n        }\n\n        // calculate fresh config nodes\n        configNodes = this.ast.comments.filter(comment => {\n\n            // shebang comments are never directives\n            if (comment.type === \"Shebang\") {\n                return false;\n            }\n\n            const { directivePart } = commentParser.extractDirectiveComment(comment.value);\n\n            const directiveMatch = directivesPattern.exec(directivePart);\n\n            if (!directiveMatch) {\n                return false;\n            }\n\n            // only certain comment types are supported as line comments\n            return comment.type !== \"Line\" || !!/^eslint-disable-(next-)?line$/u.test(directiveMatch[1]);\n        });\n\n        this[caches].set(\"configNodes\", configNodes);\n\n        return configNodes;\n    }\n\n    /**\n     * Applies language options sent in from the core.\n     * @param {Object} languageOptions The language options for this run.\n     * @returns {void}\n     */\n    applyLanguageOptions(languageOptions) {\n\n        /*\n         * Add configured globals and language globals\n         *\n         * Using Object.assign instead of object spread for performance reasons\n         * https://github.com/eslint/eslint/issues/16302\n         */\n        const configGlobals = Object.assign(\n            Object.create(null), // https://github.com/eslint/eslint/issues/18363\n            getGlobalsForEcmaVersion(languageOptions.ecmaVersion),\n            languageOptions.sourceType === \"commonjs\" ? globals.commonjs : void 0,\n            languageOptions.globals\n        );\n        const varsCache = this[caches].get(\"vars\");\n\n        varsCache.set(\"configGlobals\", configGlobals);\n    }\n\n    /**\n     * Applies configuration found inside of the source code. This method is only\n     * called when ESLint is running with inline configuration allowed.\n     * @returns {{problems:Array<Problem>,configs:{config:FlatConfigArray,node:ASTNode}}} Information\n     *      that ESLint needs to further process the inline configuration.\n     */\n    applyInlineConfig() {\n\n        const problems = [];\n        const configs = [];\n        const exportedVariables = {};\n        const inlineGlobals = Object.create(null);\n\n        this.getInlineConfigNodes().forEach(comment => {\n\n            const { directiveText, directiveValue } = commentParser.parseDirective(comment);\n\n            switch (directiveText) {\n                case \"exported\":\n                    Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n                    break;\n\n                case \"globals\":\n                case \"global\":\n                    for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n                        let normalizedValue;\n\n                        try {\n                            normalizedValue = normalizeConfigGlobal(value);\n                        } catch (err) {\n                            problems.push({\n                                ruleId: null,\n                                loc: comment.loc,\n                                message: err.message\n                            });\n                            continue;\n                        }\n\n                        if (inlineGlobals[id]) {\n                            inlineGlobals[id].comments.push(comment);\n                            inlineGlobals[id].value = normalizedValue;\n                        } else {\n                            inlineGlobals[id] = {\n                                comments: [comment],\n                                value: normalizedValue\n                            };\n                        }\n                    }\n                    break;\n\n                case \"eslint\": {\n                    const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n                    if (parseResult.success) {\n                        configs.push({\n                            config: {\n                                rules: parseResult.config\n                            },\n                            node: comment\n                        });\n                    } else {\n                        problems.push(parseResult.error);\n                    }\n\n                    break;\n                }\n\n                // no default\n            }\n        });\n\n        // save all the new variables for later\n        const varsCache = this[caches].get(\"vars\");\n\n        varsCache.set(\"inlineGlobals\", inlineGlobals);\n        varsCache.set(\"exportedVariables\", exportedVariables);\n\n        return {\n            configs,\n            problems\n        };\n    }\n\n    /**\n     * Called by ESLint core to indicate that it has finished providing\n     * information. We now add in all the missing variables and ensure that\n     * state-changing methods cannot be called by rules.\n     * @returns {void}\n     */\n    finalize() {\n\n        // Step 1: ensure that all of the necessary variables are up to date\n        const varsCache = this[caches].get(\"vars\");\n        const globalScope = this.scopeManager.scopes[0];\n        const configGlobals = varsCache.get(\"configGlobals\");\n        const inlineGlobals = varsCache.get(\"inlineGlobals\");\n        const exportedVariables = varsCache.get(\"exportedVariables\");\n\n        addDeclaredGlobals(globalScope, configGlobals, inlineGlobals);\n\n        if (exportedVariables) {\n            markExportedVariables(globalScope, exportedVariables);\n        }\n\n    }\n\n}\n\nmodule.exports = SourceCode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}