{"ast":null,"code":"/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n  const emptyLines = lines.map((line, i) => ({\n    code: line.trim(),\n    num: i + 1\n  })).filter(line => !line.code).map(line => line.num);\n  return emptyLines;\n}\n\n/**\n * Return an array with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n  const lines = [];\n  comments.forEach(token => {\n    const start = token.loc.start.line;\n    const end = token.loc.end.line;\n    lines.push(start, end);\n  });\n  return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Require empty lines around comments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/lines-around-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        beforeBlockComment: {\n          type: \"boolean\",\n          default: true\n        },\n        afterBlockComment: {\n          type: \"boolean\",\n          default: false\n        },\n        beforeLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        afterLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockStart: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockEnd: {\n          type: \"boolean\",\n          default: false\n        },\n        allowClassStart: {\n          type: \"boolean\"\n        },\n        allowClassEnd: {\n          type: \"boolean\"\n        },\n        allowObjectStart: {\n          type: \"boolean\"\n        },\n        allowObjectEnd: {\n          type: \"boolean\"\n        },\n        allowArrayStart: {\n          type: \"boolean\"\n        },\n        allowArrayEnd: {\n          type: \"boolean\"\n        },\n        ignorePattern: {\n          type: \"string\"\n        },\n        applyDefaultIgnorePatterns: {\n          type: \"boolean\"\n        },\n        afterHashbangComment: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      after: \"Expected line after comment.\",\n      before: \"Expected line before comment.\"\n    }\n  },\n  create(context) {\n    const options = Object.assign({}, context.options[0]);\n    const ignorePattern = options.ignorePattern;\n    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n    const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n    options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n    const sourceCode = context.sourceCode;\n    const lines = sourceCode.lines,\n      numLines = lines.length + 1,\n      comments = sourceCode.getAllComments(),\n      commentLines = getCommentLineNums(comments),\n      emptyLines = getEmptyLineNums(lines),\n      commentAndEmptyLines = new Set(commentLines.concat(emptyLines));\n\n    /**\n     * Returns whether or not comments are on lines starting with or ending with code\n     * @param {token} token The comment token to check.\n     * @returns {boolean} True if the comment is not alone.\n     */\n    function codeAroundComment(token) {\n      let currentToken = token;\n      do {\n        currentToken = sourceCode.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n      if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n        return true;\n      }\n      currentToken = token;\n      do {\n        currentToken = sourceCode.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n      if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns whether or not comments are inside a node type or not.\n     * @param {ASTNode} parent The Comment parent node.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is inside nodeType.\n     */\n    function isParentNodeType(parent, nodeType) {\n      return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;\n    }\n\n    /**\n     * Returns the parent node that contains the given token.\n     * @param {token} token The token to check.\n     * @returns {ASTNode|null} The parent node that contains the given token.\n     */\n    function getParentNodeOfToken(token) {\n      const node = sourceCode.getNodeByRangeIndex(token.range[0]);\n\n      /*\n       * For the purpose of this rule, the comment token is in a `StaticBlock` node only\n       * if it's inside the braces of that `StaticBlock` node.\n       *\n       * Example where this function returns `null`:\n       *\n       *   static\n       *   // comment\n       *   {\n       *   }\n       *\n       * Example where this function returns `StaticBlock` node:\n       *\n       *   static\n       *   {\n       *   // comment\n       *   }\n       *\n       */\n      if (node && node.type === \"StaticBlock\") {\n        const openingBrace = sourceCode.getFirstToken(node, {\n          skip: 1\n        }); // skip the `static` token\n\n        return token.range[0] >= openingBrace.range[0] ? node : null;\n      }\n      return node;\n    }\n\n    /**\n     * Returns whether or not comments are at the parent start or not.\n     * @param {token} token The Comment token.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is at parent start.\n     */\n    function isCommentAtParentStart(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      if (parent && isParentNodeType(parent, nodeType)) {\n        let parentStartNodeOrToken = parent;\n        if (parent.type === \"StaticBlock\") {\n          parentStartNodeOrToken = sourceCode.getFirstToken(parent, {\n            skip: 1\n          }); // opening brace of the static block\n        } else if (parent.type === \"SwitchStatement\") {\n          parentStartNodeOrToken = sourceCode.getTokenAfter(parent.discriminant, {\n            filter: astUtils.isOpeningBraceToken\n          }); // opening brace of the switch statement\n        }\n        return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;\n      }\n      return false;\n    }\n\n    /**\n     * Returns whether or not comments are at the parent end or not.\n     * @param {token} token The Comment token.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is at parent end.\n     */\n    function isCommentAtParentEnd(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      return !!parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;\n    }\n\n    /**\n     * Returns whether or not comments are at the block start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at block start.\n     */\n    function isCommentAtBlockStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"StaticBlock\") || isCommentAtParentStart(token, \"SwitchCase\") || isCommentAtParentStart(token, \"SwitchStatement\");\n    }\n\n    /**\n     * Returns whether or not comments are at the block end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at block end.\n     */\n    function isCommentAtBlockEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"StaticBlock\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n    }\n\n    /**\n     * Returns whether or not comments are at the class start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at class start.\n     */\n    function isCommentAtClassStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\");\n    }\n\n    /**\n     * Returns whether or not comments are at the class end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at class end.\n     */\n    function isCommentAtClassEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\");\n    }\n\n    /**\n     * Returns whether or not comments are at the object start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at object start.\n     */\n    function isCommentAtObjectStart(token) {\n      return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n    }\n\n    /**\n     * Returns whether or not comments are at the object end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at object end.\n     */\n    function isCommentAtObjectEnd(token) {\n      return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n    }\n\n    /**\n     * Returns whether or not comments are at the array start or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at array start.\n     */\n    function isCommentAtArrayStart(token) {\n      return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n    }\n\n    /**\n     * Returns whether or not comments are at the array end or not.\n     * @param {token} token The Comment token.\n     * @returns {boolean} True if the comment is at array end.\n     */\n    function isCommentAtArrayEnd(token) {\n      return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n    }\n\n    /**\n     * Checks if a comment token has lines around it (ignores inline comments)\n     * @param {token} token The Comment token.\n     * @param {Object} opts Options to determine the newline.\n     * @param {boolean} opts.after Should have a newline after this line.\n     * @param {boolean} opts.before Should have a newline before this line.\n     * @returns {void}\n     */\n    function checkForEmptyLine(token, opts) {\n      if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n        return;\n      }\n      if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n        return;\n      }\n      let after = opts.after,\n        before = opts.before;\n      const prevLineNum = token.loc.start.line - 1,\n        nextLineNum = token.loc.end.line + 1,\n        commentIsNotAlone = codeAroundComment(token);\n      const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),\n        blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n        classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n        classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n        objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n        objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n        arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n        arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n      const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n      const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n      // ignore top of the file and bottom of the file\n      if (prevLineNum < 1) {\n        before = false;\n      }\n      if (nextLineNum >= numLines) {\n        after = false;\n      }\n\n      // we ignore all inline comments\n      if (commentIsNotAlone) {\n        return;\n      }\n      const previousTokenOrComment = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      const nextTokenOrComment = sourceCode.getTokenAfter(token, {\n        includeComments: true\n      });\n\n      // check for newline before\n      if (!exceptionStartAllowed && before && !commentAndEmptyLines.has(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n        const lineStart = token.range[0] - token.loc.start.column;\n        const range = [lineStart, lineStart];\n        context.report({\n          node: token,\n          messageId: \"before\",\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\n\");\n          }\n        });\n      }\n\n      // check for newline after\n      if (!exceptionEndAllowed && after && !commentAndEmptyLines.has(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n        context.report({\n          node: token,\n          messageId: \"after\",\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \"\\n\");\n          }\n        });\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program() {\n        comments.forEach(token => {\n          if (token.type === \"Line\") {\n            if (options.beforeLineComment || options.afterLineComment) {\n              checkForEmptyLine(token, {\n                after: options.afterLineComment,\n                before: options.beforeLineComment\n              });\n            }\n          } else if (token.type === \"Block\") {\n            if (options.beforeBlockComment || options.afterBlockComment) {\n              checkForEmptyLine(token, {\n                after: options.afterBlockComment,\n                before: options.beforeBlockComment\n              });\n            }\n          } else if (token.type === \"Shebang\") {\n            if (options.afterHashbangComment) {\n              checkForEmptyLine(token, {\n                after: options.afterHashbangComment,\n                before: false\n              });\n            }\n          }\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","getEmptyLineNums","lines","emptyLines","map","line","i","code","trim","num","filter","getCommentLineNums","comments","forEach","token","start","loc","end","push","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","properties","beforeBlockComment","default","afterBlockComment","beforeLineComment","afterLineComment","allowBlockStart","allowBlockEnd","allowClassStart","allowClassEnd","allowObjectStart","allowObjectEnd","allowArrayStart","allowArrayEnd","ignorePattern","applyDefaultIgnorePatterns","afterHashbangComment","additionalProperties","messages","after","before","create","context","options","Object","assign","defaultIgnoreRegExp","COMMENTS_IGNORE_PATTERN","customIgnoreRegExp","RegExp","sourceCode","numLines","length","getAllComments","commentLines","commentAndEmptyLines","Set","concat","codeAroundComment","currentToken","getTokenBefore","includeComments","isCommentToken","isTokenOnSameLine","getTokenAfter","isParentNodeType","parent","nodeType","body","consequent","getParentNodeOfToken","node","getNodeByRangeIndex","range","openingBrace","getFirstToken","skip","isCommentAtParentStart","parentStartNodeOrToken","discriminant","isOpeningBraceToken","isCommentAtParentEnd","isCommentAtBlockStart","isCommentAtBlockEnd","isCommentAtClassStart","isCommentAtClassEnd","isCommentAtObjectStart","isCommentAtObjectEnd","isCommentAtArrayStart","isCommentAtArrayEnd","checkForEmptyLine","opts","test","value","prevLineNum","nextLineNum","commentIsNotAlone","blockStartAllowed","blockEndAllowed","classStartAllowed","classEndAllowed","objectStartAllowed","objectEndAllowed","arrayStartAllowed","arrayEndAllowed","exceptionStartAllowed","exceptionEndAllowed","previousTokenOrComment","nextTokenOrComment","has","lineStart","column","report","messageId","fix","fixer","insertTextBeforeRange","insertTextAfter","Program"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/lines-around-comment.js"],"sourcesContent":["/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Require empty lines around comments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/lines-around-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    afterLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowClassStart: {\n                        type: \"boolean\"\n                    },\n                    allowClassEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    },\n                    afterHashbangComment: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            after: \"Expected line after comment.\",\n            before: \"Expected line before comment.\"\n        }\n    },\n\n    create(context) {\n\n        const options = Object.assign({}, context.options[0]);\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n\n        const sourceCode = context.sourceCode;\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = new Set(commentLines.concat(emptyLines));\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {token} token The comment token to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(token) {\n            let currentToken = token;\n\n            do {\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n                return true;\n            }\n\n            currentToken = token;\n            do {\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns the parent node that contains the given token.\n         * @param {token} token The token to check.\n         * @returns {ASTNode|null} The parent node that contains the given token.\n         */\n        function getParentNodeOfToken(token) {\n            const node = sourceCode.getNodeByRangeIndex(token.range[0]);\n\n            /*\n             * For the purpose of this rule, the comment token is in a `StaticBlock` node only\n             * if it's inside the braces of that `StaticBlock` node.\n             *\n             * Example where this function returns `null`:\n             *\n             *   static\n             *   // comment\n             *   {\n             *   }\n             *\n             * Example where this function returns `StaticBlock` node:\n             *\n             *   static\n             *   {\n             *   // comment\n             *   }\n             *\n             */\n            if (node && node.type === \"StaticBlock\") {\n                const openingBrace = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\n\n                return token.range[0] >= openingBrace.range[0]\n                    ? node\n                    : null;\n            }\n\n            return node;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            if (parent && isParentNodeType(parent, nodeType)) {\n                let parentStartNodeOrToken = parent;\n\n                if (parent.type === \"StaticBlock\") {\n                    parentStartNodeOrToken = sourceCode.getFirstToken(parent, { skip: 1 }); // opening brace of the static block\n                } else if (parent.type === \"SwitchStatement\") {\n                    parentStartNodeOrToken = sourceCode.getTokenAfter(parent.discriminant, {\n                        filter: astUtils.isOpeningBraceToken\n                    }); // opening brace of the switch statement\n                }\n\n                return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return !!parent && isParentNodeType(parent, nodeType) &&\n                    parent.loc.end.line - token.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(token) {\n            return (\n                isCommentAtParentStart(token, \"ClassBody\") ||\n                isCommentAtParentStart(token, \"BlockStatement\") ||\n                isCommentAtParentStart(token, \"StaticBlock\") ||\n                isCommentAtParentStart(token, \"SwitchCase\") ||\n                isCommentAtParentStart(token, \"SwitchStatement\")\n            );\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(token) {\n            return (\n                isCommentAtParentEnd(token, \"ClassBody\") ||\n                isCommentAtParentEnd(token, \"BlockStatement\") ||\n                isCommentAtParentEnd(token, \"StaticBlock\") ||\n                isCommentAtParentEnd(token, \"SwitchCase\") ||\n                isCommentAtParentEnd(token, \"SwitchStatement\")\n            );\n        }\n\n        /**\n         * Returns whether or not comments are at the class start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class start.\n         */\n        function isCommentAtClassStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class end.\n         */\n        function isCommentAtClassEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(token) {\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(token) {\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(token) {\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(token) {\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment token has lines around it (ignores inline comments)\n         * @param {token} token The Comment token.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(token, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = token.loc.start.line - 1,\n                nextLineNum = token.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(token);\n\n            const blockStartAllowed = options.allowBlockStart &&\n                    isCommentAtBlockStart(token) &&\n                    !(options.allowClassStart === false &&\n                    isCommentAtClassStart(token)),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n                classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n                classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n            const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !commentAndEmptyLines.has(prevLineNum) &&\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n                const lineStart = token.range[0] - token.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node: token,\n                    messageId: \"before\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !commentAndEmptyLines.has(nextLineNum) &&\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n                context.report({\n                    node: token,\n                    messageId: \"after\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                comments.forEach(token => {\n                    if (token.type === \"Line\") {\n                        if (options.beforeLineComment || options.afterLineComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterLineComment,\n                                before: options.beforeLineComment\n                            });\n                        }\n                    } else if (token.type === \"Block\") {\n                        if (options.beforeBlockComment || options.afterBlockComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterBlockComment,\n                                before: options.beforeBlockComment\n                            });\n                        }\n                    } else if (token.type === \"Shebang\") {\n                        if (options.afterHashbangComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterHashbangComment,\n                                before: false\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}