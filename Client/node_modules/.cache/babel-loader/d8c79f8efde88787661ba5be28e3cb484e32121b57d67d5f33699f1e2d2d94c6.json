{"ast":null,"code":"/**\n * @fileoverview Rule Validator\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\nconst ajvImport = require(\"../shared/ajv\");\nconst ajv = ajvImport();\nconst {\n  parseRuleId,\n  getRuleFromConfig,\n  getRuleOptionsSchema\n} = require(\"./flat-config-helpers\");\nconst ruleReplacements = require(\"../../conf/replacements.json\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Throws a helpful error when a rule cannot be found.\n * @param {Object} ruleId The rule identifier.\n * @param {string} ruleId.pluginName The ID of the rule to find.\n * @param {string} ruleId.ruleName The ID of the rule to find.\n * @param {Object} config The config to search in.\n * @throws {TypeError} For missing plugin or rule.\n * @returns {void}\n */\nfunction throwRuleNotFoundError({\n  pluginName,\n  ruleName\n}, config) {\n  const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\n  const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\n  let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\".`;\n\n  // if the plugin exists then we need to check if the rule exists\n  if (config.plugins && config.plugins[pluginName]) {\n    const replacementRuleName = ruleReplacements.rules[ruleName];\n    if (pluginName === \"@\" && replacementRuleName) {\n      errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\n    } else {\n      errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`;\n\n      // otherwise, let's see if we can find the rule name elsewhere\n      for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\n        if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\n          errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\n          break;\n        }\n      }\n    }\n\n    // falls through to throw error\n  }\n  throw new TypeError(errorMessage);\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Implements validation functionality for the rules portion of a config.\n */\nclass RuleValidator {\n  /**\n   * Creates a new instance.\n   */\n  constructor() {\n    /**\n     * A collection of compiled validators for rules that have already\n     * been validated.\n     * @type {WeakMap}\n     */\n    this.validators = new WeakMap();\n  }\n\n  /**\n   * Validates all of the rule configurations in a config against each\n   * rule's schema.\n   * @param {Object} config The full config to validate. This object must\n   *      contain both the rules section and the plugins section.\n   * @returns {void}\n   * @throws {Error} If a rule's configuration does not match its schema.\n   */\n  validate(config) {\n    if (!config.rules) {\n      return;\n    }\n    for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\n      // check for edge case\n      if (ruleId === \"__proto__\") {\n        continue;\n      }\n\n      /*\n       * If a rule is disabled, we don't do any validation. This allows\n       * users to safely set any value to 0 or \"off\" without worrying\n       * that it will cause a validation error.\n       *\n       * Note: ruleOptions is always an array at this point because\n       * this validation occurs after FlatConfigArray has merged and\n       * normalized values.\n       */\n      if (ruleOptions[0] === 0) {\n        continue;\n      }\n      const rule = getRuleFromConfig(ruleId, config);\n      if (!rule) {\n        throwRuleNotFoundError(parseRuleId(ruleId), config);\n      }\n\n      // Precompile and cache validator the first time\n      if (!this.validators.has(rule)) {\n        const schema = getRuleOptionsSchema(rule);\n        if (schema) {\n          this.validators.set(rule, ajv.compile(schema));\n        }\n      }\n      const validateRule = this.validators.get(rule);\n      if (validateRule) {\n        validateRule(ruleOptions.slice(1));\n        if (validateRule.errors) {\n          throw new Error(`Key \"rules\": Key \"${ruleId}\": ${validateRule.errors.map(error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`).join(\"\")}`);\n        }\n      }\n    }\n  }\n}\nexports.RuleValidator = RuleValidator;","map":{"version":3,"names":["ajvImport","require","ajv","parseRuleId","getRuleFromConfig","getRuleOptionsSchema","ruleReplacements","throwRuleNotFoundError","pluginName","ruleName","config","ruleId","errorMessageHeader","errorMessage","plugins","replacementRuleName","rules","otherPluginName","otherPlugin","Object","entries","TypeError","RuleValidator","constructor","validators","WeakMap","validate","ruleOptions","rule","has","schema","set","compile","validateRule","get","slice","errors","Error","map","error","JSON","stringify","data","message","join","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/config/rule-validator.js"],"sourcesContent":["/**\n * @fileoverview Rule Validator\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst ajvImport = require(\"../shared/ajv\");\nconst ajv = ajvImport();\nconst {\n    parseRuleId,\n    getRuleFromConfig,\n    getRuleOptionsSchema\n} = require(\"./flat-config-helpers\");\nconst ruleReplacements = require(\"../../conf/replacements.json\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Throws a helpful error when a rule cannot be found.\n * @param {Object} ruleId The rule identifier.\n * @param {string} ruleId.pluginName The ID of the rule to find.\n * @param {string} ruleId.ruleName The ID of the rule to find.\n * @param {Object} config The config to search in.\n * @throws {TypeError} For missing plugin or rule.\n * @returns {void}\n */\nfunction throwRuleNotFoundError({ pluginName, ruleName }, config) {\n\n    const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\n\n    const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\n    let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\".`;\n\n    // if the plugin exists then we need to check if the rule exists\n    if (config.plugins && config.plugins[pluginName]) {\n        const replacementRuleName = ruleReplacements.rules[ruleName];\n\n        if (pluginName === \"@\" && replacementRuleName) {\n\n            errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\n\n        } else {\n\n            errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`;\n\n            // otherwise, let's see if we can find the rule name elsewhere\n            for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\n                if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\n                    errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\n                    break;\n                }\n            }\n\n        }\n\n        // falls through to throw error\n    }\n\n    throw new TypeError(errorMessage);\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Implements validation functionality for the rules portion of a config.\n */\nclass RuleValidator {\n\n    /**\n     * Creates a new instance.\n     */\n    constructor() {\n\n        /**\n         * A collection of compiled validators for rules that have already\n         * been validated.\n         * @type {WeakMap}\n         */\n        this.validators = new WeakMap();\n    }\n\n    /**\n     * Validates all of the rule configurations in a config against each\n     * rule's schema.\n     * @param {Object} config The full config to validate. This object must\n     *      contain both the rules section and the plugins section.\n     * @returns {void}\n     * @throws {Error} If a rule's configuration does not match its schema.\n     */\n    validate(config) {\n\n        if (!config.rules) {\n            return;\n        }\n\n        for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\n\n            // check for edge case\n            if (ruleId === \"__proto__\") {\n                continue;\n            }\n\n            /*\n             * If a rule is disabled, we don't do any validation. This allows\n             * users to safely set any value to 0 or \"off\" without worrying\n             * that it will cause a validation error.\n             *\n             * Note: ruleOptions is always an array at this point because\n             * this validation occurs after FlatConfigArray has merged and\n             * normalized values.\n             */\n            if (ruleOptions[0] === 0) {\n                continue;\n            }\n\n            const rule = getRuleFromConfig(ruleId, config);\n\n            if (!rule) {\n                throwRuleNotFoundError(parseRuleId(ruleId), config);\n            }\n\n            // Precompile and cache validator the first time\n            if (!this.validators.has(rule)) {\n                const schema = getRuleOptionsSchema(rule);\n\n                if (schema) {\n                    this.validators.set(rule, ajv.compile(schema));\n                }\n            }\n\n            const validateRule = this.validators.get(rule);\n\n            if (validateRule) {\n\n                validateRule(ruleOptions.slice(1));\n\n                if (validateRule.errors) {\n                    throw new Error(`Key \"rules\": Key \"${ruleId}\": ${\n                        validateRule.errors.map(\n                            error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n                        ).join(\"\")\n                    }`);\n                }\n            }\n        }\n    }\n}\n\nexports.RuleValidator = RuleValidator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}