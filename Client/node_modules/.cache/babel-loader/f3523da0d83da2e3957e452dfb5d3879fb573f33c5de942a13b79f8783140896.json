{"ast":null,"code":"/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  upperCaseFirst\n} = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks all segments in a set and returns true if all are unreachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if all segments are unreachable; false otherwise.\n */\nfunction areAllSegmentsUnreachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks whether a given node is a `constructor` method in an ES6 class\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is a `constructor` method\n */\nfunction isClassConstructor(node) {\n  return node.type === \"FunctionExpression\" && node.parent && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require `return` statements to either always or never specify values\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/consistent-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        treatUndefinedAsUnspecified: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingReturn: \"Expected to return a value at the end of {{name}}.\",\n      missingReturnValue: \"{{name}} expected a return value.\",\n      unexpectedReturnValue: \"{{name}} expected no return value.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n    let funcInfo = null;\n\n    /**\n     * Checks whether of not the implicit returning is consistent if the last\n     * code path segment is reachable.\n     * @param {ASTNode} node A program/function node to check.\n     * @returns {void}\n     */\n    function checkLastSegment(node) {\n      let loc, name;\n\n      /*\n       * Skip if it expected no return value or unreachable.\n       * When unreachable, all paths are returned or thrown.\n       */\n      if (!funcInfo.hasReturnValue || areAllSegmentsUnreachable(funcInfo.currentSegments) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {\n        return;\n      }\n\n      // Adjust a location and a message.\n      if (node.type === \"Program\") {\n        // The head of program.\n        loc = {\n          line: 1,\n          column: 0\n        };\n        name = \"program\";\n      } else if (node.type === \"ArrowFunctionExpression\") {\n        // `=>` token\n        loc = context.sourceCode.getTokenBefore(node.body, astUtils.isArrowToken).loc;\n      } else if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        // Method name.\n        loc = node.parent.key.loc;\n      } else {\n        // Function name or `function` keyword.\n        loc = (node.id || context.sourceCode.getFirstToken(node)).loc;\n      }\n      if (!name) {\n        name = astUtils.getFunctionNameWithKind(node);\n      }\n\n      // Reports.\n      context.report({\n        node,\n        loc,\n        messageId: \"missingReturn\",\n        data: {\n          name\n        }\n      });\n    }\n    return {\n      // Initializes/Disposes state of each code path.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          hasReturnValue: false,\n          messageId: \"\",\n          node,\n          currentSegments: new Set()\n        };\n      },\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      onCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      // Reports a given return statement if it's inconsistent.\n      ReturnStatement(node) {\n        const argument = node.argument;\n        let hasReturnValue = Boolean(argument);\n        if (treatUndefinedAsUnspecified && hasReturnValue) {\n          hasReturnValue = !astUtils.isSpecificId(argument, \"undefined\") && argument.operator !== \"void\";\n        }\n        if (!funcInfo.hasReturn) {\n          funcInfo.hasReturn = true;\n          funcInfo.hasReturnValue = hasReturnValue;\n          funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n          funcInfo.data = {\n            name: funcInfo.node.type === \"Program\" ? \"Program\" : upperCaseFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n          };\n        } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n          context.report({\n            node,\n            messageId: funcInfo.messageId,\n            data: funcInfo.data\n          });\n        }\n      },\n      // Reports a given program/function if the implicit returning is not consistent.\n      \"Program:exit\": checkLastSegment,\n      \"FunctionDeclaration:exit\": checkLastSegment,\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","upperCaseFirst","areAllSegmentsUnreachable","segments","segment","reachable","isClassConstructor","node","type","parent","kind","module","exports","meta","docs","description","recommended","url","schema","properties","treatUndefinedAsUnspecified","default","additionalProperties","messages","missingReturn","missingReturnValue","unexpectedReturnValue","create","context","options","funcInfo","checkLastSegment","loc","name","hasReturnValue","currentSegments","isES5Constructor","line","column","sourceCode","getTokenBefore","body","isArrowToken","method","key","id","getFirstToken","getFunctionNameWithKind","report","messageId","data","onCodePathStart","codePath","upper","hasReturn","Set","onCodePathEnd","onUnreachableCodePathSegmentStart","add","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentStart","onCodePathSegmentEnd","ReturnStatement","argument","Boolean","isSpecificId","operator"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/consistent-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { upperCaseFirst } = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks all segments in a set and returns true if all are unreachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if all segments are unreachable; false otherwise.\n */\nfunction areAllSegmentsUnreachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether a given node is a `constructor` method in an ES6 class\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is a `constructor` method\n */\nfunction isClassConstructor(node) {\n    return node.type === \"FunctionExpression\" &&\n        node.parent &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require `return` statements to either always or never specify values\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/consistent-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingReturn: \"Expected to return a value at the end of {{name}}.\",\n            missingReturnValue: \"{{name}} expected a return value.\",\n            unexpectedReturnValue: \"{{name}} expected no return value.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        let funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         * @param {ASTNode} node A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            let loc, name;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                areAllSegmentsUnreachable(funcInfo.currentSegments) ||\n                astUtils.isES5Constructor(node) ||\n                isClassConstructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = { line: 1, column: 0 };\n                name = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.sourceCode.getTokenBefore(node.body, astUtils.isArrowToken).loc;\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc;\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || context.sourceCode.getFirstToken(node)).loc;\n            }\n\n            if (!name) {\n                name = astUtils.getFunctionNameWithKind(node);\n            }\n\n            // Reports.\n            context.report({\n                node,\n                loc,\n                messageId: \"missingReturn\",\n                data: { name }\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    messageId: \"\",\n                    node,\n                    currentSegments: new Set()\n                };\n            },\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement(node) {\n                const argument = node.argument;\n                let hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !astUtils.isSpecificId(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n                    funcInfo.data = {\n                        name: funcInfo.node.type === \"Program\"\n                            ? \"Program\"\n                            : upperCaseFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                    };\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({\n                        node,\n                        messageId: funcInfo.messageId,\n                        data: funcInfo.data\n                    });\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}