{"ast":null,"code":"/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n  return {\n    boolean: \"boolean\" in options ? options.boolean : true,\n    number: \"number\" in options ? options.number : true,\n    string: \"string\" in options ? options.string : true,\n    disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n    allow: options.allow || []\n  };\n}\n\n/**\n * Checks whether or not a node is a double logical negating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical negating.\n */\nfunction isDoubleLogicalNegating(node) {\n  return node.operator === \"!\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n  if (node.operator !== \"~\") {\n    return false;\n  }\n  const callNode = astUtils.skipChainExpression(node.argument);\n  return callNode.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n  return node.operator === \"*\" && (node.left.type === \"Literal\" && node.left.value === 1 || node.right.type === \"Literal\" && node.right.value === 1);\n}\n\n/**\n * Checks whether the given node logically represents multiplication by a fraction of `1`.\n * For example, `a * 1` in `a * 1 / b` is technically multiplication by `1`, but the\n * whole expression can be logically interpreted as `a * (1 / b)` rather than `(a * 1) / b`.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @param {SourceCode} sourceCode The source code object.\n * @returns {boolean} Whether or not the node is a multiplying by a fraction of `1`.\n */\nfunction isMultiplyByFractionOfOne(node, sourceCode) {\n  return node.type === \"BinaryExpression\" && node.operator === \"*\" && node.right.type === \"Literal\" && node.right.value === 1 && node.parent.type === \"BinaryExpression\" && node.parent.operator === \"/\" && node.parent.left === node && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n  return node.type === \"Literal\" && typeof node.value === \"number\" || node.type === \"CallExpression\" && (node.callee.name === \"Number\" || node.callee.name === \"parseInt\" || node.callee.name === \"parseFloat\");\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n  const left = node.left,\n    right = node.right;\n  if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n    return right;\n  }\n  if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n    return left;\n  }\n  return null;\n}\n\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\nfunction isStringType(node) {\n  return astUtils.isStringLiteral(node) || node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"String\";\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n  return astUtils.isStringLiteral(node) && (node.value === \"\" || node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\");\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n  return node.operator === \"+\" && (isEmptyString(node.left) && !isStringType(node.right) || isEmptyString(node.right) && !isStringType(node.left));\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n  return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n  return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow shorthand type conversions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-implicit-coercion\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        boolean: {\n          type: \"boolean\",\n          default: true\n        },\n        number: {\n          type: \"boolean\",\n          default: true\n        },\n        string: {\n          type: \"boolean\",\n          default: true\n        },\n        disallowTemplateShorthand: {\n          type: \"boolean\",\n          default: false\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOWABLE_OPERATORS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useRecommendation: \"use `{{recommendation}}` instead.\"\n    }\n  },\n  create(context) {\n    const options = parseOptions(context.options[0] || {});\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Reports an error and autofixes the node\n     * @param {ASTNode} node An ast node to report the error on.\n     * @param {string} recommendation The recommended code for the issue\n     * @param {bool} shouldFix Whether this report should fix the node\n     * @returns {void}\n     */\n    function report(node, recommendation, shouldFix) {\n      context.report({\n        node,\n        messageId: \"useRecommendation\",\n        data: {\n          recommendation\n        },\n        fix(fixer) {\n          if (!shouldFix) {\n            return null;\n          }\n          const tokenBefore = sourceCode.getTokenBefore(node);\n          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {\n            return fixer.replaceText(node, ` ${recommendation}`);\n          }\n          return fixer.replaceText(node, recommendation);\n        }\n      });\n    }\n    return {\n      UnaryExpression(node) {\n        let operatorAllowed;\n\n        // !!foo\n        operatorAllowed = options.allow.includes(\"!!\");\n        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n          report(node, recommendation, true);\n        }\n\n        // ~foo.indexOf(bar)\n        operatorAllowed = options.allow.includes(\"~\");\n        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n          // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n          const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n          const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n          report(node, recommendation, false);\n        }\n\n        // +foo\n        operatorAllowed = options.allow.includes(\"+\");\n        if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n          const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n          report(node, recommendation, true);\n        }\n      },\n      // Use `:exit` to prevent double reporting\n      \"BinaryExpression:exit\"(node) {\n        let operatorAllowed;\n\n        // 1 * foo\n        operatorAllowed = options.allow.includes(\"*\");\n        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && !isMultiplyByFractionOfOne(node, sourceCode) && getNonNumericOperand(node);\n        if (nonNumericOperand) {\n          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n          report(node, recommendation, true);\n        }\n\n        // \"\" + foo\n        operatorAllowed = options.allow.includes(\"+\");\n        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n          report(node, recommendation, true);\n        }\n      },\n      AssignmentExpression(node) {\n        // foo += \"\"\n        const operatorAllowed = options.allow.includes(\"+\");\n        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n          const code = sourceCode.getText(getNonEmptyOperand(node));\n          const recommendation = `${code} = String(${code})`;\n          report(node, recommendation, true);\n        }\n      },\n      TemplateLiteral(node) {\n        if (!options.disallowTemplateShorthand) {\n          return;\n        }\n\n        // tag`${foo}`\n        if (node.parent.type === \"TaggedTemplateExpression\") {\n          return;\n        }\n\n        // `` or `${foo}${bar}`\n        if (node.expressions.length !== 1) {\n          return;\n        }\n\n        //  `prefix${foo}`\n        if (node.quasis[0].value.cooked !== \"\") {\n          return;\n        }\n\n        //  `${foo}postfix`\n        if (node.quasis[1].value.cooked !== \"\") {\n          return;\n        }\n\n        // if the expression is already a string, then this isn't a coercion\n        if (isStringType(node.expressions[0])) {\n          return;\n        }\n        const code = sourceCode.getText(node.expressions[0]);\n        const recommendation = `String(${code})`;\n        report(node, recommendation, true);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","INDEX_OF_PATTERN","ALLOWABLE_OPERATORS","parseOptions","options","boolean","number","string","disallowTemplateShorthand","allow","isDoubleLogicalNegating","node","operator","argument","type","isBinaryNegatingOfIndexOf","callNode","skipChainExpression","isSpecificMemberAccess","callee","isMultiplyByOne","left","value","right","isMultiplyByFractionOfOne","sourceCode","parent","isParenthesised","isNumeric","name","getNonNumericOperand","isStringType","isStringLiteral","isEmptyString","quasis","length","cooked","isConcatWithEmptyString","isAppendEmptyString","getNonEmptyOperand","module","exports","meta","docs","description","recommended","url","fixable","schema","properties","default","items","enum","uniqueItems","additionalProperties","messages","useRecommendation","create","context","report","recommendation","shouldFix","messageId","data","fix","fixer","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","replaceText","UnaryExpression","operatorAllowed","includes","getText","comparison","BinaryExpression:exit","nonNumericOperand","AssignmentExpression","code","TemplateLiteral","expressions"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-implicit-coercion.js"],"sourcesContent":["/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    return {\n        boolean: \"boolean\" in options ? options.boolean : true,\n        number: \"number\" in options ? options.number : true,\n        string: \"string\" in options ? options.string : true,\n        disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical negating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical negating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    if (node.operator !== \"~\") {\n        return false;\n    }\n    const callNode = astUtils.skipChainExpression(node.argument);\n\n    return (\n        callNode.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the given node logically represents multiplication by a fraction of `1`.\n * For example, `a * 1` in `a * 1 / b` is technically multiplication by `1`, but the\n * whole expression can be logically interpreted as `a * (1 / b)` rather than `(a * 1) / b`.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @param {SourceCode} sourceCode The source code object.\n * @returns {boolean} Whether or not the node is a multiplying by a fraction of `1`.\n */\nfunction isMultiplyByFractionOfOne(node, sourceCode) {\n    return node.type === \"BinaryExpression\" &&\n        node.operator === \"*\" &&\n        (node.right.type === \"Literal\" && node.right.value === 1) &&\n        node.parent.type === \"BinaryExpression\" &&\n        node.parent.operator === \"/\" &&\n        node.parent.left === node &&\n        !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\nfunction isStringType(node) {\n    return astUtils.isStringLiteral(node) ||\n        (\n            node.type === \"CallExpression\" &&\n            node.callee.type === \"Identifier\" &&\n            node.callee.name === \"String\"\n        );\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !isStringType(node.right)) ||\n        (isEmptyString(node.right) && !isStringType(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow shorthand type conversions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\",\n                    default: true\n                },\n                number: {\n                    type: \"boolean\",\n                    default: true\n                },\n                string: {\n                    type: \"boolean\",\n                    default: true\n                },\n                disallowTemplateShorthand: {\n                    type: \"boolean\",\n                    default: false\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useRecommendation: \"use `{{recommendation}}` instead.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0] || {});\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node An ast node to report the error on.\n         * @param {string} recommendation The recommended code for the issue\n         * @param {bool} shouldFix Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldFix) {\n            context.report({\n                node,\n                messageId: \"useRecommendation\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.includes(\"!!\");\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.includes(\"~\");\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n\n                    // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n                    const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n                    const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.includes(\"+\");\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.includes(\"*\");\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && !isMultiplyByFractionOfOne(node, sourceCode) &&\n                    getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.includes(\"+\");\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.includes(\"+\");\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            TemplateLiteral(node) {\n                if (!options.disallowTemplateShorthand) {\n                    return;\n                }\n\n                // tag`${foo}`\n                if (node.parent.type === \"TaggedTemplateExpression\") {\n                    return;\n                }\n\n                // `` or `${foo}${bar}`\n                if (node.expressions.length !== 1) {\n                    return;\n                }\n\n\n                //  `prefix${foo}`\n                if (node.quasis[0].value.cooked !== \"\") {\n                    return;\n                }\n\n                //  `${foo}postfix`\n                if (node.quasis[1].value.cooked !== \"\") {\n                    return;\n                }\n\n                // if the expression is already a string, then this isn't a coercion\n                if (isStringType(node.expressions[0])) {\n                    return;\n                }\n\n                const code = sourceCode.getText(node.expressions[0]);\n                const recommendation = `String(${code})`;\n\n                report(node, recommendation, true);\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}