{"ast":null,"code":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow specified warning terms in comments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        },\n        decoration: {\n          type: \"array\",\n          items: {\n            type: \"string\",\n            pattern: \"^\\\\S$\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode,\n      configuration = context.options[0] || {},\n      warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n      location = configuration.location || \"start\",\n      decoration = [...(configuration.decoration || [])].join(\"\"),\n      selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n    /**\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n     * require word boundaries on that side.\n     * @param {string} term A term to convert to a RegExp\n     * @returns {RegExp} The term converted to a RegExp\n     */\n    function convertToRegExp(term) {\n      const escaped = escapeRegExp(term);\n      const escapedDecoration = escapeRegExp(decoration);\n\n      /*\n       * When matching at the start, ignore leading whitespace, and\n       * there's no need to worry about word boundaries.\n       *\n       * These expressions for the prefix and suffix are designed as follows:\n       * ^   handles any terms at the beginning of a comment.\n       *     e.g. terms [\"TODO\"] matches `//TODO something`\n       * $   handles any terms at the end of a comment\n       *     e.g. terms [\"TODO\"] matches `// something TODO`\n       * \\b  handles terms preceded/followed by word boundary\n       *     e.g. terms: [\"!FIX\", \"FIX!\"] matches `// FIX!something` or `// something!FIX`\n       *          terms: [\"FIX\"] matches `// FIX!` or `// !FIX`, but not `// fixed or affix`\n       *\n       * For location start:\n       * [\\s]* handles optional leading spaces\n       *     e.g. terms [\"TODO\"] matches `//    TODO something`\n       * [\\s\\*]* (where \"\\*\" is the escaped string of decoration)\n       *     handles optional leading spaces or decoration characters (for \"start\" location only)\n       *     e.g. terms [\"TODO\"] matches `/**** TODO something ... `\n       */\n      const wordBoundary = \"\\\\b\";\n      let prefix = \"\";\n      if (location === \"start\") {\n        prefix = `^[\\\\s${escapedDecoration}]*`;\n      } else if (/^\\w/u.test(term)) {\n        prefix = wordBoundary;\n      }\n      const suffix = /\\w$/u.test(term) ? wordBoundary : \"\";\n      const flags = \"iu\"; // Case-insensitive with Unicode case folding.\n\n      /*\n       * For location \"start\", the typical regex is:\n       *   /^[\\s]*ESCAPED_TERM\\b/iu.\n       * Or if decoration characters are specified (e.g. \"*\"), then any of\n       * those characters may appear in any order at the start:\n       *   /^[\\s\\*]*ESCAPED_TERM\\b/iu.\n       *\n       * For location \"anywhere\" the typical regex is\n       *   /\\bESCAPED_TERM\\b/iu\n       *\n       * If it starts or ends with non-word character, the prefix and suffix are empty, respectively.\n       */\n      return new RegExp(`${prefix}${escaped}${suffix}`, flags);\n    }\n    const warningRegExps = warningTerms.map(convertToRegExp);\n\n    /**\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\n     * @param {string} comment The comment which is checked.\n     * @returns {Array} All matched warning terms for this comment.\n     */\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n\n    /**\n     * Checks the specified node for matching warning comments and reports them.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {void} undefined.\n     */\n    function checkComment(node) {\n      const comment = node.value;\n      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {\n        return;\n      }\n      const matches = commentContainsWarningTerm(comment);\n      matches.forEach(matchedTerm => {\n        let commentToDisplay = \"\";\n        let truncated = false;\n        for (const c of comment.trim().split(/\\s+/u)) {\n          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n          if (tmp.length <= CHAR_LIMIT) {\n            commentToDisplay = tmp;\n          } else {\n            truncated = true;\n            break;\n          }\n        }\n        context.report({\n          node,\n          messageId: \"unexpectedComment\",\n          data: {\n            matchedTerm,\n            comment: `${commentToDisplay}${truncated ? \"...\" : \"\"}`\n          }\n        });\n      });\n    }\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n    };\n  }\n};","map":{"version":3,"names":["escapeRegExp","require","astUtils","CHAR_LIMIT","module","exports","meta","type","docs","description","recommended","url","schema","properties","terms","items","location","enum","decoration","pattern","minItems","uniqueItems","additionalProperties","messages","unexpectedComment","create","context","sourceCode","configuration","options","warningTerms","join","selfConfigRegEx","convertToRegExp","term","escaped","escapedDecoration","wordBoundary","prefix","test","suffix","flags","RegExp","warningRegExps","map","commentContainsWarningTerm","comment","matches","forEach","regex","index","push","checkComment","node","value","isDirectiveComment","matchedTerm","commentToDisplay","truncated","c","trim","split","tmp","length","report","messageId","data","Program","comments","getAllComments","filter","token"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-warning-comments.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified warning terms in comments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    },\n                    decoration: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            pattern: \"^\\\\S$\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode,\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            decoration = [...configuration.decoration || []].join(\"\"),\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n            const escapedDecoration = escapeRegExp(decoration);\n\n            /*\n             * When matching at the start, ignore leading whitespace, and\n             * there's no need to worry about word boundaries.\n             *\n             * These expressions for the prefix and suffix are designed as follows:\n             * ^   handles any terms at the beginning of a comment.\n             *     e.g. terms [\"TODO\"] matches `//TODO something`\n             * $   handles any terms at the end of a comment\n             *     e.g. terms [\"TODO\"] matches `// something TODO`\n             * \\b  handles terms preceded/followed by word boundary\n             *     e.g. terms: [\"!FIX\", \"FIX!\"] matches `// FIX!something` or `// something!FIX`\n             *          terms: [\"FIX\"] matches `// FIX!` or `// !FIX`, but not `// fixed or affix`\n             *\n             * For location start:\n             * [\\s]* handles optional leading spaces\n             *     e.g. terms [\"TODO\"] matches `//    TODO something`\n             * [\\s\\*]* (where \"\\*\" is the escaped string of decoration)\n             *     handles optional leading spaces or decoration characters (for \"start\" location only)\n             *     e.g. terms [\"TODO\"] matches `/**** TODO something ... `\n             */\n            const wordBoundary = \"\\\\b\";\n\n            let prefix = \"\";\n\n            if (location === \"start\") {\n                prefix = `^[\\\\s${escapedDecoration}]*`;\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            }\n\n            const suffix = /\\w$/u.test(term) ? wordBoundary : \"\";\n            const flags = \"iu\"; // Case-insensitive with Unicode case folding.\n\n            /*\n             * For location \"start\", the typical regex is:\n             *   /^[\\s]*ESCAPED_TERM\\b/iu.\n             * Or if decoration characters are specified (e.g. \"*\"), then any of\n             * those characters may appear in any order at the start:\n             *   /^[\\s\\*]*ESCAPED_TERM\\b/iu.\n             *\n             * For location \"anywhere\" the typical regex is\n             *   /\\bESCAPED_TERM\\b/iu\n             *\n             * If it starts or ends with non-word character, the prefix and suffix are empty, respectively.\n             */\n            return new RegExp(`${prefix}${escaped}${suffix}`, flags);\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            const comment = node.value;\n\n            if (\n                astUtils.isDirectiveComment(node) &&\n                selfConfigRegEx.test(comment)\n            ) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(comment);\n\n            matches.forEach(matchedTerm => {\n                let commentToDisplay = \"\";\n                let truncated = false;\n\n                for (const c of comment.trim().split(/\\s+/u)) {\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n                    if (tmp.length <= CHAR_LIMIT) {\n                        commentToDisplay = tmp;\n                    } else {\n                        truncated = true;\n                        break;\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedComment\",\n                    data: {\n                        matchedTerm,\n                        comment: `${commentToDisplay}${\n                            truncated ? \"...\" : \"\"\n                        }`\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(checkComment);\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}