{"ast":null,"code":"/**\n * @fileoverview `FileEnumerator` class.\n *\n * `FileEnumerator` class has two responsibilities:\n *\n * 1. Find target files by processing glob patterns.\n * 2. Tie each target file and appropriate configuration.\n *\n * It provides a method:\n *\n * - `iterateFiles(patterns)`\n *     Iterate files which are matched by given patterns together with the\n *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.\n *     While iterating files, it loads the configuration file of each directory\n *     before iterate files on the directory, so we can use the configuration\n *     files to determine target files.\n *\n * @example\n * const enumerator = new FileEnumerator();\n * const linter = new Linter();\n *\n * for (const { config, filePath } of enumerator.iterateFiles([\"*.js\"])) {\n *     const code = fs.readFileSync(filePath, \"utf8\");\n *     const messages = linter.verify(code, config, filePath);\n *\n *     console.log(messages);\n * }\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst getGlobParent = require(\"glob-parent\");\nconst isGlob = require(\"is-glob\");\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst {\n  Minimatch\n} = require(\"minimatch\");\nconst {\n  Legacy: {\n    IgnorePattern,\n    CascadingConfigArrayFactory\n  }\n} = require(\"@eslint/eslintrc\");\nconst debug = require(\"debug\")(\"eslint:file-enumerator\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst minimatchOpts = {\n  dot: true,\n  matchBase: true\n};\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\nconst NONE = 0;\nconst IGNORED_SILENTLY = 1;\nconst IGNORED = 2;\n\n// For VSCode intellisense\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\n\n/**\n * @typedef {Object} FileEnumeratorOptions\n * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string[]} [extensions] The extensions to match files for directory patterns.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] The flag to check ignored files.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n */\n\n/**\n * @typedef {Object} FileAndConfig\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEntry\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.\n * - `NONE` means the file is a target file.\n * - `IGNORED_SILENTLY` means the file should be ignored silently.\n * - `IGNORED` means the file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEnumeratorInternalSlots\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {RegExp|null} extensionRegExp The RegExp to test if a string ends with specific file extensions.\n * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} ignoreFlag The flag to check ignored files.\n * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.\n */\n\n/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n  return isGlob(path.sep === \"\\\\\" ? pattern.replace(/\\\\/gu, \"/\") : pattern);\n}\n\n/**\n * Get stats of a given path.\n * @param {string} filePath The path to target file.\n * @throws {Error} As may be thrown by `fs.statSync`.\n * @returns {fs.Stats|null} The stats.\n * @private\n */\nfunction statSafeSync(filePath) {\n  try {\n    return fs.statSync(filePath);\n  } catch (error) {\n    /* c8 ignore next */\n    if (error.code !== \"ENOENT\") {\n      throw error;\n    }\n    return null;\n  }\n}\n\n/**\n * Get filenames in a given path to a directory.\n * @param {string} directoryPath The path to target directory.\n * @throws {Error} As may be thrown by `fs.readdirSync`.\n * @returns {import(\"fs\").Dirent[]} The filenames.\n * @private\n */\nfunction readdirSafeSync(directoryPath) {\n  try {\n    return fs.readdirSync(directoryPath, {\n      withFileTypes: true\n    });\n  } catch (error) {\n    /* c8 ignore next */\n    if (error.code !== \"ENOENT\") {\n      throw error;\n    }\n    return [];\n  }\n}\n\n/**\n * Create a `RegExp` object to detect extensions.\n * @param {string[] | null} extensions The extensions to create.\n * @returns {RegExp | null} The created `RegExp` object or null.\n */\nfunction createExtensionRegExp(extensions) {\n  if (extensions) {\n    const normalizedExts = extensions.map(ext => escapeRegExp(ext.startsWith(\".\") ? ext.slice(1) : ext));\n    return new RegExp(`.\\\\.(?:${normalizedExts.join(\"|\")})$`, \"u\");\n  }\n  return null;\n}\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.\n   */\n  constructor(pattern, globDisabled) {\n    super(`No files matching '${pattern}' were found${globDisabled ? \" (glob was disabled)\" : \"\"}.`);\n    this.messageTemplate = \"file-not-found\";\n    this.messageData = {\n      pattern,\n      globDisabled\n    };\n  }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   */\n  constructor(pattern) {\n    super(`All files matched by '${pattern}' are ignored.`);\n    this.messageTemplate = \"all-files-ignored\";\n    this.messageData = {\n      pattern\n    };\n  }\n}\n\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\nclass FileEnumerator {\n  /**\n   * Initialize this enumerator.\n   * @param {FileEnumeratorOptions} options The options.\n   */\n  constructor({\n    cwd = process.cwd(),\n    configArrayFactory = new CascadingConfigArrayFactory({\n      cwd,\n      getEslintRecommendedConfig: () => require(\"@eslint/js\").configs.recommended,\n      getEslintAllConfig: () => require(\"@eslint/js\").configs.all\n    }),\n    extensions = null,\n    globInputPaths = true,\n    errorOnUnmatchedPattern = true,\n    ignore = true\n  } = {}) {\n    internalSlotsMap.set(this, {\n      configArrayFactory,\n      cwd,\n      defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),\n      extensionRegExp: createExtensionRegExp(extensions),\n      globInputPaths,\n      errorOnUnmatchedPattern,\n      ignoreFlag: ignore\n    });\n  }\n\n  /**\n   * Check if a given file is target or not.\n   * @param {string} filePath The path to a candidate file.\n   * @param {ConfigArray} [providedConfig] Optional. The configuration for the file.\n   * @returns {boolean} `true` if the file is a target.\n   */\n  isTargetPath(filePath, providedConfig) {\n    const {\n      configArrayFactory,\n      extensionRegExp\n    } = internalSlotsMap.get(this);\n\n    // If `--ext` option is present, use it.\n    if (extensionRegExp) {\n      return extensionRegExp.test(filePath);\n    }\n\n    // `.js` file is target by default.\n    if (filePath.endsWith(\".js\")) {\n      return true;\n    }\n\n    // use `overrides[].files` to check additional targets.\n    const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {\n      ignoreNotFoundError: true\n    });\n    return config.isAdditionalTargetPath(filePath);\n  }\n\n  /**\n   * Iterate files which are matched by given glob patterns.\n   * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.\n   * @throws {NoFilesFoundError|AllFilesIgnoredError} On an unmatched pattern.\n   * @returns {IterableIterator<FileAndConfig>} The found files.\n   */\n  *iterateFiles(patternOrPatterns) {\n    const {\n      globInputPaths,\n      errorOnUnmatchedPattern\n    } = internalSlotsMap.get(this);\n    const patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];\n    debug(\"Start to iterate files: %o\", patterns);\n\n    // The set of paths to remove duplicate.\n    const set = new Set();\n    for (const pattern of patterns) {\n      let foundRegardlessOfIgnored = false;\n      let found = false;\n\n      // Skip empty string.\n      if (!pattern) {\n        continue;\n      }\n\n      // Iterate files of this pattern.\n      for (const {\n        config,\n        filePath,\n        flag\n      } of this._iterateFiles(pattern)) {\n        foundRegardlessOfIgnored = true;\n        if (flag === IGNORED_SILENTLY) {\n          continue;\n        }\n        found = true;\n\n        // Remove duplicate paths while yielding paths.\n        if (!set.has(filePath)) {\n          set.add(filePath);\n          yield {\n            config,\n            filePath,\n            ignored: flag === IGNORED\n          };\n        }\n      }\n\n      // Raise an error if any files were not found.\n      if (errorOnUnmatchedPattern) {\n        if (!foundRegardlessOfIgnored) {\n          throw new NoFilesFoundError(pattern, !globInputPaths && isGlob(pattern));\n        }\n        if (!found) {\n          throw new AllFilesIgnoredError(pattern);\n        }\n      }\n    }\n    debug(`Complete iterating files: ${JSON.stringify(patterns)}`);\n  }\n\n  /**\n   * Iterate files which are matched by a given glob pattern.\n   * @param {string} pattern The glob pattern to iterate files.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   */\n  _iterateFiles(pattern) {\n    const {\n      cwd,\n      globInputPaths\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, pattern);\n    const isDot = dotfilesPattern.test(pattern);\n    const stat = statSafeSync(absolutePath);\n    if (stat && stat.isDirectory()) {\n      return this._iterateFilesWithDirectory(absolutePath, isDot);\n    }\n    if (stat && stat.isFile()) {\n      return this._iterateFilesWithFile(absolutePath);\n    }\n    if (globInputPaths && isGlobPattern(pattern)) {\n      return this._iterateFilesWithGlob(pattern, isDot);\n    }\n    return [];\n  }\n\n  /**\n   * Iterate a file which is matched by a given path.\n   * @param {string} filePath The path to the target file.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n  _iterateFilesWithFile(filePath) {\n    debug(`File: ${filePath}`);\n    const {\n      configArrayFactory\n    } = internalSlotsMap.get(this);\n    const config = configArrayFactory.getConfigArrayForFile(filePath);\n    const ignored = this._isIgnoredFile(filePath, {\n      config,\n      direct: true\n    });\n    const flag = ignored ? IGNORED : NONE;\n    return [{\n      config,\n      filePath,\n      flag\n    }];\n  }\n\n  /**\n   * Iterate files in a given path.\n   * @param {string} directoryPath The path to the target directory.\n   * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n  _iterateFilesWithDirectory(directoryPath, dotfiles) {\n    debug(`Directory: ${directoryPath}`);\n    return this._iterateFilesRecursive(directoryPath, {\n      dotfiles,\n      recursive: true,\n      selector: null\n    });\n  }\n\n  /**\n   * Iterate files which are matched by a given glob pattern.\n   * @param {string} pattern The glob pattern to iterate files.\n   * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n  _iterateFilesWithGlob(pattern, dotfiles) {\n    debug(`Glob: ${pattern}`);\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const directoryPath = path.resolve(cwd, getGlobParent(pattern));\n    const absolutePath = path.resolve(cwd, pattern);\n    const globPart = absolutePath.slice(directoryPath.length + 1);\n\n    /*\n     * recursive if there are `**` or path separators in the glob part.\n     * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.\n     */\n    const recursive = /\\*\\*|\\/|\\\\/u.test(globPart);\n    const selector = new Minimatch(absolutePath, minimatchOpts);\n    debug(`recursive? ${recursive}`);\n    return this._iterateFilesRecursive(directoryPath, {\n      dotfiles,\n      recursive,\n      selector\n    });\n  }\n\n  /**\n   * Iterate files in a given path.\n   * @param {string} directoryPath The path to the target directory.\n   * @param {Object} options The options to iterate files.\n   * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.\n   * @param {boolean} [options.recursive] If `true` then it dives into sub directories.\n   * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n  *_iterateFilesRecursive(directoryPath, options) {\n    debug(`Enter the directory: ${directoryPath}`);\n    const {\n      configArrayFactory\n    } = internalSlotsMap.get(this);\n\n    /** @type {ConfigArray|null} */\n    let config = null;\n\n    // Enumerate the files of this directory.\n    for (const entry of readdirSafeSync(directoryPath)) {\n      const filePath = path.join(directoryPath, entry.name);\n      const fileInfo = entry.isSymbolicLink() ? statSafeSync(filePath) : entry;\n      if (!fileInfo) {\n        continue;\n      }\n\n      // Check if the file is matched.\n      if (fileInfo.isFile()) {\n        if (!config) {\n          config = configArrayFactory.getConfigArrayForFile(filePath,\n          /*\n           * We must ignore `ConfigurationNotFoundError` at this\n           * point because we don't know if target files exist in\n           * this directory.\n           */\n          {\n            ignoreNotFoundError: true\n          });\n        }\n        const matched = options.selector\n\n        // Started with a glob pattern; choose by the pattern.\n        ? options.selector.match(filePath)\n\n        // Started with a directory path; choose by file extensions.\n        : this.isTargetPath(filePath, config);\n        if (matched) {\n          const ignored = this._isIgnoredFile(filePath, {\n            ...options,\n            config\n          });\n          const flag = ignored ? IGNORED_SILENTLY : NONE;\n          debug(`Yield: ${entry.name}${ignored ? \" but ignored\" : \"\"}`);\n          yield {\n            config: configArrayFactory.getConfigArrayForFile(filePath),\n            filePath,\n            flag\n          };\n        } else {\n          debug(`Didn't match: ${entry.name}`);\n        }\n\n        // Dive into the sub directory.\n      } else if (options.recursive && fileInfo.isDirectory()) {\n        if (!config) {\n          config = configArrayFactory.getConfigArrayForFile(filePath, {\n            ignoreNotFoundError: true\n          });\n        }\n        const ignored = this._isIgnoredFile(filePath + path.sep, {\n          ...options,\n          config\n        });\n        if (!ignored) {\n          yield* this._iterateFilesRecursive(filePath, options);\n        }\n      }\n    }\n    debug(`Leave the directory: ${directoryPath}`);\n  }\n\n  /**\n   * Check if a given file should be ignored.\n   * @param {string} filePath The path to a file to check.\n   * @param {Object} options Options\n   * @param {ConfigArray} [options.config] The config for this file.\n   * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.\n   * @param {boolean} [options.direct] If `true` then this is a direct specified file.\n   * @returns {boolean} `true` if the file should be ignored.\n   * @private\n   */\n  _isIgnoredFile(filePath, {\n    config: providedConfig,\n    dotfiles = false,\n    direct = false\n  }) {\n    const {\n      configArrayFactory,\n      defaultIgnores,\n      ignoreFlag\n    } = internalSlotsMap.get(this);\n    if (ignoreFlag) {\n      const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {\n        ignoreNotFoundError: true\n      });\n      const ignores = config.extractConfig(filePath).ignores || defaultIgnores;\n      return ignores(filePath, dotfiles);\n    }\n    return !direct && defaultIgnores(filePath, dotfiles);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  FileEnumerator\n};","map":{"version":3,"names":["fs","require","path","getGlobParent","isGlob","escapeRegExp","Minimatch","Legacy","IgnorePattern","CascadingConfigArrayFactory","debug","minimatchOpts","dot","matchBase","dotfilesPattern","NONE","IGNORED_SILENTLY","IGNORED","internalSlotsMap","WeakMap","isGlobPattern","pattern","sep","replace","statSafeSync","filePath","statSync","error","code","readdirSafeSync","directoryPath","readdirSync","withFileTypes","createExtensionRegExp","extensions","normalizedExts","map","ext","startsWith","slice","RegExp","join","NoFilesFoundError","Error","constructor","globDisabled","messageTemplate","messageData","AllFilesIgnoredError","FileEnumerator","cwd","process","configArrayFactory","getEslintRecommendedConfig","configs","recommended","getEslintAllConfig","all","globInputPaths","errorOnUnmatchedPattern","ignore","set","defaultIgnores","createDefaultIgnore","extensionRegExp","ignoreFlag","isTargetPath","providedConfig","get","test","endsWith","config","getConfigArrayForFile","ignoreNotFoundError","isAdditionalTargetPath","iterateFiles","patternOrPatterns","patterns","Array","isArray","Set","foundRegardlessOfIgnored","found","flag","_iterateFiles","has","add","ignored","JSON","stringify","absolutePath","resolve","isDot","stat","isDirectory","_iterateFilesWithDirectory","isFile","_iterateFilesWithFile","_iterateFilesWithGlob","_isIgnoredFile","direct","dotfiles","_iterateFilesRecursive","recursive","selector","globPart","length","options","entry","name","fileInfo","isSymbolicLink","matched","match","ignores","extractConfig","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/cli-engine/file-enumerator.js"],"sourcesContent":["/**\n * @fileoverview `FileEnumerator` class.\n *\n * `FileEnumerator` class has two responsibilities:\n *\n * 1. Find target files by processing glob patterns.\n * 2. Tie each target file and appropriate configuration.\n *\n * It provides a method:\n *\n * - `iterateFiles(patterns)`\n *     Iterate files which are matched by given patterns together with the\n *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.\n *     While iterating files, it loads the configuration file of each directory\n *     before iterate files on the directory, so we can use the configuration\n *     files to determine target files.\n *\n * @example\n * const enumerator = new FileEnumerator();\n * const linter = new Linter();\n *\n * for (const { config, filePath } of enumerator.iterateFiles([\"*.js\"])) {\n *     const code = fs.readFileSync(filePath, \"utf8\");\n *     const messages = linter.verify(code, config, filePath);\n *\n *     console.log(messages);\n * }\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst getGlobParent = require(\"glob-parent\");\nconst isGlob = require(\"is-glob\");\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst { Minimatch } = require(\"minimatch\");\n\nconst {\n    Legacy: {\n        IgnorePattern,\n        CascadingConfigArrayFactory\n    }\n} = require(\"@eslint/eslintrc\");\nconst debug = require(\"debug\")(\"eslint:file-enumerator\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst minimatchOpts = { dot: true, matchBase: true };\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\nconst NONE = 0;\nconst IGNORED_SILENTLY = 1;\nconst IGNORED = 2;\n\n// For VSCode intellisense\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\n\n/**\n * @typedef {Object} FileEnumeratorOptions\n * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string[]} [extensions] The extensions to match files for directory patterns.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] The flag to check ignored files.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n */\n\n/**\n * @typedef {Object} FileAndConfig\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEntry\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.\n * - `NONE` means the file is a target file.\n * - `IGNORED_SILENTLY` means the file should be ignored silently.\n * - `IGNORED` means the file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEnumeratorInternalSlots\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {RegExp|null} extensionRegExp The RegExp to test if a string ends with specific file extensions.\n * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} ignoreFlag The flag to check ignored files.\n * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.\n */\n\n/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n    return isGlob(path.sep === \"\\\\\" ? pattern.replace(/\\\\/gu, \"/\") : pattern);\n}\n\n/**\n * Get stats of a given path.\n * @param {string} filePath The path to target file.\n * @throws {Error} As may be thrown by `fs.statSync`.\n * @returns {fs.Stats|null} The stats.\n * @private\n */\nfunction statSafeSync(filePath) {\n    try {\n        return fs.statSync(filePath);\n    } catch (error) {\n\n        /* c8 ignore next */\n        if (error.code !== \"ENOENT\") {\n            throw error;\n        }\n        return null;\n    }\n}\n\n/**\n * Get filenames in a given path to a directory.\n * @param {string} directoryPath The path to target directory.\n * @throws {Error} As may be thrown by `fs.readdirSync`.\n * @returns {import(\"fs\").Dirent[]} The filenames.\n * @private\n */\nfunction readdirSafeSync(directoryPath) {\n    try {\n        return fs.readdirSync(directoryPath, { withFileTypes: true });\n    } catch (error) {\n\n        /* c8 ignore next */\n        if (error.code !== \"ENOENT\") {\n            throw error;\n        }\n        return [];\n    }\n}\n\n/**\n * Create a `RegExp` object to detect extensions.\n * @param {string[] | null} extensions The extensions to create.\n * @returns {RegExp | null} The created `RegExp` object or null.\n */\nfunction createExtensionRegExp(extensions) {\n    if (extensions) {\n        const normalizedExts = extensions.map(ext => escapeRegExp(\n            ext.startsWith(\".\")\n                ? ext.slice(1)\n                : ext\n        ));\n\n        return new RegExp(\n            `.\\\\.(?:${normalizedExts.join(\"|\")})$`,\n            \"u\"\n        );\n    }\n    return null;\n}\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.\n     */\n    constructor(pattern, globDisabled) {\n        super(`No files matching '${pattern}' were found${globDisabled ? \" (glob was disabled)\" : \"\"}.`);\n        this.messageTemplate = \"file-not-found\";\n        this.messageData = { pattern, globDisabled };\n    }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`All files matched by '${pattern}' are ignored.`);\n        this.messageTemplate = \"all-files-ignored\";\n        this.messageData = { pattern };\n    }\n}\n\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\nclass FileEnumerator {\n\n    /**\n     * Initialize this enumerator.\n     * @param {FileEnumeratorOptions} options The options.\n     */\n    constructor({\n        cwd = process.cwd(),\n        configArrayFactory = new CascadingConfigArrayFactory({\n            cwd,\n            getEslintRecommendedConfig: () => require(\"@eslint/js\").configs.recommended,\n            getEslintAllConfig: () => require(\"@eslint/js\").configs.all\n        }),\n        extensions = null,\n        globInputPaths = true,\n        errorOnUnmatchedPattern = true,\n        ignore = true\n    } = {}) {\n        internalSlotsMap.set(this, {\n            configArrayFactory,\n            cwd,\n            defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),\n            extensionRegExp: createExtensionRegExp(extensions),\n            globInputPaths,\n            errorOnUnmatchedPattern,\n            ignoreFlag: ignore\n        });\n    }\n\n    /**\n     * Check if a given file is target or not.\n     * @param {string} filePath The path to a candidate file.\n     * @param {ConfigArray} [providedConfig] Optional. The configuration for the file.\n     * @returns {boolean} `true` if the file is a target.\n     */\n    isTargetPath(filePath, providedConfig) {\n        const {\n            configArrayFactory,\n            extensionRegExp\n        } = internalSlotsMap.get(this);\n\n        // If `--ext` option is present, use it.\n        if (extensionRegExp) {\n            return extensionRegExp.test(filePath);\n        }\n\n        // `.js` file is target by default.\n        if (filePath.endsWith(\".js\")) {\n            return true;\n        }\n\n        // use `overrides[].files` to check additional targets.\n        const config =\n            providedConfig ||\n            configArrayFactory.getConfigArrayForFile(\n                filePath,\n                { ignoreNotFoundError: true }\n            );\n\n        return config.isAdditionalTargetPath(filePath);\n    }\n\n    /**\n     * Iterate files which are matched by given glob patterns.\n     * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.\n     * @throws {NoFilesFoundError|AllFilesIgnoredError} On an unmatched pattern.\n     * @returns {IterableIterator<FileAndConfig>} The found files.\n     */\n    *iterateFiles(patternOrPatterns) {\n        const { globInputPaths, errorOnUnmatchedPattern } = internalSlotsMap.get(this);\n        const patterns = Array.isArray(patternOrPatterns)\n            ? patternOrPatterns\n            : [patternOrPatterns];\n\n        debug(\"Start to iterate files: %o\", patterns);\n\n        // The set of paths to remove duplicate.\n        const set = new Set();\n\n        for (const pattern of patterns) {\n            let foundRegardlessOfIgnored = false;\n            let found = false;\n\n            // Skip empty string.\n            if (!pattern) {\n                continue;\n            }\n\n            // Iterate files of this pattern.\n            for (const { config, filePath, flag } of this._iterateFiles(pattern)) {\n                foundRegardlessOfIgnored = true;\n                if (flag === IGNORED_SILENTLY) {\n                    continue;\n                }\n                found = true;\n\n                // Remove duplicate paths while yielding paths.\n                if (!set.has(filePath)) {\n                    set.add(filePath);\n                    yield {\n                        config,\n                        filePath,\n                        ignored: flag === IGNORED\n                    };\n                }\n            }\n\n            // Raise an error if any files were not found.\n            if (errorOnUnmatchedPattern) {\n                if (!foundRegardlessOfIgnored) {\n                    throw new NoFilesFoundError(\n                        pattern,\n                        !globInputPaths && isGlob(pattern)\n                    );\n                }\n                if (!found) {\n                    throw new AllFilesIgnoredError(pattern);\n                }\n            }\n        }\n\n        debug(`Complete iterating files: ${JSON.stringify(patterns)}`);\n    }\n\n    /**\n     * Iterate files which are matched by a given glob pattern.\n     * @param {string} pattern The glob pattern to iterate files.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     */\n    _iterateFiles(pattern) {\n        const { cwd, globInputPaths } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, pattern);\n        const isDot = dotfilesPattern.test(pattern);\n        const stat = statSafeSync(absolutePath);\n\n        if (stat && stat.isDirectory()) {\n            return this._iterateFilesWithDirectory(absolutePath, isDot);\n        }\n        if (stat && stat.isFile()) {\n            return this._iterateFilesWithFile(absolutePath);\n        }\n        if (globInputPaths && isGlobPattern(pattern)) {\n            return this._iterateFilesWithGlob(pattern, isDot);\n        }\n\n        return [];\n    }\n\n    /**\n     * Iterate a file which is matched by a given path.\n     * @param {string} filePath The path to the target file.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    _iterateFilesWithFile(filePath) {\n        debug(`File: ${filePath}`);\n\n        const { configArrayFactory } = internalSlotsMap.get(this);\n        const config = configArrayFactory.getConfigArrayForFile(filePath);\n        const ignored = this._isIgnoredFile(filePath, { config, direct: true });\n        const flag = ignored ? IGNORED : NONE;\n\n        return [{ config, filePath, flag }];\n    }\n\n    /**\n     * Iterate files in a given path.\n     * @param {string} directoryPath The path to the target directory.\n     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    _iterateFilesWithDirectory(directoryPath, dotfiles) {\n        debug(`Directory: ${directoryPath}`);\n\n        return this._iterateFilesRecursive(\n            directoryPath,\n            { dotfiles, recursive: true, selector: null }\n        );\n    }\n\n    /**\n     * Iterate files which are matched by a given glob pattern.\n     * @param {string} pattern The glob pattern to iterate files.\n     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    _iterateFilesWithGlob(pattern, dotfiles) {\n        debug(`Glob: ${pattern}`);\n\n        const { cwd } = internalSlotsMap.get(this);\n        const directoryPath = path.resolve(cwd, getGlobParent(pattern));\n        const absolutePath = path.resolve(cwd, pattern);\n        const globPart = absolutePath.slice(directoryPath.length + 1);\n\n        /*\n         * recursive if there are `**` or path separators in the glob part.\n         * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.\n         */\n        const recursive = /\\*\\*|\\/|\\\\/u.test(globPart);\n        const selector = new Minimatch(absolutePath, minimatchOpts);\n\n        debug(`recursive? ${recursive}`);\n\n        return this._iterateFilesRecursive(\n            directoryPath,\n            { dotfiles, recursive, selector }\n        );\n    }\n\n    /**\n     * Iterate files in a given path.\n     * @param {string} directoryPath The path to the target directory.\n     * @param {Object} options The options to iterate files.\n     * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.\n     * @param {boolean} [options.recursive] If `true` then it dives into sub directories.\n     * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    *_iterateFilesRecursive(directoryPath, options) {\n        debug(`Enter the directory: ${directoryPath}`);\n        const { configArrayFactory } = internalSlotsMap.get(this);\n\n        /** @type {ConfigArray|null} */\n        let config = null;\n\n        // Enumerate the files of this directory.\n        for (const entry of readdirSafeSync(directoryPath)) {\n            const filePath = path.join(directoryPath, entry.name);\n            const fileInfo = entry.isSymbolicLink() ? statSafeSync(filePath) : entry;\n\n            if (!fileInfo) {\n                continue;\n            }\n\n            // Check if the file is matched.\n            if (fileInfo.isFile()) {\n                if (!config) {\n                    config = configArrayFactory.getConfigArrayForFile(\n                        filePath,\n\n                        /*\n                         * We must ignore `ConfigurationNotFoundError` at this\n                         * point because we don't know if target files exist in\n                         * this directory.\n                         */\n                        { ignoreNotFoundError: true }\n                    );\n                }\n                const matched = options.selector\n\n                    // Started with a glob pattern; choose by the pattern.\n                    ? options.selector.match(filePath)\n\n                    // Started with a directory path; choose by file extensions.\n                    : this.isTargetPath(filePath, config);\n\n                if (matched) {\n                    const ignored = this._isIgnoredFile(filePath, { ...options, config });\n                    const flag = ignored ? IGNORED_SILENTLY : NONE;\n\n                    debug(`Yield: ${entry.name}${ignored ? \" but ignored\" : \"\"}`);\n                    yield {\n                        config: configArrayFactory.getConfigArrayForFile(filePath),\n                        filePath,\n                        flag\n                    };\n                } else {\n                    debug(`Didn't match: ${entry.name}`);\n                }\n\n            // Dive into the sub directory.\n            } else if (options.recursive && fileInfo.isDirectory()) {\n                if (!config) {\n                    config = configArrayFactory.getConfigArrayForFile(\n                        filePath,\n                        { ignoreNotFoundError: true }\n                    );\n                }\n                const ignored = this._isIgnoredFile(\n                    filePath + path.sep,\n                    { ...options, config }\n                );\n\n                if (!ignored) {\n                    yield* this._iterateFilesRecursive(filePath, options);\n                }\n            }\n        }\n\n        debug(`Leave the directory: ${directoryPath}`);\n    }\n\n    /**\n     * Check if a given file should be ignored.\n     * @param {string} filePath The path to a file to check.\n     * @param {Object} options Options\n     * @param {ConfigArray} [options.config] The config for this file.\n     * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.\n     * @param {boolean} [options.direct] If `true` then this is a direct specified file.\n     * @returns {boolean} `true` if the file should be ignored.\n     * @private\n     */\n    _isIgnoredFile(filePath, {\n        config: providedConfig,\n        dotfiles = false,\n        direct = false\n    }) {\n        const {\n            configArrayFactory,\n            defaultIgnores,\n            ignoreFlag\n        } = internalSlotsMap.get(this);\n\n        if (ignoreFlag) {\n            const config =\n                providedConfig ||\n                configArrayFactory.getConfigArrayForFile(\n                    filePath,\n                    { ignoreNotFoundError: true }\n                );\n            const ignores =\n                config.extractConfig(filePath).ignores || defaultIgnores;\n\n            return ignores(filePath, dotfiles);\n        }\n\n        return !direct && defaultIgnores(filePath, dotfiles);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = { FileEnumerator };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}