{"ast":null,"code":"/**\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\n * @author Aladdin-ADD<hh_2013@foxmail.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  getStaticValue\n} = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Enforce \\\"for\\\" loop update clause moving the counter in the right direction\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/for-direction\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n    }\n  },\n  create(context) {\n    const {\n      sourceCode\n    } = context;\n\n    /**\n     * report an error.\n     * @param {ASTNode} node the node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"incorrectDirection\"\n      });\n    }\n\n    /**\n     * check the right side of the assignment\n     * @param {ASTNode} update UpdateExpression to check\n     * @param {int} dir expected direction that could either be turned around or invalidated\n     * @returns {int} return dir, the negated dir, or zero if the counter does not change or the direction is not clear\n     */\n    function getRightDirection(update, dir) {\n      const staticValue = getStaticValue(update.right, sourceCode.getScope(update));\n      if (staticValue && [\"bigint\", \"boolean\", \"number\"].includes(typeof staticValue.value)) {\n        const sign = Math.sign(Number(staticValue.value)) || 0; // convert NaN to 0\n\n        return dir * sign;\n      }\n      return 0;\n    }\n\n    /**\n     * check UpdateExpression add/sub the counter\n     * @param {ASTNode} update UpdateExpression to check\n     * @param {string} counter variable name to check\n     * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n     */\n    function getUpdateDirection(update, counter) {\n      if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n        if (update.operator === \"++\") {\n          return 1;\n        }\n        if (update.operator === \"--\") {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * check AssignmentExpression add/sub the counter\n     * @param {ASTNode} update AssignmentExpression to check\n     * @param {string} counter variable name to check\n     * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n     */\n    function getAssignmentDirection(update, counter) {\n      if (update.left.name === counter) {\n        if (update.operator === \"+=\") {\n          return getRightDirection(update, 1);\n        }\n        if (update.operator === \"-=\") {\n          return getRightDirection(update, -1);\n        }\n      }\n      return 0;\n    }\n    return {\n      ForStatement(node) {\n        if (node.test && node.test.type === \"BinaryExpression\" && node.update) {\n          for (const counterPosition of [\"left\", \"right\"]) {\n            if (node.test[counterPosition].type !== \"Identifier\") {\n              continue;\n            }\n            const counter = node.test[counterPosition].name;\n            const operator = node.test.operator;\n            const update = node.update;\n            let wrongDirection;\n            if (operator === \"<\" || operator === \"<=\") {\n              wrongDirection = counterPosition === \"left\" ? -1 : 1;\n            } else if (operator === \">\" || operator === \">=\") {\n              wrongDirection = counterPosition === \"left\" ? 1 : -1;\n            } else {\n              return;\n            }\n            if (update.type === \"UpdateExpression\") {\n              if (getUpdateDirection(update, counter) === wrongDirection) {\n                report(node);\n              }\n            } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n              report(node);\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["getStaticValue","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","messages","incorrectDirection","create","context","sourceCode","report","node","messageId","getRightDirection","update","dir","staticValue","right","getScope","includes","value","sign","Math","Number","getUpdateDirection","counter","argument","name","operator","getAssignmentDirection","left","ForStatement","test","counterPosition","wrongDirection"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/for-direction.js"],"sourcesContent":["/**\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\n * @author Aladdin-ADD<hh_2013@foxmail.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { getStaticValue } = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Enforce \\\"for\\\" loop update clause moving the counter in the right direction\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/for-direction\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n        }\n    },\n\n    create(context) {\n        const { sourceCode } = context;\n\n        /**\n         * report an error.\n         * @param {ASTNode} node the node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"incorrectDirection\"\n            });\n        }\n\n        /**\n         * check the right side of the assignment\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {int} dir expected direction that could either be turned around or invalidated\n         * @returns {int} return dir, the negated dir, or zero if the counter does not change or the direction is not clear\n         */\n        function getRightDirection(update, dir) {\n            const staticValue = getStaticValue(update.right, sourceCode.getScope(update));\n\n            if (staticValue && [\"bigint\", \"boolean\", \"number\"].includes(typeof staticValue.value)) {\n                const sign = Math.sign(Number(staticValue.value)) || 0; // convert NaN to 0\n\n                return dir * sign;\n            }\n            return 0;\n        }\n\n        /**\n         * check UpdateExpression add/sub the counter\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getUpdateDirection(update, counter) {\n            if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n                if (update.operator === \"++\") {\n                    return 1;\n                }\n                if (update.operator === \"--\") {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n\n        /**\n         * check AssignmentExpression add/sub the counter\n         * @param {ASTNode} update AssignmentExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getAssignmentDirection(update, counter) {\n            if (update.left.name === counter) {\n                if (update.operator === \"+=\") {\n                    return getRightDirection(update, 1);\n                }\n                if (update.operator === \"-=\") {\n                    return getRightDirection(update, -1);\n                }\n            }\n            return 0;\n        }\n\n        return {\n            ForStatement(node) {\n\n                if (node.test && node.test.type === \"BinaryExpression\" && node.update) {\n                    for (const counterPosition of [\"left\", \"right\"]) {\n                        if (node.test[counterPosition].type !== \"Identifier\") {\n                            continue;\n                        }\n\n                        const counter = node.test[counterPosition].name;\n                        const operator = node.test.operator;\n                        const update = node.update;\n\n                        let wrongDirection;\n\n                        if (operator === \"<\" || operator === \"<=\") {\n                            wrongDirection = counterPosition === \"left\" ? -1 : 1;\n                        } else if (operator === \">\" || operator === \">=\") {\n                            wrongDirection = counterPosition === \"left\" ? 1 : -1;\n                        } else {\n                            return;\n                        }\n\n                        if (update.type === \"UpdateExpression\") {\n                            if (getUpdateDirection(update, counter) === wrongDirection) {\n                                report(node);\n                            }\n                        } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n                            report(node);\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}