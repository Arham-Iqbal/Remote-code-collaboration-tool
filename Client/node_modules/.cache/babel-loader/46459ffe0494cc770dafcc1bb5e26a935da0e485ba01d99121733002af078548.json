{"ast":null,"code":"/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* globals describe, it -- Mocha globals */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.run(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst assert = require(\"assert\"),\n  path = require(\"path\"),\n  util = require(\"util\"),\n  merge = require(\"lodash.merge\"),\n  equal = require(\"fast-deep-equal\"),\n  Traverser = require(\"../../lib/shared/traverser\"),\n  {\n    getRuleOptionsSchema,\n    validate\n  } = require(\"../shared/config-validator\"),\n  {\n    Linter,\n    SourceCodeFixer,\n    interpolate\n  } = require(\"../linter\"),\n  CodePath = require(\"../linter/code-path-analysis/code-path\");\nconst ajv = require(\"../shared/ajv\")({\n  strictDefaults: true\n});\nconst espreePath = require.resolve(\"espree\");\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\nconst {\n  SourceCode\n} = require(\"../source-code\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/**\n * A test case that is expected to pass lint.\n * @typedef {Object} ValidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {any[]} [options] Options for the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {string} [parser] The absolute path for the parser.\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A test case that is expected to fail lint.\n * @typedef {Object} InvalidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\n * @property {any[]} [options] Options for the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {string} [parser] The absolute path for the parser.\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A description of a reported error used in a rule tester test.\n * @typedef {Object} TestCaseError\n * @property {string | RegExp} [message] Message.\n * @property {string} [messageId] Message ID.\n * @property {string} [type] The type of the reported AST node.\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\n * @property {number} [line] The 1-based line number of the reported start location.\n * @property {number} [column] The 1-based column number of the reported start location.\n * @property {number} [endLine] The 1-based line number of the reported end location.\n * @property {number} [endColumn] The 1-based column number of the reported end location.\n */\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = {\n  rules: {}\n};\nlet defaultConfig = {\n  rules: {}\n};\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\"name\", \"code\", \"filename\", \"options\", \"errors\", \"output\", \"only\"];\n\n/*\n * All allowed property names in error objects.\n */\nconst errorObjectParameters = new Set([\"message\", \"messageId\", \"data\", \"type\", \"line\", \"column\", \"endLine\", \"endColumn\", \"suggestions\"]);\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\n/*\n * All allowed property names in suggestion objects.\n */\nconst suggestionObjectParameters = new Set([\"desc\", \"messageId\", \"data\", \"output\"]);\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\nconst forbiddenMethods = [\"applyInlineConfig\", \"applyLanguageOptions\", \"finalize\"];\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n  getSource: \"getText\",\n  getSourceLines: \"getLines\",\n  getAllComments: \"getAllComments\",\n  getNodeByRangeIndex: \"getNodeByRangeIndex\",\n  // getComments: \"getComments\", -- already handled by a separate error\n  getCommentsBefore: \"getCommentsBefore\",\n  getCommentsAfter: \"getCommentsAfter\",\n  getCommentsInside: \"getCommentsInside\",\n  getJSDocComment: \"getJSDocComment\",\n  getFirstToken: \"getFirstToken\",\n  getFirstTokens: \"getFirstTokens\",\n  getLastToken: \"getLastToken\",\n  getLastTokens: \"getLastTokens\",\n  getTokenAfter: \"getTokenAfter\",\n  getTokenBefore: \"getTokenBefore\",\n  getTokenByRangeStart: \"getTokenByRangeStart\",\n  getTokens: \"getTokens\",\n  getTokensAfter: \"getTokensAfter\",\n  getTokensBefore: \"getTokensBefore\",\n  getTokensBetween: \"getTokensBetween\",\n  getScope: \"getScope\",\n  getAncestors: \"getAncestors\",\n  getDeclaredVariables: \"getDeclaredVariables\",\n  markVariableAsUsed: \"markVariableAsUsed\"\n};\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      return x.map(cloneDeeplyExcludesParent);\n    }\n    const retv = {};\n    for (const key in x) {\n      if (key !== \"parent\" && hasOwnProperty(x, key)) {\n        retv[key] = cloneDeeplyExcludesParent(x[key]);\n      }\n    }\n    return retv;\n  }\n  return x;\n}\n\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      x.forEach(freezeDeeply);\n    } else {\n      for (const key in x) {\n        if (key !== \"parent\" && hasOwnProperty(x, key)) {\n          freezeDeeply(x[key]);\n        }\n      }\n    }\n    Object.freeze(x);\n  }\n}\n\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\nfunction sanitize(text) {\n  if (typeof text !== \"string\") {\n    return \"\";\n  }\n  return text.replace(/[\\u0000-\\u0009\\u000b-\\u001a]/gu,\n  // eslint-disable-line no-control-regex -- Escaping controls\n  c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`);\n}\n\n/**\n * Define `start`/`end` properties as throwing error.\n * @param {string} objName Object name used for error messages.\n * @param {ASTNode} node The node to define.\n * @returns {void}\n */\nfunction defineStartEndAsError(objName, node) {\n  Object.defineProperties(node, {\n    start: {\n      get() {\n        throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\n      },\n      configurable: true,\n      enumerable: false\n    },\n    end: {\n      get() {\n        throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\n      },\n      configurable: true,\n      enumerable: false\n    }\n  });\n}\n\n/**\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\n * @returns {void}\n */\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\n  Traverser.traverse(ast, {\n    visitorKeys,\n    enter: defineStartEndAsError.bind(null, \"node\")\n  });\n  ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\n  ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\n}\n\n/**\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\n * @param {Parser} parser Parser object.\n * @returns {Parser} Wrapped parser object.\n */\nfunction wrapParser(parser) {\n  if (typeof parser.parseForESLint === \"function\") {\n    return {\n      [parserSymbol]: parser,\n      parseForESLint(...args) {\n        const ret = parser.parseForESLint(...args);\n        defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\n        return ret;\n      }\n    };\n  }\n  return {\n    [parserSymbol]: parser,\n    parse(...args) {\n      const ast = parser.parse(...args);\n      defineStartEndAsErrorInTree(ast);\n      return ast;\n    }\n  };\n}\n\n/**\n * Function to replace `SourceCode.prototype.getComments`.\n * @returns {void}\n * @throws {Error} Deprecation message.\n */\nfunction getCommentsDeprecation() {\n  throw new Error(\"`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.\");\n}\n\n/**\n * Function to replace forbidden `SourceCode` methods.\n * @param {string} methodName The name of the method to forbid.\n * @returns {Function} The function that throws the error.\n */\nfunction throwForbiddenMethodError(methodName) {\n  return () => {\n    throw new Error(`\\`SourceCode#${methodName}()\\` cannot be called inside a rule.`);\n  };\n}\n\n/**\n * Emit a deprecation warning if function-style format is being used.\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitLegacyRuleAPIWarning(ruleName) {\n  if (!emitLegacyRuleAPIWarning[`warned-${ruleName}`]) {\n    emitLegacyRuleAPIWarning[`warned-${ruleName}`] = true;\n    process.emitWarning(`\"${ruleName}\" rule is using the deprecated function-style format and will stop working in ESLint v9. Please use object-style format: https://eslint.org/docs/latest/extend/custom-rules`, \"DeprecationWarning\");\n  }\n}\n\n/**\n * Emit a deprecation warning if rule has options but is missing the \"meta.schema\" property\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitMissingSchemaWarning(ruleName) {\n  if (!emitMissingSchemaWarning[`warned-${ruleName}`]) {\n    emitMissingSchemaWarning[`warned-${ruleName}`] = true;\n    process.emitWarning(`\"${ruleName}\" rule has options but is missing the \"meta.schema\" property and will stop working in ESLint v9. Please add a schema: https://eslint.org/docs/latest/extend/custom-rules#options-schemas`, \"DeprecationWarning\");\n  }\n}\n\n/**\n * Emit a deprecation warning if a rule uses a deprecated `context` method.\n * @param {string} ruleName Name of the rule.\n * @param {string} methodName The name of the method on `context` that was used.\n * @returns {void}\n */\nfunction emitDeprecatedContextMethodWarning(ruleName, methodName) {\n  if (!emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`]) {\n    emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`] = true;\n    process.emitWarning(`\"${ruleName}\" rule is using \\`context.${methodName}()\\`, which is deprecated and will be removed in ESLint v9. Please use \\`sourceCode.${DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]}()\\` instead.`, \"DeprecationWarning\");\n  }\n}\n\n/**\n * Emit a deprecation warning if rule uses CodePath#currentSegments.\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitCodePathCurrentSegmentsWarning(ruleName) {\n  if (!emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`]) {\n    emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`] = true;\n    process.emitWarning(`\"${ruleName}\" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples`, \"DeprecationWarning\");\n  }\n}\n\n/**\n * Emit a deprecation warning if `context.parserServices` is used.\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitParserServicesWarning(ruleName) {\n  if (!emitParserServicesWarning[`warned-${ruleName}`]) {\n    emitParserServicesWarning[`warned-${ruleName}`] = true;\n    process.emitWarning(`\"${ruleName}\" rule is using \\`context.parserServices\\`, which is deprecated and will be removed in ESLint v9. Please use \\`sourceCode.parserServices\\` instead.`, \"DeprecationWarning\");\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\nconst IT_ONLY = Symbol(\"itOnly\");\n\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @throws {Error} Any error upon execution of `method`.\n * @returns {any} Returned value of `method`.\n */\nfunction itDefaultHandler(text, method) {\n  try {\n    return method.call(this);\n  } catch (err) {\n    if (err instanceof assert.AssertionError) {\n      err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n    }\n    throw err;\n  }\n}\n\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction describeDefaultHandler(text, method) {\n  return method.call(this);\n}\n\n/**\n * Mocha test wrapper.\n */\nclass RuleTester {\n  /**\n   * Creates a new instance of RuleTester.\n   * @param {Object} [testerConfig] Optional, extra configuration for the tester\n   */\n  constructor(testerConfig) {\n    /**\n     * The configuration to use for this tester. Combination of the tester\n     * configuration and the default configuration.\n     * @type {Object}\n     */\n    this.testerConfig = merge({}, defaultConfig, testerConfig, {\n      rules: {\n        \"rule-tester/validate-ast\": \"error\"\n      }\n    });\n\n    /**\n     * Rule definitions to define before tests.\n     * @type {Object}\n     */\n    this.rules = {};\n    this.linter = new Linter();\n  }\n\n  /**\n   * Set the configuration to use for all future tests\n   * @param {Object} config the configuration to use.\n   * @throws {TypeError} If non-object config.\n   * @returns {void}\n   */\n  static setDefaultConfig(config) {\n    if (typeof config !== \"object\" || config === null) {\n      throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n    }\n    defaultConfig = config;\n\n    // Make sure the rules object exists since it is assumed to exist later\n    defaultConfig.rules = defaultConfig.rules || {};\n  }\n\n  /**\n   * Get the current configuration used for all tests\n   * @returns {Object} the current configuration\n   */\n  static getDefaultConfig() {\n    return defaultConfig;\n  }\n\n  /**\n   * Reset the configuration to the initial configuration of the tester removing\n   * any changes made until now.\n   * @returns {void}\n   */\n  static resetDefaultConfig() {\n    defaultConfig = merge({}, testerDefaultConfig);\n  }\n\n  /*\n   * If people use `mocha test.js --watch` command, `describe` and `it` function\n   * instances are different for each execution. So `describe` and `it` should get fresh instance\n   * always.\n   */\n  static get describe() {\n    return this[DESCRIBE] || (typeof describe === \"function\" ? describe : describeDefaultHandler);\n  }\n  static set describe(value) {\n    this[DESCRIBE] = value;\n  }\n  static get it() {\n    return this[IT] || (typeof it === \"function\" ? it : itDefaultHandler);\n  }\n  static set it(value) {\n    this[IT] = value;\n  }\n\n  /**\n   * Adds the `only` property to a test to run it in isolation.\n   * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\n   * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\n   */\n  static only(item) {\n    if (typeof item === \"string\") {\n      return {\n        code: item,\n        only: true\n      };\n    }\n    return {\n      ...item,\n      only: true\n    };\n  }\n  static get itOnly() {\n    if (typeof this[IT_ONLY] === \"function\") {\n      return this[IT_ONLY];\n    }\n    if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\n      return Function.bind.call(this[IT].only, this[IT]);\n    }\n    if (typeof it === \"function\" && typeof it.only === \"function\") {\n      return Function.bind.call(it.only, it);\n    }\n    if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\n      throw new Error(\"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" + \"See https://eslint.org/docs/latest/integrate/nodejs-api#customizing-ruletester for more.\");\n    }\n    if (typeof it === \"function\") {\n      throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\n    }\n    throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\n  }\n  static set itOnly(value) {\n    this[IT_ONLY] = value;\n  }\n\n  /**\n   * Define a rule for one particular run of tests.\n   * @param {string} name The name of the rule to define.\n   * @param {Function | Rule} rule The rule definition.\n   * @returns {void}\n   */\n  defineRule(name, rule) {\n    if (typeof rule === \"function\") {\n      emitLegacyRuleAPIWarning(name);\n    }\n    this.rules[name] = rule;\n  }\n\n  /**\n   * Adds a new rule test to execute.\n   * @param {string} ruleName The name of the rule to run.\n   * @param {Function | Rule} rule The rule to test.\n   * @param {{\n   *   valid: (ValidTestCase | string)[],\n   *   invalid: InvalidTestCase[]\n   * }} test The collection of tests to run.\n   * @throws {TypeError|Error} If non-object `test`, or if a required\n   * scenario of the given type is missing.\n   * @returns {void}\n   */\n  run(ruleName, rule, test) {\n    const testerConfig = this.testerConfig,\n      requiredScenarios = [\"valid\", \"invalid\"],\n      scenarioErrors = [],\n      linter = this.linter;\n    if (!test || typeof test !== \"object\") {\n      throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n    }\n    requiredScenarios.forEach(scenarioType => {\n      if (!test[scenarioType]) {\n        scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n      }\n    });\n    if (scenarioErrors.length > 0) {\n      throw new Error([`Test Scenarios for rule ${ruleName} is invalid:`].concat(scenarioErrors).join(\"\\n\"));\n    }\n    if (typeof rule === \"function\") {\n      emitLegacyRuleAPIWarning(ruleName);\n    }\n    linter.defineRule(ruleName, Object.assign({}, rule, {\n      // Create a wrapper rule that freezes the `context` properties.\n      create(context) {\n        freezeDeeply(context.options);\n        freezeDeeply(context.settings);\n        freezeDeeply(context.parserOptions);\n\n        // wrap all deprecated methods\n        const newContext = Object.create(context, Object.fromEntries(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).map(methodName => [methodName, {\n          value(...args) {\n            // emit deprecation warning\n            emitDeprecatedContextMethodWarning(ruleName, methodName);\n\n            // call the original method\n            return context[methodName].call(this, ...args);\n          },\n          enumerable: true\n        }])));\n\n        // emit warning about context.parserServices\n        const parserServices = context.parserServices;\n        Object.defineProperty(newContext, \"parserServices\", {\n          get() {\n            emitParserServicesWarning(ruleName);\n            return parserServices;\n          }\n        });\n        Object.freeze(newContext);\n        return (typeof rule === \"function\" ? rule : rule.create)(newContext);\n      }\n    }));\n    linter.defineRules(this.rules);\n\n    /**\n     * Run the rule for the given item\n     * @param {string|Object} item Item to run the rule against\n     * @throws {Error} If an invalid schema.\n     * @returns {Object} Eslint run result\n     * @private\n     */\n    function runRuleForItem(item) {\n      let config = merge({}, testerConfig),\n        code,\n        filename,\n        output,\n        beforeAST,\n        afterAST;\n      if (typeof item === \"string\") {\n        code = item;\n      } else {\n        code = item.code;\n\n        /*\n         * Assumes everything on the item is a config except for the\n         * parameters used by this tester\n         */\n        const itemConfig = {\n          ...item\n        };\n        for (const parameter of RuleTesterParameters) {\n          delete itemConfig[parameter];\n        }\n\n        /*\n         * Create the config object from the tester config and this item\n         * specific configurations.\n         */\n        config = merge(config, itemConfig);\n      }\n      if (item.filename) {\n        filename = item.filename;\n      }\n      if (hasOwnProperty(item, \"options\")) {\n        assert(Array.isArray(item.options), \"options must be an array\");\n        if (item.options.length > 0 && typeof rule === \"object\" && (!rule.meta || rule.meta && (typeof rule.meta.schema === \"undefined\" || rule.meta.schema === null))) {\n          emitMissingSchemaWarning(ruleName);\n        }\n        config.rules[ruleName] = [1].concat(item.options);\n      } else {\n        config.rules[ruleName] = 1;\n      }\n      const schema = getRuleOptionsSchema(rule);\n\n      /*\n       * Setup AST getters.\n       * The goal is to check whether or not AST was modified when\n       * running the rule under test.\n       */\n      linter.defineRule(\"rule-tester/validate-ast\", {\n        create() {\n          return {\n            Program(node) {\n              beforeAST = cloneDeeplyExcludesParent(node);\n            },\n            \"Program:exit\"(node) {\n              afterAST = node;\n            }\n          };\n        }\n      });\n      if (typeof config.parser === \"string\") {\n        assert(path.isAbsolute(config.parser), \"Parsers provided as strings to RuleTester must be absolute paths\");\n      } else {\n        config.parser = espreePath;\n      }\n      linter.defineParser(config.parser, wrapParser(require(config.parser)));\n      if (schema) {\n        ajv.validateSchema(schema);\n        if (ajv.errors) {\n          const errors = ajv.errors.map(error => {\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n            return `\\t${field}: ${error.message}`;\n          }).join(\"\\n\");\n          throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n        }\n\n        /*\n         * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n         * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n         * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n         * the schema is compiled here separately from checking for `validateSchema` errors.\n         */\n        try {\n          ajv.compile(schema);\n        } catch (err) {\n          throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n        }\n      }\n      validate(config, \"rule-tester\", id => id === ruleName ? rule : null);\n\n      // Verify the code.\n      const {\n        getComments,\n        applyLanguageOptions,\n        applyInlineConfig,\n        finalize\n      } = SourceCode.prototype;\n      const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, \"currentSegments\");\n      let messages;\n      try {\n        SourceCode.prototype.getComments = getCommentsDeprecation;\n        Object.defineProperty(CodePath.prototype, \"currentSegments\", {\n          get() {\n            emitCodePathCurrentSegmentsWarning(ruleName);\n            return originalCurrentSegments.get.call(this);\n          }\n        });\n        forbiddenMethods.forEach(methodName => {\n          SourceCode.prototype[methodName] = throwForbiddenMethodError(methodName);\n        });\n        messages = linter.verify(code, config, filename);\n      } finally {\n        SourceCode.prototype.getComments = getComments;\n        Object.defineProperty(CodePath.prototype, \"currentSegments\", originalCurrentSegments);\n        SourceCode.prototype.applyInlineConfig = applyInlineConfig;\n        SourceCode.prototype.applyLanguageOptions = applyLanguageOptions;\n        SourceCode.prototype.finalize = finalize;\n      }\n      const fatalErrorMessage = messages.find(m => m.fatal);\n      assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);\n\n      // Verify if autofix makes a syntax error or not.\n      if (messages.some(m => m.fix)) {\n        output = SourceCodeFixer.applyFixes(code, messages).output;\n        const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);\n        assert(!errorMessageInFix, [\"A fatal parsing error occurred in autofix.\", `Error: ${errorMessageInFix && errorMessageInFix.message}`, \"Autofix output:\", output].join(\"\\n\"));\n      } else {\n        output = code;\n      }\n      return {\n        messages,\n        output,\n        beforeAST,\n        afterAST: cloneDeeplyExcludesParent(afterAST)\n      };\n    }\n\n    /**\n     * Check if the AST was changed\n     * @param {ASTNode} beforeAST AST node before running\n     * @param {ASTNode} afterAST AST node after running\n     * @returns {void}\n     * @private\n     */\n    function assertASTDidntChange(beforeAST, afterAST) {\n      if (!equal(beforeAST, afterAST)) {\n        assert.fail(\"Rule should not modify AST.\");\n      }\n    }\n\n    /**\n     * Check if the template is valid or not\n     * all valid cases go through this\n     * @param {string|Object} item Item to run the rule against\n     * @returns {void}\n     * @private\n     */\n    function testValidTemplate(item) {\n      const code = typeof item === \"object\" ? item.code : item;\n      assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\n      if (item.name) {\n        assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n      }\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n      assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\", messages.length, util.inspect(messages)));\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n\n    /**\n     * Asserts that the message matches its expected value. If the expected\n     * value is a regular expression, it is checked against the actual\n     * value.\n     * @param {string} actual Actual value\n     * @param {string|RegExp} expected Expected value\n     * @returns {void}\n     * @private\n     */\n    function assertMessageMatches(actual, expected) {\n      if (expected instanceof RegExp) {\n        // assert.js doesn't have a built-in RegExp match function\n        assert.ok(expected.test(actual), `Expected '${actual}' to match ${expected}`);\n      } else {\n        assert.strictEqual(actual, expected);\n      }\n    }\n\n    /**\n     * Check if the template is invalid or not\n     * all invalid cases go through this.\n     * @param {string|Object} item Item to run the rule against\n     * @returns {void}\n     * @private\n     */\n    function testInvalidTemplate(item) {\n      assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\n      if (item.name) {\n        assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n      }\n      assert.ok(item.errors || item.errors === 0, `Did not specify errors for an invalid test of ${ruleName}`);\n      if (Array.isArray(item.errors) && item.errors.length === 0) {\n        assert.fail(\"Invalid cases must have at least one error\");\n      }\n      const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\n      const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n      if (typeof item.errors === \"number\") {\n        if (item.errors === 0) {\n          assert.fail(\"Invalid cases must have 'error' value greater than 0\");\n        }\n        assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\", item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n      } else {\n        assert.strictEqual(messages.length, item.errors.length, util.format(\"Should have %d error%s but had %d: %s\", item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n        const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\n        for (let i = 0, l = item.errors.length; i < l; i++) {\n          const error = item.errors[i];\n          const message = messages[i];\n          assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n          if (typeof error === \"string\" || error instanceof RegExp) {\n            // Just an error message.\n            assertMessageMatches(message.message, error);\n          } else if (typeof error === \"object\" && error !== null) {\n            /*\n             * Error object.\n             * This may have a message, messageId, data, node type, line, and/or\n             * column.\n             */\n\n            Object.keys(error).forEach(propertyName => {\n              assert.ok(errorObjectParameters.has(propertyName), `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`);\n            });\n            if (hasOwnProperty(error, \"message\")) {\n              assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n              assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n              assertMessageMatches(message.message, error.message);\n            } else if (hasOwnProperty(error, \"messageId\")) {\n              assert.ok(ruleHasMetaMessages, \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\");\n              if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n              }\n              assert.strictEqual(message.messageId, error.messageId, `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`);\n              if (hasOwnProperty(error, \"data\")) {\n                /*\n                 *  if data was provided, then directly compare the returned message to a synthetic\n                 *  interpolated message using the same message ID and data provided in the test.\n                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                 */\n                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n                assert.strictEqual(message.message, rehydratedMessage, `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`);\n              }\n            }\n            assert.ok(hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true, \"Error must specify 'messageId' if 'data' is used.\");\n            if (error.type) {\n              assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n            }\n            if (hasOwnProperty(error, \"line\")) {\n              assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n            }\n            if (hasOwnProperty(error, \"column\")) {\n              assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n            }\n            if (hasOwnProperty(error, \"endLine\")) {\n              assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n            }\n            if (hasOwnProperty(error, \"endColumn\")) {\n              assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n            }\n            if (hasOwnProperty(error, \"suggestions\")) {\n              // Support asserting there are no suggestions\n              if (!error.suggestions || Array.isArray(error.suggestions) && error.suggestions.length === 0) {\n                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                  assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                }\n              } else {\n                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n                error.suggestions.forEach((expectedSuggestion, index) => {\n                  assert.ok(typeof expectedSuggestion === \"object\" && expectedSuggestion !== null, \"Test suggestion in 'suggestions' array must be an object.\");\n                  Object.keys(expectedSuggestion).forEach(propertyName => {\n                    assert.ok(suggestionObjectParameters.has(propertyName), `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`);\n                  });\n                  const actualSuggestion = message.suggestions[index];\n                  const suggestionPrefix = `Error Suggestion at index ${index} :`;\n                  if (hasOwnProperty(expectedSuggestion, \"desc\")) {\n                    assert.ok(!hasOwnProperty(expectedSuggestion, \"data\"), `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`);\n                    assert.strictEqual(actualSuggestion.desc, expectedSuggestion.desc, `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`);\n                  }\n                  if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\n                    assert.ok(ruleHasMetaMessages, `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`);\n                    assert.ok(hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId), `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`);\n                    assert.strictEqual(actualSuggestion.messageId, expectedSuggestion.messageId, `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`);\n                    if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                      const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\n                      const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\n                      assert.strictEqual(actualSuggestion.desc, rehydratedDesc, `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`);\n                    }\n                  } else {\n                    assert.ok(!hasOwnProperty(expectedSuggestion, \"data\"), `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`);\n                  }\n                  if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                    const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n                    assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                  }\n                });\n              }\n            }\n          } else {\n            // Message was an unexpected type\n            assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n          }\n        }\n      }\n      if (hasOwnProperty(item, \"output\")) {\n        if (item.output === null) {\n          assert.strictEqual(result.output, item.code, \"Expected no autofixes to be suggested\");\n        } else {\n          assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n        }\n      } else {\n        assert.strictEqual(result.output, item.code, \"The rule fixed the code. Please add 'output' property.\");\n      }\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n\n    /*\n     * This creates a mocha test suite and pipes all supplied info through\n     * one of the templates above.\n     * The test suites for valid/invalid are created conditionally as\n     * test runners (eg. vitest) fail for empty test suites.\n     */\n    this.constructor.describe(ruleName, () => {\n      if (test.valid.length > 0) {\n        this.constructor.describe(\"valid\", () => {\n          test.valid.forEach(valid => {\n            this.constructor[valid.only ? \"itOnly\" : \"it\"](sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid), () => {\n              testValidTemplate(valid);\n            });\n          });\n        });\n      }\n      if (test.invalid.length > 0) {\n        this.constructor.describe(\"invalid\", () => {\n          test.invalid.forEach(invalid => {\n            this.constructor[invalid.only ? \"itOnly\" : \"it\"](sanitize(invalid.name || invalid.code), () => {\n              testInvalidTemplate(invalid);\n            });\n          });\n        });\n      }\n    });\n  }\n}\nRuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = null;\nmodule.exports = RuleTester;","map":{"version":3,"names":["assert","require","path","util","merge","equal","Traverser","getRuleOptionsSchema","validate","Linter","SourceCodeFixer","interpolate","CodePath","ajv","strictDefaults","espreePath","resolve","parserSymbol","Symbol","for","SourceCode","testerDefaultConfig","rules","defaultConfig","RuleTesterParameters","errorObjectParameters","Set","friendlyErrorObjectParameterList","map","key","join","suggestionObjectParameters","friendlySuggestionObjectParameterList","forbiddenMethods","hasOwnProperty","Function","call","bind","Object","DEPRECATED_SOURCECODE_PASSTHROUGHS","getSource","getSourceLines","getAllComments","getNodeByRangeIndex","getCommentsBefore","getCommentsAfter","getCommentsInside","getJSDocComment","getFirstToken","getFirstTokens","getLastToken","getLastTokens","getTokenAfter","getTokenBefore","getTokenByRangeStart","getTokens","getTokensAfter","getTokensBefore","getTokensBetween","getScope","getAncestors","getDeclaredVariables","markVariableAsUsed","cloneDeeplyExcludesParent","x","Array","isArray","retv","freezeDeeply","forEach","freeze","sanitize","text","replace","c","codePointAt","toString","padStart","defineStartEndAsError","objName","node","defineProperties","start","get","Error","configurable","enumerable","end","defineStartEndAsErrorInTree","ast","visitorKeys","traverse","enter","tokens","comments","wrapParser","parser","parseForESLint","args","ret","parse","getCommentsDeprecation","throwForbiddenMethodError","methodName","emitLegacyRuleAPIWarning","ruleName","process","emitWarning","emitMissingSchemaWarning","emitDeprecatedContextMethodWarning","emitCodePathCurrentSegmentsWarning","emitParserServicesWarning","DESCRIBE","IT","IT_ONLY","itDefaultHandler","method","err","AssertionError","message","inspect","actual","operator","expected","describeDefaultHandler","RuleTester","constructor","testerConfig","linter","setDefaultConfig","config","TypeError","getDefaultConfig","resetDefaultConfig","describe","value","it","only","item","code","itOnly","defineRule","name","rule","run","test","requiredScenarios","scenarioErrors","scenarioType","push","length","concat","assign","create","context","options","settings","parserOptions","newContext","fromEntries","keys","parserServices","defineProperty","defineRules","runRuleForItem","filename","output","beforeAST","afterAST","itemConfig","parameter","meta","schema","Program","Program:exit","isAbsolute","defineParser","validateSchema","errors","error","field","dataPath","slice","compile","id","getComments","applyLanguageOptions","applyInlineConfig","finalize","prototype","originalCurrentSegments","getOwnPropertyDescriptor","messages","verify","fatalErrorMessage","find","m","fatal","some","fix","applyFixes","errorMessageInFix","assertASTDidntChange","fail","testValidTemplate","ok","result","strictEqual","format","assertMessageMatches","RegExp","testInvalidTemplate","ruleHasMetaMessages","friendlyIDList","hasMessageOfThisRule","ruleId","i","l","propertyName","has","messageId","unformattedOriginalMessage","rehydratedMessage","data","type","nodeType","line","column","endLine","endColumn","suggestions","expectedSuggestion","index","actualSuggestion","suggestionPrefix","desc","unformattedMetaMessage","rehydratedDesc","codeWithAppliedSuggestion","valid","invalid","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rule-tester/rule-tester.js"],"sourcesContent":["/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* globals describe, it -- Mocha globals */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.run(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    assert = require(\"assert\"),\n    path = require(\"path\"),\n    util = require(\"util\"),\n    merge = require(\"lodash.merge\"),\n    equal = require(\"fast-deep-equal\"),\n    Traverser = require(\"../../lib/shared/traverser\"),\n    { getRuleOptionsSchema, validate } = require(\"../shared/config-validator\"),\n    { Linter, SourceCodeFixer, interpolate } = require(\"../linter\"),\n    CodePath = require(\"../linter/code-path-analysis/code-path\");\n\nconst ajv = require(\"../shared/ajv\")({ strictDefaults: true });\n\nconst espreePath = require.resolve(\"espree\");\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\nconst { SourceCode } = require(\"../source-code\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n\n/**\n * A test case that is expected to pass lint.\n * @typedef {Object} ValidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {any[]} [options] Options for the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {string} [parser] The absolute path for the parser.\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A test case that is expected to fail lint.\n * @typedef {Object} InvalidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\n * @property {any[]} [options] Options for the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {string} [parser] The absolute path for the parser.\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A description of a reported error used in a rule tester test.\n * @typedef {Object} TestCaseError\n * @property {string | RegExp} [message] Message.\n * @property {string} [messageId] Message ID.\n * @property {string} [type] The type of the reported AST node.\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\n * @property {number} [line] The 1-based line number of the reported start location.\n * @property {number} [column] The 1-based column number of the reported start location.\n * @property {number} [endLine] The 1-based line number of the reported end location.\n * @property {number} [endColumn] The 1-based column number of the reported end location.\n */\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\nlet defaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"name\",\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"errors\",\n    \"output\",\n    \"only\"\n];\n\n/*\n * All allowed property names in error objects.\n */\nconst errorObjectParameters = new Set([\n    \"message\",\n    \"messageId\",\n    \"data\",\n    \"type\",\n    \"line\",\n    \"column\",\n    \"endLine\",\n    \"endColumn\",\n    \"suggestions\"\n]);\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\n/*\n * All allowed property names in suggestion objects.\n */\nconst suggestionObjectParameters = new Set([\n    \"desc\",\n    \"messageId\",\n    \"data\",\n    \"output\"\n]);\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\nconst forbiddenMethods = [\n    \"applyInlineConfig\",\n    \"applyLanguageOptions\",\n    \"finalize\"\n];\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n    getSource: \"getText\",\n    getSourceLines: \"getLines\",\n    getAllComments: \"getAllComments\",\n    getNodeByRangeIndex: \"getNodeByRangeIndex\",\n\n    // getComments: \"getComments\", -- already handled by a separate error\n    getCommentsBefore: \"getCommentsBefore\",\n    getCommentsAfter: \"getCommentsAfter\",\n    getCommentsInside: \"getCommentsInside\",\n    getJSDocComment: \"getJSDocComment\",\n    getFirstToken: \"getFirstToken\",\n    getFirstTokens: \"getFirstTokens\",\n    getLastToken: \"getLastToken\",\n    getLastTokens: \"getLastTokens\",\n    getTokenAfter: \"getTokenAfter\",\n    getTokenBefore: \"getTokenBefore\",\n    getTokenByRangeStart: \"getTokenByRangeStart\",\n    getTokens: \"getTokens\",\n    getTokensAfter: \"getTokensAfter\",\n    getTokensBefore: \"getTokensBefore\",\n    getTokensBetween: \"getTokensBetween\",\n\n    getScope: \"getScope\",\n    getAncestors: \"getAncestors\",\n    getDeclaredVariables: \"getDeclaredVariables\",\n    markVariableAsUsed: \"markVariableAsUsed\"\n};\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\nfunction sanitize(text) {\n    if (typeof text !== \"string\") {\n        return \"\";\n    }\n    return text.replace(\n        /[\\u0000-\\u0009\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls\n        c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`\n    );\n}\n\n/**\n * Define `start`/`end` properties as throwing error.\n * @param {string} objName Object name used for error messages.\n * @param {ASTNode} node The node to define.\n * @returns {void}\n */\nfunction defineStartEndAsError(objName, node) {\n    Object.defineProperties(node, {\n        start: {\n            get() {\n                throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\n            },\n            configurable: true,\n            enumerable: false\n        },\n        end: {\n            get() {\n                throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\n            },\n            configurable: true,\n            enumerable: false\n        }\n    });\n}\n\n\n/**\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\n * @returns {void}\n */\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\n    Traverser.traverse(ast, { visitorKeys, enter: defineStartEndAsError.bind(null, \"node\") });\n    ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\n    ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\n}\n\n/**\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\n * @param {Parser} parser Parser object.\n * @returns {Parser} Wrapped parser object.\n */\nfunction wrapParser(parser) {\n\n    if (typeof parser.parseForESLint === \"function\") {\n        return {\n            [parserSymbol]: parser,\n            parseForESLint(...args) {\n                const ret = parser.parseForESLint(...args);\n\n                defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\n                return ret;\n            }\n        };\n    }\n\n    return {\n        [parserSymbol]: parser,\n        parse(...args) {\n            const ast = parser.parse(...args);\n\n            defineStartEndAsErrorInTree(ast);\n            return ast;\n        }\n    };\n}\n\n/**\n * Function to replace `SourceCode.prototype.getComments`.\n * @returns {void}\n * @throws {Error} Deprecation message.\n */\nfunction getCommentsDeprecation() {\n    throw new Error(\n        \"`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.\"\n    );\n}\n\n/**\n * Function to replace forbidden `SourceCode` methods.\n * @param {string} methodName The name of the method to forbid.\n * @returns {Function} The function that throws the error.\n */\nfunction throwForbiddenMethodError(methodName) {\n    return () => {\n        throw new Error(\n            `\\`SourceCode#${methodName}()\\` cannot be called inside a rule.`\n        );\n    };\n}\n\n/**\n * Emit a deprecation warning if function-style format is being used.\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitLegacyRuleAPIWarning(ruleName) {\n    if (!emitLegacyRuleAPIWarning[`warned-${ruleName}`]) {\n        emitLegacyRuleAPIWarning[`warned-${ruleName}`] = true;\n        process.emitWarning(\n            `\"${ruleName}\" rule is using the deprecated function-style format and will stop working in ESLint v9. Please use object-style format: https://eslint.org/docs/latest/extend/custom-rules`,\n            \"DeprecationWarning\"\n        );\n    }\n}\n\n/**\n * Emit a deprecation warning if rule has options but is missing the \"meta.schema\" property\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitMissingSchemaWarning(ruleName) {\n    if (!emitMissingSchemaWarning[`warned-${ruleName}`]) {\n        emitMissingSchemaWarning[`warned-${ruleName}`] = true;\n        process.emitWarning(\n            `\"${ruleName}\" rule has options but is missing the \"meta.schema\" property and will stop working in ESLint v9. Please add a schema: https://eslint.org/docs/latest/extend/custom-rules#options-schemas`,\n            \"DeprecationWarning\"\n        );\n    }\n}\n\n/**\n * Emit a deprecation warning if a rule uses a deprecated `context` method.\n * @param {string} ruleName Name of the rule.\n * @param {string} methodName The name of the method on `context` that was used.\n * @returns {void}\n */\nfunction emitDeprecatedContextMethodWarning(ruleName, methodName) {\n    if (!emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`]) {\n        emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`] = true;\n        process.emitWarning(\n            `\"${ruleName}\" rule is using \\`context.${methodName}()\\`, which is deprecated and will be removed in ESLint v9. Please use \\`sourceCode.${DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]}()\\` instead.`,\n            \"DeprecationWarning\"\n        );\n    }\n}\n\n/**\n * Emit a deprecation warning if rule uses CodePath#currentSegments.\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitCodePathCurrentSegmentsWarning(ruleName) {\n    if (!emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`]) {\n        emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`] = true;\n        process.emitWarning(\n            `\"${ruleName}\" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples`,\n            \"DeprecationWarning\"\n        );\n    }\n}\n\n/**\n * Emit a deprecation warning if `context.parserServices` is used.\n * @param {string} ruleName Name of the rule.\n * @returns {void}\n */\nfunction emitParserServicesWarning(ruleName) {\n    if (!emitParserServicesWarning[`warned-${ruleName}`]) {\n        emitParserServicesWarning[`warned-${ruleName}`] = true;\n        process.emitWarning(\n            `\"${ruleName}\" rule is using \\`context.parserServices\\`, which is deprecated and will be removed in ESLint v9. Please use \\`sourceCode.parserServices\\` instead.`,\n            \"DeprecationWarning\"\n        );\n    }\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\nconst IT_ONLY = Symbol(\"itOnly\");\n\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @throws {Error} Any error upon execution of `method`.\n * @returns {any} Returned value of `method`.\n */\nfunction itDefaultHandler(text, method) {\n    try {\n        return method.call(this);\n    } catch (err) {\n        if (err instanceof assert.AssertionError) {\n            err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n        }\n        throw err;\n    }\n}\n\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction describeDefaultHandler(text, method) {\n    return method.call(this);\n}\n\n/**\n * Mocha test wrapper.\n */\nclass RuleTester {\n\n    /**\n     * Creates a new instance of RuleTester.\n     * @param {Object} [testerConfig] Optional, extra configuration for the tester\n     */\n    constructor(testerConfig) {\n\n        /**\n         * The configuration to use for this tester. Combination of the tester\n         * configuration and the default configuration.\n         * @type {Object}\n         */\n        this.testerConfig = merge(\n            {},\n            defaultConfig,\n            testerConfig,\n            { rules: { \"rule-tester/validate-ast\": \"error\" } }\n        );\n\n        /**\n         * Rule definitions to define before tests.\n         * @type {Object}\n         */\n        this.rules = {};\n        this.linter = new Linter();\n    }\n\n    /**\n     * Set the configuration to use for all future tests\n     * @param {Object} config the configuration to use.\n     * @throws {TypeError} If non-object config.\n     * @returns {void}\n     */\n    static setDefaultConfig(config) {\n        if (typeof config !== \"object\" || config === null) {\n            throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n        }\n        defaultConfig = config;\n\n        // Make sure the rules object exists since it is assumed to exist later\n        defaultConfig.rules = defaultConfig.rules || {};\n    }\n\n    /**\n     * Get the current configuration used for all tests\n     * @returns {Object} the current configuration\n     */\n    static getDefaultConfig() {\n        return defaultConfig;\n    }\n\n    /**\n     * Reset the configuration to the initial configuration of the tester removing\n     * any changes made until now.\n     * @returns {void}\n     */\n    static resetDefaultConfig() {\n        defaultConfig = merge({}, testerDefaultConfig);\n    }\n\n\n    /*\n     * If people use `mocha test.js --watch` command, `describe` and `it` function\n     * instances are different for each execution. So `describe` and `it` should get fresh instance\n     * always.\n     */\n    static get describe() {\n        return (\n            this[DESCRIBE] ||\n            (typeof describe === \"function\" ? describe : describeDefaultHandler)\n        );\n    }\n\n    static set describe(value) {\n        this[DESCRIBE] = value;\n    }\n\n    static get it() {\n        return (\n            this[IT] ||\n            (typeof it === \"function\" ? it : itDefaultHandler)\n        );\n    }\n\n    static set it(value) {\n        this[IT] = value;\n    }\n\n    /**\n     * Adds the `only` property to a test to run it in isolation.\n     * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\n     * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\n     */\n    static only(item) {\n        if (typeof item === \"string\") {\n            return { code: item, only: true };\n        }\n\n        return { ...item, only: true };\n    }\n\n    static get itOnly() {\n        if (typeof this[IT_ONLY] === \"function\") {\n            return this[IT_ONLY];\n        }\n        if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\n            return Function.bind.call(this[IT].only, this[IT]);\n        }\n        if (typeof it === \"function\" && typeof it.only === \"function\") {\n            return Function.bind.call(it.only, it);\n        }\n\n        if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\n            throw new Error(\n                \"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" +\n                \"See https://eslint.org/docs/latest/integrate/nodejs-api#customizing-ruletester for more.\"\n            );\n        }\n        if (typeof it === \"function\") {\n            throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\n        }\n        throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\n    }\n\n    static set itOnly(value) {\n        this[IT_ONLY] = value;\n    }\n\n    /**\n     * Define a rule for one particular run of tests.\n     * @param {string} name The name of the rule to define.\n     * @param {Function | Rule} rule The rule definition.\n     * @returns {void}\n     */\n    defineRule(name, rule) {\n        if (typeof rule === \"function\") {\n            emitLegacyRuleAPIWarning(name);\n        }\n        this.rules[name] = rule;\n    }\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Function | Rule} rule The rule to test.\n     * @param {{\n     *   valid: (ValidTestCase | string)[],\n     *   invalid: InvalidTestCase[]\n     * }} test The collection of tests to run.\n     * @throws {TypeError|Error} If non-object `test`, or if a required\n     * scenario of the given type is missing.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            linter = this.linter;\n\n        if (!test || typeof test !== \"object\") {\n            throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (!test[scenarioType]) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n        if (typeof rule === \"function\") {\n            emitLegacyRuleAPIWarning(ruleName);\n        }\n\n        linter.defineRule(ruleName, Object.assign({}, rule, {\n\n            // Create a wrapper rule that freezes the `context` properties.\n            create(context) {\n                freezeDeeply(context.options);\n                freezeDeeply(context.settings);\n                freezeDeeply(context.parserOptions);\n\n                // wrap all deprecated methods\n                const newContext = Object.create(\n                    context,\n                    Object.fromEntries(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).map(methodName => [\n                        methodName,\n                        {\n                            value(...args) {\n\n                                // emit deprecation warning\n                                emitDeprecatedContextMethodWarning(ruleName, methodName);\n\n                                // call the original method\n                                return context[methodName].call(this, ...args);\n                            },\n                            enumerable: true\n                        }\n                    ]))\n                );\n\n                // emit warning about context.parserServices\n                const parserServices = context.parserServices;\n\n                Object.defineProperty(newContext, \"parserServices\", {\n                    get() {\n                        emitParserServicesWarning(ruleName);\n                        return parserServices;\n                    }\n                });\n\n                Object.freeze(newContext);\n\n                return (typeof rule === \"function\" ? rule : rule.create)(newContext);\n            }\n        }));\n\n        linter.defineRules(this.rules);\n\n        /**\n         * Run the rule for the given item\n         * @param {string|Object} item Item to run the rule against\n         * @throws {Error} If an invalid schema.\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(item) {\n            let config = merge({}, testerConfig),\n                code, filename, output, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                /*\n                 * Assumes everything on the item is a config except for the\n                 * parameters used by this tester\n                 */\n                const itemConfig = { ...item };\n\n                for (const parameter of RuleTesterParameters) {\n                    delete itemConfig[parameter];\n                }\n\n                /*\n                 * Create the config object from the tester config and this item\n                 * specific configurations.\n                 */\n                config = merge(\n                    config,\n                    itemConfig\n                );\n            }\n\n            if (item.filename) {\n                filename = item.filename;\n            }\n\n            if (hasOwnProperty(item, \"options\")) {\n                assert(Array.isArray(item.options), \"options must be an array\");\n                if (\n                    item.options.length > 0 &&\n                    typeof rule === \"object\" &&\n                    (\n                        !rule.meta || (rule.meta && (typeof rule.meta.schema === \"undefined\" || rule.meta.schema === null))\n                    )\n                ) {\n                    emitMissingSchemaWarning(ruleName);\n                }\n                config.rules[ruleName] = [1].concat(item.options);\n            } else {\n                config.rules[ruleName] = 1;\n            }\n\n            const schema = getRuleOptionsSchema(rule);\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            linter.defineRule(\"rule-tester/validate-ast\", {\n                create() {\n                    return {\n                        Program(node) {\n                            beforeAST = cloneDeeplyExcludesParent(node);\n                        },\n                        \"Program:exit\"(node) {\n                            afterAST = node;\n                        }\n                    };\n                }\n            });\n\n            if (typeof config.parser === \"string\") {\n                assert(path.isAbsolute(config.parser), \"Parsers provided as strings to RuleTester must be absolute paths\");\n            } else {\n                config.parser = espreePath;\n            }\n\n            linter.defineParser(config.parser, wrapParser(require(config.parser)));\n\n            if (schema) {\n                ajv.validateSchema(schema);\n\n                if (ajv.errors) {\n                    const errors = ajv.errors.map(error => {\n                        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n                        return `\\t${field}: ${error.message}`;\n                    }).join(\"\\n\");\n\n                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n                }\n\n                /*\n                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n                 * the schema is compiled here separately from checking for `validateSchema` errors.\n                 */\n                try {\n                    ajv.compile(schema);\n                } catch (err) {\n                    throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n                }\n            }\n\n            validate(config, \"rule-tester\", id => (id === ruleName ? rule : null));\n\n            // Verify the code.\n            const { getComments, applyLanguageOptions, applyInlineConfig, finalize } = SourceCode.prototype;\n            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, \"currentSegments\");\n            let messages;\n\n            try {\n                SourceCode.prototype.getComments = getCommentsDeprecation;\n                Object.defineProperty(CodePath.prototype, \"currentSegments\", {\n                    get() {\n                        emitCodePathCurrentSegmentsWarning(ruleName);\n                        return originalCurrentSegments.get.call(this);\n                    }\n                });\n\n                forbiddenMethods.forEach(methodName => {\n                    SourceCode.prototype[methodName] = throwForbiddenMethodError(methodName);\n                });\n\n                messages = linter.verify(code, config, filename);\n            } finally {\n                SourceCode.prototype.getComments = getComments;\n                Object.defineProperty(CodePath.prototype, \"currentSegments\", originalCurrentSegments);\n                SourceCode.prototype.applyInlineConfig = applyInlineConfig;\n                SourceCode.prototype.applyLanguageOptions = applyLanguageOptions;\n                SourceCode.prototype.finalize = finalize;\n            }\n\n            const fatalErrorMessage = messages.find(m => m.fatal);\n\n            assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);\n\n            // Verify if autofix makes a syntax error or not.\n            if (messages.some(m => m.fix)) {\n                output = SourceCodeFixer.applyFixes(code, messages).output;\n                const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);\n\n                assert(!errorMessageInFix, [\n                    \"A fatal parsing error occurred in autofix.\",\n                    `Error: ${errorMessageInFix && errorMessageInFix.message}`,\n                    \"Autofix output:\",\n                    output\n                ].join(\"\\n\"));\n            } else {\n                output = code;\n            }\n\n            return {\n                messages,\n                output,\n                beforeAST,\n                afterAST: cloneDeeplyExcludesParent(afterAST)\n            };\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!equal(beforeAST, afterAST)) {\n                assert.fail(\"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(item) {\n            const code = typeof item === \"object\" ? item.code : item;\n\n            assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\n            if (item.name) {\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n            }\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                messages.length,\n                util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.strictEqual(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(item) {\n            assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\n            if (item.name) {\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n            }\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            if (Array.isArray(item.errors) && item.errors.length === 0) {\n                assert.fail(\"Invalid cases must have at least one error\");\n            }\n\n            const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\n            const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            if (typeof item.errors === \"number\") {\n\n                if (item.errors === 0) {\n                    assert.fail(\"Invalid cases must have 'error' value greater than 0\");\n                }\n\n                assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors,\n                    item.errors === 1 ? \"\" : \"s\",\n                    messages.length,\n                    util.inspect(messages)));\n            } else {\n                assert.strictEqual(\n                    messages.length, item.errors.length, util.format(\n                        \"Should have %d error%s but had %d: %s\",\n                        item.errors.length,\n                        item.errors.length === 1 ? \"\" : \"s\",\n                        messages.length,\n                        util.inspect(messages)\n                    )\n                );\n\n                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    const error = item.errors[i];\n                    const message = messages[i];\n\n                    assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof error === \"string\" || error instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(message.message, error);\n                    } else if (typeof error === \"object\" && error !== null) {\n\n                        /*\n                         * Error object.\n                         * This may have a message, messageId, data, node type, line, and/or\n                         * column.\n                         */\n\n                        Object.keys(error).forEach(propertyName => {\n                            assert.ok(\n                                errorObjectParameters.has(propertyName),\n                                `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`\n                            );\n                        });\n\n                        if (hasOwnProperty(error, \"message\")) {\n                            assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n                            assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n                            assertMessageMatches(message.message, error.message);\n                        } else if (hasOwnProperty(error, \"messageId\")) {\n                            assert.ok(\n                                ruleHasMetaMessages,\n                                \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\"\n                            );\n                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n                            }\n                            assert.strictEqual(\n                                message.messageId,\n                                error.messageId,\n                                `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`\n                            );\n                            if (hasOwnProperty(error, \"data\")) {\n\n                                /*\n                                 *  if data was provided, then directly compare the returned message to a synthetic\n                                 *  interpolated message using the same message ID and data provided in the test.\n                                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                                 */\n                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n\n                                assert.strictEqual(\n                                    message.message,\n                                    rehydratedMessage,\n                                    `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`\n                                );\n                            }\n                        }\n\n                        assert.ok(\n                            hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true,\n                            \"Error must specify 'messageId' if 'data' is used.\"\n                        );\n\n                        if (error.type) {\n                            assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n                        }\n\n                        if (hasOwnProperty(error, \"line\")) {\n                            assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n                        }\n\n                        if (hasOwnProperty(error, \"column\")) {\n                            assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endLine\")) {\n                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endColumn\")) {\n                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n                        }\n\n                        if (hasOwnProperty(error, \"suggestions\")) {\n\n                            // Support asserting there are no suggestions\n                            if (!error.suggestions || (Array.isArray(error.suggestions) && error.suggestions.length === 0)) {\n                                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                                    assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                                }\n                            } else {\n                                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n\n                                error.suggestions.forEach((expectedSuggestion, index) => {\n                                    assert.ok(\n                                        typeof expectedSuggestion === \"object\" && expectedSuggestion !== null,\n                                        \"Test suggestion in 'suggestions' array must be an object.\"\n                                    );\n                                    Object.keys(expectedSuggestion).forEach(propertyName => {\n                                        assert.ok(\n                                            suggestionObjectParameters.has(propertyName),\n                                            `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`\n                                        );\n                                    });\n\n                                    const actualSuggestion = message.suggestions[index];\n                                    const suggestionPrefix = `Error Suggestion at index ${index} :`;\n\n                                    if (hasOwnProperty(expectedSuggestion, \"desc\")) {\n                                        assert.ok(\n                                            !hasOwnProperty(expectedSuggestion, \"data\"),\n                                            `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`\n                                        );\n                                        assert.strictEqual(\n                                            actualSuggestion.desc,\n                                            expectedSuggestion.desc,\n                                            `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`\n                                        );\n                                    }\n\n                                    if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\n                                        assert.ok(\n                                            ruleHasMetaMessages,\n                                            `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`\n                                        );\n                                        assert.ok(\n                                            hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId),\n                                            `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`\n                                        );\n                                        assert.strictEqual(\n                                            actualSuggestion.messageId,\n                                            expectedSuggestion.messageId,\n                                            `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`\n                                        );\n                                        if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                                            const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\n                                            const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\n\n                                            assert.strictEqual(\n                                                actualSuggestion.desc,\n                                                rehydratedDesc,\n                                                `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`\n                                            );\n                                        }\n                                    } else {\n                                        assert.ok(\n                                            !hasOwnProperty(expectedSuggestion, \"data\"),\n                                            `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`\n                                        );\n                                    }\n\n                                    if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                                        const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n\n                                        assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                                    }\n                                });\n                            }\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n                    }\n                }\n            }\n\n            if (hasOwnProperty(item, \"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        result.output,\n                        item.code,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n                }\n            } else {\n                assert.strictEqual(\n                    result.output,\n                    item.code,\n                    \"The rule fixed the code. Please add 'output' property.\"\n                );\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         * The test suites for valid/invalid are created conditionally as\n         * test runners (eg. vitest) fail for empty test suites.\n         */\n        this.constructor.describe(ruleName, () => {\n            if (test.valid.length > 0) {\n                this.constructor.describe(\"valid\", () => {\n                    test.valid.forEach(valid => {\n                        this.constructor[valid.only ? \"itOnly\" : \"it\"](\n                            sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid),\n                            () => {\n                                testValidTemplate(valid);\n                            }\n                        );\n                    });\n                });\n            }\n\n            if (test.invalid.length > 0) {\n                this.constructor.describe(\"invalid\", () => {\n                    test.invalid.forEach(invalid => {\n                        this.constructor[invalid.only ? \"itOnly\" : \"it\"](\n                            sanitize(invalid.name || invalid.code),\n                            () => {\n                                testInvalidTemplate(invalid);\n                            }\n                        );\n                    });\n                });\n            }\n        });\n    }\n}\n\nRuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = null;\n\nmodule.exports = RuleTester;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,MACIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;EAC1BC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;EACtBE,IAAI,GAAGF,OAAO,CAAC,MAAM,CAAC;EACtBG,KAAK,GAAGH,OAAO,CAAC,cAAc,CAAC;EAC/BI,KAAK,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;EAClCK,SAAS,GAAGL,OAAO,CAAC,4BAA4B,CAAC;EACjD;IAAEM,oBAAoB;IAAEC;EAAS,CAAC,GAAGP,OAAO,CAAC,4BAA4B,CAAC;EAC1E;IAAEQ,MAAM;IAAEC,eAAe;IAAEC;EAAY,CAAC,GAAGV,OAAO,CAAC,WAAW,CAAC;EAC/DW,QAAQ,GAAGX,OAAO,CAAC,wCAAwC,CAAC;AAEhE,MAAMY,GAAG,GAAGZ,OAAO,CAAC,eAAe,CAAC,CAAC;EAAEa,cAAc,EAAE;AAAK,CAAC,CAAC;AAE9D,MAAMC,UAAU,GAAGd,OAAO,CAACe,OAAO,CAAC,QAAQ,CAAC;AAC5C,MAAMC,YAAY,GAAGC,MAAM,CAACC,GAAG,CAAC,0BAA0B,CAAC;AAE3D,MAAM;EAAEC;AAAW,CAAC,GAAGnB,OAAO,CAAC,gBAAgB,CAAC;;AAEhD;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMoB,mBAAmB,GAAG;EAAEC,KAAK,EAAE,CAAC;AAAE,CAAC;AACzC,IAAIC,aAAa,GAAG;EAAED,KAAK,EAAE,CAAC;AAAE,CAAC;;AAEjC;AACA;AACA;AACA;AACA,MAAME,oBAAoB,GAAG,CACzB,MAAM,EACN,MAAM,EACN,UAAU,EACV,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,MAAM,CACT;;AAED;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,IAAIC,GAAG,CAAC,CAClC,SAAS,EACT,WAAW,EACX,MAAM,EACN,MAAM,EACN,MAAM,EACN,QAAQ,EACR,SAAS,EACT,WAAW,EACX,aAAa,CAChB,CAAC;AACF,MAAMC,gCAAgC,GAAG,IAAI,CAAC,GAAGF,qBAAqB,CAAC,CAACG,GAAG,CAACC,GAAG,IAAI,IAAIA,GAAG,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG;;AAE5G;AACA;AACA;AACA,MAAMC,0BAA0B,GAAG,IAAIL,GAAG,CAAC,CACvC,MAAM,EACN,WAAW,EACX,MAAM,EACN,QAAQ,CACX,CAAC;AACF,MAAMM,qCAAqC,GAAG,IAAI,CAAC,GAAGD,0BAA0B,CAAC,CAACH,GAAG,CAACC,GAAG,IAAI,IAAIA,GAAG,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG;AAEtH,MAAMG,gBAAgB,GAAG,CACrB,mBAAmB,EACnB,sBAAsB,EACtB,UAAU,CACb;AAED,MAAMC,cAAc,GAAGC,QAAQ,CAACC,IAAI,CAACC,IAAI,CAACC,MAAM,CAACJ,cAAc,CAAC;AAEhE,MAAMK,kCAAkC,GAAG;EACvCC,SAAS,EAAE,SAAS;EACpBC,cAAc,EAAE,UAAU;EAC1BC,cAAc,EAAE,gBAAgB;EAChCC,mBAAmB,EAAE,qBAAqB;EAE1C;EACAC,iBAAiB,EAAE,mBAAmB;EACtCC,gBAAgB,EAAE,kBAAkB;EACpCC,iBAAiB,EAAE,mBAAmB;EACtCC,eAAe,EAAE,iBAAiB;EAClCC,aAAa,EAAE,eAAe;EAC9BC,cAAc,EAAE,gBAAgB;EAChCC,YAAY,EAAE,cAAc;EAC5BC,aAAa,EAAE,eAAe;EAC9BC,aAAa,EAAE,eAAe;EAC9BC,cAAc,EAAE,gBAAgB;EAChCC,oBAAoB,EAAE,sBAAsB;EAC5CC,SAAS,EAAE,WAAW;EACtBC,cAAc,EAAE,gBAAgB;EAChCC,eAAe,EAAE,iBAAiB;EAClCC,gBAAgB,EAAE,kBAAkB;EAEpCC,QAAQ,EAAE,UAAU;EACpBC,YAAY,EAAE,cAAc;EAC5BC,oBAAoB,EAAE,sBAAsB;EAC5CC,kBAAkB,EAAE;AACxB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,yBAAyBA,CAACC,CAAC,EAAE;EAClC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,EAAE;IACrC,IAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,EAAE;MAClB,OAAOA,CAAC,CAACpC,GAAG,CAACmC,yBAAyB,CAAC;IAC3C;IAEA,MAAMI,IAAI,GAAG,CAAC,CAAC;IAEf,KAAK,MAAMtC,GAAG,IAAImC,CAAC,EAAE;MACjB,IAAInC,GAAG,KAAK,QAAQ,IAAIK,cAAc,CAAC8B,CAAC,EAAEnC,GAAG,CAAC,EAAE;QAC5CsC,IAAI,CAACtC,GAAG,CAAC,GAAGkC,yBAAyB,CAACC,CAAC,CAACnC,GAAG,CAAC,CAAC;MACjD;IACJ;IAEA,OAAOsC,IAAI;EACf;EAEA,OAAOH,CAAC;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASI,YAAYA,CAACJ,CAAC,EAAE;EACrB,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,EAAE;IACrC,IAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,EAAE;MAClBA,CAAC,CAACK,OAAO,CAACD,YAAY,CAAC;IAC3B,CAAC,MAAM;MACH,KAAK,MAAMvC,GAAG,IAAImC,CAAC,EAAE;QACjB,IAAInC,GAAG,KAAK,QAAQ,IAAIK,cAAc,CAAC8B,CAAC,EAAEnC,GAAG,CAAC,EAAE;UAC5CuC,YAAY,CAACJ,CAAC,CAACnC,GAAG,CAAC,CAAC;QACxB;MACJ;IACJ;IACAS,MAAM,CAACgC,MAAM,CAACN,CAAC,CAAC;EACpB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASO,QAAQA,CAACC,IAAI,EAAE;EACpB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC1B,OAAO,EAAE;EACb;EACA,OAAOA,IAAI,CAACC,OAAO,CACf,gCAAgC;EAAE;EAClCC,CAAC,IAAI,MAAMA,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAC7D,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,OAAO,EAAEC,IAAI,EAAE;EAC1C1C,MAAM,CAAC2C,gBAAgB,CAACD,IAAI,EAAE;IAC1BE,KAAK,EAAE;MACHC,GAAGA,CAAA,EAAG;QACF,MAAM,IAAIC,KAAK,CAAC,OAAOL,OAAO,wBAAwBA,OAAO,QAAQ,CAAC;MAC1E,CAAC;MACDM,YAAY,EAAE,IAAI;MAClBC,UAAU,EAAE;IAChB,CAAC;IACDC,GAAG,EAAE;MACDJ,GAAGA,CAAA,EAAG;QACF,MAAM,IAAIC,KAAK,CAAC,OAAOL,OAAO,wBAAwBA,OAAO,MAAM,CAAC;MACxE,CAAC;MACDM,YAAY,EAAE,IAAI;MAClBC,UAAU,EAAE;IAChB;EACJ,CAAC,CAAC;AACN;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,2BAA2BA,CAACC,GAAG,EAAEC,WAAW,EAAE;EACnDpF,SAAS,CAACqF,QAAQ,CAACF,GAAG,EAAE;IAAEC,WAAW;IAAEE,KAAK,EAAEd,qBAAqB,CAACzC,IAAI,CAAC,IAAI,EAAE,MAAM;EAAE,CAAC,CAAC;EACzFoD,GAAG,CAACI,MAAM,CAACxB,OAAO,CAACS,qBAAqB,CAACzC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;EAC7DoD,GAAG,CAACK,QAAQ,CAACzB,OAAO,CAACS,qBAAqB,CAACzC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0D,UAAUA,CAACC,MAAM,EAAE;EAExB,IAAI,OAAOA,MAAM,CAACC,cAAc,KAAK,UAAU,EAAE;IAC7C,OAAO;MACH,CAAChF,YAAY,GAAG+E,MAAM;MACtBC,cAAcA,CAAC,GAAGC,IAAI,EAAE;QACpB,MAAMC,GAAG,GAAGH,MAAM,CAACC,cAAc,CAAC,GAAGC,IAAI,CAAC;QAE1CV,2BAA2B,CAACW,GAAG,CAACV,GAAG,EAAEU,GAAG,CAACT,WAAW,CAAC;QACrD,OAAOS,GAAG;MACd;IACJ,CAAC;EACL;EAEA,OAAO;IACH,CAAClF,YAAY,GAAG+E,MAAM;IACtBI,KAAKA,CAAC,GAAGF,IAAI,EAAE;MACX,MAAMT,GAAG,GAAGO,MAAM,CAACI,KAAK,CAAC,GAAGF,IAAI,CAAC;MAEjCV,2BAA2B,CAACC,GAAG,CAAC;MAChC,OAAOA,GAAG;IACd;EACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASY,sBAAsBA,CAAA,EAAG;EAC9B,MAAM,IAAIjB,KAAK,CACX,6KACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASkB,yBAAyBA,CAACC,UAAU,EAAE;EAC3C,OAAO,MAAM;IACT,MAAM,IAAInB,KAAK,CACX,gBAAgBmB,UAAU,sCAC9B,CAAC;EACL,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwBA,CAACC,QAAQ,EAAE;EACxC,IAAI,CAACD,wBAAwB,CAAC,UAAUC,QAAQ,EAAE,CAAC,EAAE;IACjDD,wBAAwB,CAAC,UAAUC,QAAQ,EAAE,CAAC,GAAG,IAAI;IACrDC,OAAO,CAACC,WAAW,CACf,IAAIF,QAAQ,6KAA6K,EACzL,oBACJ,CAAC;EACL;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASG,wBAAwBA,CAACH,QAAQ,EAAE;EACxC,IAAI,CAACG,wBAAwB,CAAC,UAAUH,QAAQ,EAAE,CAAC,EAAE;IACjDG,wBAAwB,CAAC,UAAUH,QAAQ,EAAE,CAAC,GAAG,IAAI;IACrDC,OAAO,CAACC,WAAW,CACf,IAAIF,QAAQ,0LAA0L,EACtM,oBACJ,CAAC;EACL;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,kCAAkCA,CAACJ,QAAQ,EAAEF,UAAU,EAAE;EAC9D,IAAI,CAACM,kCAAkC,CAAC,UAAUJ,QAAQ,IAAIF,UAAU,EAAE,CAAC,EAAE;IACzEM,kCAAkC,CAAC,UAAUJ,QAAQ,IAAIF,UAAU,EAAE,CAAC,GAAG,IAAI;IAC7EG,OAAO,CAACC,WAAW,CACf,IAAIF,QAAQ,6BAA6BF,UAAU,uFAAuFhE,kCAAkC,CAACgE,UAAU,CAAC,eAAe,EACvM,oBACJ,CAAC;EACL;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASO,kCAAkCA,CAACL,QAAQ,EAAE;EAClD,IAAI,CAACK,kCAAkC,CAAC,UAAUL,QAAQ,EAAE,CAAC,EAAE;IAC3DK,kCAAkC,CAAC,UAAUL,QAAQ,EAAE,CAAC,GAAG,IAAI;IAC/DC,OAAO,CAACC,WAAW,CACf,IAAIF,QAAQ,6MAA6M,EACzN,oBACJ,CAAC;EACL;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASM,yBAAyBA,CAACN,QAAQ,EAAE;EACzC,IAAI,CAACM,yBAAyB,CAAC,UAAUN,QAAQ,EAAE,CAAC,EAAE;IAClDM,yBAAyB,CAAC,UAAUN,QAAQ,EAAE,CAAC,GAAG,IAAI;IACtDC,OAAO,CAACC,WAAW,CACf,IAAIF,QAAQ,qJAAqJ,EACjK,oBACJ,CAAC;EACL;AACJ;;AAGA;AACA;AACA;;AAEA;AACA,MAAMO,QAAQ,GAAG9F,MAAM,CAAC,UAAU,CAAC;AACnC,MAAM+F,EAAE,GAAG/F,MAAM,CAAC,IAAI,CAAC;AACvB,MAAMgG,OAAO,GAAGhG,MAAM,CAAC,QAAQ,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiG,gBAAgBA,CAAC3C,IAAI,EAAE4C,MAAM,EAAE;EACpC,IAAI;IACA,OAAOA,MAAM,CAAChF,IAAI,CAAC,IAAI,CAAC;EAC5B,CAAC,CAAC,OAAOiF,GAAG,EAAE;IACV,IAAIA,GAAG,YAAYrH,MAAM,CAACsH,cAAc,EAAE;MACtCD,GAAG,CAACE,OAAO,IAAI,KAAKpH,IAAI,CAACqH,OAAO,CAACH,GAAG,CAACI,MAAM,CAAC,IAAIJ,GAAG,CAACK,QAAQ,IAAIvH,IAAI,CAACqH,OAAO,CAACH,GAAG,CAACM,QAAQ,CAAC,GAAG;IACjG;IACA,MAAMN,GAAG;EACb;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,sBAAsBA,CAACpD,IAAI,EAAE4C,MAAM,EAAE;EAC1C,OAAOA,MAAM,CAAChF,IAAI,CAAC,IAAI,CAAC;AAC5B;;AAEA;AACA;AACA;AACA,MAAMyF,UAAU,CAAC;EAEb;AACJ;AACA;AACA;EACIC,WAAWA,CAACC,YAAY,EAAE;IAEtB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACA,YAAY,GAAG3H,KAAK,CACrB,CAAC,CAAC,EACFmB,aAAa,EACbwG,YAAY,EACZ;MAAEzG,KAAK,EAAE;QAAE,0BAA0B,EAAE;MAAQ;IAAE,CACrD,CAAC;;IAED;AACR;AACA;AACA;IACQ,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAAC0G,MAAM,GAAG,IAAIvH,MAAM,CAAC,CAAC;EAC9B;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOwH,gBAAgBA,CAACC,MAAM,EAAE;IAC5B,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,EAAE;MAC/C,MAAM,IAAIC,SAAS,CAAC,uDAAuD,CAAC;IAChF;IACA5G,aAAa,GAAG2G,MAAM;;IAEtB;IACA3G,aAAa,CAACD,KAAK,GAAGC,aAAa,CAACD,KAAK,IAAI,CAAC,CAAC;EACnD;;EAEA;AACJ;AACA;AACA;EACI,OAAO8G,gBAAgBA,CAAA,EAAG;IACtB,OAAO7G,aAAa;EACxB;;EAEA;AACJ;AACA;AACA;AACA;EACI,OAAO8G,kBAAkBA,CAAA,EAAG;IACxB9G,aAAa,GAAGnB,KAAK,CAAC,CAAC,CAAC,EAAEiB,mBAAmB,CAAC;EAClD;;EAGA;AACJ;AACA;AACA;AACA;EACI,WAAWiH,QAAQA,CAAA,EAAG;IAClB,OACI,IAAI,CAACtB,QAAQ,CAAC,KACb,OAAOsB,QAAQ,KAAK,UAAU,GAAGA,QAAQ,GAAGV,sBAAsB,CAAC;EAE5E;EAEA,WAAWU,QAAQA,CAACC,KAAK,EAAE;IACvB,IAAI,CAACvB,QAAQ,CAAC,GAAGuB,KAAK;EAC1B;EAEA,WAAWC,EAAEA,CAAA,EAAG;IACZ,OACI,IAAI,CAACvB,EAAE,CAAC,KACP,OAAOuB,EAAE,KAAK,UAAU,GAAGA,EAAE,GAAGrB,gBAAgB,CAAC;EAE1D;EAEA,WAAWqB,EAAEA,CAACD,KAAK,EAAE;IACjB,IAAI,CAACtB,EAAE,CAAC,GAAGsB,KAAK;EACpB;;EAEA;AACJ;AACA;AACA;AACA;EACI,OAAOE,IAAIA,CAACC,IAAI,EAAE;IACd,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC1B,OAAO;QAAEC,IAAI,EAAED,IAAI;QAAED,IAAI,EAAE;MAAK,CAAC;IACrC;IAEA,OAAO;MAAE,GAAGC,IAAI;MAAED,IAAI,EAAE;IAAK,CAAC;EAClC;EAEA,WAAWG,MAAMA,CAAA,EAAG;IAChB,IAAI,OAAO,IAAI,CAAC1B,OAAO,CAAC,KAAK,UAAU,EAAE;MACrC,OAAO,IAAI,CAACA,OAAO,CAAC;IACxB;IACA,IAAI,OAAO,IAAI,CAACD,EAAE,CAAC,KAAK,UAAU,IAAI,OAAO,IAAI,CAACA,EAAE,CAAC,CAACwB,IAAI,KAAK,UAAU,EAAE;MACvE,OAAOtG,QAAQ,CAACE,IAAI,CAACD,IAAI,CAAC,IAAI,CAAC6E,EAAE,CAAC,CAACwB,IAAI,EAAE,IAAI,CAACxB,EAAE,CAAC,CAAC;IACtD;IACA,IAAI,OAAOuB,EAAE,KAAK,UAAU,IAAI,OAAOA,EAAE,CAACC,IAAI,KAAK,UAAU,EAAE;MAC3D,OAAOtG,QAAQ,CAACE,IAAI,CAACD,IAAI,CAACoG,EAAE,CAACC,IAAI,EAAED,EAAE,CAAC;IAC1C;IAEA,IAAI,OAAO,IAAI,CAACxB,QAAQ,CAAC,KAAK,UAAU,IAAI,OAAO,IAAI,CAACC,EAAE,CAAC,KAAK,UAAU,EAAE;MACxE,MAAM,IAAI7B,KAAK,CACX,uEAAuE,GACvE,0FACJ,CAAC;IACL;IACA,IAAI,OAAOoD,EAAE,KAAK,UAAU,EAAE;MAC1B,MAAM,IAAIpD,KAAK,CAAC,0EAA0E,CAAC;IAC/F;IACA,MAAM,IAAIA,KAAK,CAAC,2FAA2F,CAAC;EAChH;EAEA,WAAWwD,MAAMA,CAACL,KAAK,EAAE;IACrB,IAAI,CAACrB,OAAO,CAAC,GAAGqB,KAAK;EACzB;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIM,UAAUA,CAACC,IAAI,EAAEC,IAAI,EAAE;IACnB,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;MAC5BvC,wBAAwB,CAACsC,IAAI,CAAC;IAClC;IACA,IAAI,CAACxH,KAAK,CAACwH,IAAI,CAAC,GAAGC,IAAI;EAC3B;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,GAAGA,CAACvC,QAAQ,EAAEsC,IAAI,EAAEE,IAAI,EAAE;IAEtB,MAAMlB,YAAY,GAAG,IAAI,CAACA,YAAY;MAClCmB,iBAAiB,GAAG,CAAC,OAAO,EAAE,SAAS,CAAC;MACxCC,cAAc,GAAG,EAAE;MACnBnB,MAAM,GAAG,IAAI,CAACA,MAAM;IAExB,IAAI,CAACiB,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MACnC,MAAM,IAAId,SAAS,CAAC,2BAA2B1B,QAAQ,wCAAwC,CAAC;IACpG;IAEAyC,iBAAiB,CAAC7E,OAAO,CAAC+E,YAAY,IAAI;MACtC,IAAI,CAACH,IAAI,CAACG,YAAY,CAAC,EAAE;QACrBD,cAAc,CAACE,IAAI,CAAC,sBAAsBD,YAAY,iBAAiB,CAAC;MAC5E;IACJ,CAAC,CAAC;IAEF,IAAID,cAAc,CAACG,MAAM,GAAG,CAAC,EAAE;MAC3B,MAAM,IAAIlE,KAAK,CAAC,CACZ,2BAA2BqB,QAAQ,cAAc,CACpD,CAAC8C,MAAM,CAACJ,cAAc,CAAC,CAACrH,IAAI,CAAC,IAAI,CAAC,CAAC;IACxC;IAEA,IAAI,OAAOiH,IAAI,KAAK,UAAU,EAAE;MAC5BvC,wBAAwB,CAACC,QAAQ,CAAC;IACtC;IAEAuB,MAAM,CAACa,UAAU,CAACpC,QAAQ,EAAEnE,MAAM,CAACkH,MAAM,CAAC,CAAC,CAAC,EAAET,IAAI,EAAE;MAEhD;MACAU,MAAMA,CAACC,OAAO,EAAE;QACZtF,YAAY,CAACsF,OAAO,CAACC,OAAO,CAAC;QAC7BvF,YAAY,CAACsF,OAAO,CAACE,QAAQ,CAAC;QAC9BxF,YAAY,CAACsF,OAAO,CAACG,aAAa,CAAC;;QAEnC;QACA,MAAMC,UAAU,GAAGxH,MAAM,CAACmH,MAAM,CAC5BC,OAAO,EACPpH,MAAM,CAACyH,WAAW,CAACzH,MAAM,CAAC0H,IAAI,CAACzH,kCAAkC,CAAC,CAACX,GAAG,CAAC2E,UAAU,IAAI,CACjFA,UAAU,EACV;UACIgC,KAAKA,CAAC,GAAGrC,IAAI,EAAE;YAEX;YACAW,kCAAkC,CAACJ,QAAQ,EAAEF,UAAU,CAAC;;YAExD;YACA,OAAOmD,OAAO,CAACnD,UAAU,CAAC,CAACnE,IAAI,CAAC,IAAI,EAAE,GAAG8D,IAAI,CAAC;UAClD,CAAC;UACDZ,UAAU,EAAE;QAChB,CAAC,CACJ,CAAC,CACN,CAAC;;QAED;QACA,MAAM2E,cAAc,GAAGP,OAAO,CAACO,cAAc;QAE7C3H,MAAM,CAAC4H,cAAc,CAACJ,UAAU,EAAE,gBAAgB,EAAE;UAChD3E,GAAGA,CAAA,EAAG;YACF4B,yBAAyB,CAACN,QAAQ,CAAC;YACnC,OAAOwD,cAAc;UACzB;QACJ,CAAC,CAAC;QAEF3H,MAAM,CAACgC,MAAM,CAACwF,UAAU,CAAC;QAEzB,OAAO,CAAC,OAAOf,IAAI,KAAK,UAAU,GAAGA,IAAI,GAAGA,IAAI,CAACU,MAAM,EAAEK,UAAU,CAAC;MACxE;IACJ,CAAC,CAAC,CAAC;IAEH9B,MAAM,CAACmC,WAAW,CAAC,IAAI,CAAC7I,KAAK,CAAC;;IAE9B;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAAS8I,cAAcA,CAAC1B,IAAI,EAAE;MAC1B,IAAIR,MAAM,GAAG9H,KAAK,CAAC,CAAC,CAAC,EAAE2H,YAAY,CAAC;QAChCY,IAAI;QAAE0B,QAAQ;QAAEC,MAAM;QAAEC,SAAS;QAAEC,QAAQ;MAE/C,IAAI,OAAO9B,IAAI,KAAK,QAAQ,EAAE;QAC1BC,IAAI,GAAGD,IAAI;MACf,CAAC,MAAM;QACHC,IAAI,GAAGD,IAAI,CAACC,IAAI;;QAEhB;AAChB;AACA;AACA;QACgB,MAAM8B,UAAU,GAAG;UAAE,GAAG/B;QAAK,CAAC;QAE9B,KAAK,MAAMgC,SAAS,IAAIlJ,oBAAoB,EAAE;UAC1C,OAAOiJ,UAAU,CAACC,SAAS,CAAC;QAChC;;QAEA;AAChB;AACA;AACA;QACgBxC,MAAM,GAAG9H,KAAK,CACV8H,MAAM,EACNuC,UACJ,CAAC;MACL;MAEA,IAAI/B,IAAI,CAAC2B,QAAQ,EAAE;QACfA,QAAQ,GAAG3B,IAAI,CAAC2B,QAAQ;MAC5B;MAEA,IAAInI,cAAc,CAACwG,IAAI,EAAE,SAAS,CAAC,EAAE;QACjC1I,MAAM,CAACiE,KAAK,CAACC,OAAO,CAACwE,IAAI,CAACiB,OAAO,CAAC,EAAE,0BAA0B,CAAC;QAC/D,IACIjB,IAAI,CAACiB,OAAO,CAACL,MAAM,GAAG,CAAC,IACvB,OAAOP,IAAI,KAAK,QAAQ,KAEpB,CAACA,IAAI,CAAC4B,IAAI,IAAK5B,IAAI,CAAC4B,IAAI,KAAK,OAAO5B,IAAI,CAAC4B,IAAI,CAACC,MAAM,KAAK,WAAW,IAAI7B,IAAI,CAAC4B,IAAI,CAACC,MAAM,KAAK,IAAI,CAAE,CACtG,EACH;UACEhE,wBAAwB,CAACH,QAAQ,CAAC;QACtC;QACAyB,MAAM,CAAC5G,KAAK,CAACmF,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC8C,MAAM,CAACb,IAAI,CAACiB,OAAO,CAAC;MACrD,CAAC,MAAM;QACHzB,MAAM,CAAC5G,KAAK,CAACmF,QAAQ,CAAC,GAAG,CAAC;MAC9B;MAEA,MAAMmE,MAAM,GAAGrK,oBAAoB,CAACwI,IAAI,CAAC;;MAEzC;AACZ;AACA;AACA;AACA;MACYf,MAAM,CAACa,UAAU,CAAC,0BAA0B,EAAE;QAC1CY,MAAMA,CAAA,EAAG;UACL,OAAO;YACHoB,OAAOA,CAAC7F,IAAI,EAAE;cACVuF,SAAS,GAAGxG,yBAAyB,CAACiB,IAAI,CAAC;YAC/C,CAAC;YACD,cAAc8F,CAAC9F,IAAI,EAAE;cACjBwF,QAAQ,GAAGxF,IAAI;YACnB;UACJ,CAAC;QACL;MACJ,CAAC,CAAC;MAEF,IAAI,OAAOkD,MAAM,CAAClC,MAAM,KAAK,QAAQ,EAAE;QACnChG,MAAM,CAACE,IAAI,CAAC6K,UAAU,CAAC7C,MAAM,CAAClC,MAAM,CAAC,EAAE,kEAAkE,CAAC;MAC9G,CAAC,MAAM;QACHkC,MAAM,CAAClC,MAAM,GAAGjF,UAAU;MAC9B;MAEAiH,MAAM,CAACgD,YAAY,CAAC9C,MAAM,CAAClC,MAAM,EAAED,UAAU,CAAC9F,OAAO,CAACiI,MAAM,CAAClC,MAAM,CAAC,CAAC,CAAC;MAEtE,IAAI4E,MAAM,EAAE;QACR/J,GAAG,CAACoK,cAAc,CAACL,MAAM,CAAC;QAE1B,IAAI/J,GAAG,CAACqK,MAAM,EAAE;UACZ,MAAMA,MAAM,GAAGrK,GAAG,CAACqK,MAAM,CAACtJ,GAAG,CAACuJ,KAAK,IAAI;YACnC,MAAMC,KAAK,GAAGD,KAAK,CAACE,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,GAAGF,KAAK,CAACE,QAAQ,CAACC,KAAK,CAAC,CAAC,CAAC,GAAGH,KAAK,CAACE,QAAQ;YAElF,OAAO,KAAKD,KAAK,KAAKD,KAAK,CAAC5D,OAAO,EAAE;UACzC,CAAC,CAAC,CAACzF,IAAI,CAAC,IAAI,CAAC;UAEb,MAAM,IAAIsD,KAAK,CAAC,CAAC,mBAAmBqB,QAAQ,cAAc,EAAEyE,MAAM,CAAC,CAAC;QACxE;;QAEA;AAChB;AACA;AACA;AACA;AACA;QACgB,IAAI;UACArK,GAAG,CAAC0K,OAAO,CAACX,MAAM,CAAC;QACvB,CAAC,CAAC,OAAOvD,GAAG,EAAE;UACV,MAAM,IAAIjC,KAAK,CAAC,mBAAmBqB,QAAQ,gBAAgBY,GAAG,CAACE,OAAO,EAAE,CAAC;QAC7E;MACJ;MAEA/G,QAAQ,CAAC0H,MAAM,EAAE,aAAa,EAAEsD,EAAE,IAAKA,EAAE,KAAK/E,QAAQ,GAAGsC,IAAI,GAAG,IAAK,CAAC;;MAEtE;MACA,MAAM;QAAE0C,WAAW;QAAEC,oBAAoB;QAAEC,iBAAiB;QAAEC;MAAS,CAAC,GAAGxK,UAAU,CAACyK,SAAS;MAC/F,MAAMC,uBAAuB,GAAGxJ,MAAM,CAACyJ,wBAAwB,CAACnL,QAAQ,CAACiL,SAAS,EAAE,iBAAiB,CAAC;MACtG,IAAIG,QAAQ;MAEZ,IAAI;QACA5K,UAAU,CAACyK,SAAS,CAACJ,WAAW,GAAGpF,sBAAsB;QACzD/D,MAAM,CAAC4H,cAAc,CAACtJ,QAAQ,CAACiL,SAAS,EAAE,iBAAiB,EAAE;UACzD1G,GAAGA,CAAA,EAAG;YACF2B,kCAAkC,CAACL,QAAQ,CAAC;YAC5C,OAAOqF,uBAAuB,CAAC3G,GAAG,CAAC/C,IAAI,CAAC,IAAI,CAAC;UACjD;QACJ,CAAC,CAAC;QAEFH,gBAAgB,CAACoC,OAAO,CAACkC,UAAU,IAAI;UACnCnF,UAAU,CAACyK,SAAS,CAACtF,UAAU,CAAC,GAAGD,yBAAyB,CAACC,UAAU,CAAC;QAC5E,CAAC,CAAC;QAEFyF,QAAQ,GAAGhE,MAAM,CAACiE,MAAM,CAACtD,IAAI,EAAET,MAAM,EAAEmC,QAAQ,CAAC;MACpD,CAAC,SAAS;QACNjJ,UAAU,CAACyK,SAAS,CAACJ,WAAW,GAAGA,WAAW;QAC9CnJ,MAAM,CAAC4H,cAAc,CAACtJ,QAAQ,CAACiL,SAAS,EAAE,iBAAiB,EAAEC,uBAAuB,CAAC;QACrF1K,UAAU,CAACyK,SAAS,CAACF,iBAAiB,GAAGA,iBAAiB;QAC1DvK,UAAU,CAACyK,SAAS,CAACH,oBAAoB,GAAGA,oBAAoB;QAChEtK,UAAU,CAACyK,SAAS,CAACD,QAAQ,GAAGA,QAAQ;MAC5C;MAEA,MAAMM,iBAAiB,GAAGF,QAAQ,CAACG,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,KAAK,CAAC;MAErDrM,MAAM,CAAC,CAACkM,iBAAiB,EAAE,mCAAmCA,iBAAiB,IAAIA,iBAAiB,CAAC3E,OAAO,EAAE,CAAC;;MAE/G;MACA,IAAIyE,QAAQ,CAACM,IAAI,CAACF,CAAC,IAAIA,CAAC,CAACG,GAAG,CAAC,EAAE;QAC3BjC,MAAM,GAAG5J,eAAe,CAAC8L,UAAU,CAAC7D,IAAI,EAAEqD,QAAQ,CAAC,CAAC1B,MAAM;QAC1D,MAAMmC,iBAAiB,GAAGzE,MAAM,CAACiE,MAAM,CAAC3B,MAAM,EAAEpC,MAAM,EAAEmC,QAAQ,CAAC,CAAC8B,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,KAAK,CAAC;QAEpFrM,MAAM,CAAC,CAACyM,iBAAiB,EAAE,CACvB,4CAA4C,EAC5C,UAAUA,iBAAiB,IAAIA,iBAAiB,CAAClF,OAAO,EAAE,EAC1D,iBAAiB,EACjB+C,MAAM,CACT,CAACxI,IAAI,CAAC,IAAI,CAAC,CAAC;MACjB,CAAC,MAAM;QACHwI,MAAM,GAAG3B,IAAI;MACjB;MAEA,OAAO;QACHqD,QAAQ;QACR1B,MAAM;QACNC,SAAS;QACTC,QAAQ,EAAEzG,yBAAyB,CAACyG,QAAQ;MAChD,CAAC;IACL;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASkC,oBAAoBA,CAACnC,SAAS,EAAEC,QAAQ,EAAE;MAC/C,IAAI,CAACnK,KAAK,CAACkK,SAAS,EAAEC,QAAQ,CAAC,EAAE;QAC7BxK,MAAM,CAAC2M,IAAI,CAAC,6BAA6B,CAAC;MAC9C;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,iBAAiBA,CAAClE,IAAI,EAAE;MAC7B,MAAMC,IAAI,GAAG,OAAOD,IAAI,KAAK,QAAQ,GAAGA,IAAI,CAACC,IAAI,GAAGD,IAAI;MAExD1I,MAAM,CAAC6M,EAAE,CAAC,OAAOlE,IAAI,KAAK,QAAQ,EAAE,kDAAkD,CAAC;MACvF,IAAID,IAAI,CAACI,IAAI,EAAE;QACX9I,MAAM,CAAC6M,EAAE,CAAC,OAAOnE,IAAI,CAACI,IAAI,KAAK,QAAQ,EAAE,qDAAqD,CAAC;MACnG;MAEA,MAAMgE,MAAM,GAAG1C,cAAc,CAAC1B,IAAI,CAAC;MACnC,MAAMsD,QAAQ,GAAGc,MAAM,CAACd,QAAQ;MAEhChM,MAAM,CAAC+M,WAAW,CAACf,QAAQ,CAAC1C,MAAM,EAAE,CAAC,EAAEnJ,IAAI,CAAC6M,MAAM,CAAC,sCAAsC,EACrFhB,QAAQ,CAAC1C,MAAM,EACfnJ,IAAI,CAACqH,OAAO,CAACwE,QAAQ,CAAC,CAAC,CAAC;MAE5BU,oBAAoB,CAACI,MAAM,CAACvC,SAAS,EAAEuC,MAAM,CAACtC,QAAQ,CAAC;IAC3D;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASyC,oBAAoBA,CAACxF,MAAM,EAAEE,QAAQ,EAAE;MAC5C,IAAIA,QAAQ,YAAYuF,MAAM,EAAE;QAE5B;QACAlN,MAAM,CAAC6M,EAAE,CACLlF,QAAQ,CAACsB,IAAI,CAACxB,MAAM,CAAC,EACrB,aAAaA,MAAM,cAAcE,QAAQ,EAC7C,CAAC;MACL,CAAC,MAAM;QACH3H,MAAM,CAAC+M,WAAW,CAACtF,MAAM,EAAEE,QAAQ,CAAC;MACxC;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASwF,mBAAmBA,CAACzE,IAAI,EAAE;MAC/B1I,MAAM,CAAC6M,EAAE,CAAC,OAAOnE,IAAI,CAACC,IAAI,KAAK,QAAQ,EAAE,kDAAkD,CAAC;MAC5F,IAAID,IAAI,CAACI,IAAI,EAAE;QACX9I,MAAM,CAAC6M,EAAE,CAAC,OAAOnE,IAAI,CAACI,IAAI,KAAK,QAAQ,EAAE,qDAAqD,CAAC;MACnG;MACA9I,MAAM,CAAC6M,EAAE,CAACnE,IAAI,CAACwC,MAAM,IAAIxC,IAAI,CAACwC,MAAM,KAAK,CAAC,EACtC,iDAAiDzE,QAAQ,EAAE,CAAC;MAEhE,IAAIxC,KAAK,CAACC,OAAO,CAACwE,IAAI,CAACwC,MAAM,CAAC,IAAIxC,IAAI,CAACwC,MAAM,CAAC5B,MAAM,KAAK,CAAC,EAAE;QACxDtJ,MAAM,CAAC2M,IAAI,CAAC,4CAA4C,CAAC;MAC7D;MAEA,MAAMS,mBAAmB,GAAGlL,cAAc,CAAC6G,IAAI,EAAE,MAAM,CAAC,IAAI7G,cAAc,CAAC6G,IAAI,CAAC4B,IAAI,EAAE,UAAU,CAAC;MACjG,MAAM0C,cAAc,GAAGD,mBAAmB,GAAG,IAAI9K,MAAM,CAAC0H,IAAI,CAACjB,IAAI,CAAC4B,IAAI,CAACqB,QAAQ,CAAC,CAACpK,GAAG,CAACC,GAAG,IAAI,IAAIA,GAAG,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI;MAE5H,MAAMgL,MAAM,GAAG1C,cAAc,CAAC1B,IAAI,CAAC;MACnC,MAAMsD,QAAQ,GAAGc,MAAM,CAACd,QAAQ;MAEhC,IAAI,OAAOtD,IAAI,CAACwC,MAAM,KAAK,QAAQ,EAAE;QAEjC,IAAIxC,IAAI,CAACwC,MAAM,KAAK,CAAC,EAAE;UACnBlL,MAAM,CAAC2M,IAAI,CAAC,sDAAsD,CAAC;QACvE;QAEA3M,MAAM,CAAC+M,WAAW,CAACf,QAAQ,CAAC1C,MAAM,EAAEZ,IAAI,CAACwC,MAAM,EAAE/K,IAAI,CAAC6M,MAAM,CAAC,uCAAuC,EAChGtE,IAAI,CAACwC,MAAM,EACXxC,IAAI,CAACwC,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,EAC5Bc,QAAQ,CAAC1C,MAAM,EACfnJ,IAAI,CAACqH,OAAO,CAACwE,QAAQ,CAAC,CAAC,CAAC;MAChC,CAAC,MAAM;QACHhM,MAAM,CAAC+M,WAAW,CACdf,QAAQ,CAAC1C,MAAM,EAAEZ,IAAI,CAACwC,MAAM,CAAC5B,MAAM,EAAEnJ,IAAI,CAAC6M,MAAM,CAC5C,uCAAuC,EACvCtE,IAAI,CAACwC,MAAM,CAAC5B,MAAM,EAClBZ,IAAI,CAACwC,MAAM,CAAC5B,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,EACnC0C,QAAQ,CAAC1C,MAAM,EACfnJ,IAAI,CAACqH,OAAO,CAACwE,QAAQ,CACzB,CACJ,CAAC;QAED,MAAMsB,oBAAoB,GAAGtB,QAAQ,CAACM,IAAI,CAACF,CAAC,IAAIA,CAAC,CAACmB,MAAM,KAAK9G,QAAQ,CAAC;QAEtE,KAAK,IAAI+G,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG/E,IAAI,CAACwC,MAAM,CAAC5B,MAAM,EAAEkE,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAChD,MAAMrC,KAAK,GAAGzC,IAAI,CAACwC,MAAM,CAACsC,CAAC,CAAC;UAC5B,MAAMjG,OAAO,GAAGyE,QAAQ,CAACwB,CAAC,CAAC;UAE3BxN,MAAM,CAACsN,oBAAoB,EAAE,yEAAyE,CAAC;UAEvG,IAAI,OAAOnC,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAY+B,MAAM,EAAE;YAEtD;YACAD,oBAAoB,CAAC1F,OAAO,CAACA,OAAO,EAAE4D,KAAK,CAAC;UAChD,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;YAEpD;AACxB;AACA;AACA;AACA;;YAEwB7I,MAAM,CAAC0H,IAAI,CAACmB,KAAK,CAAC,CAAC9G,OAAO,CAACqJ,YAAY,IAAI;cACvC1N,MAAM,CAAC6M,EAAE,CACLpL,qBAAqB,CAACkM,GAAG,CAACD,YAAY,CAAC,EACvC,gCAAgCA,YAAY,sBAAsB/L,gCAAgC,GACtG,CAAC;YACL,CAAC,CAAC;YAEF,IAAIO,cAAc,CAACiJ,KAAK,EAAE,SAAS,CAAC,EAAE;cAClCnL,MAAM,CAAC6M,EAAE,CAAC,CAAC3K,cAAc,CAACiJ,KAAK,EAAE,WAAW,CAAC,EAAE,4DAA4D,CAAC;cAC5GnL,MAAM,CAAC6M,EAAE,CAAC,CAAC3K,cAAc,CAACiJ,KAAK,EAAE,MAAM,CAAC,EAAE,qDAAqD,CAAC;cAChG8B,oBAAoB,CAAC1F,OAAO,CAACA,OAAO,EAAE4D,KAAK,CAAC5D,OAAO,CAAC;YACxD,CAAC,MAAM,IAAIrF,cAAc,CAACiJ,KAAK,EAAE,WAAW,CAAC,EAAE;cAC3CnL,MAAM,CAAC6M,EAAE,CACLO,mBAAmB,EACnB,kFACJ,CAAC;cACD,IAAI,CAAClL,cAAc,CAAC6G,IAAI,CAAC4B,IAAI,CAACqB,QAAQ,EAAEb,KAAK,CAACyC,SAAS,CAAC,EAAE;gBACtD5N,MAAM,CAAC,KAAK,EAAE,sBAAsBmL,KAAK,CAACyC,SAAS,sBAAsBP,cAAc,GAAG,CAAC;cAC/F;cACArN,MAAM,CAAC+M,WAAW,CACdxF,OAAO,CAACqG,SAAS,EACjBzC,KAAK,CAACyC,SAAS,EACf,cAAcrG,OAAO,CAACqG,SAAS,wCAAwCzC,KAAK,CAACyC,SAAS,IAC1F,CAAC;cACD,IAAI1L,cAAc,CAACiJ,KAAK,EAAE,MAAM,CAAC,EAAE;gBAE/B;AAChC;AACA;AACA;AACA;gBACgC,MAAM0C,0BAA0B,GAAG9E,IAAI,CAAC4B,IAAI,CAACqB,QAAQ,CAACb,KAAK,CAACyC,SAAS,CAAC;gBACtE,MAAME,iBAAiB,GAAGnN,WAAW,CAACkN,0BAA0B,EAAE1C,KAAK,CAAC4C,IAAI,CAAC;gBAE7E/N,MAAM,CAAC+M,WAAW,CACdxF,OAAO,CAACA,OAAO,EACfuG,iBAAiB,EACjB,qBAAqBA,iBAAiB,qBAAqBvG,OAAO,CAACA,OAAO,GAC9E,CAAC;cACL;YACJ;YAEAvH,MAAM,CAAC6M,EAAE,CACL3K,cAAc,CAACiJ,KAAK,EAAE,MAAM,CAAC,GAAGjJ,cAAc,CAACiJ,KAAK,EAAE,WAAW,CAAC,GAAG,IAAI,EACzE,mDACJ,CAAC;YAED,IAAIA,KAAK,CAAC6C,IAAI,EAAE;cACZhO,MAAM,CAAC+M,WAAW,CAACxF,OAAO,CAAC0G,QAAQ,EAAE9C,KAAK,CAAC6C,IAAI,EAAE,wBAAwB7C,KAAK,CAAC6C,IAAI,WAAWzG,OAAO,CAAC0G,QAAQ,EAAE,CAAC;YACrH;YAEA,IAAI/L,cAAc,CAACiJ,KAAK,EAAE,MAAM,CAAC,EAAE;cAC/BnL,MAAM,CAAC+M,WAAW,CAACxF,OAAO,CAAC2G,IAAI,EAAE/C,KAAK,CAAC+C,IAAI,EAAE,wBAAwB/C,KAAK,CAAC+C,IAAI,EAAE,CAAC;YACtF;YAEA,IAAIhM,cAAc,CAACiJ,KAAK,EAAE,QAAQ,CAAC,EAAE;cACjCnL,MAAM,CAAC+M,WAAW,CAACxF,OAAO,CAAC4G,MAAM,EAAEhD,KAAK,CAACgD,MAAM,EAAE,0BAA0BhD,KAAK,CAACgD,MAAM,EAAE,CAAC;YAC9F;YAEA,IAAIjM,cAAc,CAACiJ,KAAK,EAAE,SAAS,CAAC,EAAE;cAClCnL,MAAM,CAAC+M,WAAW,CAACxF,OAAO,CAAC6G,OAAO,EAAEjD,KAAK,CAACiD,OAAO,EAAE,2BAA2BjD,KAAK,CAACiD,OAAO,EAAE,CAAC;YAClG;YAEA,IAAIlM,cAAc,CAACiJ,KAAK,EAAE,WAAW,CAAC,EAAE;cACpCnL,MAAM,CAAC+M,WAAW,CAACxF,OAAO,CAAC8G,SAAS,EAAElD,KAAK,CAACkD,SAAS,EAAE,6BAA6BlD,KAAK,CAACkD,SAAS,EAAE,CAAC;YAC1G;YAEA,IAAInM,cAAc,CAACiJ,KAAK,EAAE,aAAa,CAAC,EAAE;cAEtC;cACA,IAAI,CAACA,KAAK,CAACmD,WAAW,IAAKrK,KAAK,CAACC,OAAO,CAACiH,KAAK,CAACmD,WAAW,CAAC,IAAInD,KAAK,CAACmD,WAAW,CAAChF,MAAM,KAAK,CAAE,EAAE;gBAC5F,IAAIrF,KAAK,CAACC,OAAO,CAACqD,OAAO,CAAC+G,WAAW,CAAC,IAAI/G,OAAO,CAAC+G,WAAW,CAAChF,MAAM,GAAG,CAAC,EAAE;kBACtEtJ,MAAM,CAAC2M,IAAI,CAAC,4DAA4DpF,OAAO,CAACA,OAAO,GAAG,CAAC;gBAC/F;cACJ,CAAC,MAAM;gBACHvH,MAAM,CAAC+M,WAAW,CAAC9I,KAAK,CAACC,OAAO,CAACqD,OAAO,CAAC+G,WAAW,CAAC,EAAE,IAAI,EAAE,gEAAgE/G,OAAO,CAAC+G,WAAW,6BAA6B/G,OAAO,CAACA,OAAO,GAAG,CAAC;gBAChMvH,MAAM,CAAC+M,WAAW,CAACxF,OAAO,CAAC+G,WAAW,CAAChF,MAAM,EAAE6B,KAAK,CAACmD,WAAW,CAAChF,MAAM,EAAE,qBAAqB6B,KAAK,CAACmD,WAAW,CAAChF,MAAM,+BAA+B/B,OAAO,CAAC+G,WAAW,CAAChF,MAAM,cAAc,CAAC;gBAE9L6B,KAAK,CAACmD,WAAW,CAACjK,OAAO,CAAC,CAACkK,kBAAkB,EAAEC,KAAK,KAAK;kBACrDxO,MAAM,CAAC6M,EAAE,CACL,OAAO0B,kBAAkB,KAAK,QAAQ,IAAIA,kBAAkB,KAAK,IAAI,EACrE,2DACJ,CAAC;kBACDjM,MAAM,CAAC0H,IAAI,CAACuE,kBAAkB,CAAC,CAAClK,OAAO,CAACqJ,YAAY,IAAI;oBACpD1N,MAAM,CAAC6M,EAAE,CACL9K,0BAA0B,CAAC4L,GAAG,CAACD,YAAY,CAAC,EAC5C,qCAAqCA,YAAY,sBAAsB1L,qCAAqC,GAChH,CAAC;kBACL,CAAC,CAAC;kBAEF,MAAMyM,gBAAgB,GAAGlH,OAAO,CAAC+G,WAAW,CAACE,KAAK,CAAC;kBACnD,MAAME,gBAAgB,GAAG,6BAA6BF,KAAK,IAAI;kBAE/D,IAAItM,cAAc,CAACqM,kBAAkB,EAAE,MAAM,CAAC,EAAE;oBAC5CvO,MAAM,CAAC6M,EAAE,CACL,CAAC3K,cAAc,CAACqM,kBAAkB,EAAE,MAAM,CAAC,EAC3C,GAAGG,gBAAgB,kDACvB,CAAC;oBACD1O,MAAM,CAAC+M,WAAW,CACd0B,gBAAgB,CAACE,IAAI,EACrBJ,kBAAkB,CAACI,IAAI,EACvB,GAAGD,gBAAgB,oBAAoBH,kBAAkB,CAACI,IAAI,cAAcF,gBAAgB,CAACE,IAAI,YACrG,CAAC;kBACL;kBAEA,IAAIzM,cAAc,CAACqM,kBAAkB,EAAE,WAAW,CAAC,EAAE;oBACjDvO,MAAM,CAAC6M,EAAE,CACLO,mBAAmB,EACnB,GAAGsB,gBAAgB,kFACvB,CAAC;oBACD1O,MAAM,CAAC6M,EAAE,CACL3K,cAAc,CAAC6G,IAAI,CAAC4B,IAAI,CAACqB,QAAQ,EAAEuC,kBAAkB,CAACX,SAAS,CAAC,EAChE,GAAGc,gBAAgB,gCAAgCH,kBAAkB,CAACX,SAAS,6CAA6CP,cAAc,GAC9I,CAAC;oBACDrN,MAAM,CAAC+M,WAAW,CACd0B,gBAAgB,CAACb,SAAS,EAC1BW,kBAAkB,CAACX,SAAS,EAC5B,GAAGc,gBAAgB,yBAAyBH,kBAAkB,CAACX,SAAS,cAAca,gBAAgB,CAACb,SAAS,YACpH,CAAC;oBACD,IAAI1L,cAAc,CAACqM,kBAAkB,EAAE,MAAM,CAAC,EAAE;sBAC5C,MAAMK,sBAAsB,GAAG7F,IAAI,CAAC4B,IAAI,CAACqB,QAAQ,CAACuC,kBAAkB,CAACX,SAAS,CAAC;sBAC/E,MAAMiB,cAAc,GAAGlO,WAAW,CAACiO,sBAAsB,EAAEL,kBAAkB,CAACR,IAAI,CAAC;sBAEnF/N,MAAM,CAAC+M,WAAW,CACd0B,gBAAgB,CAACE,IAAI,EACrBE,cAAc,EACd,GAAGH,gBAAgB,wBAAwBG,cAAc,mCAAmCJ,gBAAgB,CAACE,IAAI,IACrH,CAAC;oBACL;kBACJ,CAAC,MAAM;oBACH3O,MAAM,CAAC6M,EAAE,CACL,CAAC3K,cAAc,CAACqM,kBAAkB,EAAE,MAAM,CAAC,EAC3C,GAAGG,gBAAgB,mDACvB,CAAC;kBACL;kBAEA,IAAIxM,cAAc,CAACqM,kBAAkB,EAAE,QAAQ,CAAC,EAAE;oBAC9C,MAAMO,yBAAyB,GAAGpO,eAAe,CAAC8L,UAAU,CAAC9D,IAAI,CAACC,IAAI,EAAE,CAAC8F,gBAAgB,CAAC,CAAC,CAACnE,MAAM;oBAElGtK,MAAM,CAAC+M,WAAW,CAAC+B,yBAAyB,EAAEP,kBAAkB,CAACjE,MAAM,EAAE,oGAAoGkE,KAAK,4BAA4BjH,OAAO,CAACA,OAAO,GAAG,CAAC;kBACrO;gBACJ,CAAC,CAAC;cACN;YACJ;UACJ,CAAC,MAAM;YAEH;YACAvH,MAAM,CAAC2M,IAAI,CAAC,2DAA2DxM,IAAI,CAACqH,OAAO,CAACD,OAAO,CAAC,GAAG,CAAC;UACpG;QACJ;MACJ;MAEA,IAAIrF,cAAc,CAACwG,IAAI,EAAE,QAAQ,CAAC,EAAE;QAChC,IAAIA,IAAI,CAAC4B,MAAM,KAAK,IAAI,EAAE;UACtBtK,MAAM,CAAC+M,WAAW,CACdD,MAAM,CAACxC,MAAM,EACb5B,IAAI,CAACC,IAAI,EACT,uCACJ,CAAC;QACL,CAAC,MAAM;UACH3I,MAAM,CAAC+M,WAAW,CAACD,MAAM,CAACxC,MAAM,EAAE5B,IAAI,CAAC4B,MAAM,EAAE,sBAAsB,CAAC;QAC1E;MACJ,CAAC,MAAM;QACHtK,MAAM,CAAC+M,WAAW,CACdD,MAAM,CAACxC,MAAM,EACb5B,IAAI,CAACC,IAAI,EACT,wDACJ,CAAC;MACL;MAEA+D,oBAAoB,CAACI,MAAM,CAACvC,SAAS,EAAEuC,MAAM,CAACtC,QAAQ,CAAC;IAC3D;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAAC1C,WAAW,CAACQ,QAAQ,CAAC7B,QAAQ,EAAE,MAAM;MACtC,IAAIwC,IAAI,CAAC8F,KAAK,CAACzF,MAAM,GAAG,CAAC,EAAE;QACvB,IAAI,CAACxB,WAAW,CAACQ,QAAQ,CAAC,OAAO,EAAE,MAAM;UACrCW,IAAI,CAAC8F,KAAK,CAAC1K,OAAO,CAAC0K,KAAK,IAAI;YACxB,IAAI,CAACjH,WAAW,CAACiH,KAAK,CAACtG,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC,CAC1ClE,QAAQ,CAAC,OAAOwK,KAAK,KAAK,QAAQ,GAAGA,KAAK,CAACjG,IAAI,IAAIiG,KAAK,CAACpG,IAAI,GAAGoG,KAAK,CAAC,EACtE,MAAM;cACFnC,iBAAiB,CAACmC,KAAK,CAAC;YAC5B,CACJ,CAAC;UACL,CAAC,CAAC;QACN,CAAC,CAAC;MACN;MAEA,IAAI9F,IAAI,CAAC+F,OAAO,CAAC1F,MAAM,GAAG,CAAC,EAAE;QACzB,IAAI,CAACxB,WAAW,CAACQ,QAAQ,CAAC,SAAS,EAAE,MAAM;UACvCW,IAAI,CAAC+F,OAAO,CAAC3K,OAAO,CAAC2K,OAAO,IAAI;YAC5B,IAAI,CAAClH,WAAW,CAACkH,OAAO,CAACvG,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC,CAC5ClE,QAAQ,CAACyK,OAAO,CAAClG,IAAI,IAAIkG,OAAO,CAACrG,IAAI,CAAC,EACtC,MAAM;cACFwE,mBAAmB,CAAC6B,OAAO,CAAC;YAChC,CACJ,CAAC;UACL,CAAC,CAAC;QACN,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;EACN;AACJ;AAEAnH,UAAU,CAACb,QAAQ,CAAC,GAAGa,UAAU,CAACZ,EAAE,CAAC,GAAGY,UAAU,CAACX,OAAO,CAAC,GAAG,IAAI;AAElE+H,MAAM,CAACC,OAAO,GAAGrH,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}