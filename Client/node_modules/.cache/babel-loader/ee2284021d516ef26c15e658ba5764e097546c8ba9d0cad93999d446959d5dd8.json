{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow unused variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          },\n          destructuredArrayIgnorePattern: {\n            type: \"string\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n        if (firstOption.destructuredArrayIgnorePattern) {\n          config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\n        }\n      }\n    }\n\n    /**\n     * Generates the message data about the variable being defined and unused,\n     * including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n    function getDefinedMessageData(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"defined\",\n        additional\n      };\n    }\n\n    /**\n     * Generate the warning message about the variable being\n     * assigned and unused, including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n    function getAssignedMessageData(unusedVar) {\n      const def = unusedVar.defs[0];\n      let additional = \"\";\n      if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === \"ArrayPattern\") {\n        additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;\n      } else if (config.varsIgnorePattern) {\n        additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;\n      }\n      return {\n        varName: unusedVar.name,\n        action: \"assigned a value\",\n        additional\n      };\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n    /**\n     * Determines if a given variable is being exported from a module.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n    function isExported(variable) {\n      const definition = variable.defs[0];\n      if (definition) {\n        let node = definition.node;\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether a node is a sibling of the rest property or not.\n     * @param {ASTNode} node a node to check\n     * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n     */\n    function hasRestSibling(node) {\n      return node.type === \"Property\" && node.parent.type === \"ObjectPattern\" && REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n    }\n\n    /**\n     * Determines if a variable has a sibling rest property\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n        const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n        return hasRestSiblingDefinition || hasRestSiblingReference;\n      }\n      return false;\n    }\n\n    /**\n     * Determines if a reference is a read operation.\n     * @param {Reference} ref An eslint-scope Reference\n     * @returns {boolean} whether the given reference represents a read operation\n     * @private\n     */\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n\n    /**\n     * Determine if an identifier is referencing an enclosing function name.\n     * @param {Reference} ref The reference to check.\n     * @param {ASTNode[]} nodes The candidate function nodes.\n     * @returns {boolean} True if it's a self-reference, false if not.\n     * @private\n     */\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n      while (scope) {\n        if (nodes.includes(scope.block)) {\n          return true;\n        }\n        scope = scope.upper;\n      }\n      return false;\n    }\n\n    /**\n     * Gets a list of function definitions for a specified variable.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {ASTNode[]} Function nodes.\n     * @private\n     */\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def;\n\n        // FunctionDeclarations\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        }\n\n        // FunctionExpressions\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n\n    /**\n     * Checks the position of given nodes.\n     * @param {ASTNode} inner A node which is expected as inside.\n     * @param {ASTNode} outer A node which is expected as outside.\n     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n     * @private\n     */\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n\n    /**\n     * Checks whether a given node is unused expression or not.\n     * @param {ASTNode} node The node itself\n     * @returns {boolean} The node is an unused expression.\n     * @private\n     */\n    function isUnusedExpression(node) {\n      const parent = node.parent;\n      if (parent.type === \"ExpressionStatement\") {\n        return true;\n      }\n      if (parent.type === \"SequenceExpression\") {\n        const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n        if (!isLastExpression) {\n          return true;\n        }\n        return isUnusedExpression(parent);\n      }\n      return false;\n    }\n\n    /**\n     * If a given reference is left-hand side of an assignment, this gets\n     * the right-hand side node of the assignment.\n     *\n     * In the following cases, this returns null.\n     *\n     * - The reference is not the LHS of an assignment expression.\n     * - The reference is inside of a loop.\n     * - The reference is inside of a function scope which is different from\n     *   the declaration.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} prevRhsNode The previous RHS node.\n     * @returns {ASTNode|null} The RHS node or null.\n     * @private\n     */\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n      /*\n       * Inherits the previous node if this reference is in the node.\n       * This is for `a = a + a`-like code.\n       */\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n      if (parent.type === \"AssignmentExpression\" && isUnusedExpression(parent) && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n      return null;\n    }\n\n    /**\n     * Checks whether a given function node is stored to somewhere or not.\n     * If the function node is stored, the function can be used later.\n     * @param {ASTNode} funcNode A function node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if under the following conditions:\n     *      - the funcNode is assigned to a variable.\n     *      - the funcNode is bound as an argument of a function call.\n     *      - the function is bound to a property and the object satisfies above conditions.\n     * @private\n     */\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n            break;\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n          default:\n            if (STATEMENT_TYPE.test(parent.type)) {\n              /*\n               * If it encountered statements, this is a complex pattern.\n               * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n               */\n              return true;\n            }\n        }\n        node = parent;\n        parent = parent.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param {ASTNode} id An Identifier node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n     * @private\n     */\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n\n    /**\n     * Checks whether a given reference is a read to update itself or not.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} The reference is a read to update itself.\n     * @private\n     */\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      return ref.isRead() && (\n      // self update. e.g. `a += 1`, `a++`\n      parent.type === \"AssignmentExpression\" && parent.left === id && isUnusedExpression(parent) && !astUtils.isLogicalAssignmentOperator(parent.operator) || parent.type === \"UpdateExpression\" && isUnusedExpression(parent) ||\n      // in RHS of an assignment for itself. e.g. `a = a + 1`\n\n      rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n\n    /**\n     * Determine if an identifier is used either in for-in or for-of loops.\n     * @param {Reference} ref The reference to check.\n     * @returns {boolean} whether reference is used in the for-in loops\n     * @private\n     */\n    function isForInOfRef(ref) {\n      let target = ref.identifier.parent;\n\n      // \"for (var ...) { return; }\"\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n      if (target.type !== \"ForInStatement\" && target.type !== \"ForOfStatement\") {\n        return false;\n      }\n\n      // \"for (...) { return; }\"\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0];\n\n        // \"for (...) return;\"\n      } else {\n        target = target.body;\n      }\n\n      // For empty loop body\n      if (!target) {\n        return false;\n      }\n      return target.type === \"ReturnStatement\";\n    }\n\n    /**\n     * Determines if the variable is used.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} True if the variable is used\n     * @private\n     */\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n        isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInOfRef(ref)) {\n          return true;\n        }\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n\n    /**\n     * Checks whether the given variable is after the last used parameter.\n     * @param {eslint-scope.Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is defined after the last\n     * used parameter.\n     */\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = sourceCode.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n      // If any used parameters occur after this parameter, do not report.\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n\n    /**\n     * Gets an array of variables without read references.\n     * @param {Scope} scope an eslint-scope Scope object.\n     * @param {Variable[]} unusedVars an array that saving result.\n     * @returns {Variable[]} unused variables of the scope and descendant scopes.\n     * @private\n     */\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i];\n\n          // skip a variable of class itself name in the class scope\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          }\n\n          // skip function expression names and variables marked with markVariableAsUsed()\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          }\n\n          // skip implicit \"arguments\" variable\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          }\n\n          // explicit global variables don't have definitions.\n          const def = variable.defs[0];\n          if (def) {\n            const type = def.type;\n            const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\");\n\n            // skip elements of array destructuring patterns\n            if ((def.name.parent.type === \"ArrayPattern\" || refUsedInArrayPatterns) && config.destructuredArrayIgnorePattern && config.destructuredArrayIgnorePattern.test(def.name.name)) {\n              continue;\n            }\n\n            // skip catch variables\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              }\n\n              // skip ignored parameters\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n            if (type === \"Parameter\") {\n              // skip any setter argument\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              }\n\n              // if \"args\" option is \"none\", skip any parameter\n              if (config.args === \"none\") {\n                continue;\n              }\n\n              // skip ignored parameters\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n\n              // if \"args\" option is \"after-used\", skip used variables\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              // skip ignored variables\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n      return unusedVars;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(sourceCode.getScope(programNode), []);\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i];\n\n          // Report the first declaration.\n          if (unusedVar.defs.length > 0) {\n            // report last write reference, https://github.com/eslint/eslint/issues/14324\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            let referenceToReport;\n            if (writeReferences.length > 0) {\n              referenceToReport = writeReferences[writeReferences.length - 1];\n            }\n            context.report({\n              node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n              messageId: \"unusedVar\",\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            });\n\n            // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: \"unusedVar\",\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","destructuredArrayIgnorePattern","additionalProperties","messages","unusedVar","create","context","sourceCode","REST_PROPERTY_TYPE","config","firstOption","options","RegExp","getDefinedMessageData","defType","defs","pattern","toString","additional","varName","name","action","getAssignedMessageData","def","parent","STATEMENT_TYPE","isExported","variable","definition","node","indexOf","hasRestSibling","test","length","hasRestSpreadSibling","hasRestSiblingDefinition","some","hasRestSiblingReference","references","ref","identifier","isReadRef","isRead","isSelfReference","nodes","scope","from","includes","block","upper","getFunctionDefinitions","functionDefinitions","forEach","push","init","isInside","inner","outer","range","isUnusedExpression","isLastExpression","expressions","getRhsNode","prevRhsNode","id","refScope","variableScope","varScope","resolved","canBeUsedLater","isInLoop","left","right","isStorableFunction","funcNode","rhsNode","callee","isInsideOfStorableFunction","getUpperFunction","isReadForItself","isLogicalAssignmentOperator","operator","isForInOfRef","target","body","isUsedVariable","functionNodes","isFunctionDefinition","forItself","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","v","eslintUsed","collectUnusedVariables","unusedVars","variables","childScopes","i","l","identifiers","functionExpressionScope","refUsedInArrayPatterns","kind","isFunction","Program:exit","programNode","getScope","writeReferences","filter","isWrite","referenceToReport","report","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-unused-vars.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unused variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            destructuredArrayIgnorePattern: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.destructuredArrayIgnorePattern) {\n                    config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"defined\",\n                additional\n            };\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const def = unusedVar.defs[0];\n            let additional = \"\";\n\n            if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === \"ArrayPattern\") {\n                additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;\n            } else if (config.varsIgnorePattern) {\n                additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;\n            }\n\n            return {\n                varName: unusedVar.name,\n                action: \"assigned a value\",\n                additional\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Checks whether a node is a sibling of the rest property or not.\n         * @param {ASTNode} node a node to check\n         * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n         */\n        function hasRestSibling(node) {\n            return node.type === \"Property\" &&\n                node.parent.type === \"ObjectPattern\" &&\n                REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n                const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n\n                return hasRestSiblingDefinition || hasRestSiblingReference;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.includes(scope.block)) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * Checks whether a given node is unused expression or not.\n         * @param {ASTNode} node The node itself\n         * @returns {boolean} The node is an unused expression.\n         * @private\n         */\n        function isUnusedExpression(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"ExpressionStatement\") {\n                return true;\n            }\n\n            if (parent.type === \"SequenceExpression\") {\n                const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n                if (!isLastExpression) {\n                    return true;\n                }\n                return isUnusedExpression(parent);\n            }\n\n            return false;\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                isUnusedExpression(parent) &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    (\n                        parent.type === \"AssignmentExpression\" &&\n                        parent.left === id &&\n                        isUnusedExpression(parent) &&\n                        !astUtils.isLogicalAssignmentOperator(parent.operator)\n                    ) ||\n                    (\n                        parent.type === \"UpdateExpression\" &&\n                        isUnusedExpression(parent)\n                    )\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in or for-of loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInOfRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\" && target.type !== \"ForOfStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInOfRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = sourceCode.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n                        const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\");\n\n                        // skip elements of array destructuring patterns\n                        if (\n                            (\n                                def.name.parent.type === \"ArrayPattern\" ||\n                                refUsedInArrayPatterns\n                            ) &&\n                            config.destructuredArrayIgnorePattern &&\n                            config.destructuredArrayIgnorePattern.test(def.name.name)\n                        ) {\n                            continue;\n                        }\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(sourceCode.getScope(programNode), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n\n                        // report last write reference, https://github.com/eslint/eslint/issues/14324\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n\n                        let referenceToReport;\n\n                        if (writeReferences.length > 0) {\n                            referenceToReport = writeReferences[writeReferences.length - 1];\n                        }\n\n                        context.report({\n                            node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n                            messageId: \"unusedVar\",\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar)\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            messageId: \"unusedVar\",\n                            data: getDefinedMessageData(unusedVar)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}