{"ast":null,"code":"/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\"),\n  FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n  const index = array.indexOf(element);\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {\n    if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow redundant return statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-useless-return\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unnecessaryReturn: \"Unnecessary return statement.\"\n    }\n  },\n  create(context) {\n    const segmentInfoMap = new WeakMap();\n    const sourceCode = context.sourceCode;\n    let scopeInfo = null;\n\n    /**\n     * Checks whether the given segment is terminated by a return statement or not.\n     * @param {CodePathSegment} segment The segment to check.\n     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n     */\n    function isReturned(segment) {\n      const info = segmentInfoMap.get(segment);\n      return !info || info.returned;\n    }\n\n    /**\n     * Collects useless return statements from the given previous segments.\n     *\n     * A previous segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {ASTNode[]} uselessReturns The collected return statements.\n     * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n     * @returns {ASTNode[]} `uselessReturns`.\n     */\n    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n      const traversedSegments = providedTraversedSegments || new WeakSet();\n      for (const segment of prevSegments) {\n        if (!segment.reachable) {\n          if (!traversedSegments.has(segment)) {\n            traversedSegments.add(segment);\n            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);\n          }\n          continue;\n        }\n        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n      }\n      return uselessReturns;\n    }\n\n    /**\n     * Removes the return statements on the given segment from the useless return\n     * statement list.\n     *\n     * This segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {CodePathSegment} segment The segment to get return statements.\n     * @param {Set<CodePathSegment>} usedUnreachableSegments A set of segments that have already been traversed in this call.\n     * @returns {void}\n     */\n    function markReturnStatementsOnSegmentAsUsed(segment, usedUnreachableSegments) {\n      if (!segment.reachable) {\n        usedUnreachableSegments.add(segment);\n        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(prevSegment => markReturnStatementsOnSegmentAsUsed(prevSegment, usedUnreachableSegments));\n        return;\n      }\n      const info = segmentInfoMap.get(segment);\n      info.uselessReturns = info.uselessReturns.filter(node => {\n        if (scopeInfo.traversedTryBlockStatements && scopeInfo.traversedTryBlockStatements.length > 0) {\n          const returnInitialRange = node.range[0];\n          const returnFinalRange = node.range[1];\n          const areBlocksInRange = scopeInfo.traversedTryBlockStatements.some(tryBlockStatement => {\n            const blockInitialRange = tryBlockStatement.range[0];\n            const blockFinalRange = tryBlockStatement.range[1];\n            return returnInitialRange >= blockInitialRange && returnFinalRange <= blockFinalRange;\n          });\n          if (areBlocksInRange) {\n            return true;\n          }\n        }\n        remove(scopeInfo.uselessReturns, node);\n        return false;\n      });\n    }\n\n    /**\n     * Removes the return statements on the current segments from the useless\n     * return statement list.\n     *\n     * This function will be called at every statement except FunctionDeclaration,\n     * BlockStatement, and BreakStatement.\n     *\n     * - FunctionDeclarations are always executed whether it's returned or not.\n     * - BlockStatements do nothing.\n     * - BreakStatements go the next merely.\n     * @returns {void}\n     */\n    function markReturnStatementsOnCurrentSegmentsAsUsed() {\n      scopeInfo.currentSegments.forEach(segment => markReturnStatementsOnSegmentAsUsed(segment, new Set()));\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      // Makes and pushes a new scope information.\n      onCodePathStart(codePath) {\n        scopeInfo = {\n          upper: scopeInfo,\n          uselessReturns: [],\n          traversedTryBlockStatements: [],\n          codePath,\n          currentSegments: new Set()\n        };\n      },\n      // Reports useless return statements if exist.\n      onCodePathEnd() {\n        for (const node of scopeInfo.uselessReturns) {\n          context.report({\n            node,\n            loc: node.loc,\n            messageId: \"unnecessaryReturn\",\n            fix(fixer) {\n              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n                /*\n                 * Extend the replacement range to include the\n                 * entire function to avoid conflicting with\n                 * no-else-return.\n                 * https://github.com/eslint/eslint/issues/8026\n                 */\n                return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);\n              }\n              return null;\n            }\n          });\n        }\n        scopeInfo = scopeInfo.upper;\n      },\n      /*\n       * Initializes segments.\n       * NOTE: This event is notified for only reachable segments.\n       */\n      onCodePathSegmentStart(segment) {\n        scopeInfo.currentSegments.add(segment);\n        const info = {\n          uselessReturns: getUselessReturns([], segment.allPrevSegments),\n          returned: false\n        };\n\n        // Stores the info.\n        segmentInfoMap.set(segment, info);\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        scopeInfo.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        scopeInfo.currentSegments.delete(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        scopeInfo.currentSegments.delete(segment);\n      },\n      // Adds ReturnStatement node to check whether it's useless or not.\n      ReturnStatement(node) {\n        if (node.argument) {\n          markReturnStatementsOnCurrentSegmentsAsUsed();\n        }\n        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) ||\n        // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n        !isAnySegmentReachable(scopeInfo.currentSegments)) {\n          return;\n        }\n        for (const segment of scopeInfo.currentSegments) {\n          const info = segmentInfoMap.get(segment);\n          if (info) {\n            info.uselessReturns.push(node);\n            info.returned = true;\n          }\n        }\n        scopeInfo.uselessReturns.push(node);\n      },\n      \"TryStatement > BlockStatement.block:exit\"(node) {\n        scopeInfo.traversedTryBlockStatements.push(node);\n      },\n      \"TryStatement:exit\"() {\n        scopeInfo.traversedTryBlockStatements.pop();\n      },\n      /*\n       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n       * Removes return statements of the current segments from the useless return statement list.\n       */\n      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","FixTracker","remove","array","element","index","indexOf","splice","isRemovable","node","STATEMENT_LIST_PARENTS","has","parent","type","isInFinally","currentNode","isFunction","finalizer","isAnySegmentReachable","segments","segment","reachable","module","exports","meta","docs","description","recommended","url","fixable","schema","messages","unnecessaryReturn","create","context","segmentInfoMap","WeakMap","sourceCode","scopeInfo","isReturned","info","get","returned","getUselessReturns","uselessReturns","prevSegments","providedTraversedSegments","traversedSegments","WeakSet","add","allPrevSegments","filter","push","markReturnStatementsOnSegmentAsUsed","usedUnreachableSegments","prevSegment","forEach","traversedTryBlockStatements","length","returnInitialRange","range","returnFinalRange","areBlocksInRange","some","tryBlockStatement","blockInitialRange","blockFinalRange","markReturnStatementsOnCurrentSegmentsAsUsed","currentSegments","Set","onCodePathStart","codePath","upper","onCodePathEnd","report","loc","messageId","fix","fixer","getCommentsInside","retainEnclosingFunction","onCodePathSegmentStart","set","onUnreachableCodePathSegmentStart","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentEnd","ReturnStatement","argument","isInLoop","TryStatement > BlockStatement.block:exit","TryStatement:exit","pop","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","EmptyStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-useless-return.js"],"sourcesContent":["/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow redundant return statements\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unnecessaryReturn: \"Unnecessary return statement.\"\n        }\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const sourceCode = context.sourceCode;\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         * @param {CodePathSegment} segment The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {ASTNode[]} uselessReturns The collected return statements.\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {CodePathSegment} segment The segment to get return statements.\n         * @param {Set<CodePathSegment>} usedUnreachableSegments A set of segments that have already been traversed in this call.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment, usedUnreachableSegments) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(prevSegment => markReturnStatementsOnSegmentAsUsed(prevSegment, usedUnreachableSegments));\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            info.uselessReturns = info.uselessReturns.filter(node => {\n                if (scopeInfo.traversedTryBlockStatements && scopeInfo.traversedTryBlockStatements.length > 0) {\n                    const returnInitialRange = node.range[0];\n                    const returnFinalRange = node.range[1];\n\n                    const areBlocksInRange = scopeInfo.traversedTryBlockStatements.some(tryBlockStatement => {\n                        const blockInitialRange = tryBlockStatement.range[0];\n                        const blockFinalRange = tryBlockStatement.range[1];\n\n                        return (\n                            returnInitialRange >= blockInitialRange &&\n                            returnFinalRange <= blockFinalRange\n                        );\n                    });\n\n                    if (areBlocksInRange) {\n                        return true;\n                    }\n                }\n\n                remove(scopeInfo.uselessReturns, node);\n                return false;\n            });\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .currentSegments\n                .forEach(segment => markReturnStatementsOnSegmentAsUsed(segment, new Set()));\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushes a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    traversedTryBlockStatements: [],\n                    codePath,\n                    currentSegments: new Set()\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        messageId: \"unnecessaryReturn\",\n                        fix(fixer) {\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n\n                scopeInfo.currentSegments.add(segment);\n\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                scopeInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                scopeInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                scopeInfo.currentSegments.delete(segment);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (\n                    node.argument ||\n                    astUtils.isInLoop(node) ||\n                    isInFinally(node) ||\n\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n                    !isAnySegmentReachable(scopeInfo.currentSegments)\n                ) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            \"TryStatement > BlockStatement.block:exit\"(node) {\n                scopeInfo.traversedTryBlockStatements.push(node);\n            },\n\n            \"TryStatement:exit\"() {\n                scopeInfo.traversedTryBlockStatements.pop();\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;EACzCC,UAAU,GAAGD,OAAO,CAAC,qBAAqB,CAAC;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,MAAMA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC5B,MAAMC,KAAK,GAAGF,KAAK,CAACG,OAAO,CAACF,OAAO,CAAC;EAEpC,IAAIC,KAAK,KAAK,CAAC,CAAC,EAAE;IACdF,KAAK,CAACI,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;EAC1B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASG,WAAWA,CAACC,IAAI,EAAE;EACvB,OAAOV,QAAQ,CAACW,sBAAsB,CAACC,GAAG,CAACF,IAAI,CAACG,MAAM,CAACC,IAAI,CAAC;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACL,IAAI,EAAE;EACvB,KACI,IAAIM,WAAW,GAAGN,IAAI,EACtBM,WAAW,IAAIA,WAAW,CAACH,MAAM,IAAI,CAACb,QAAQ,CAACiB,UAAU,CAACD,WAAW,CAAC,EACtEA,WAAW,GAAGA,WAAW,CAACH,MAAM,EAClC;IACE,IAAIG,WAAW,CAACH,MAAM,CAACC,IAAI,KAAK,cAAc,IAAIE,WAAW,CAACH,MAAM,CAACK,SAAS,KAAKF,WAAW,EAAE;MAC5F,OAAO,IAAI;IACf;EACJ;EAEA,OAAO,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASG,qBAAqBA,CAACC,QAAQ,EAAE;EAErC,KAAK,MAAMC,OAAO,IAAID,QAAQ,EAAE;IAC5B,IAAIC,OAAO,CAACC,SAAS,EAAE;MACnB,OAAO,IAAI;IACf;EACJ;EAEA,OAAO,KAAK;AAChB;;AAEA;AACA;AACA;;AAEA;AACAC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFX,IAAI,EAAE,YAAY;IAElBY,IAAI,EAAE;MACFC,WAAW,EAAE,sCAAsC;MACnDC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,MAAM;IACfC,MAAM,EAAE,EAAE;IAEVC,QAAQ,EAAE;MACNC,iBAAiB,EAAE;IACvB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,cAAc,GAAG,IAAIC,OAAO,CAAC,CAAC;IACpC,MAAMC,UAAU,GAAGH,OAAO,CAACG,UAAU;IACrC,IAAIC,SAAS,GAAG,IAAI;;IAEpB;AACR;AACA;AACA;AACA;IACQ,SAASC,UAAUA,CAACnB,OAAO,EAAE;MACzB,MAAMoB,IAAI,GAAGL,cAAc,CAACM,GAAG,CAACrB,OAAO,CAAC;MAExC,OAAO,CAACoB,IAAI,IAAIA,IAAI,CAACE,QAAQ;IACjC;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,iBAAiBA,CAACC,cAAc,EAAEC,YAAY,EAAEC,yBAAyB,EAAE;MAChF,MAAMC,iBAAiB,GAAGD,yBAAyB,IAAI,IAAIE,OAAO,CAAC,CAAC;MAEpE,KAAK,MAAM5B,OAAO,IAAIyB,YAAY,EAAE;QAChC,IAAI,CAACzB,OAAO,CAACC,SAAS,EAAE;UACpB,IAAI,CAAC0B,iBAAiB,CAACpC,GAAG,CAACS,OAAO,CAAC,EAAE;YACjC2B,iBAAiB,CAACE,GAAG,CAAC7B,OAAO,CAAC;YAC9BuB,iBAAiB,CACbC,cAAc,EACdxB,OAAO,CAAC8B,eAAe,CAACC,MAAM,CAACZ,UAAU,CAAC,EAC1CQ,iBACJ,CAAC;UACL;UACA;QACJ;QAEAH,cAAc,CAACQ,IAAI,CAAC,GAAGjB,cAAc,CAACM,GAAG,CAACrB,OAAO,CAAC,CAACwB,cAAc,CAAC;MACtE;MAEA,OAAOA,cAAc;IACzB;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASS,mCAAmCA,CAACjC,OAAO,EAAEkC,uBAAuB,EAAE;MAC3E,IAAI,CAAClC,OAAO,CAACC,SAAS,EAAE;QACpBiC,uBAAuB,CAACL,GAAG,CAAC7B,OAAO,CAAC;QACpCA,OAAO,CAAC8B,eAAe,CAClBC,MAAM,CAACZ,UAAU,CAAC,CAClBY,MAAM,CAACI,WAAW,IAAI,CAACD,uBAAuB,CAAC3C,GAAG,CAAC4C,WAAW,CAAC,CAAC,CAChEC,OAAO,CAACD,WAAW,IAAIF,mCAAmC,CAACE,WAAW,EAAED,uBAAuB,CAAC,CAAC;QACtG;MACJ;MAEA,MAAMd,IAAI,GAAGL,cAAc,CAACM,GAAG,CAACrB,OAAO,CAAC;MAExCoB,IAAI,CAACI,cAAc,GAAGJ,IAAI,CAACI,cAAc,CAACO,MAAM,CAAC1C,IAAI,IAAI;QACrD,IAAI6B,SAAS,CAACmB,2BAA2B,IAAInB,SAAS,CAACmB,2BAA2B,CAACC,MAAM,GAAG,CAAC,EAAE;UAC3F,MAAMC,kBAAkB,GAAGlD,IAAI,CAACmD,KAAK,CAAC,CAAC,CAAC;UACxC,MAAMC,gBAAgB,GAAGpD,IAAI,CAACmD,KAAK,CAAC,CAAC,CAAC;UAEtC,MAAME,gBAAgB,GAAGxB,SAAS,CAACmB,2BAA2B,CAACM,IAAI,CAACC,iBAAiB,IAAI;YACrF,MAAMC,iBAAiB,GAAGD,iBAAiB,CAACJ,KAAK,CAAC,CAAC,CAAC;YACpD,MAAMM,eAAe,GAAGF,iBAAiB,CAACJ,KAAK,CAAC,CAAC,CAAC;YAElD,OACID,kBAAkB,IAAIM,iBAAiB,IACvCJ,gBAAgB,IAAIK,eAAe;UAE3C,CAAC,CAAC;UAEF,IAAIJ,gBAAgB,EAAE;YAClB,OAAO,IAAI;UACf;QACJ;QAEA5D,MAAM,CAACoC,SAAS,CAACM,cAAc,EAAEnC,IAAI,CAAC;QACtC,OAAO,KAAK;MAChB,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAAS0D,2CAA2CA,CAAA,EAAG;MACnD7B,SAAS,CACJ8B,eAAe,CACfZ,OAAO,CAACpC,OAAO,IAAIiC,mCAAmC,CAACjC,OAAO,EAAE,IAAIiD,GAAG,CAAC,CAAC,CAAC,CAAC;IACpF;;IAEA;IACA;IACA;;IAEA,OAAO;MAEH;MACAC,eAAeA,CAACC,QAAQ,EAAE;QACtBjC,SAAS,GAAG;UACRkC,KAAK,EAAElC,SAAS;UAChBM,cAAc,EAAE,EAAE;UAClBa,2BAA2B,EAAE,EAAE;UAC/Bc,QAAQ;UACRH,eAAe,EAAE,IAAIC,GAAG,CAAC;QAC7B,CAAC;MACL,CAAC;MAED;MACAI,aAAaA,CAAA,EAAG;QACZ,KAAK,MAAMhE,IAAI,IAAI6B,SAAS,CAACM,cAAc,EAAE;UACzCV,OAAO,CAACwC,MAAM,CAAC;YACXjE,IAAI;YACJkE,GAAG,EAAElE,IAAI,CAACkE,GAAG;YACbC,SAAS,EAAE,mBAAmB;YAC9BC,GAAGA,CAACC,KAAK,EAAE;cACP,IAAItE,WAAW,CAACC,IAAI,CAAC,IAAI,CAAC4B,UAAU,CAAC0C,iBAAiB,CAACtE,IAAI,CAAC,CAACiD,MAAM,EAAE;gBAEjE;AAChC;AACA;AACA;AACA;AACA;gBACgC,OAAO,IAAIzD,UAAU,CAAC6E,KAAK,EAAEzC,UAAU,CAAC,CACnC2C,uBAAuB,CAACvE,IAAI,CAAC,CAC7BP,MAAM,CAACO,IAAI,CAAC;cACrB;cACA,OAAO,IAAI;YACf;UACJ,CAAC,CAAC;QACN;QAEA6B,SAAS,GAAGA,SAAS,CAACkC,KAAK;MAC/B,CAAC;MAED;AACZ;AACA;AACA;MACYS,sBAAsBA,CAAC7D,OAAO,EAAE;QAE5BkB,SAAS,CAAC8B,eAAe,CAACnB,GAAG,CAAC7B,OAAO,CAAC;QAEtC,MAAMoB,IAAI,GAAG;UACTI,cAAc,EAAED,iBAAiB,CAAC,EAAE,EAAEvB,OAAO,CAAC8B,eAAe,CAAC;UAC9DR,QAAQ,EAAE;QACd,CAAC;;QAED;QACAP,cAAc,CAAC+C,GAAG,CAAC9D,OAAO,EAAEoB,IAAI,CAAC;MACrC,CAAC;MAED2C,iCAAiCA,CAAC/D,OAAO,EAAE;QACvCkB,SAAS,CAAC8B,eAAe,CAACnB,GAAG,CAAC7B,OAAO,CAAC;MAC1C,CAAC;MAEDgE,+BAA+BA,CAAChE,OAAO,EAAE;QACrCkB,SAAS,CAAC8B,eAAe,CAACiB,MAAM,CAACjE,OAAO,CAAC;MAC7C,CAAC;MAEDkE,oBAAoBA,CAAClE,OAAO,EAAE;QAC1BkB,SAAS,CAAC8B,eAAe,CAACiB,MAAM,CAACjE,OAAO,CAAC;MAC7C,CAAC;MAED;MACAmE,eAAeA,CAAC9E,IAAI,EAAE;QAClB,IAAIA,IAAI,CAAC+E,QAAQ,EAAE;UACfrB,2CAA2C,CAAC,CAAC;QACjD;QACA,IACI1D,IAAI,CAAC+E,QAAQ,IACbzF,QAAQ,CAAC0F,QAAQ,CAAChF,IAAI,CAAC,IACvBK,WAAW,CAACL,IAAI,CAAC;QAEjB;QACA,CAACS,qBAAqB,CAACoB,SAAS,CAAC8B,eAAe,CAAC,EACnD;UACE;QACJ;QAEA,KAAK,MAAMhD,OAAO,IAAIkB,SAAS,CAAC8B,eAAe,EAAE;UAC7C,MAAM5B,IAAI,GAAGL,cAAc,CAACM,GAAG,CAACrB,OAAO,CAAC;UAExC,IAAIoB,IAAI,EAAE;YACNA,IAAI,CAACI,cAAc,CAACQ,IAAI,CAAC3C,IAAI,CAAC;YAC9B+B,IAAI,CAACE,QAAQ,GAAG,IAAI;UACxB;QACJ;QACAJ,SAAS,CAACM,cAAc,CAACQ,IAAI,CAAC3C,IAAI,CAAC;MACvC,CAAC;MAED,0CAA0CiF,CAACjF,IAAI,EAAE;QAC7C6B,SAAS,CAACmB,2BAA2B,CAACL,IAAI,CAAC3C,IAAI,CAAC;MACpD,CAAC;MAED,mBAAmBkF,CAAA,EAAG;QAClBrD,SAAS,CAACmB,2BAA2B,CAACmC,GAAG,CAAC,CAAC;MAC/C,CAAC;MAED;AACZ;AACA;AACA;MACYC,gBAAgB,EAAE1B,2CAA2C;MAC7D2B,iBAAiB,EAAE3B,2CAA2C;MAC9D4B,iBAAiB,EAAE5B,2CAA2C;MAC9D6B,gBAAgB,EAAE7B,2CAA2C;MAC7D8B,cAAc,EAAE9B,2CAA2C;MAC3D+B,mBAAmB,EAAE/B,2CAA2C;MAChEgC,cAAc,EAAEhC,2CAA2C;MAC3DiC,cAAc,EAAEjC,2CAA2C;MAC3DkC,YAAY,EAAElC,2CAA2C;MACzDmC,WAAW,EAAEnC,2CAA2C;MACxDoC,iBAAiB,EAAEpC,2CAA2C;MAC9DqC,gBAAgB,EAAErC,2CAA2C;MAC7DsC,eAAe,EAAEtC,2CAA2C;MAC5DuC,cAAc,EAAEvC,2CAA2C;MAC3DwC,YAAY,EAAExC,2CAA2C;MACzDyC,mBAAmB,EAAEzC,2CAA2C;MAChE0C,cAAc,EAAE1C,2CAA2C;MAC3D2C,aAAa,EAAE3C,2CAA2C;MAC1D4C,sBAAsB,EAAE5C,2CAA2C;MACnE6C,wBAAwB,EAAE7C,2CAA2C;MACrE8C,oBAAoB,EAAE9C;IAC1B,CAAC;EACL;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}