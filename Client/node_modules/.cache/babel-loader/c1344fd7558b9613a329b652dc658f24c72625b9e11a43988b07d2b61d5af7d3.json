{"ast":null,"code":"/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow renaming import, export, and destructured assignments to the same name\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-useless-rename\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImport: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreExport: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode,\n      options = context.options[0] || {},\n      ignoreDestructuring = options.ignoreDestructuring === true,\n      ignoreImport = options.ignoreImport === true,\n      ignoreExport = options.ignoreExport === true;\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Reports error for unnecessarily renamed assignments\n     * @param {ASTNode} node node to report\n     * @param {ASTNode} initial node with initial name value\n     * @param {string} type the type of the offending node\n     * @returns {void}\n     */\n    function reportError(node, initial, type) {\n      const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n      return context.report({\n        node,\n        messageId: \"unnecessarilyRenamed\",\n        data: {\n          name,\n          type\n        },\n        fix(fixer) {\n          const replacementNode = node.type === \"Property\" ? node.value : node.local;\n          if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n            return null;\n          }\n\n          // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\n          if (replacementNode.type === \"AssignmentPattern\" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {\n            return null;\n          }\n          return fixer.replaceText(node, sourceCode.getText(replacementNode));\n        }\n      });\n    }\n\n    /**\n     * Checks whether a destructured assignment is unnecessarily renamed\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function checkDestructured(node) {\n      if (ignoreDestructuring) {\n        return;\n      }\n      for (const property of node.properties) {\n        /**\n         * Properties using shorthand syntax and rest elements can not be renamed.\n         * If the property is computed, we have no idea if a rename is useless or not.\n         */\n        if (property.type !== \"Property\" || property.shorthand || property.computed) {\n          continue;\n        }\n        const key = property.key.type === \"Identifier\" && property.key.name || property.key.type === \"Literal\" && property.key.value;\n        const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n        if (key === renamedKey) {\n          reportError(property, property.key, \"Destructuring assignment\");\n        }\n      }\n    }\n\n    /**\n     * Checks whether an import is unnecessarily renamed\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function checkImport(node) {\n      if (ignoreImport) {\n        return;\n      }\n      if (node.imported.range[0] !== node.local.range[0] && astUtils.getModuleExportName(node.imported) === node.local.name) {\n        reportError(node, node.imported, \"Import\");\n      }\n    }\n\n    /**\n     * Checks whether an export is unnecessarily renamed\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function checkExport(node) {\n      if (ignoreExport) {\n        return;\n      }\n      if (node.local.range[0] !== node.exported.range[0] && astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)) {\n        reportError(node, node.local, \"Export\");\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ObjectPattern: checkDestructured,\n      ImportSpecifier: checkImport,\n      ExportSpecifier: checkExport\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","ignoreDestructuring","default","ignoreImport","ignoreExport","additionalProperties","messages","unnecessarilyRenamed","create","context","sourceCode","options","reportError","node","initial","name","value","report","messageId","data","fix","fixer","replacementNode","local","getCommentsInside","length","isParenthesised","left","replaceText","getText","checkDestructured","property","shorthand","computed","key","renamedKey","checkImport","imported","range","getModuleExportName","checkExport","exported","ObjectPattern","ImportSpecifier","ExportSpecifier"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-useless-rename.js"],"sourcesContent":["/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow renaming import, export, and destructured assignments to the same name\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-rename\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: { type: \"boolean\", default: false },\n                    ignoreImport: { type: \"boolean\", default: false },\n                    ignoreExport: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode,\n            options = context.options[0] || {},\n            ignoreDestructuring = options.ignoreDestructuring === true,\n            ignoreImport = options.ignoreImport === true,\n            ignoreExport = options.ignoreExport === true;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports error for unnecessarily renamed assignments\n         * @param {ASTNode} node node to report\n         * @param {ASTNode} initial node with initial name value\n         * @param {string} type the type of the offending node\n         * @returns {void}\n         */\n        function reportError(node, initial, type) {\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n\n            return context.report({\n                node,\n                messageId: \"unnecessarilyRenamed\",\n                data: {\n                    name,\n                    type\n                },\n                fix(fixer) {\n                    const replacementNode = node.type === \"Property\" ? node.value : node.local;\n\n                    if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n                        return null;\n                    }\n\n                    // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\n                    if (\n                        replacementNode.type === \"AssignmentPattern\" &&\n                        astUtils.isParenthesised(sourceCode, replacementNode.left)\n                    ) {\n                        return null;\n                    }\n\n                    return fixer.replaceText(node, sourceCode.getText(replacementNode));\n                }\n            });\n        }\n\n        /**\n         * Checks whether a destructured assignment is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDestructured(node) {\n            if (ignoreDestructuring) {\n                return;\n            }\n\n            for (const property of node.properties) {\n\n                /**\n                 * Properties using shorthand syntax and rest elements can not be renamed.\n                 * If the property is computed, we have no idea if a rename is useless or not.\n                 */\n                if (property.type !== \"Property\" || property.shorthand || property.computed) {\n                    continue;\n                }\n\n                const key = (property.key.type === \"Identifier\" && property.key.name) || (property.key.type === \"Literal\" && property.key.value);\n                const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n\n                if (key === renamedKey) {\n                    reportError(property, property.key, \"Destructuring assignment\");\n                }\n            }\n        }\n\n        /**\n         * Checks whether an import is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkImport(node) {\n            if (ignoreImport) {\n                return;\n            }\n\n            if (\n                node.imported.range[0] !== node.local.range[0] &&\n                astUtils.getModuleExportName(node.imported) === node.local.name\n            ) {\n                reportError(node, node.imported, \"Import\");\n            }\n        }\n\n        /**\n         * Checks whether an export is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkExport(node) {\n            if (ignoreExport) {\n                return;\n            }\n\n            if (\n                node.local.range[0] !== node.exported.range[0] &&\n                astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)\n            ) {\n                reportError(node, node.local, \"Export\");\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ObjectPattern: checkDestructured,\n            ImportSpecifier: checkImport,\n            ExportSpecifier: checkExport\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}