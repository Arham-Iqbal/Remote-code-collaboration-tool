{"ast":null,"code":"/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  directivesPattern\n} = require(\"../shared/directives\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.\n * @param {string} comment The comment string to check.\n * @param {RegExp} fallthroughCommentPattern The regular expression used for checking for fallthrough comments.\n * @returns {boolean} `true` if the comment string is truly a fallthrough comment.\n */\nfunction isFallThroughComment(comment, fallthroughCommentPattern) {\n  return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());\n}\n\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n  const sourceCode = context.sourceCode;\n  if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n    const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n    const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n    if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {\n      return true;\n    }\n  }\n  const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n  return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n  return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow fallthrough of `case` statements\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-fallthrough\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\",\n          default: \"\"\n        },\n        allowEmptyCase: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      case: \"Expected a 'break' statement before 'case'.\",\n      default: \"Expected a 'break' statement before 'default'.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const codePathSegments = [];\n    let currentCodePathSegments = new Set();\n    const sourceCode = context.sourceCode;\n    const allowEmptyCase = options.allowEmptyCase || false;\n\n    /*\n     * We need to use leading comments of the next SwitchCase node because\n     * trailing comments is wrong if semicolons are omitted.\n     */\n    let fallthroughCase = null;\n    let fallthroughCommentPattern = null;\n    if (options.commentPattern) {\n      fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n    } else {\n      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n    }\n    return {\n      onCodePathStart() {\n        codePathSegments.push(currentCodePathSegments);\n        currentCodePathSegments = new Set();\n      },\n      onCodePathEnd() {\n        currentCodePathSegments = codePathSegments.pop();\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        currentCodePathSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        currentCodePathSegments.delete(segment);\n      },\n      onCodePathSegmentStart(segment) {\n        currentCodePathSegments.add(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        currentCodePathSegments.delete(segment);\n      },\n      SwitchCase(node) {\n        /*\n         * Checks whether or not there is a fallthrough comment.\n         * And reports the previous fallthrough node if that does not exist.\n         */\n\n        if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n          context.report({\n            messageId: node.test ? \"case\" : \"default\",\n            node\n          });\n        }\n        fallthroughCase = null;\n      },\n      \"SwitchCase:exit\"(node) {\n        const nextToken = sourceCode.getTokenAfter(node);\n\n        /*\n         * `reachable` meant fall through because statements preceded by\n         * `break`, `return`, or `throw` are unreachable.\n         * And allows empty cases and the last case.\n         */\n        if (isAnySegmentReachable(currentCodePathSegments) && (node.consequent.length > 0 || !allowEmptyCase && hasBlankLinesBetween(node, nextToken)) && node.parent.cases[node.parent.cases.length - 1] !== node) {\n          fallthroughCase = node;\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["directivesPattern","require","DEFAULT_FALLTHROUGH_COMMENT","isAnySegmentReachable","segments","segment","reachable","isFallThroughComment","comment","fallthroughCommentPattern","test","trim","hasFallthroughComment","caseWhichFallsThrough","subsequentCase","context","sourceCode","consequent","length","type","trailingCloseBrace","getLastToken","commentInBlock","getCommentsBefore","pop","value","Boolean","hasBlankLinesBetween","node","token","loc","start","line","end","module","exports","meta","docs","description","recommended","url","schema","properties","commentPattern","default","allowEmptyCase","additionalProperties","messages","case","create","options","codePathSegments","currentCodePathSegments","Set","fallthroughCase","RegExp","onCodePathStart","push","onCodePathEnd","onUnreachableCodePathSegmentStart","add","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentStart","onCodePathSegmentEnd","SwitchCase","report","messageId","SwitchCase:exit","nextToken","getTokenAfter","parent","cases"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-fallthrough.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { directivesPattern } = require(\"../shared/directives\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.\n * @param {string} comment The comment string to check.\n * @param {RegExp} fallthroughCommentPattern The regular expression used for checking for fallthrough comments.\n * @returns {boolean} `true` if the comment string is truly a fallthrough comment.\n */\nfunction isFallThroughComment(comment, fallthroughCommentPattern) {\n    return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());\n}\n\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n    const sourceCode = context.sourceCode;\n\n    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n        if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {\n            return true;\n        }\n    }\n\n    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n\n    return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow fallthrough of `case` statements\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    },\n                    allowEmptyCase: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const codePathSegments = [];\n        let currentCodePathSegments = new Set();\n        const sourceCode = context.sourceCode;\n        const allowEmptyCase = options.allowEmptyCase || false;\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n        return {\n\n            onCodePathStart() {\n                codePathSegments.push(currentCodePathSegments);\n                currentCodePathSegments = new Set();\n            },\n\n            onCodePathEnd() {\n                currentCodePathSegments = codePathSegments.pop();\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n\n                if (fallthroughCase && (!hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern))) {\n                    context.report({\n                        messageId: node.test ? \"case\" : \"default\",\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (isAnySegmentReachable(currentCodePathSegments) &&\n                    (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&\n                    node.parent.cases[node.parent.cases.length - 1] !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}