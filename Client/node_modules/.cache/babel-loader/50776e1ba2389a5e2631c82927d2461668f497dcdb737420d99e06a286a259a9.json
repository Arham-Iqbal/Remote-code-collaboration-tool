{"ast":null,"code":"/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  arrays: \"never\",\n  objects: \"never\",\n  imports: \"never\",\n  exports: \"never\",\n  functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n  return !(lastItem.type === \"RestElement\" || lastItem.type === \"RestProperty\" || lastItem.type === \"ExperimentalRestProperty\");\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n  if (typeof optionValue === \"string\") {\n    return {\n      arrays: optionValue,\n      objects: optionValue,\n      imports: optionValue,\n      exports: optionValue,\n      functions: ecmaVersion < 2017 ? \"ignore\" : optionValue\n    };\n  }\n  if (typeof optionValue === \"object\" && optionValue !== null) {\n    return {\n      arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n      objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n      imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n      exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n      functions: optionValue.functions || DEFAULT_OPTIONS.functions\n    };\n  }\n  return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Require or disallow trailing commas\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/comma-dangle\"\n    },\n    fixable: \"code\",\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always-multiline\", \"always\", \"never\", \"only-multiline\"]\n        },\n        valueWithIgnore: {\n          enum: [\"always-multiline\", \"always\", \"ignore\", \"never\", \"only-multiline\"]\n        }\n      },\n      type: \"array\",\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/value\"\n        }, {\n          type: \"object\",\n          properties: {\n            arrays: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            objects: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            imports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            exports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            functions: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            }\n          },\n          additionalProperties: false\n        }]\n      }],\n      additionalItems: false\n    },\n    messages: {\n      unexpected: \"Unexpected trailing comma.\",\n      missing: \"Missing trailing comma.\"\n    }\n  },\n  create(context) {\n    const options = normalizeOptions(context.options[0], context.languageOptions.ecmaVersion);\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Gets the last item of the given node.\n     * @param {ASTNode} node The node to get.\n     * @returns {ASTNode|null} The last node or null.\n     */\n    function getLastItem(node) {\n      /**\n       * Returns the last element of an array\n       * @param {any[]} array The input array\n       * @returns {any} The last element\n       */\n      function last(array) {\n        return array[array.length - 1];\n      }\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          return last(node.properties);\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          return last(node.elements);\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return last(node.specifiers);\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n          return last(node.params);\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return last(node.arguments);\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Gets the trailing comma token of the given node.\n     * If the trailing comma does not exist, this returns the token which is\n     * the insertion point of the trailing comma token.\n     * @param {ASTNode} node The node to get.\n     * @param {ASTNode} lastItem The last item of the node.\n     * @returns {Token} The trailing comma token or the insertion point.\n     */\n    function getTrailingToken(node, lastItem) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return sourceCode.getLastToken(node, 1);\n        default:\n          {\n            const nextToken = sourceCode.getTokenAfter(lastItem);\n            if (astUtils.isCommaToken(nextToken)) {\n              return nextToken;\n            }\n            return sourceCode.getLastToken(lastItem);\n          }\n      }\n    }\n\n    /**\n     * Checks whether or not a given node is multiline.\n     * This rule handles a given node as multiline when the closing parenthesis\n     * and the last element are not on the same line.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is multiline.\n     */\n    function isMultiline(node) {\n      const lastItem = getLastItem(node);\n      if (!lastItem) {\n        return false;\n      }\n      const penultimateToken = getTrailingToken(node, lastItem);\n      const lastToken = sourceCode.getTokenAfter(penultimateToken);\n      return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n    }\n\n    /**\n     * Reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function forbidTrailingComma(node) {\n      const lastItem = getLastItem(node);\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n      const trailingToken = getTrailingToken(node, lastItem);\n      if (astUtils.isCommaToken(trailingToken)) {\n        context.report({\n          node: lastItem,\n          loc: trailingToken.loc,\n          messageId: \"unexpected\",\n          *fix(fixer) {\n            yield fixer.remove(trailingToken);\n\n            /*\n             * Extend the range of the fix to include surrounding tokens to ensure\n             * that the element after which the comma is removed stays _last_.\n             * This intentionally makes conflicts in fix ranges with rules that may be\n             * adding or removing elements in the same autofix pass.\n             * https://github.com/eslint/eslint/issues/15660\n             */\n            yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), \"\");\n            yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n          }\n        });\n      }\n    }\n\n    /**\n     * Reports the last element of a given node if it does not have a trailing\n     * comma.\n     *\n     * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n     * comma is disallowed, so report if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function forceTrailingComma(node) {\n      const lastItem = getLastItem(node);\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n      if (!isTrailingCommaAllowed(lastItem)) {\n        forbidTrailingComma(node);\n        return;\n      }\n      const trailingToken = getTrailingToken(node, lastItem);\n      if (trailingToken.value !== \",\") {\n        context.report({\n          node: lastItem,\n          loc: {\n            start: trailingToken.loc.end,\n            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n          },\n          messageId: \"missing\",\n          *fix(fixer) {\n            yield fixer.insertTextAfter(trailingToken, \",\");\n\n            /*\n             * Extend the range of the fix to include surrounding tokens to ensure\n             * that the element after which the comma is inserted stays _last_.\n             * This intentionally makes conflicts in fix ranges with rules that may be\n             * adding or removing elements in the same autofix pass.\n             * https://github.com/eslint/eslint/issues/15660\n             */\n            yield fixer.insertTextBefore(trailingToken, \"\");\n            yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n          }\n        });\n      }\n    }\n\n    /**\n     * If a given node is multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function forceTrailingCommaIfMultiline(node) {\n      if (isMultiline(node)) {\n        forceTrailingComma(node);\n      } else {\n        forbidTrailingComma(node);\n      }\n    }\n\n    /**\n     * Only if a given node is not multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function allowTrailingCommaIfMultiline(node) {\n      if (!isMultiline(node)) {\n        forbidTrailingComma(node);\n      }\n    }\n    const predicate = {\n      always: forceTrailingComma,\n      \"always-multiline\": forceTrailingCommaIfMultiline,\n      \"only-multiline\": allowTrailingCommaIfMultiline,\n      never: forbidTrailingComma,\n      ignore() {}\n    };\n    return {\n      ObjectExpression: predicate[options.objects],\n      ObjectPattern: predicate[options.objects],\n      ArrayExpression: predicate[options.arrays],\n      ArrayPattern: predicate[options.arrays],\n      ImportDeclaration: predicate[options.imports],\n      ExportNamedDeclaration: predicate[options.exports],\n      FunctionDeclaration: predicate[options.functions],\n      FunctionExpression: predicate[options.functions],\n      ArrowFunctionExpression: predicate[options.functions],\n      CallExpression: predicate[options.functions],\n      NewExpression: predicate[options.functions]\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","DEFAULT_OPTIONS","Object","freeze","arrays","objects","imports","exports","functions","isTrailingCommaAllowed","lastItem","type","normalizeOptions","optionValue","ecmaVersion","module","meta","deprecated","replacedBy","docs","description","recommended","url","fixable","schema","definitions","value","enum","valueWithIgnore","items","oneOf","$ref","properties","additionalProperties","additionalItems","messages","unexpected","missing","create","context","options","languageOptions","sourceCode","getLastItem","node","last","array","length","elements","specifiers","params","arguments","getTrailingToken","getLastToken","nextToken","getTokenAfter","isCommaToken","isMultiline","penultimateToken","lastToken","loc","end","line","forbidTrailingComma","trailingToken","report","messageId","fix","fixer","remove","insertTextBefore","getTokenBefore","insertTextAfter","forceTrailingComma","start","getNextLocation","forceTrailingCommaIfMultiline","allowTrailingCommaIfMultiline","predicate","always","never","ignore","ObjectExpression","ObjectPattern","ArrayExpression","ArrayPattern","ImportDeclaration","ExportNamedDeclaration","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","CallExpression","NewExpression"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/comma-dangle.js"],"sourcesContent":["/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n            functions: ecmaVersion < 2017 ? \"ignore\" : optionValue\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow trailing commas\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ],\n            additionalItems: false\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0], context.languageOptions.ecmaVersion);\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n\n            /**\n             * Returns the last element of an array\n             * @param {any[]} array The input array\n             * @returns {any} The last element\n             */\n            function last(array) {\n                return array[array.length - 1];\n            }\n\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         * @param {ASTNode} node The node to get.\n         * @param {ASTNode} lastItem The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc,\n                    messageId: \"unexpected\",\n                    *fix(fixer) {\n                        yield fixer.remove(trailingToken);\n\n                        /*\n                         * Extend the range of the fix to include surrounding tokens to ensure\n                         * that the element after which the comma is removed stays _last_.\n                         * This intentionally makes conflicts in fix ranges with rules that may be\n                         * adding or removing elements in the same autofix pass.\n                         * https://github.com/eslint/eslint/issues/15660\n                         */\n                        yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), \"\");\n                        yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: {\n                        start: trailingToken.loc.end,\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n                    },\n                    messageId: \"missing\",\n                    *fix(fixer) {\n                        yield fixer.insertTextAfter(trailingToken, \",\");\n\n                        /*\n                         * Extend the range of the fix to include surrounding tokens to ensure\n                         * that the element after which the comma is inserted stays _last_.\n                         * This intentionally makes conflicts in fix ranges with rules that may be\n                         * adding or removing elements in the same autofix pass.\n                         * https://github.com/eslint/eslint/issues/15660\n                         */\n                        yield fixer.insertTextBefore(trailingToken, \"\");\n                        yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore() {}\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}