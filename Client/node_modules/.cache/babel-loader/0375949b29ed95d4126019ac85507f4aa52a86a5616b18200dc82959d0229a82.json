{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar minimatch = require('minimatch');\nvar createDebug = require('debug');\nvar objectSchema = require('@humanwhocodes/object-schema');\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NOOP_STRATEGY = {\n  required: false,\n  merge() {\n    return undefined;\n  },\n  validate() {}\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\nconst baseSchema = Object.freeze({\n  name: {\n    required: false,\n    merge() {\n      return undefined;\n    },\n    validate(value) {\n      if (typeof value !== 'string') {\n        throw new TypeError('Property must be a string.');\n      }\n    }\n  },\n  files: NOOP_STRATEGY,\n  ignores: NOOP_STRATEGY\n});\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Asserts that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array.\n */\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new TypeError('Expected value to be an array.');\n  }\n}\n\n/**\n * Asserts that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n  assertIsArray(value);\n  if (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n    throw new TypeError('Expected array to only contain strings and functions.');\n  }\n}\n\n/**\n * Asserts that a given value is a non-empty array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array or an empty array.\n */\nfunction assertIsNonEmptyArray(value) {\n  if (!Array.isArray(value) || value.length === 0) {\n    throw new TypeError('Expected value to be a non-empty array.');\n  }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The schema for `files` and `ignores` that every ConfigArray uses.\n * @type Object\n */\nconst filesAndIgnoresSchema = Object.freeze({\n  files: {\n    required: false,\n    merge() {\n      return undefined;\n    },\n    validate(value) {\n      // first check if it's an array\n      assertIsNonEmptyArray(value);\n\n      // then check each member\n      value.forEach(item => {\n        if (Array.isArray(item)) {\n          assertIsArrayOfStringsAndFunctions(item);\n        } else if (typeof item !== 'string' && typeof item !== 'function') {\n          throw new TypeError('Items must be a string, a function, or an array of strings and functions.');\n        }\n      });\n    }\n  },\n  ignores: {\n    required: false,\n    merge() {\n      return undefined;\n    },\n    validate: assertIsArrayOfStringsAndFunctions\n  }\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst minimatchCache = new Map();\nconst negatedMinimatchCache = new Map();\nconst debug = createDebug('@hwc/config-array');\nconst MINIMATCH_OPTIONS = {\n  // matchBase: true,\n  dot: true\n};\nconst CONFIG_TYPES = new Set(['array', 'function']);\n\n/**\n * Fields that are considered metadata and not part of the config object.\n */\nconst META_FIELDS = new Set(['name']);\nconst FILES_AND_IGNORES_SCHEMA = new objectSchema.ObjectSchema(filesAndIgnoresSchema);\n\n/**\n * Wrapper error for config validation errors that adds a name to the front of the\n * error message.\n */\nclass ConfigError extends Error {\n  /**\n   * Creates a new instance.\n   * @param {string} name The config object name causing the error.\n   * @param {number} index The index of the config object in the array.\n   * @param {Error} source The source error. \n   */\n  constructor(name, index, {\n    cause,\n    message\n  }) {\n    const finalMessage = message || cause.message;\n    super(`Config ${name}: ${finalMessage}`, {\n      cause\n    });\n\n    // copy over custom properties that aren't represented\n    if (cause) {\n      for (const key of Object.keys(cause)) {\n        if (!(key in this)) {\n          this[key] = cause[key];\n        }\n      }\n    }\n\n    /**\n     * The name of the error.\n     * @type {string}\n     * @readonly\n     */\n    this.name = 'ConfigError';\n\n    /**\n     * The index of the config object in the array.\n     * @type {number}\n     * @readonly\n     */\n    this.index = index;\n  }\n}\n\n/**\n * Gets the name of a config object.\n * @param {object} config The config object to get the name of.\n * @returns {string} The name of the config object.\n */\nfunction getConfigName(config) {\n  if (config && typeof config.name === 'string' && config.name) {\n    return `\"${config.name}\"`;\n  }\n  return '(unnamed)';\n}\n\n/**\n * Rethrows a config error with additional information about the config object.\n * @param {object} config The config object to get the name of. \n * @param {number} index The index of the config object in the array.\n * @param {Error} error The error to rethrow.\n * @throws {ConfigError} When the error is rethrown for a config.\n */\nfunction rethrowConfigError(config, index, error) {\n  const configName = getConfigName(config);\n  throw new ConfigError(configName, index, error);\n}\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Creates a function that asserts that the config is valid\n * during normalization. This checks that the config is not nullish\n * and that files and ignores keys  of a config object are valid as per base schema.\n * @param {Object} config The config object to check.\n * @param {number} index The index of the config object in the array.\n * @returns {void}\n * @throws {ConfigError} If the files and ignores keys of a config object are not valid.\n */\nfunction assertValidBaseConfig(config, index) {\n  if (config === null) {\n    throw new ConfigError(getConfigName(config), index, {\n      message: 'Unexpected null config.'\n    });\n  }\n  if (config === undefined) {\n    throw new ConfigError(getConfigName(config), index, {\n      message: 'Unexpected undefined config.'\n    });\n  }\n  if (typeof config !== 'object') {\n    throw new ConfigError(getConfigName(config), index, {\n      message: 'Unexpected non-object config.'\n    });\n  }\n  const validateConfig = {};\n  if ('files' in config) {\n    validateConfig.files = config.files;\n  }\n  if ('ignores' in config) {\n    validateConfig.ignores = config.ignores;\n  }\n  try {\n    FILES_AND_IGNORES_SCHEMA.validate(validateConfig);\n  } catch (validationError) {\n    rethrowConfigError(config, index, {\n      cause: validationError\n    });\n  }\n}\n\n/**\n * Wrapper around minimatch that caches minimatch patterns for\n * faster matching speed over multiple file path evaluations.\n * @param {string} filepath The file path to match.\n * @param {string} pattern The glob pattern to match against.\n * @param {object} options The minimatch options to use.\n * @returns \n */\nfunction doMatch(filepath, pattern, options = {}) {\n  let cache = minimatchCache;\n  if (options.flipNegate) {\n    cache = negatedMinimatchCache;\n  }\n  let matcher = cache.get(pattern);\n  if (!matcher) {\n    matcher = new Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));\n    cache.set(pattern, matcher);\n  }\n  return matcher.match(filepath);\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n  async function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n        item = item(context);\n        if (item.then) {\n          item = await item;\n        }\n      }\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n\n  /*\n   * Async iterables cannot be used with the spread operator, so we need to manually\n   * create the array to return.\n   */\n  const asyncIterable = await flatTraverse(items);\n  const configs = [];\n  for await (const config of asyncIterable) {\n    configs.push(config);\n  }\n  return configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n  function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n        item = item(context);\n        if (item.then) {\n          throw new TypeError('Async config functions are not supported.');\n        }\n      }\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n  return [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnorePath(ignores, filePath, relativeFilePath) {\n  // all files outside of the basePath are ignored\n  if (relativeFilePath.startsWith('..')) {\n    return true;\n  }\n  return ignores.reduce((ignored, matcher) => {\n    if (!ignored) {\n      if (typeof matcher === 'function') {\n        return matcher(filePath);\n      }\n\n      // don't check negated patterns because we're not ignored yet\n      if (!matcher.startsWith('!')) {\n        return doMatch(relativeFilePath, matcher);\n      }\n\n      // otherwise we're still not ignored\n      return false;\n    }\n\n    // only need to check negated patterns because we're ignored\n    if (typeof matcher === 'string' && matcher.startsWith('!')) {\n      return !doMatch(relativeFilePath, matcher, {\n        flipNegate: true\n      });\n    }\n    return ignored;\n  }, false);\n}\n\n/**\n * Determines if a given file path is matched by a config based on\n * `ignores` only.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatchesIgnores(filePath, basePath, config) {\n  /*\n   * For both files and ignores, functions are passed the absolute\n   * file path while strings are compared against the relative\n   * file path.\n   */\n  const relativeFilePath = path.relative(basePath, filePath);\n  return Object.keys(config).filter(key => !META_FIELDS.has(key)).length > 1 && !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n}\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, basePath, config) {\n  /*\n   * For both files and ignores, functions are passed the absolute\n   * file path while strings are compared against the relative\n   * file path.\n   */\n  const relativeFilePath = path.relative(basePath, filePath);\n\n  // match both strings and functions\n  const match = pattern => {\n    if (isString(pattern)) {\n      return doMatch(relativeFilePath, pattern);\n    }\n    if (typeof pattern === 'function') {\n      return pattern(filePath);\n    }\n    throw new TypeError(`Unexpected matcher type ${pattern}.`);\n  };\n\n  // check for all matches to config.files\n  let filePathMatchesPattern = config.files.some(pattern => {\n    if (Array.isArray(pattern)) {\n      return pattern.every(match);\n    }\n    return match(pattern);\n  });\n\n  /*\n   * If the file path matches the config.files patterns, then check to see\n   * if there are any files to ignore.\n   */\n  if (filePathMatchesPattern && config.ignores) {\n    filePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n  }\n  return filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n  // TODO: Throw more verbose error\n  if (!configArray.isNormalized()) {\n    throw new Error('ConfigArray must be normalized to perform this operation.');\n  }\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n  if (extraConfigTypes.length > 2) {\n    throw new TypeError('configTypes must be an array with at most two items.');\n  }\n  for (const configType of extraConfigTypes) {\n    if (!CONFIG_TYPES.has(configType)) {\n      throw new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n  isNormalized: Symbol('isNormalized'),\n  configCache: Symbol('configCache'),\n  schema: Symbol('schema'),\n  finalizeConfig: Symbol('finalizeConfig'),\n  preprocessConfig: Symbol('preprocessConfig')\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n  /**\n   * Creates a new instance of ConfigArray.\n   * @param {Iterable|Function|Object} configs An iterable yielding config\n   *      objects, or a config function, or a config object.\n   * @param {string} [options.basePath=\"\"] The path of the config file\n   * @param {boolean} [options.normalized=false] Flag indicating if the\n   *      configs have already been normalized.\n   * @param {Object} [options.schema] The additional schema \n   *      definitions to use for the ConfigArray schema.\n   * @param {Array<string>} [options.configTypes] List of config types supported.\n   */\n  constructor(configs, {\n    basePath = '',\n    normalized = false,\n    schema: customSchema,\n    extraConfigTypes = []\n  } = {}) {\n    super();\n\n    /**\n     * Tracks if the array has been normalized.\n     * @property isNormalized\n     * @type {boolean}\n     * @private\n     */\n    this[ConfigArraySymbol.isNormalized] = normalized;\n\n    /**\n     * The schema used for validating and merging configs.\n     * @property schema\n     * @type ObjectSchema\n     * @private\n     */\n    this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(Object.assign({}, customSchema, baseSchema));\n\n    /**\n     * The path of the config file that this array was loaded from.\n     * This is used to calculate filename matches.\n     * @property basePath\n     * @type {string}\n     */\n    this.basePath = basePath;\n    assertExtraConfigTypes(extraConfigTypes);\n\n    /**\n     * The supported config types.\n     * @property configTypes\n     * @type {Array<string>}\n     */\n    this.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n\n    /**\n     * A cache to store calculated configs for faster repeat lookup.\n     * @property configCache\n     * @type {Map<string, Object>}\n     * @private\n     */\n    this[ConfigArraySymbol.configCache] = new Map();\n\n    // init cache\n    dataCache.set(this, {\n      explicitMatches: new Map(),\n      directoryMatches: new Map(),\n      files: undefined,\n      ignores: undefined\n    });\n\n    // load the configs into this array\n    if (Array.isArray(configs)) {\n      this.push(...configs);\n    } else {\n      this.push(configs);\n    }\n  }\n\n  /**\n   * Prevent normal array methods from creating a new `ConfigArray` instance.\n   * This is to ensure that methods such as `slice()` won't try to create a \n   * new instance of `ConfigArray` behind the scenes as doing so may throw\n   * an error due to the different constructor signature.\n   * @returns {Function} The `Array` constructor.\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  /**\n   * Returns the `files` globs from every config object in the array.\n   * This can be used to determine which files will be matched by a\n   * config array or to use as a glob pattern when no patterns are provided\n   * for a command line interface.\n   * @returns {Array<string|Function>} An array of matchers.\n   */\n  get files() {\n    assertNormalized(this);\n\n    // if this data has been cached, retrieve it\n    const cache = dataCache.get(this);\n    if (cache.files) {\n      return cache.files;\n    }\n\n    // otherwise calculate it\n\n    const result = [];\n    for (const config of this) {\n      if (config.files) {\n        config.files.forEach(filePattern => {\n          result.push(filePattern);\n        });\n      }\n    }\n\n    // store result\n    cache.files = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n\n  /**\n   * Returns ignore matchers that should always be ignored regardless of\n   * the matching `files` fields in any configs. This is necessary to mimic\n   * the behavior of things like .gitignore and .eslintignore, allowing a\n   * globbing operation to be faster.\n   * @returns {string[]} An array of string patterns and functions to be ignored.\n   */\n  get ignores() {\n    assertNormalized(this);\n\n    // if this data has been cached, retrieve it\n    const cache = dataCache.get(this);\n    if (cache.ignores) {\n      return cache.ignores;\n    }\n\n    // otherwise calculate it\n\n    const result = [];\n    for (const config of this) {\n      /*\n       * We only count ignores if there are no other keys in the object.\n       * In this case, it acts list a globally ignored pattern. If there\n       * are additional keys, then ignores act like exclusions.\n       */\n      if (config.ignores && Object.keys(config).filter(key => !META_FIELDS.has(key)).length === 1) {\n        result.push(...config.ignores);\n      }\n    }\n\n    // store result\n    cache.ignores = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n\n  /**\n   * Indicates if the config array has been normalized.\n   * @returns {boolean} True if the config array is normalized, false if not.\n   */\n  isNormalized() {\n    return this[ConfigArraySymbol.isNormalized];\n  }\n\n  /**\n   * Normalizes a config array by flattening embedded arrays and executing\n   * config functions.\n   * @param {ConfigContext} context The context object for config functions.\n   * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n   */\n  async normalize(context = {}) {\n    if (!this.isNormalized()) {\n      const normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this.forEach(assertValidBaseConfig);\n      this[ConfigArraySymbol.isNormalized] = true;\n\n      // prevent further changes\n      Object.freeze(this);\n    }\n    return this;\n  }\n\n  /**\n   * Normalizes a config array by flattening embedded arrays and executing\n   * config functions.\n   * @param {ConfigContext} context The context object for config functions.\n   * @returns {ConfigArray} The current ConfigArray instance.\n   */\n  normalizeSync(context = {}) {\n    if (!this.isNormalized()) {\n      const normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this.forEach(assertValidBaseConfig);\n      this[ConfigArraySymbol.isNormalized] = true;\n\n      // prevent further changes\n      Object.freeze(this);\n    }\n    return this;\n  }\n\n  /**\n   * Finalizes the state of a config before being cached and returned by\n   * `getConfig()`. Does nothing by default but is provided to be\n   * overridden by subclasses as necessary.\n   * @param {Object} config The config to finalize.\n   * @returns {Object} The finalized config.\n   */\n  [ConfigArraySymbol.finalizeConfig](config) {\n    return config;\n  }\n\n  /**\n   * Preprocesses a config during the normalization process. This is the\n   * method to override if you want to convert an array item before it is\n   * validated for the first time. For example, if you want to replace a\n   * string with an object, this is the method to override.\n   * @param {Object} config The config to preprocess.\n   * @returns {Object} The config to use in place of the argument.\n   */\n  [ConfigArraySymbol.preprocessConfig](config) {\n    return config;\n  }\n\n  /**\n   * Determines if a given file path explicitly matches a `files` entry\n   * and also doesn't match an `ignores` entry. Configs that don't have\n   * a `files` property are not considered an explicit match.\n   * @param {string} filePath The complete path of a file to check.\n   * @returns {boolean} True if the file path matches a `files` entry\n   * \t\tor false if not.\n   */\n  isExplicitMatch(filePath) {\n    assertNormalized(this);\n    const cache = dataCache.get(this);\n\n    // first check the cache to avoid duplicate work\n    let result = cache.explicitMatches.get(filePath);\n    if (typeof result == 'boolean') {\n      return result;\n    }\n\n    // TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n    const relativeFilePath = path.relative(this.basePath, filePath);\n    if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n      debug(`Ignoring ${filePath}`);\n\n      // cache and return result\n      cache.explicitMatches.set(filePath, false);\n      return false;\n    }\n\n    // filePath isn't automatically ignored, so try to find a match\n\n    for (const config of this) {\n      if (!config.files) {\n        continue;\n      }\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        cache.explicitMatches.set(filePath, true);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the config object for a given file path.\n   * @param {string} filePath The complete path of a file to get a config for.\n   * @returns {Object} The config object for this file.\n   */\n  getConfig(filePath) {\n    assertNormalized(this);\n    const cache = this[ConfigArraySymbol.configCache];\n\n    // first check the cache for a filename match to avoid duplicate work\n    if (cache.has(filePath)) {\n      return cache.get(filePath);\n    }\n    let finalConfig;\n\n    // next check to see if the file should be ignored\n\n    // check if this should be ignored due to its directory\n    if (this.isDirectoryIgnored(path.dirname(filePath))) {\n      debug(`Ignoring ${filePath} based on directory pattern`);\n\n      // cache and return result - finalConfig is undefined at this point\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // TODO: Maybe move elsewhere?\n    const relativeFilePath = path.relative(this.basePath, filePath);\n    if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n      debug(`Ignoring ${filePath} based on file pattern`);\n\n      // cache and return result - finalConfig is undefined at this point\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // filePath isn't automatically ignored, so try to construct config\n\n    const matchingConfigIndices = [];\n    let matchFound = false;\n    const universalPattern = /\\/\\*{1,2}$/;\n    this.forEach((config, index) => {\n      if (!config.files) {\n        if (!config.ignores) {\n          debug(`Anonymous universal config found for ${filePath}`);\n          matchingConfigIndices.push(index);\n          return;\n        }\n        if (pathMatchesIgnores(filePath, this.basePath, config)) {\n          debug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);\n          matchingConfigIndices.push(index);\n          return;\n        }\n        debug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);\n        return;\n      }\n\n      /*\n       * If a config has a files pattern ending in /** or /*, and the\n       * filePath only matches those patterns, then the config is only\n       * applied if there is another config where the filePath matches\n       * a file with a specific extensions such as *.js.\n       */\n\n      const universalFiles = config.files.filter(pattern => universalPattern.test(pattern));\n\n      // universal patterns were found so we need to check the config twice\n      if (universalFiles.length) {\n        debug('Universal files patterns found. Checking carefully.');\n        const nonUniversalFiles = config.files.filter(pattern => !universalPattern.test(pattern));\n\n        // check that the config matches without the non-universal files first\n        if (nonUniversalFiles.length && pathMatches(filePath, this.basePath, {\n          files: nonUniversalFiles,\n          ignores: config.ignores\n        })) {\n          debug(`Matching config found for ${filePath}`);\n          matchingConfigIndices.push(index);\n          matchFound = true;\n          return;\n        }\n\n        // if there wasn't a match then check if it matches with universal files\n        if (universalFiles.length && pathMatches(filePath, this.basePath, {\n          files: universalFiles,\n          ignores: config.ignores\n        })) {\n          debug(`Matching config found for ${filePath}`);\n          matchingConfigIndices.push(index);\n          return;\n        }\n\n        // if we make here, then there was no match\n        return;\n      }\n\n      // the normal case\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        matchingConfigIndices.push(index);\n        matchFound = true;\n        return;\n      }\n    });\n\n    // if matching both files and ignores, there will be no config to create\n    if (!matchFound) {\n      debug(`No matching configs found for ${filePath}`);\n\n      // cache and return result - finalConfig is undefined at this point\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // check to see if there is a config cached by indices\n    finalConfig = cache.get(matchingConfigIndices.toString());\n    if (finalConfig) {\n      // also store for filename for faster lookup next time\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // otherwise construct the config\n\n    finalConfig = matchingConfigIndices.reduce((result, index) => {\n      try {\n        return this[ConfigArraySymbol.schema].merge(result, this[index]);\n      } catch (validationError) {\n        rethrowConfigError(this[index], index, {\n          cause: validationError\n        });\n      }\n    }, {}, this);\n    finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n    cache.set(filePath, finalConfig);\n    cache.set(matchingConfigIndices.toString(), finalConfig);\n    return finalConfig;\n  }\n\n  /**\n   * Determines if the given filepath is ignored based on the configs.\n   * @param {string} filePath The complete path of a file to check.\n   * @returns {boolean} True if the path is ignored, false if not.\n   * @deprecated Use `isFileIgnored` instead.\n   */\n  isIgnored(filePath) {\n    return this.isFileIgnored(filePath);\n  }\n\n  /**\n   * Determines if the given filepath is ignored based on the configs.\n   * @param {string} filePath The complete path of a file to check.\n   * @returns {boolean} True if the path is ignored, false if not.\n   */\n  isFileIgnored(filePath) {\n    return this.getConfig(filePath) === undefined;\n  }\n\n  /**\n   * Determines if the given directory is ignored based on the configs.\n   * This checks only default `ignores` that don't have `files` in the \n   * same config. A pattern such as `/foo` be considered to ignore the directory\n   * while a pattern such as `/foo/**` is not considered to ignore the\n   * directory because it is matching files.\n   * @param {string} directoryPath The complete path of a directory to check.\n   * @returns {boolean} True if the directory is ignored, false if not. Will\n   * \t\treturn true for any directory that is not inside of `basePath`.\n   * @throws {Error} When the `ConfigArray` is not normalized.\n   */\n  isDirectoryIgnored(directoryPath) {\n    assertNormalized(this);\n    const relativeDirectoryPath = path.relative(this.basePath, directoryPath).replace(/\\\\/g, '/');\n    if (relativeDirectoryPath.startsWith('..')) {\n      return true;\n    }\n\n    // first check the cache\n    const cache = dataCache.get(this).directoryMatches;\n    if (cache.has(relativeDirectoryPath)) {\n      return cache.get(relativeDirectoryPath);\n    }\n    const directoryParts = relativeDirectoryPath.split('/');\n    let relativeDirectoryToCheck = '';\n    let result = false;\n\n    /*\n     * In order to get the correct gitignore-style ignores, where an\n     * ignored parent directory cannot have any descendants unignored,\n     * we need to check every directory starting at the parent all\n     * the way down to the actual requested directory.\n     * \n     * We aggressively cache all of this info to make sure we don't\n     * have to recalculate everything for every call.\n     */\n    do {\n      relativeDirectoryToCheck += directoryParts.shift() + '/';\n      result = shouldIgnorePath(this.ignores, path.join(this.basePath, relativeDirectoryToCheck), relativeDirectoryToCheck);\n      cache.set(relativeDirectoryToCheck, result);\n    } while (!result && directoryParts.length);\n\n    // also cache the result for the requested path\n    cache.set(relativeDirectoryPath, result);\n    return result;\n  }\n}\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;","map":{"version":3,"names":["path","require","minimatch","createDebug","objectSchema","NOOP_STRATEGY","required","merge","undefined","validate","baseSchema","Object","freeze","name","value","TypeError","files","ignores","assertIsArray","Array","isArray","assertIsArrayOfStringsAndFunctions","some","item","assertIsNonEmptyArray","length","filesAndIgnoresSchema","forEach","Minimatch","minimatchCache","Map","negatedMinimatchCache","debug","MINIMATCH_OPTIONS","dot","CONFIG_TYPES","Set","META_FIELDS","FILES_AND_IGNORES_SCHEMA","ObjectSchema","ConfigError","Error","constructor","index","cause","message","finalMessage","key","keys","getConfigName","config","rethrowConfigError","error","configName","isString","assertValidBaseConfig","validateConfig","validationError","doMatch","filepath","pattern","options","cache","flipNegate","matcher","get","assign","set","match","normalize","items","context","extraConfigTypes","allowFunctions","includes","allowArrays","flatTraverse","array","then","asyncIterable","configs","push","normalizeSync","shouldIgnorePath","filePath","relativeFilePath","startsWith","reduce","ignored","pathMatchesIgnores","basePath","relative","filter","has","pathMatches","filePathMatchesPattern","every","assertNormalized","configArray","isNormalized","assertExtraConfigTypes","configType","ConfigArraySymbol","Symbol","configCache","schema","finalizeConfig","preprocessConfig","dataCache","WeakMap","ConfigArray","normalized","customSchema","explicitMatches","directoryMatches","species","result","filePattern","normalizedConfigs","map","bind","isExplicitMatch","getConfig","finalConfig","isDirectoryIgnored","dirname","matchingConfigIndices","matchFound","universalPattern","universalFiles","test","nonUniversalFiles","toString","isIgnored","isFileIgnored","directoryPath","relativeDirectoryPath","replace","directoryParts","split","relativeDirectoryToCheck","shift","join","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/@humanwhocodes/config-array/api.js"],"sourcesContent":["'use strict';\n\nvar path = require('path');\nvar minimatch = require('minimatch');\nvar createDebug = require('debug');\nvar objectSchema = require('@humanwhocodes/object-schema');\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NOOP_STRATEGY = {\n\trequired: false,\n\tmerge() {\n\t\treturn undefined;\n\t},\n\tvalidate() { }\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\nconst baseSchema = Object.freeze({\n\tname: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError('Property must be a string.');\n\t\t\t}\n\t\t}\n\t},\n\tfiles: NOOP_STRATEGY,\n\tignores: NOOP_STRATEGY\n});\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Asserts that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array.\n */\nfunction assertIsArray(value) {\n\tif (!Array.isArray(value)) {\n\t\tthrow new TypeError('Expected value to be an array.');\n\t}\n}\n\n/**\n * Asserts that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n\tassertIsArray(value);\n\n\tif (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n\t\tthrow new TypeError('Expected array to only contain strings and functions.');\n\t}\n}\n\n/**\n * Asserts that a given value is a non-empty array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array or an empty array.\n */\nfunction assertIsNonEmptyArray(value) {\n\tif (!Array.isArray(value) || value.length === 0) {\n\t\tthrow new TypeError('Expected value to be a non-empty array.');\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The schema for `files` and `ignores` that every ConfigArray uses.\n * @type Object\n */\nconst filesAndIgnoresSchema = Object.freeze({\n\tfiles: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\n\t\t\t// first check if it's an array\n\t\t\tassertIsNonEmptyArray(value);\n\n\t\t\t// then check each member\n\t\t\tvalue.forEach(item => {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\tassertIsArrayOfStringsAndFunctions(item);\n\t\t\t\t} else if (typeof item !== 'string' && typeof item !== 'function') {\n\t\t\t\t\tthrow new TypeError('Items must be a string, a function, or an array of strings and functions.');\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t},\n\tignores: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate: assertIsArrayOfStringsAndFunctions\n\t}\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst minimatchCache = new Map();\nconst negatedMinimatchCache = new Map();\nconst debug = createDebug('@hwc/config-array');\n\nconst MINIMATCH_OPTIONS = {\n\t// matchBase: true,\n\tdot: true\n};\n\nconst CONFIG_TYPES = new Set(['array', 'function']);\n\n/**\n * Fields that are considered metadata and not part of the config object.\n */\nconst META_FIELDS = new Set(['name']);\n\nconst FILES_AND_IGNORES_SCHEMA = new objectSchema.ObjectSchema(filesAndIgnoresSchema);\n\n/**\n * Wrapper error for config validation errors that adds a name to the front of the\n * error message.\n */\nclass ConfigError extends Error {\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} name The config object name causing the error.\n\t * @param {number} index The index of the config object in the array.\n\t * @param {Error} source The source error. \n\t */\n\tconstructor(name, index, { cause, message }) {\n\n\n\t\tconst finalMessage = message || cause.message;\n\n\t\tsuper(`Config ${name}: ${finalMessage}`, { cause });\n\n\t\t// copy over custom properties that aren't represented\n\t\tif (cause) {\n\t\t\tfor (const key of Object.keys(cause)) {\n\t\t\t\tif (!(key in this)) {\n\t\t\t\t\tthis[key] = cause[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * The name of the error.\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.name = 'ConfigError';\n\n\t\t/**\n\t\t * The index of the config object in the array.\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tthis.index = index;\n\t}\n}\n\n/**\n * Gets the name of a config object.\n * @param {object} config The config object to get the name of.\n * @returns {string} The name of the config object.\n */ \nfunction getConfigName(config) {\n\tif (config && typeof config.name === 'string' && config.name) {\n\t\treturn `\"${config.name}\"`;\n\t}\n\n\treturn '(unnamed)';\n}\n\n/**\n * Rethrows a config error with additional information about the config object.\n * @param {object} config The config object to get the name of. \n * @param {number} index The index of the config object in the array.\n * @param {Error} error The error to rethrow.\n * @throws {ConfigError} When the error is rethrown for a config.\n */\nfunction rethrowConfigError(config, index, error) {\n\tconst configName = getConfigName(config);\n\tthrow new ConfigError(configName, index, error);\n}\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Creates a function that asserts that the config is valid\n * during normalization. This checks that the config is not nullish\n * and that files and ignores keys  of a config object are valid as per base schema.\n * @param {Object} config The config object to check.\n * @param {number} index The index of the config object in the array.\n * @returns {void}\n * @throws {ConfigError} If the files and ignores keys of a config object are not valid.\n */\nfunction assertValidBaseConfig(config, index) {\n\n\tif (config === null) {\n\t\tthrow new ConfigError(getConfigName(config), index, { message: 'Unexpected null config.' });\n\t}\n\n\tif (config === undefined) {\n\t\tthrow new ConfigError(getConfigName(config), index, { message: 'Unexpected undefined config.' });\n\t}\n\n\tif (typeof config !== 'object') {\n\t\tthrow new ConfigError(getConfigName(config), index, { message: 'Unexpected non-object config.' });\n\t}\n\n\tconst validateConfig = { };\n\t\n\tif ('files' in config) {\n\t\tvalidateConfig.files = config.files;\n\t}\n\t\n\tif ('ignores' in config) {\n\t\tvalidateConfig.ignores = config.ignores;\n\t}\n\n\ttry {\n\t\tFILES_AND_IGNORES_SCHEMA.validate(validateConfig);\n\t} catch (validationError) {\n\t\trethrowConfigError(config, index, { cause: validationError });\n\t}\n}\n\n/**\n * Wrapper around minimatch that caches minimatch patterns for\n * faster matching speed over multiple file path evaluations.\n * @param {string} filepath The file path to match.\n * @param {string} pattern The glob pattern to match against.\n * @param {object} options The minimatch options to use.\n * @returns \n */\nfunction doMatch(filepath, pattern, options = {}) {\n\n\tlet cache = minimatchCache;\n\n\tif (options.flipNegate) {\n\t\tcache = negatedMinimatchCache;\n\t}\n\n\tlet matcher = cache.get(pattern);\n\n\tif (!matcher) {\n\t\tmatcher = new Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));\n\t\tcache.set(pattern, matcher);\n\t}\n\n\treturn matcher.match(filepath);\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tasync function* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\titem = await item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Async iterables cannot be used with the spread operator, so we need to manually\n\t * create the array to return.\n\t */\n\tconst asyncIterable = await flatTraverse(items);\n\tconst configs = [];\n\n\tfor await (const config of asyncIterable) {\n\t\tconfigs.push(config);\n\t}\n\n\treturn configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tfunction* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\tthrow new TypeError('Async config functions are not supported.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnorePath(ignores, filePath, relativeFilePath) {\n\n\t// all files outside of the basePath are ignored\n\tif (relativeFilePath.startsWith('..')) {\n\t\treturn true;\n\t}\n\n\treturn ignores.reduce((ignored, matcher) => {\n\n\t\tif (!ignored) {\n\n\t\t\tif (typeof matcher === 'function') {\n\t\t\t\treturn matcher(filePath);\n\t\t\t}\n\n\t\t\t// don't check negated patterns because we're not ignored yet\n\t\t\tif (!matcher.startsWith('!')) {\n\t\t\t\treturn doMatch(relativeFilePath, matcher);\n\t\t\t}\n\n\t\t\t// otherwise we're still not ignored\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// only need to check negated patterns because we're ignored\n\t\tif (typeof matcher === 'string' && matcher.startsWith('!')) {\n\t\t\treturn !doMatch(relativeFilePath, matcher, {\n\t\t\t\tflipNegate: true\n\t\t\t});\n\t\t}\n\n\t\treturn ignored;\n\n\t}, false);\n\n}\n\n/**\n * Determines if a given file path is matched by a config based on\n * `ignores` only.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatchesIgnores(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\treturn Object.keys(config).filter(key => !META_FIELDS.has(key)).length > 1 &&\n\t\t!shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n}\n\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\t// match both strings and functions\n\tconst match = pattern => {\n\n\t\tif (isString(pattern)) {\n\t\t\treturn doMatch(relativeFilePath, pattern);\n\t\t}\n\n\t\tif (typeof pattern === 'function') {\n\t\t\treturn pattern(filePath);\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected matcher type ${pattern}.`);\n\t};\n\n\t// check for all matches to config.files\n\tlet filePathMatchesPattern = config.files.some(pattern => {\n\t\tif (Array.isArray(pattern)) {\n\t\t\treturn pattern.every(match);\n\t\t}\n\n\t\treturn match(pattern);\n\t});\n\n\t/*\n\t * If the file path matches the config.files patterns, then check to see\n\t * if there are any files to ignore.\n\t */\n\tif (filePathMatchesPattern && config.ignores) {\n\t\tfilePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n\t}\n\n\treturn filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n\t// TODO: Throw more verbose error\n\tif (!configArray.isNormalized()) {\n\t\tthrow new Error('ConfigArray must be normalized to perform this operation.');\n\t}\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n\tif (extraConfigTypes.length > 2) {\n\t\tthrow new TypeError('configTypes must be an array with at most two items.');\n\t}\n\n\tfor (const configType of extraConfigTypes) {\n\t\tif (!CONFIG_TYPES.has(configType)) {\n\t\t\tthrow new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n\tisNormalized: Symbol('isNormalized'),\n\tconfigCache: Symbol('configCache'),\n\tschema: Symbol('schema'),\n\tfinalizeConfig: Symbol('finalizeConfig'),\n\tpreprocessConfig: Symbol('preprocessConfig')\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n\n\t/**\n\t * Creates a new instance of ConfigArray.\n\t * @param {Iterable|Function|Object} configs An iterable yielding config\n\t *      objects, or a config function, or a config object.\n\t * @param {string} [options.basePath=\"\"] The path of the config file\n\t * @param {boolean} [options.normalized=false] Flag indicating if the\n\t *      configs have already been normalized.\n\t * @param {Object} [options.schema] The additional schema \n\t *      definitions to use for the ConfigArray schema.\n\t * @param {Array<string>} [options.configTypes] List of config types supported.\n\t */\n\tconstructor(configs, {\n\t\tbasePath = '',\n\t\tnormalized = false,\n\t\tschema: customSchema,\n\t\textraConfigTypes = []\n\t} = {}\n\t) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Tracks if the array has been normalized.\n\t\t * @property isNormalized\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.isNormalized] = normalized;\n\n\t\t/**\n\t\t * The schema used for validating and merging configs.\n\t\t * @property schema\n\t\t * @type ObjectSchema\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(\n\t\t\tObject.assign({}, customSchema, baseSchema)\n\t\t);\n\n\t\t/**\n\t\t * The path of the config file that this array was loaded from.\n\t\t * This is used to calculate filename matches.\n\t\t * @property basePath\n\t\t * @type {string}\n\t\t */\n\t\tthis.basePath = basePath;\n\n\t\tassertExtraConfigTypes(extraConfigTypes);\n\n\t\t/**\n\t\t * The supported config types.\n\t\t * @property configTypes\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n\n\t\t/**\n\t\t * A cache to store calculated configs for faster repeat lookup.\n\t\t * @property configCache\n\t\t * @type {Map<string, Object>}\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.configCache] = new Map();\n\n\t\t// init cache\n\t\tdataCache.set(this, {\n\t\t\texplicitMatches: new Map(),\n\t\t\tdirectoryMatches: new Map(),\n\t\t\tfiles: undefined,\n\t\t\tignores: undefined\n\t\t});\n\n\t\t// load the configs into this array\n\t\tif (Array.isArray(configs)) {\n\t\t\tthis.push(...configs);\n\t\t} else {\n\t\t\tthis.push(configs);\n\t\t}\n\n\t}\n\n\t/**\n\t * Prevent normal array methods from creating a new `ConfigArray` instance.\n\t * This is to ensure that methods such as `slice()` won't try to create a \n\t * new instance of `ConfigArray` behind the scenes as doing so may throw\n\t * an error due to the different constructor signature.\n\t * @returns {Function} The `Array` constructor.\n\t */\n\tstatic get [Symbol.species]() {\n\t\treturn Array;\n\t}\n\n\t/**\n\t * Returns the `files` globs from every config object in the array.\n\t * This can be used to determine which files will be matched by a\n\t * config array or to use as a glob pattern when no patterns are provided\n\t * for a command line interface.\n\t * @returns {Array<string|Function>} An array of matchers.\n\t */\n\tget files() {\n\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.files) {\n\t\t\treturn cache.files;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\t\t\tif (config.files) {\n\t\t\t\tconfig.files.forEach(filePattern => {\n\t\t\t\t\tresult.push(filePattern);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.files = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns ignore matchers that should always be ignored regardless of\n\t * the matching `files` fields in any configs. This is necessary to mimic\n\t * the behavior of things like .gitignore and .eslintignore, allowing a\n\t * globbing operation to be faster.\n\t * @returns {string[]} An array of string patterns and functions to be ignored.\n\t */\n\tget ignores() {\n\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.ignores) {\n\t\t\treturn cache.ignores;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\n\t\t\t/*\n\t\t\t * We only count ignores if there are no other keys in the object.\n\t\t\t * In this case, it acts list a globally ignored pattern. If there\n\t\t\t * are additional keys, then ignores act like exclusions.\n\t\t\t */\n\t\t\tif (config.ignores && Object.keys(config).filter(key => !META_FIELDS.has(key)).length === 1) {\n\t\t\t\tresult.push(...config.ignores);\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.ignores = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Indicates if the config array has been normalized.\n\t * @returns {boolean} True if the config array is normalized, false if not.\n\t */\n\tisNormalized() {\n\t\treturn this[ConfigArraySymbol.isNormalized];\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n\t */\n\tasync normalize(context = {}) {\n\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\t\tthis.forEach(assertValidBaseConfig);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {ConfigArray} The current ConfigArray instance.\n\t */\n\tnormalizeSync(context = {}) {\n\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\t\tthis.forEach(assertValidBaseConfig);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Finalizes the state of a config before being cached and returned by\n\t * `getConfig()`. Does nothing by default but is provided to be\n\t * overridden by subclasses as necessary.\n\t * @param {Object} config The config to finalize.\n\t * @returns {Object} The finalized config.\n\t */\n\t[ConfigArraySymbol.finalizeConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Preprocesses a config during the normalization process. This is the\n\t * method to override if you want to convert an array item before it is\n\t * validated for the first time. For example, if you want to replace a\n\t * string with an object, this is the method to override.\n\t * @param {Object} config The config to preprocess.\n\t * @returns {Object} The config to use in place of the argument.\n\t */\n\t[ConfigArraySymbol.preprocessConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Determines if a given file path explicitly matches a `files` entry\n\t * and also doesn't match an `ignores` entry. Configs that don't have\n\t * a `files` property are not considered an explicit match.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the file path matches a `files` entry\n\t * \t\tor false if not.\n\t */\n\tisExplicitMatch(filePath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst cache = dataCache.get(this);\n\n\t\t// first check the cache to avoid duplicate work\n\t\tlet result = cache.explicitMatches.get(filePath);\n\n\t\tif (typeof result == 'boolean') {\n\t\t\treturn result;\n\t\t}\n\n\t\t// TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n\t\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath}`);\n\n\t\t\t// cache and return result\n\t\t\tcache.explicitMatches.set(filePath, false);\n\t\t\treturn false;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to find a match\n\n\t\tfor (const config of this) {\n\n\t\t\tif (!config.files) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tcache.explicitMatches.set(filePath, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the config object for a given file path.\n\t * @param {string} filePath The complete path of a file to get a config for.\n\t * @returns {Object} The config object for this file.\n\t */\n\tgetConfig(filePath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst cache = this[ConfigArraySymbol.configCache];\n\n\t\t// first check the cache for a filename match to avoid duplicate work\n\t\tif (cache.has(filePath)) {\n\t\t\treturn cache.get(filePath);\n\t\t}\n\n\t\tlet finalConfig;\n\n\t\t// next check to see if the file should be ignored\n\n\t\t// check if this should be ignored due to its directory\n\t\tif (this.isDirectoryIgnored(path.dirname(filePath))) {\n\t\t\tdebug(`Ignoring ${filePath} based on directory pattern`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// TODO: Maybe move elsewhere?\n\t\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath} based on file pattern`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to construct config\n\n\t\tconst matchingConfigIndices = [];\n\t\tlet matchFound = false;\n\t\tconst universalPattern = /\\/\\*{1,2}$/;\n\n\t\tthis.forEach((config, index) => {\n\n\t\t\tif (!config.files) {\n\n\t\t\t\tif (!config.ignores) {\n\t\t\t\t\tdebug(`Anonymous universal config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (pathMatchesIgnores(filePath, this.basePath, config)) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdebug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a config has a files pattern ending in /** or /*, and the\n\t\t\t * filePath only matches those patterns, then the config is only\n\t\t\t * applied if there is another config where the filePath matches\n\t\t\t * a file with a specific extensions such as *.js.\n\t\t\t */\n\n\t\t\tconst universalFiles = config.files.filter(\n\t\t\t\tpattern => universalPattern.test(pattern)\n\t\t\t);\n\n\t\t\t// universal patterns were found so we need to check the config twice\n\t\t\tif (universalFiles.length) {\n\n\t\t\t\tdebug('Universal files patterns found. Checking carefully.');\n\n\t\t\t\tconst nonUniversalFiles = config.files.filter(\n\t\t\t\t\tpattern => !universalPattern.test(pattern)\n\t\t\t\t);\n\n\t\t\t\t// check that the config matches without the non-universal files first\n\t\t\t\tif (\n\t\t\t\t\tnonUniversalFiles.length && \n\t\t\t\t\tpathMatches(\n\t\t\t\t\t\tfilePath, this.basePath,\n\t\t\t\t\t\t{ files: nonUniversalFiles, ignores: config.ignores }\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\tmatchFound = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if there wasn't a match then check if it matches with universal files\n\t\t\t\tif (\n\t\t\t\t\tuniversalFiles.length &&\n\t\t\t\t\tpathMatches(\n\t\t\t\t\t\tfilePath, this.basePath,\n\t\t\t\t\t\t{ files: universalFiles, ignores: config.ignores }\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if we make here, then there was no match\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// the normal case\n\t\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\tmatchFound = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t});\n\n\t\t// if matching both files and ignores, there will be no config to create\n\t\tif (!matchFound) {\n\t\t\tdebug(`No matching configs found for ${filePath}`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// check to see if there is a config cached by indices\n\t\tfinalConfig = cache.get(matchingConfigIndices.toString());\n\n\t\tif (finalConfig) {\n\n\t\t\t// also store for filename for faster lookup next time\n\t\t\tcache.set(filePath, finalConfig);\n\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// otherwise construct the config\n\n\t\tfinalConfig = matchingConfigIndices.reduce((result, index) => {\n\t\t\ttry {\n\t\t\t\treturn this[ConfigArraySymbol.schema].merge(result, this[index]);\n\t\t\t} catch (validationError) {\n\t\t\t\trethrowConfigError(this[index], index, { cause: validationError});\n\t\t\t}\n\t\t}, {}, this);\n\n\t\tfinalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n\n\t\tcache.set(filePath, finalConfig);\n\t\tcache.set(matchingConfigIndices.toString(), finalConfig);\n\n\t\treturn finalConfig;\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t * @deprecated Use `isFileIgnored` instead.\n\t */\n\tisIgnored(filePath) {\n\t\treturn this.isFileIgnored(filePath);\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t */\n\tisFileIgnored(filePath) {\n\t\treturn this.getConfig(filePath) === undefined;\n\t}\n\n\t/**\n\t * Determines if the given directory is ignored based on the configs.\n\t * This checks only default `ignores` that don't have `files` in the \n\t * same config. A pattern such as `/foo` be considered to ignore the directory\n\t * while a pattern such as `/foo/**` is not considered to ignore the\n\t * directory because it is matching files.\n\t * @param {string} directoryPath The complete path of a directory to check.\n\t * @returns {boolean} True if the directory is ignored, false if not. Will\n\t * \t\treturn true for any directory that is not inside of `basePath`.\n\t * @throws {Error} When the `ConfigArray` is not normalized.\n\t */\n\tisDirectoryIgnored(directoryPath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst relativeDirectoryPath = path.relative(this.basePath, directoryPath)\n\t\t\t.replace(/\\\\/g, '/');\n\n\t\tif (relativeDirectoryPath.startsWith('..')) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// first check the cache\n\t\tconst cache = dataCache.get(this).directoryMatches;\n\n\t\tif (cache.has(relativeDirectoryPath)) {\n\t\t\treturn cache.get(relativeDirectoryPath);\n\t\t}\n\n\t\tconst directoryParts = relativeDirectoryPath.split('/');\n\t\tlet relativeDirectoryToCheck = '';\n\t\tlet result = false;\n\n\t\t/*\n\t\t * In order to get the correct gitignore-style ignores, where an\n\t\t * ignored parent directory cannot have any descendants unignored,\n\t\t * we need to check every directory starting at the parent all\n\t\t * the way down to the actual requested directory.\n\t\t * \n\t\t * We aggressively cache all of this info to make sure we don't\n\t\t * have to recalculate everything for every call.\n\t\t */\n\t\tdo {\n\n\t\t\trelativeDirectoryToCheck += directoryParts.shift() + '/';\n\n\t\t\tresult = shouldIgnorePath(\n\t\t\t\tthis.ignores,\n\t\t\t\tpath.join(this.basePath, relativeDirectoryToCheck),\n\t\t\t\trelativeDirectoryToCheck\n\t\t\t);\n\n\t\t\tcache.set(relativeDirectoryToCheck, result);\n\n\t\t} while (!result && directoryParts.length);\n\n\t\t// also cache the result for the requested path\n\t\tcache.set(relativeDirectoryPath, result);\n\n\t\treturn result;\n\t}\n\n}\n\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}