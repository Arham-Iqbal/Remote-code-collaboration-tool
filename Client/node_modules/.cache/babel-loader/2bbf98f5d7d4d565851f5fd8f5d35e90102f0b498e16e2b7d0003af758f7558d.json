{"ast":null,"code":"/**\n * @fileoverview Rule to enforce requiring named capture groups in regular expression.\n * @author Pig Fang <https://github.com/g-plane>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"@eslint-community/eslint-utils\");\nconst regexpp = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new regexpp.RegExpParser();\n\n/**\n * Creates fixer suggestions for the regex, if statically determinable.\n * @param {number} groupStart Starting index of the regex group.\n * @param {string} pattern The regular expression pattern to be checked.\n * @param {string} rawText Source text of the regexNode.\n * @param {ASTNode} regexNode AST node which contains the regular expression.\n * @returns {Array<SuggestionResult>} Fixer suggestions for the regex, if statically determinable.\n */\nfunction suggestIfPossible(groupStart, pattern, rawText, regexNode) {\n  switch (regexNode.type) {\n    case \"Literal\":\n      if (typeof regexNode.value === \"string\" && rawText.includes(\"\\\\\")) {\n        return null;\n      }\n      break;\n    case \"TemplateLiteral\":\n      if (regexNode.expressions.length || rawText.slice(1, -1) !== pattern) {\n        return null;\n      }\n      break;\n    default:\n      return null;\n  }\n  const start = regexNode.range[0] + groupStart + 2;\n  return [{\n    fix(fixer) {\n      const existingTemps = pattern.match(/temp\\d+/gu) || [];\n      const highestTempCount = existingTemps.reduce((previous, next) => Math.max(previous, Number(next.slice(\"temp\".length))), 0);\n      return fixer.insertTextBeforeRange([start, start], `?<temp${highestTempCount + 1}>`);\n    },\n    messageId: \"addGroupName\"\n  }, {\n    fix(fixer) {\n      return fixer.insertTextBeforeRange([start, start], \"?:\");\n    },\n    messageId: \"addNonCapture\"\n  }];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce using named capture group in regular expression\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/prefer-named-capture-group\"\n    },\n    hasSuggestions: true,\n    schema: [],\n    messages: {\n      addGroupName: \"Add name to capture group.\",\n      addNonCapture: \"Convert group to non-capturing.\",\n      required: \"Capture group '{{group}}' should be converted to a named or non-capturing group.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Function to check regular expression.\n     * @param {string} pattern The regular expression pattern to be checked.\n     * @param {ASTNode} node AST node which contains the regular expression or a call/new expression.\n     * @param {ASTNode} regexNode AST node which contains the regular expression.\n     * @param {string|null} flags The regular expression flags to be checked.\n     * @returns {void}\n     */\n    function checkRegex(pattern, node, regexNode, flags) {\n      let ast;\n      try {\n        ast = parser.parsePattern(pattern, 0, pattern.length, {\n          unicode: Boolean(flags && flags.includes(\"u\")),\n          unicodeSets: Boolean(flags && flags.includes(\"v\"))\n        });\n      } catch {\n        // ignore regex syntax errors\n        return;\n      }\n      regexpp.visitRegExpAST(ast, {\n        onCapturingGroupEnter(group) {\n          if (!group.name) {\n            const rawText = sourceCode.getText(regexNode);\n            const suggest = suggestIfPossible(group.start, pattern, rawText, regexNode);\n            context.report({\n              node,\n              messageId: \"required\",\n              data: {\n                group: group.raw\n              },\n              suggest\n            });\n          }\n        }\n      });\n    }\n    return {\n      Literal(node) {\n        if (node.regex) {\n          checkRegex(node.regex.pattern, node, node, node.regex.flags);\n        }\n      },\n      Program(node) {\n        const scope = sourceCode.getScope(node);\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n        for (const {\n          node: refNode\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const regex = getStringIfConstant(refNode.arguments[0]);\n          const flags = getStringIfConstant(refNode.arguments[1]);\n          if (regex) {\n            checkRegex(regex, refNode, refNode.arguments[0], flags);\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","regexpp","parser","RegExpParser","suggestIfPossible","groupStart","pattern","rawText","regexNode","type","value","includes","expressions","length","slice","start","range","fix","fixer","existingTemps","match","highestTempCount","reduce","previous","next","Math","max","Number","insertTextBeforeRange","messageId","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","messages","addGroupName","addNonCapture","required","create","context","sourceCode","checkRegex","node","flags","ast","parsePattern","unicode","Boolean","unicodeSets","visitRegExpAST","onCapturingGroupEnter","group","name","getText","suggest","report","data","raw","Literal","regex","Program","scope","getScope","tracker","traceMap","RegExp","refNode","iterateGlobalReferences","arguments"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/prefer-named-capture-group.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce requiring named capture groups in regular expression.\n * @author Pig Fang <https://github.com/g-plane>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"@eslint-community/eslint-utils\");\nconst regexpp = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new regexpp.RegExpParser();\n\n/**\n * Creates fixer suggestions for the regex, if statically determinable.\n * @param {number} groupStart Starting index of the regex group.\n * @param {string} pattern The regular expression pattern to be checked.\n * @param {string} rawText Source text of the regexNode.\n * @param {ASTNode} regexNode AST node which contains the regular expression.\n * @returns {Array<SuggestionResult>} Fixer suggestions for the regex, if statically determinable.\n */\nfunction suggestIfPossible(groupStart, pattern, rawText, regexNode) {\n    switch (regexNode.type) {\n        case \"Literal\":\n            if (typeof regexNode.value === \"string\" && rawText.includes(\"\\\\\")) {\n                return null;\n            }\n            break;\n        case \"TemplateLiteral\":\n            if (regexNode.expressions.length || rawText.slice(1, -1) !== pattern) {\n                return null;\n            }\n            break;\n        default:\n            return null;\n    }\n\n    const start = regexNode.range[0] + groupStart + 2;\n\n    return [\n        {\n            fix(fixer) {\n                const existingTemps = pattern.match(/temp\\d+/gu) || [];\n                const highestTempCount = existingTemps.reduce(\n                    (previous, next) =>\n                        Math.max(previous, Number(next.slice(\"temp\".length))),\n                    0\n                );\n\n                return fixer.insertTextBeforeRange(\n                    [start, start],\n                    `?<temp${highestTempCount + 1}>`\n                );\n            },\n            messageId: \"addGroupName\"\n        },\n        {\n            fix(fixer) {\n                return fixer.insertTextBeforeRange(\n                    [start, start],\n                    \"?:\"\n                );\n            },\n            messageId: \"addNonCapture\"\n        }\n    ];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce using named capture group in regular expression\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-named-capture-group\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            addGroupName: \"Add name to capture group.\",\n            addNonCapture: \"Convert group to non-capturing.\",\n            required: \"Capture group '{{group}}' should be converted to a named or non-capturing group.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Function to check regular expression.\n         * @param {string} pattern The regular expression pattern to be checked.\n         * @param {ASTNode} node AST node which contains the regular expression or a call/new expression.\n         * @param {ASTNode} regexNode AST node which contains the regular expression.\n         * @param {string|null} flags The regular expression flags to be checked.\n         * @returns {void}\n         */\n        function checkRegex(pattern, node, regexNode, flags) {\n            let ast;\n\n            try {\n                ast = parser.parsePattern(pattern, 0, pattern.length, {\n                    unicode: Boolean(flags && flags.includes(\"u\")),\n                    unicodeSets: Boolean(flags && flags.includes(\"v\"))\n                });\n            } catch {\n\n                // ignore regex syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(ast, {\n                onCapturingGroupEnter(group) {\n                    if (!group.name) {\n                        const rawText = sourceCode.getText(regexNode);\n                        const suggest = suggestIfPossible(group.start, pattern, rawText, regexNode);\n\n                        context.report({\n                            node,\n                            messageId: \"required\",\n                            data: {\n                                group: group.raw\n                            },\n                            suggest\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            Literal(node) {\n                if (node.regex) {\n                    checkRegex(node.regex.pattern, node, node, node.regex.flags);\n                }\n            },\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {\n                    const regex = getStringIfConstant(refNode.arguments[0]);\n                    const flags = getStringIfConstant(refNode.arguments[1]);\n\n                    if (regex) {\n                        checkRegex(regex, refNode, refNode.arguments[0], flags);\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}