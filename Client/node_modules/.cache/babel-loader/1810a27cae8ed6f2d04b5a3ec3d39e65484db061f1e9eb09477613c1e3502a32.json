{"ast":null,"code":"/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nconst {\n  isParenthesized: isParenthesizedRaw\n} = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Disallow unnecessary parentheses\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-extra-parens\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"functions\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }, {\n          type: \"object\",\n          properties: {\n            conditionalAssign: {\n              type: \"boolean\"\n            },\n            ternaryOperandBinaryExpressions: {\n              type: \"boolean\"\n            },\n            nestedBinaryExpressions: {\n              type: \"boolean\"\n            },\n            returnAssign: {\n              type: \"boolean\"\n            },\n            ignoreJSX: {\n              enum: [\"none\", \"all\", \"single-line\", \"multi-line\"]\n            },\n            enforceForArrowConditionals: {\n              type: \"boolean\"\n            },\n            enforceForSequenceExpressions: {\n              type: \"boolean\"\n            },\n            enforceForNewInMemberExpressions: {\n              type: \"boolean\"\n            },\n            enforceForFunctionPrototypeMethods: {\n              type: \"boolean\"\n            },\n            allowParensAfterCommentPattern: {\n              type: \"string\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      unexpected: \"Unnecessary parentheses around expression.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const tokensToIgnore = new WeakSet();\n    const precedence = astUtils.getPrecedence;\n    const ALL_NODES = context.options[0] !== \"functions\";\n    const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n    const EXCEPT_COND_TERNARY = ALL_NODES && context.options[1] && context.options[1].ternaryOperandBinaryExpressions === false;\n    const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n    const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n    const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;\n    const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;\n    const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;\n    const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] && context.options[1].enforceForFunctionPrototypeMethods === false;\n    const ALLOW_PARENS_AFTER_COMMENT_PATTERN = ALL_NODES && context.options[1] && context.options[1].allowParensAfterCommentPattern;\n    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({\n      type: \"AssignmentExpression\"\n    });\n    const PRECEDENCE_OF_UPDATE_EXPR = precedence({\n      type: \"UpdateExpression\"\n    });\n    let reportsBuffer;\n\n    /**\n     * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.\n     * Example: function(){}.call()\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is an immediate `call` or `apply` method call.\n     * @private\n     */\n    function isImmediateFunctionPrototypeMethodCall(node) {\n      const callNode = astUtils.skipChainExpression(node);\n      if (callNode.type !== \"CallExpression\") {\n        return false;\n      }\n      const callee = astUtils.skipChainExpression(callNode.callee);\n      return callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee));\n    }\n\n    /**\n     * Determines if this rule should be enforced for a node given the current configuration.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the rule should be enforced for this node.\n     * @private\n     */\n    function ruleApplies(node) {\n      if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n        const isSingleLine = node.loc.start.line === node.loc.end.line;\n        switch (IGNORE_JSX) {\n          // Exclude this JSX element from linting\n          case \"all\":\n            return false;\n\n          // Exclude this JSX element if it is multi-line element\n          case \"multi-line\":\n            return isSingleLine;\n\n          // Exclude this JSX element if it is single-line element\n          case \"single-line\":\n            return !isSingleLine;\n\n          // Nothing special to be done for JSX elements\n          case \"none\":\n            break;\n\n          // no default\n        }\n      }\n      if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n        return false;\n      }\n      if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\n        return false;\n      }\n      return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n    }\n\n    /**\n     * Determines if a node is surrounded by parentheses.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is parenthesised.\n     * @private\n     */\n    function isParenthesised(node) {\n      return isParenthesizedRaw(1, node, sourceCode);\n    }\n\n    /**\n     * Determines if a node is surrounded by parentheses twice.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is doubly parenthesised.\n     * @private\n     */\n    function isParenthesisedTwice(node) {\n      return isParenthesizedRaw(2, node, sourceCode);\n    }\n\n    /**\n     * Determines if a node is surrounded by (potentially) invalid parentheses.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is incorrectly parenthesised.\n     * @private\n     */\n    function hasExcessParens(node) {\n      return ruleApplies(node) && isParenthesised(node);\n    }\n\n    /**\n     * Determines if a node that is expected to be parenthesised is surrounded by\n     * (potentially) invalid extra parentheses.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n     * @private\n     */\n    function hasDoubleExcessParens(node) {\n      return ruleApplies(node) && isParenthesisedTwice(node);\n    }\n\n    /**\n     * Determines if a node that is expected to be parenthesised is surrounded by\n     * (potentially) invalid extra parentheses with considering precedence level of the node.\n     * If the preference level of the node is not higher or equal to precedence lower limit, it also checks\n     * whether the node is surrounded by parentheses twice or not.\n     * @param {ASTNode} node The node to be checked.\n     * @param {number} precedenceLowerLimit The lower limit of precedence.\n     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n     * @private\n     */\n    function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\n      if (ruleApplies(node) && isParenthesised(node)) {\n        if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Determines if a node test expression is allowed to have a parenthesised assignment\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the assignment can be parenthesised.\n     * @private\n     */\n    function isCondAssignException(node) {\n      return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n    }\n\n    /**\n     * Determines if a node is in a return statement\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is in a return statement.\n     * @private\n     */\n    function isInReturnStatement(node) {\n      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (currentNode.type === \"ReturnStatement\" || currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\") {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Determines if a constructor function is newed-up with parens\n     * @param {ASTNode} newExpression The NewExpression node to be checked.\n     * @returns {boolean} True if the constructor is called with parens.\n     * @private\n     */\n    function isNewExpressionWithParens(newExpression) {\n      const lastToken = sourceCode.getLastToken(newExpression);\n      const penultimateToken = sourceCode.getTokenBefore(lastToken);\n      return newExpression.arguments.length > 0 ||\n      // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n      astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];\n    }\n\n    /**\n     * Determines if a node is or contains an assignment expression\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is or contains an assignment expression.\n     * @private\n     */\n    function containsAssignment(node) {\n      if (node.type === \"AssignmentExpression\") {\n        return true;\n      }\n      if (node.type === \"ConditionalExpression\" && (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n        return true;\n      }\n      if (node.left && node.left.type === \"AssignmentExpression\" || node.right && node.right.type === \"AssignmentExpression\") {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the assignment can be parenthesised.\n     * @private\n     */\n    function isReturnAssignException(node) {\n      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n        return false;\n      }\n      if (node.type === \"ReturnStatement\") {\n        return node.argument && containsAssignment(node.argument);\n      }\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        return containsAssignment(node.body);\n      }\n      return containsAssignment(node);\n    }\n\n    /**\n     * Determines if a node following a [no LineTerminator here] restriction is\n     * surrounded by (potentially) invalid extra parentheses.\n     * @param {Token} token The token preceding the [no LineTerminator here] restriction.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is incorrectly parenthesised.\n     * @private\n     */\n    function hasExcessParensNoLineTerminator(token, node) {\n      if (token.loc.end.line === node.loc.start.line) {\n        return hasExcessParens(node);\n      }\n      return hasDoubleExcessParens(node);\n    }\n\n    /**\n     * Determines whether a node should be preceded by an additional space when removing parens\n     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n     * @returns {boolean} `true` if a space should be inserted before the node\n     * @private\n     */\n    function requiresLeadingSpace(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, {\n        includeComments: true\n      });\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, {\n        includeComments: true\n      });\n      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\n    }\n\n    /**\n     * Determines whether a node should be followed by an additional space when removing parens\n     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n     * @returns {boolean} `true` if a space should be inserted after the node\n     * @private\n     */\n    function requiresTrailingSpace(node) {\n      const nextTwoTokens = sourceCode.getTokensAfter(node, {\n        count: 2\n      });\n      const rightParenToken = nextTwoTokens[0];\n      const tokenAfterRightParen = nextTwoTokens[1];\n      const tokenBeforeRightParen = sourceCode.getLastToken(node);\n      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n    }\n\n    /**\n     * Determines if a given expression node is an IIFE\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the given node is an IIFE\n     */\n    function isIIFE(node) {\n      const maybeCallNode = astUtils.skipChainExpression(node);\n      return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\n    }\n\n    /**\n     * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.\n     * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,\n     * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.\n     * @param {ASTNode} [node] The node to check\n     * @returns {boolean} `true` if the given node can be a valid assignment target\n     */\n    function canBeAssignmentTarget(node) {\n      return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\n    }\n\n    /**\n     * Checks if a node is fixable.\n     * A node is fixable if removing a single pair of surrounding parentheses does not turn it\n     * into a directive after fixing other nodes.\n     * Almost all nodes are fixable, except if all of the following conditions are met:\n     * The node is a string Literal\n     * It has a single pair of parentheses\n     * It is the only child of an ExpressionStatement\n     * @param {ASTNode} node The node to evaluate.\n     * @returns {boolean} Whether or not the node is fixable.\n     * @private\n     */\n    function isFixable(node) {\n      // if it's not a string literal it can be autofixed\n      if (node.type !== \"Literal\" || typeof node.value !== \"string\") {\n        return true;\n      }\n      if (isParenthesisedTwice(node)) {\n        return true;\n      }\n      return !astUtils.isTopLevelExpressionStatement(node.parent);\n    }\n\n    /**\n     * Report the node\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function report(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const rightParenToken = sourceCode.getTokenAfter(node);\n      if (!isParenthesisedTwice(node)) {\n        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n          return;\n        }\n        if (isIIFE(node) && !isParenthesised(node.callee)) {\n          return;\n        }\n        if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {\n          const commentsBeforeLeftParenToken = sourceCode.getCommentsBefore(leftParenToken);\n          const totalCommentsBeforeLeftParenTokenCount = commentsBeforeLeftParenToken.length;\n          const ignorePattern = new RegExp(ALLOW_PARENS_AFTER_COMMENT_PATTERN, \"u\");\n          if (totalCommentsBeforeLeftParenTokenCount > 0 && ignorePattern.test(commentsBeforeLeftParenToken[totalCommentsBeforeLeftParenTokenCount - 1].value)) {\n            return;\n          }\n        }\n      }\n\n      /**\n       * Finishes reporting\n       * @returns {void}\n       * @private\n       */\n      function finishReport() {\n        context.report({\n          node,\n          loc: leftParenToken.loc,\n          messageId: \"unexpected\",\n          fix: isFixable(node) ? fixer => {\n            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n            return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n          } : null\n        });\n      }\n      if (reportsBuffer) {\n        reportsBuffer.reports.push({\n          node,\n          finishReport\n        });\n        return;\n      }\n      finishReport();\n    }\n\n    /**\n     * Evaluate a argument of the node.\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkArgumentWithPrecedence(node) {\n      if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\n        report(node.argument);\n      }\n    }\n\n    /**\n     * Check if a member expression contains a call expression\n     * @param {ASTNode} node MemberExpression node to evaluate\n     * @returns {boolean} true if found, false if not\n     */\n    function doesMemberExpressionContainCallExpression(node) {\n      let currentNode = node.object;\n      let currentNodeType = node.object.type;\n      while (currentNodeType === \"MemberExpression\") {\n        currentNode = currentNode.object;\n        currentNodeType = currentNode.type;\n      }\n      return currentNodeType === \"CallExpression\";\n    }\n\n    /**\n     * Evaluate a new call\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkCallNew(node) {\n      const callee = node.callee;\n      if (hasExcessParensWithPrecedence(callee, precedence(node))) {\n        if (hasDoubleExcessParens(callee) || !(isIIFE(node) ||\n        // (new A)(); new (new A)();\n\n        callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee) && !(node.type === \"NewExpression\" && !isNewExpressionWithParens(node)) ||\n        // new (a().b)(); new (a.b().c);\n\n        node.type === \"NewExpression\" && callee.type === \"MemberExpression\" && doesMemberExpressionContainCallExpression(callee) ||\n        // (a?.b)(); (a?.())();\n\n        !node.optional && callee.type === \"ChainExpression\")) {\n          report(node.callee);\n        }\n      }\n      node.arguments.filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);\n    }\n\n    /**\n     * Evaluate binary logicals\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkBinaryLogical(node) {\n      const prec = precedence(node);\n      const leftPrecedence = precedence(node.left);\n      const rightPrecedence = precedence(node.right);\n      const isExponentiation = node.operator === \"**\";\n      const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\n      const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n      if (!shouldSkipLeft && hasExcessParens(node.left)) {\n        if (!([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) && !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(node.left)) {\n          report(node.left);\n        }\n      }\n      if (!shouldSkipRight && hasExcessParens(node.right)) {\n        if (!astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(node.right)) {\n          report(node.right);\n        }\n      }\n    }\n\n    /**\n     * Check the parentheses around the super class of the given class definition.\n     * @param {ASTNode} node The node of class declarations to check.\n     * @returns {void}\n     */\n    function checkClass(node) {\n      if (!node.superClass) {\n        return;\n      }\n\n      /*\n       * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n       * Otherwise, parentheses are needed.\n       */\n      const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);\n      if (hasExtraParens) {\n        report(node.superClass);\n      }\n    }\n\n    /**\n     * Check the parentheses around the argument of the given spread operator.\n     * @param {ASTNode} node The node of spread elements/properties to check.\n     * @returns {void}\n     */\n    function checkSpreadOperator(node) {\n      if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n        report(node.argument);\n      }\n    }\n\n    /**\n     * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n     * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n     * @returns {void}\n     */\n    function checkExpressionOrExportStatement(node) {\n      const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n      const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n      if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === \"Keyword\" && (secondToken.value === \"function\" || secondToken.value === \"class\" || secondToken.value === \"let\" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === \"Identifier\")) || secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\")) {\n        tokensToIgnore.add(secondToken);\n      }\n      const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node);\n      if (hasExtraParens) {\n        report(node);\n      }\n    }\n\n    /**\n     * Finds the path from the given node to the specified ancestor.\n     * @param {ASTNode} node First node in the path.\n     * @param {ASTNode} ancestor Last node in the path.\n     * @returns {ASTNode[]} Path, including both nodes.\n     * @throws {Error} If the given node does not have the specified ancestor.\n     */\n    function pathToAncestor(node, ancestor) {\n      const path = [node];\n      let currentNode = node;\n      while (currentNode !== ancestor) {\n        currentNode = currentNode.parent;\n\n        /* c8 ignore start */\n        if (currentNode === null) {\n          throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n        } /* c8 ignore stop */\n\n        path.push(currentNode);\n      }\n      return path;\n    }\n\n    /**\n     * Finds the path from the given node to the specified descendant.\n     * @param {ASTNode} node First node in the path.\n     * @param {ASTNode} descendant Last node in the path.\n     * @returns {ASTNode[]} Path, including both nodes.\n     * @throws {Error} If the given node does not have the specified descendant.\n     */\n    function pathToDescendant(node, descendant) {\n      return pathToAncestor(descendant, node).reverse();\n    }\n\n    /**\n     * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\n     * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\n     * @param {ASTNode} node Ancestor of an 'in' expression.\n     * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\n     * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\n     */\n    function isSafelyEnclosingInExpression(node, child) {\n      switch (node.type) {\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n        case \"BlockStatement\":\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n        case \"TemplateLiteral\":\n          return true;\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n          return node.params.includes(child);\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.arguments.includes(child);\n        case \"MemberExpression\":\n          return node.computed && node.property === child;\n        case \"ConditionalExpression\":\n          return node.consequent === child;\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\n     * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\n     * @returns {void}\n     */\n    function startNewReportsBuffering() {\n      reportsBuffer = {\n        upper: reportsBuffer,\n        inExpressionNodes: [],\n        reports: []\n      };\n    }\n\n    /**\n     * Ends the current reports buffering.\n     * @returns {void}\n     */\n    function endCurrentReportsBuffering() {\n      const {\n        upper,\n        inExpressionNodes,\n        reports\n      } = reportsBuffer;\n      if (upper) {\n        upper.inExpressionNodes.push(...inExpressionNodes);\n        upper.reports.push(...reports);\n      } else {\n        // flush remaining reports\n        reports.forEach(({\n          finishReport\n        }) => finishReport());\n      }\n      reportsBuffer = upper;\n    }\n\n    /**\n     * Checks whether the given node is in the current reports buffer.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is in the current buffer, false otherwise.\n     */\n    function isInCurrentReportsBuffer(node) {\n      return reportsBuffer.reports.some(r => r.node === node);\n    }\n\n    /**\n     * Removes the given node from the current reports buffer.\n     * @param {ASTNode} node Node to remove.\n     * @returns {void}\n     */\n    function removeFromCurrentReportsBuffer(node) {\n      reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n    }\n\n    /**\n     * Checks whether a node is a MemberExpression at NewExpression's callee.\n     * @param {ASTNode} node node to check.\n     * @returns {boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.\n     */\n    function isMemberExpInNewCallee(node) {\n      if (node.type === \"MemberExpression\") {\n        return node.parent.type === \"NewExpression\" && node.parent.callee === node ? true : node.parent.object === node && isMemberExpInNewCallee(node.parent);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if the left-hand side of an assignment is an identifier, the operator is one of\n     * `=`, `&&=`, `||=` or `??=` and the right-hand side is an anonymous class or function.\n     *\n     * As per https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation, an\n     * assignment involving one of the operators `=`, `&&=`, `||=` or `??=` where the right-hand\n     * side is an anonymous class or function and the left-hand side is an *unparenthesized*\n     * identifier has different semantics than other assignments.\n     * Specifically, when an expression like `foo = function () {}` is evaluated, `foo.name`\n     * will be set to the string \"foo\", i.e. the identifier name. The same thing does not happen\n     * when evaluating `(foo) = function () {}`.\n     * Since the parenthesizing of the identifier in the left-hand side is significant in this\n     * special case, the parentheses, if present, should not be flagged as unnecessary.\n     * @param {ASTNode} node an AssignmentExpression node.\n     * @returns {boolean} `true` if the left-hand side of the assignment is an identifier, the\n     * operator is one of `=`, `&&=`, `||=` or `??=` and the right-hand side is an anonymous\n     * class or function; otherwise, `false`.\n     */\n    function isAnonymousFunctionAssignmentException({\n      left,\n      operator,\n      right\n    }) {\n      if (left.type === \"Identifier\" && [\"=\", \"&&=\", \"||=\", \"??=\"].includes(operator)) {\n        const rhsType = right.type;\n        if (rhsType === \"ArrowFunctionExpression\") {\n          return true;\n        }\n        if ((rhsType === \"FunctionExpression\" || rhsType === \"ClassExpression\") && !right.id) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return {\n      ArrayExpression(node) {\n        node.elements.filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);\n      },\n      ArrayPattern(node) {\n        node.elements.filter(e => canBeAssignmentTarget(e) && hasExcessParens(e)).forEach(report);\n      },\n      ArrowFunctionExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n        if (node.body.type === \"ConditionalExpression\" && IGNORE_ARROW_CONDITIONALS) {\n          return;\n        }\n        if (node.body.type !== \"BlockStatement\") {\n          const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n          const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n          if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n            tokensToIgnore.add(firstBodyToken);\n          }\n          if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n            report(node.body);\n          }\n        }\n      },\n      AssignmentExpression(node) {\n        if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left) && (!isAnonymousFunctionAssignmentException(node) || isParenthesisedTwice(node.left))) {\n          report(node.left);\n        }\n        if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\n          report(node.right);\n        }\n      },\n      BinaryExpression(node) {\n        if (reportsBuffer && node.operator === \"in\") {\n          reportsBuffer.inExpressionNodes.push(node);\n        }\n        checkBinaryLogical(node);\n      },\n      CallExpression: checkCallNew,\n      ConditionalExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n        const availableTypes = new Set([\"BinaryExpression\", \"LogicalExpression\"]);\n        if (!(EXCEPT_COND_TERNARY && availableTypes.has(node.test.type)) && !isCondAssignException(node) && hasExcessParensWithPrecedence(node.test, precedence({\n          type: \"LogicalExpression\",\n          operator: \"||\"\n        }))) {\n          report(node.test);\n        }\n        if (!(EXCEPT_COND_TERNARY && availableTypes.has(node.consequent.type)) && hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.consequent);\n        }\n        if (!(EXCEPT_COND_TERNARY && availableTypes.has(node.alternate.type)) && hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.alternate);\n        }\n      },\n      DoWhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n      ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n      ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n      ForInStatement(node) {\n        if (node.left.type !== \"VariableDeclaration\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n          if (firstLeftToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken))) {\n            // ForInStatement#left expression cannot start with `let[`.\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n        if (hasExcessParens(node.right)) {\n          report(node.right);\n        }\n      },\n      ForOfStatement(node) {\n        if (node.left.type !== \"VariableDeclaration\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n          if (firstLeftToken.value === \"let\") {\n            // ForOfStatement#left expression cannot start with `let`.\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n        if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.right);\n        }\n      },\n      ForStatement(node) {\n        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n        if (node.update && hasExcessParens(node.update)) {\n          report(node.update);\n        }\n        if (node.init) {\n          if (node.init.type !== \"VariableDeclaration\") {\n            const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\n            if (firstToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken))) {\n              // ForStatement#init expression cannot start with `let[`.\n              tokensToIgnore.add(firstToken);\n            }\n          }\n          startNewReportsBuffering();\n          if (hasExcessParens(node.init)) {\n            report(node.init);\n          }\n        }\n      },\n      \"ForStatement > *.init:exit\"(node) {\n        /*\n         * Removing parentheses around `in` expressions might change semantics and cause errors.\n         *\n         * For example, this valid for loop:\n         *      for (let a = (b in c); ;);\n         * after removing parentheses would be treated as an invalid for-in loop:\n         *      for (let a = b in c; ;);\n         */\n\n        if (reportsBuffer.reports.length) {\n          reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n            const path = pathToDescendant(node, inExpressionNode);\n            let nodeToExclude;\n            for (let i = 0; i < path.length; i++) {\n              const pathNode = path[i];\n              if (i < path.length - 1) {\n                const nextPathNode = path[i + 1];\n                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n                  // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                  return;\n                }\n              }\n              if (isParenthesised(pathNode)) {\n                if (isInCurrentReportsBuffer(pathNode)) {\n                  // This node was supposed to be reported, but parentheses might be necessary.\n\n                  if (isParenthesisedTwice(pathNode)) {\n                    /*\n                     * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\n                     * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\n                     * The remaining pair is safely enclosing the 'in' expression.\n                     */\n                    return;\n                  }\n\n                  // Exclude the outermost node only.\n                  if (!nodeToExclude) {\n                    nodeToExclude = pathNode;\n                  }\n\n                  // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n                } else {\n                  // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                  return;\n                }\n              }\n            }\n\n            // Exclude the node from the list (i.e. treat parentheses as necessary)\n            removeFromCurrentReportsBuffer(nodeToExclude);\n          });\n        }\n        endCurrentReportsBuffering();\n      },\n      IfStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n      ImportExpression(node) {\n        const {\n          source\n        } = node;\n        if (source.type === \"SequenceExpression\") {\n          if (hasDoubleExcessParens(source)) {\n            report(source);\n          }\n        } else if (hasExcessParens(source)) {\n          report(source);\n        }\n      },\n      LogicalExpression: checkBinaryLogical,\n      MemberExpression(node) {\n        const shouldAllowWrapOnce = isMemberExpInNewCallee(node) && doesMemberExpressionContainCallExpression(node);\n        const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node.object) : hasExcessParens(node.object) && !(isImmediateFunctionPrototypeMethodCall(node.parent) && node.parent.callee === node && IGNORE_FUNCTION_PROTOTYPE_METHODS);\n        if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) ||\n        // RegExp literal is allowed to have parens (#1589)\n        node.object.type === \"Literal\" && node.object.regex))) {\n          report(node.object);\n        }\n        if (nodeObjHasExcessParens && node.object.type === \"CallExpression\") {\n          report(node.object);\n        }\n        if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === \"NewExpression\" && isNewExpressionWithParens(node.object)) {\n          report(node.object);\n        }\n        if (nodeObjHasExcessParens && node.optional && node.object.type === \"ChainExpression\") {\n          report(node.object);\n        }\n        if (node.computed && hasExcessParens(node.property)) {\n          report(node.property);\n        }\n      },\n      \"MethodDefinition[computed=true]\"(node) {\n        if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.key);\n        }\n      },\n      NewExpression: checkCallNew,\n      ObjectExpression(node) {\n        node.properties.filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(property => report(property.value));\n      },\n      ObjectPattern(node) {\n        node.properties.filter(property => {\n          const value = property.value;\n          return canBeAssignmentTarget(value) && hasExcessParens(value);\n        }).forEach(property => report(property.value));\n      },\n      Property(node) {\n        if (node.computed) {\n          const {\n            key\n          } = node;\n          if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n            report(key);\n          }\n        }\n      },\n      PropertyDefinition(node) {\n        if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.key);\n        }\n        if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.value);\n        }\n      },\n      RestElement(node) {\n        const argument = node.argument;\n        if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\n          report(argument);\n        }\n      },\n      ReturnStatement(node) {\n        const returnToken = sourceCode.getFirstToken(node);\n        if (isReturnAssignException(node)) {\n          return;\n        }\n        if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n        // RegExp literal is allowed to have parens (#1589)\n        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n          report(node.argument);\n        }\n      },\n      SequenceExpression(node) {\n        const precedenceOfNode = precedence(node);\n        node.expressions.filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode)).forEach(report);\n      },\n      SwitchCase(node) {\n        if (node.test && hasExcessParens(node.test)) {\n          report(node.test);\n        }\n      },\n      SwitchStatement(node) {\n        if (hasExcessParens(node.discriminant)) {\n          report(node.discriminant);\n        }\n      },\n      ThrowStatement(node) {\n        const throwToken = sourceCode.getFirstToken(node);\n        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n          report(node.argument);\n        }\n      },\n      UnaryExpression: checkArgumentWithPrecedence,\n      UpdateExpression(node) {\n        if (node.prefix) {\n          checkArgumentWithPrecedence(node);\n        } else {\n          const {\n            argument\n          } = node;\n          const operatorToken = sourceCode.getLastToken(node);\n          if (argument.loc.end.line === operatorToken.loc.start.line) {\n            checkArgumentWithPrecedence(node);\n          } else {\n            if (hasDoubleExcessParens(argument)) {\n              report(argument);\n            }\n          }\n        }\n      },\n      AwaitExpression: checkArgumentWithPrecedence,\n      VariableDeclarator(node) {\n        if (node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) &&\n        // RegExp literal is allowed to have parens (#1589)\n        !(node.init.type === \"Literal\" && node.init.regex)) {\n          report(node.init);\n        }\n      },\n      WhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n      WithStatement(node) {\n        if (hasExcessParens(node.object)) {\n          report(node.object);\n        }\n      },\n      YieldExpression(node) {\n        if (node.argument) {\n          const yieldToken = sourceCode.getFirstToken(node);\n          if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {\n            report(node.argument);\n          }\n        }\n      },\n      ClassDeclaration: checkClass,\n      ClassExpression: checkClass,\n      SpreadElement: checkSpreadOperator,\n      SpreadProperty: checkSpreadOperator,\n      ExperimentalSpreadProperty: checkSpreadOperator,\n      TemplateLiteral(node) {\n        node.expressions.filter(e => e && hasExcessParens(e)).forEach(report);\n      },\n      AssignmentPattern(node) {\n        const {\n          left,\n          right\n        } = node;\n        if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\n          report(left);\n        }\n        if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(right);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["isParenthesized","isParenthesizedRaw","require","astUtils","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","properties","conditionalAssign","ternaryOperandBinaryExpressions","nestedBinaryExpressions","returnAssign","ignoreJSX","enforceForArrowConditionals","enforceForSequenceExpressions","enforceForNewInMemberExpressions","enforceForFunctionPrototypeMethods","allowParensAfterCommentPattern","additionalProperties","messages","unexpected","create","context","sourceCode","tokensToIgnore","WeakSet","precedence","getPrecedence","ALL_NODES","options","EXCEPT_COND_ASSIGN","EXCEPT_COND_TERNARY","NESTED_BINARY","EXCEPT_RETURN_ASSIGN","IGNORE_JSX","IGNORE_ARROW_CONDITIONALS","IGNORE_SEQUENCE_EXPRESSIONS","IGNORE_NEW_IN_MEMBER_EXPR","IGNORE_FUNCTION_PROTOTYPE_METHODS","ALLOW_PARENS_AFTER_COMMENT_PATTERN","PRECEDENCE_OF_ASSIGNMENT_EXPR","PRECEDENCE_OF_UPDATE_EXPR","reportsBuffer","isImmediateFunctionPrototypeMethodCall","node","callNode","skipChainExpression","callee","object","includes","getStaticPropertyName","ruleApplies","isSingleLine","loc","start","line","end","isParenthesised","isParenthesisedTwice","hasExcessParens","hasDoubleExcessParens","hasExcessParensWithPrecedence","precedenceLowerLimit","isCondAssignException","test","isInReturnStatement","currentNode","parent","body","isNewExpressionWithParens","newExpression","lastToken","getLastToken","penultimateToken","getTokenBefore","arguments","length","isOpeningParenToken","isClosingParenToken","range","containsAssignment","consequent","alternate","left","right","isReturnAssignException","argument","hasExcessParensNoLineTerminator","token","requiresLeadingSpace","leftParenToken","tokenBeforeLeftParen","includeComments","tokenAfterLeftParen","getTokenAfter","canTokensBeAdjacent","requiresTrailingSpace","nextTwoTokens","getTokensAfter","count","rightParenToken","tokenAfterRightParen","tokenBeforeRightParen","isSpaceBetweenTokens","isIIFE","maybeCallNode","canBeAssignmentTarget","isFixable","value","isTopLevelExpressionStatement","report","has","getFirstToken","commentsBeforeLeftParenToken","getCommentsBefore","totalCommentsBeforeLeftParenTokenCount","ignorePattern","RegExp","finishReport","messageId","fix","fixer","parenthesizedSource","text","slice","replaceTextRange","reports","push","checkArgumentWithPrecedence","doesMemberExpressionContainCallExpression","currentNodeType","checkCallNew","optional","filter","arg","forEach","checkBinaryLogical","prec","leftPrecedence","rightPrecedence","isExponentiation","operator","shouldSkipLeft","shouldSkipRight","isMixedLogicalAndCoalesceExpressions","checkClass","superClass","hasExtraParens","checkSpreadOperator","checkExpressionOrExportStatement","firstToken","secondToken","isNotOpeningParenToken","thirdToken","tokenAfterClosingParens","isNotClosingParenToken","isOpeningBraceToken","isOpeningBracketToken","add","pathToAncestor","ancestor","path","Error","pathToDescendant","descendant","reverse","isSafelyEnclosingInExpression","child","params","computed","property","startNewReportsBuffering","upper","inExpressionNodes","endCurrentReportsBuffering","isInCurrentReportsBuffer","some","r","removeFromCurrentReportsBuffer","isMemberExpInNewCallee","isAnonymousFunctionAssignmentException","rhsType","id","ArrayExpression","elements","e","ArrayPattern","ArrowFunctionExpression","firstBodyToken","tokenBeforeFirst","AssignmentExpression","BinaryExpression","CallExpression","ConditionalExpression","availableTypes","Set","DoWhileStatement","ExportDefaultDeclaration","declaration","ExpressionStatement","expression","ForInStatement","firstLeftToken","ForOfStatement","ForStatement","update","init","ForStatement > *.init:exit","inExpressionNode","nodeToExclude","i","pathNode","nextPathNode","IfStatement","ImportExpression","source","LogicalExpression","MemberExpression","shouldAllowWrapOnce","nodeObjHasExcessParens","isDecimalInteger","regex","MethodDefinition[computed=true]","key","NewExpression","ObjectExpression","ObjectPattern","Property","PropertyDefinition","RestElement","ReturnStatement","returnToken","SequenceExpression","precedenceOfNode","expressions","SwitchCase","SwitchStatement","discriminant","ThrowStatement","throwToken","UnaryExpression","UpdateExpression","prefix","operatorToken","AwaitExpression","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","yieldToken","ClassDeclaration","ClassExpression","SpreadElement","SpreadProperty","ExperimentalSpreadProperty","TemplateLiteral","AssignmentPattern"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-extra-parens.js"],"sourcesContent":["/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst { isParenthesized: isParenthesizedRaw } = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Disallow unnecessary parentheses\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                ternaryOperandBinaryExpressions: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\n                                enforceForArrowConditionals: { type: \"boolean\" },\n                                enforceForSequenceExpressions: { type: \"boolean\" },\n                                enforceForNewInMemberExpressions: { type: \"boolean\" },\n                                enforceForFunctionPrototypeMethods: { type: \"boolean\" },\n                                allowParensAfterCommentPattern: { type: \"string\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unnecessary parentheses around expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        const tokensToIgnore = new WeakSet();\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const EXCEPT_COND_TERNARY = ALL_NODES && context.options[1] && context.options[1].ternaryOperandBinaryExpressions === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForArrowConditionals === false;\n        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForSequenceExpressions === false;\n        const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForNewInMemberExpressions === false;\n        const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForFunctionPrototypeMethods === false;\n        const ALLOW_PARENS_AFTER_COMMENT_PATTERN = ALL_NODES && context.options[1] && context.options[1].allowParensAfterCommentPattern;\n\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        let reportsBuffer;\n\n        /**\n         * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.\n         * Example: function(){}.call()\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is an immediate `call` or `apply` method call.\n         * @private\n         */\n        function isImmediateFunctionPrototypeMethodCall(node) {\n            const callNode = astUtils.skipChainExpression(node);\n\n            if (callNode.type !== \"CallExpression\") {\n                return false;\n            }\n            const callee = astUtils.skipChainExpression(callNode.callee);\n\n            return (\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee))\n            );\n        }\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n                return false;\n            }\n\n            if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\n                return false;\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is parenthesised.\n         * @private\n         */\n        function isParenthesised(node) {\n            return isParenthesizedRaw(1, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            return isParenthesizedRaw(2, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses with considering precedence level of the node.\n         * If the preference level of the node is not higher or equal to precedence lower limit, it also checks\n         * whether the node is surrounded by parentheses twice or not.\n         * @param {ASTNode} node The node to be checked.\n         * @param {number} precedenceLowerLimit The lower limit of precedence.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\n            if (ruleApplies(node) && isParenthesised(node)) {\n                if (\n                    precedence(node) >= precedenceLowerLimit ||\n                    isParenthesisedTwice(node)\n                ) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n                if (\n                    currentNode.type === \"ReturnStatement\" ||\n                    (currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\")\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 ||\n                (\n\n                    // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n                    astUtils.isOpeningParenToken(penultimateToken) &&\n                    astUtils.isClosingParenToken(lastToken) &&\n                    newExpression.callee.range[1] < newExpression.range[1]\n                );\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            }\n            if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            }\n            if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            }\n            if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, { includeComments: true });\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, { includeComments: true });\n\n            return tokenBeforeLeftParen &&\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\n                leftParenToken.range[1] === tokenAfterLeftParen.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\n        }\n\n        /**\n         * Determines whether a node should be followed by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted after the node\n         * @private\n         */\n        function requiresTrailingSpace(node) {\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\n            const rightParenToken = nextTwoTokens[0];\n            const tokenAfterRightParen = nextTwoTokens[1];\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\n\n            return rightParenToken && tokenAfterRightParen &&\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n        }\n\n        /**\n         * Determines if a given expression node is an IIFE\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the given node is an IIFE\n         */\n        function isIIFE(node) {\n            const maybeCallNode = astUtils.skipChainExpression(node);\n\n            return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\n        }\n\n        /**\n         * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.\n         * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,\n         * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.\n         * @param {ASTNode} [node] The node to check\n         * @returns {boolean} `true` if the given node can be a valid assignment target\n         */\n        function canBeAssignmentTarget(node) {\n            return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\n        }\n\n        /**\n         * Checks if a node is fixable.\n         * A node is fixable if removing a single pair of surrounding parentheses does not turn it\n         * into a directive after fixing other nodes.\n         * Almost all nodes are fixable, except if all of the following conditions are met:\n         * The node is a string Literal\n         * It has a single pair of parentheses\n         * It is the only child of an ExpressionStatement\n         * @param {ASTNode} node The node to evaluate.\n         * @returns {boolean} Whether or not the node is fixable.\n         * @private\n         */\n        function isFixable(node) {\n\n            // if it's not a string literal it can be autofixed\n            if (node.type !== \"Literal\" || typeof node.value !== \"string\") {\n                return true;\n            }\n            if (isParenthesisedTwice(node)) {\n                return true;\n            }\n            return !astUtils.isTopLevelExpressionStatement(node.parent);\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (!isParenthesisedTwice(node)) {\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n                    return;\n                }\n\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\n                    return;\n                }\n\n                if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {\n                    const commentsBeforeLeftParenToken = sourceCode.getCommentsBefore(leftParenToken);\n                    const totalCommentsBeforeLeftParenTokenCount = commentsBeforeLeftParenToken.length;\n                    const ignorePattern = new RegExp(ALLOW_PARENS_AFTER_COMMENT_PATTERN, \"u\");\n\n                    if (\n                        totalCommentsBeforeLeftParenTokenCount > 0 &&\n                        ignorePattern.test(commentsBeforeLeftParenToken[totalCommentsBeforeLeftParenTokenCount - 1].value)\n                    ) {\n                        return;\n                    }\n                }\n            }\n\n            /**\n             * Finishes reporting\n             * @returns {void}\n             * @private\n             */\n            function finishReport() {\n                context.report({\n                    node,\n                    loc: leftParenToken.loc,\n                    messageId: \"unexpected\",\n                    fix: isFixable(node)\n                        ? fixer => {\n                            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                            return fixer.replaceTextRange([\n                                leftParenToken.range[0],\n                                rightParenToken.range[1]\n                            ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n                        }\n                        : null\n                });\n            }\n\n            if (reportsBuffer) {\n                reportsBuffer.reports.push({ node, finishReport });\n                return;\n            }\n\n            finishReport();\n        }\n\n        /**\n         * Evaluate a argument of the node.\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkArgumentWithPrecedence(node) {\n            if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Check if a member expression contains a call expression\n         * @param {ASTNode} node MemberExpression node to evaluate\n         * @returns {boolean} true if found, false if not\n         */\n        function doesMemberExpressionContainCallExpression(node) {\n            let currentNode = node.object;\n            let currentNodeType = node.object.type;\n\n            while (currentNodeType === \"MemberExpression\") {\n                currentNode = currentNode.object;\n                currentNodeType = currentNode.type;\n            }\n\n            return currentNodeType === \"CallExpression\";\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            const callee = node.callee;\n\n            if (hasExcessParensWithPrecedence(callee, precedence(node))) {\n                if (\n                    hasDoubleExcessParens(callee) ||\n                    !(\n                        isIIFE(node) ||\n\n                        // (new A)(); new (new A)();\n                        (\n                            callee.type === \"NewExpression\" &&\n                            !isNewExpressionWithParens(callee) &&\n                            !(\n                                node.type === \"NewExpression\" &&\n                                !isNewExpressionWithParens(node)\n                            )\n                        ) ||\n\n                        // new (a().b)(); new (a.b().c);\n                        (\n                            node.type === \"NewExpression\" &&\n                            callee.type === \"MemberExpression\" &&\n                            doesMemberExpressionContainCallExpression(callee)\n                        ) ||\n\n                        // (a?.b)(); (a?.())();\n                        (\n                            !node.optional &&\n                            callee.type === \"ChainExpression\"\n                        )\n                    )\n                ) {\n                    report(node.callee);\n                }\n            }\n            node.arguments\n                .filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                .forEach(report);\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left)) {\n                if (\n                    !([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) &&\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) &&\n                    (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation)) ||\n                    isParenthesisedTwice(node.left)\n                ) {\n                    report(node.left);\n                }\n            }\n\n            if (!shouldSkipRight && hasExcessParens(node.right)) {\n                if (\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) &&\n                    (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation)) ||\n                    isParenthesisedTwice(node.right)\n                ) {\n                    report(node.right);\n                }\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            /*\n             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n             * Otherwise, parentheses are needed.\n             */\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" &&\n                            tokenAfterClosingParens &&\n                            (\n                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||\n                                tokenAfterClosingParens.type === \"Identifier\"\n                            )\n                    ) ||\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\"\n                ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                : hasExcessParens(node);\n\n            if (hasExtraParens) {\n                report(node);\n            }\n        }\n\n        /**\n         * Finds the path from the given node to the specified ancestor.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} ancestor Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified ancestor.\n         */\n        function pathToAncestor(node, ancestor) {\n            const path = [node];\n            let currentNode = node;\n\n            while (currentNode !== ancestor) {\n\n                currentNode = currentNode.parent;\n\n                /* c8 ignore start */\n                if (currentNode === null) {\n                    throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n                }/* c8 ignore stop */\n\n                path.push(currentNode);\n            }\n\n            return path;\n        }\n\n        /**\n         * Finds the path from the given node to the specified descendant.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} descendant Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified descendant.\n         */\n        function pathToDescendant(node, descendant) {\n            return pathToAncestor(descendant, node).reverse();\n        }\n\n        /**\n         * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\n         * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\n         * @param {ASTNode} node Ancestor of an 'in' expression.\n         * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\n         * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\n         */\n        function isSafelyEnclosingInExpression(node, child) {\n            switch (node.type) {\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                case \"BlockStatement\":\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                case \"TemplateLiteral\":\n                    return true;\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                    return node.params.includes(child);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.arguments.includes(child);\n                case \"MemberExpression\":\n                    return node.computed && node.property === child;\n                case \"ConditionalExpression\":\n                    return node.consequent === child;\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\n         * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\n         * @returns {void}\n         */\n        function startNewReportsBuffering() {\n            reportsBuffer = {\n                upper: reportsBuffer,\n                inExpressionNodes: [],\n                reports: []\n            };\n        }\n\n        /**\n         * Ends the current reports buffering.\n         * @returns {void}\n         */\n        function endCurrentReportsBuffering() {\n            const { upper, inExpressionNodes, reports } = reportsBuffer;\n\n            if (upper) {\n                upper.inExpressionNodes.push(...inExpressionNodes);\n                upper.reports.push(...reports);\n            } else {\n\n                // flush remaining reports\n                reports.forEach(({ finishReport }) => finishReport());\n            }\n\n            reportsBuffer = upper;\n        }\n\n        /**\n         * Checks whether the given node is in the current reports buffer.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is in the current buffer, false otherwise.\n         */\n        function isInCurrentReportsBuffer(node) {\n            return reportsBuffer.reports.some(r => r.node === node);\n        }\n\n        /**\n         * Removes the given node from the current reports buffer.\n         * @param {ASTNode} node Node to remove.\n         * @returns {void}\n         */\n        function removeFromCurrentReportsBuffer(node) {\n            reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n        }\n\n        /**\n         * Checks whether a node is a MemberExpression at NewExpression's callee.\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.\n         */\n        function isMemberExpInNewCallee(node) {\n            if (node.type === \"MemberExpression\") {\n                return node.parent.type === \"NewExpression\" && node.parent.callee === node\n                    ? true\n                    : node.parent.object === node && isMemberExpInNewCallee(node.parent);\n            }\n            return false;\n        }\n\n        /**\n         * Checks if the left-hand side of an assignment is an identifier, the operator is one of\n         * `=`, `&&=`, `||=` or `??=` and the right-hand side is an anonymous class or function.\n         *\n         * As per https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation, an\n         * assignment involving one of the operators `=`, `&&=`, `||=` or `??=` where the right-hand\n         * side is an anonymous class or function and the left-hand side is an *unparenthesized*\n         * identifier has different semantics than other assignments.\n         * Specifically, when an expression like `foo = function () {}` is evaluated, `foo.name`\n         * will be set to the string \"foo\", i.e. the identifier name. The same thing does not happen\n         * when evaluating `(foo) = function () {}`.\n         * Since the parenthesizing of the identifier in the left-hand side is significant in this\n         * special case, the parentheses, if present, should not be flagged as unnecessary.\n         * @param {ASTNode} node an AssignmentExpression node.\n         * @returns {boolean} `true` if the left-hand side of the assignment is an identifier, the\n         * operator is one of `=`, `&&=`, `||=` or `??=` and the right-hand side is an anonymous\n         * class or function; otherwise, `false`.\n         */\n        function isAnonymousFunctionAssignmentException({ left, operator, right }) {\n            if (left.type === \"Identifier\" && [\"=\", \"&&=\", \"||=\", \"??=\"].includes(operator)) {\n                const rhsType = right.type;\n\n                if (rhsType === \"ArrowFunctionExpression\") {\n                    return true;\n                }\n                if ((rhsType === \"FunctionExpression\" || rhsType === \"ClassExpression\") && !right.id) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return {\n            ArrayExpression(node) {\n                node.elements\n                    .filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(report);\n            },\n\n            ArrayPattern(node) {\n                node.elements\n                    .filter(e => canBeAssignmentTarget(e) && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type === \"ConditionalExpression\" &&\n                    IGNORE_ARROW_CONDITIONALS\n                ) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left) &&\n                    (!isAnonymousFunctionAssignmentException(node) || isParenthesisedTwice(node.left))) {\n                    report(node.left);\n                }\n\n                if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression(node) {\n                if (reportsBuffer && node.operator === \"in\") {\n                    reportsBuffer.inExpressionNodes.push(node);\n                }\n\n                checkBinaryLogical(node);\n            },\n\n            CallExpression: checkCallNew,\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                const availableTypes = new Set([\"BinaryExpression\", \"LogicalExpression\"]);\n\n                if (\n                    !(EXCEPT_COND_TERNARY && availableTypes.has(node.test.type)) &&\n                    !isCondAssignException(node) &&\n                    hasExcessParensWithPrecedence(node.test, precedence({ type: \"LogicalExpression\", operator: \"||\" }))\n                ) {\n                    report(node.test);\n                }\n\n                if (\n                    !(EXCEPT_COND_TERNARY && availableTypes.has(node.consequent.type)) &&\n                    hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.consequent);\n                }\n\n                if (\n                    !(EXCEPT_COND_TERNARY && availableTypes.has(node.alternate.type)) &&\n                    hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            ForInStatement(node) {\n                if (node.left.type !== \"VariableDeclaration\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (\n                        firstLeftToken.value === \"let\" &&\n                        astUtils.isOpeningBracketToken(\n                            sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\n                        )\n                    ) {\n\n                        // ForInStatement#left expression cannot start with `let[`.\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForOfStatement(node) {\n                if (node.left.type !== \"VariableDeclaration\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (firstLeftToken.value === \"let\") {\n\n                        // ForOfStatement#left expression cannot start with `let`.\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.right);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n\n                if (node.init) {\n\n                    if (node.init.type !== \"VariableDeclaration\") {\n                        const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\n\n                        if (\n                            firstToken.value === \"let\" &&\n                            astUtils.isOpeningBracketToken(\n                                sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken)\n                            )\n                        ) {\n\n                            // ForStatement#init expression cannot start with `let[`.\n                            tokensToIgnore.add(firstToken);\n                        }\n                    }\n\n                    startNewReportsBuffering();\n\n                    if (hasExcessParens(node.init)) {\n                        report(node.init);\n                    }\n                }\n            },\n\n            \"ForStatement > *.init:exit\"(node) {\n\n                /*\n                 * Removing parentheses around `in` expressions might change semantics and cause errors.\n                 *\n                 * For example, this valid for loop:\n                 *      for (let a = (b in c); ;);\n                 * after removing parentheses would be treated as an invalid for-in loop:\n                 *      for (let a = b in c; ;);\n                 */\n\n                if (reportsBuffer.reports.length) {\n                    reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n                        const path = pathToDescendant(node, inExpressionNode);\n                        let nodeToExclude;\n\n                        for (let i = 0; i < path.length; i++) {\n                            const pathNode = path[i];\n\n                            if (i < path.length - 1) {\n                                const nextPathNode = path[i + 1];\n\n                                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n\n                                    // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                                    return;\n                                }\n                            }\n\n                            if (isParenthesised(pathNode)) {\n                                if (isInCurrentReportsBuffer(pathNode)) {\n\n                                    // This node was supposed to be reported, but parentheses might be necessary.\n\n                                    if (isParenthesisedTwice(pathNode)) {\n\n                                        /*\n                                         * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\n                                         * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\n                                         * The remaining pair is safely enclosing the 'in' expression.\n                                         */\n                                        return;\n                                    }\n\n                                    // Exclude the outermost node only.\n                                    if (!nodeToExclude) {\n                                        nodeToExclude = pathNode;\n                                    }\n\n                                    // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n\n                                } else {\n\n                                    // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                                    return;\n                                }\n                            }\n                        }\n\n                        // Exclude the node from the list (i.e. treat parentheses as necessary)\n                        removeFromCurrentReportsBuffer(nodeToExclude);\n                    });\n                }\n\n                endCurrentReportsBuffering();\n            },\n\n            IfStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ImportExpression(node) {\n                const { source } = node;\n\n                if (source.type === \"SequenceExpression\") {\n                    if (hasDoubleExcessParens(source)) {\n                        report(source);\n                    }\n                } else if (hasExcessParens(source)) {\n                    report(source);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                const shouldAllowWrapOnce = isMemberExpInNewCallee(node) &&\n                  doesMemberExpressionContainCallExpression(node);\n                const nodeObjHasExcessParens = shouldAllowWrapOnce\n                    ? hasDoubleExcessParens(node.object)\n                    : hasExcessParens(node.object) &&\n                    !(\n                        isImmediateFunctionPrototypeMethodCall(node.parent) &&\n                        node.parent.callee === node &&\n                        IGNORE_FUNCTION_PROTOTYPE_METHODS\n                    );\n\n                if (\n                    nodeObjHasExcessParens &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  node.object.type === \"CallExpression\"\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  !IGNORE_NEW_IN_MEMBER_EXPR &&\n                  node.object.type === \"NewExpression\" &&\n                  isNewExpressionWithParens(node.object)) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                    node.optional &&\n                    node.object.type === \"ChainExpression\"\n                ) {\n                    report(node.object);\n                }\n\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            \"MethodDefinition[computed=true]\"(node) {\n                if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.key);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                node.properties\n                    .filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(property => report(property.value));\n            },\n\n            ObjectPattern(node) {\n                node.properties\n                    .filter(property => {\n                        const value = property.value;\n\n                        return canBeAssignmentTarget(value) && hasExcessParens(value);\n                    }).forEach(property => report(property.value));\n            },\n\n            Property(node) {\n                if (node.computed) {\n                    const { key } = node;\n\n                    if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                        report(key);\n                    }\n                }\n            },\n\n            PropertyDefinition(node) {\n                if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.key);\n                }\n\n                if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.value);\n                }\n            },\n\n            RestElement(node) {\n                const argument = node.argument;\n\n                if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\n                    report(argument);\n                }\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                const precedenceOfNode = precedence(node);\n\n                node.expressions\n                    .filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode))\n                    .forEach(report);\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkArgumentWithPrecedence,\n            UpdateExpression(node) {\n                if (node.prefix) {\n                    checkArgumentWithPrecedence(node);\n                } else {\n                    const { argument } = node;\n                    const operatorToken = sourceCode.getLastToken(node);\n\n                    if (argument.loc.end.line === operatorToken.loc.start.line) {\n                        checkArgumentWithPrecedence(node);\n                    } else {\n                        if (hasDoubleExcessParens(argument)) {\n                            report(argument);\n                        }\n                    }\n                }\n            },\n            AwaitExpression: checkArgumentWithPrecedence,\n\n            VariableDeclarator(node) {\n                if (\n                    node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) &&\n\n                    // RegExp literal is allowed to have parens (#1589)\n                    !(node.init.type === \"Literal\" && node.init.regex)\n                ) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator,\n\n            TemplateLiteral(node) {\n                node.expressions\n                    .filter(e => e && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            AssignmentPattern(node) {\n                const { left, right } = node;\n\n                if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\n                    report(left);\n                }\n\n                if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(right);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}