{"ast":null,"code":"/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\"),\n  keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function () {\n  KEYS.sort();\n  for (let i = 1; i < KEYS.length; ++i) {\n    if (KEYS[i] === KEYS[i - 1]) {\n      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n    }\n  }\n})();\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent spacing before and after keywords\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/keyword-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        },\n        overrides: {\n          type: \"object\",\n          properties: KEYS.reduce((retv, key) => {\n            retv[key] = {\n              type: \"object\",\n              properties: {\n                before: {\n                  type: \"boolean\"\n                },\n                after: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            };\n            return retv;\n          }, {}),\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n      expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n      unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n      unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const tokensToIgnore = new WeakSet();\n\n    /**\n     * Reports a given token if there are not space(s) before the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the previous token to check.\n     * @returns {void}\n     */\n    function expectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedBefore\",\n          data: token,\n          fix(fixer) {\n            return fixer.insertTextBefore(token, \" \");\n          }\n        });\n      }\n    }\n\n    /**\n     * Reports a given token if there are space(s) before the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the previous token to check.\n     * @returns {void}\n     */\n    function unexpectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: {\n            start: prevToken.loc.end,\n            end: token.loc.start\n          },\n          messageId: \"unexpectedBefore\",\n          data: token,\n          fix(fixer) {\n            return fixer.removeRange([prevToken.range[1], token.range[0]]);\n          }\n        });\n      }\n    }\n\n    /**\n     * Reports a given token if there are not space(s) after the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the next token to check.\n     * @returns {void}\n     */\n    function expectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedAfter\",\n          data: token,\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \" \");\n          }\n        });\n      }\n    }\n\n    /**\n     * Reports a given token if there are space(s) after the token.\n     * @param {Token} token A token to report.\n     * @param {RegExp} pattern A pattern of the next token to check.\n     * @returns {void}\n     */\n    function unexpectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: {\n            start: token.loc.end,\n            end: nextToken.loc.start\n          },\n          messageId: \"unexpectedAfter\",\n          data: token,\n          fix(fixer) {\n            return fixer.removeRange([token.range[1], nextToken.range[0]]);\n          }\n        });\n      }\n    }\n\n    /**\n     * Parses the option object and determines check methods for each keyword.\n     * @param {Object|undefined} options The option object to parse.\n     * @returns {Object} - Normalized option object.\n     *      Keys are keywords (there are for every keyword).\n     *      Values are instances of `{\"before\": function, \"after\": function}`.\n     */\n    function parseOptions(options = {}) {\n      const before = options.before !== false;\n      const after = options.after !== false;\n      const defaultValue = {\n        before: before ? expectSpaceBefore : unexpectSpaceBefore,\n        after: after ? expectSpaceAfter : unexpectSpaceAfter\n      };\n      const overrides = options && options.overrides || {};\n      const retv = Object.create(null);\n      for (let i = 0; i < KEYS.length; ++i) {\n        const key = KEYS[i];\n        const override = overrides[key];\n        if (override) {\n          const thisBefore = \"before\" in override ? override.before : before;\n          const thisAfter = \"after\" in override ? override.after : after;\n          retv[key] = {\n            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n          };\n        } else {\n          retv[key] = defaultValue;\n        }\n      }\n      return retv;\n    }\n    const checkMethodMap = parseOptions(context.options[0]);\n\n    /**\n     * Reports a given token if usage of spacing followed by the token is\n     * invalid.\n     * @param {Token} token A token to report.\n     * @param {RegExp} [pattern] Optional. A pattern of the previous\n     *      token to check.\n     * @returns {void}\n     */\n    function checkSpacingBefore(token, pattern) {\n      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n    }\n\n    /**\n     * Reports a given token if usage of spacing preceded by the token is\n     * invalid.\n     * @param {Token} token A token to report.\n     * @param {RegExp} [pattern] Optional. A pattern of the next\n     *      token to check.\n     * @returns {void}\n     */\n    function checkSpacingAfter(token, pattern) {\n      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n    }\n\n    /**\n     * Reports a given token if usage of spacing around the token is invalid.\n     * @param {Token} token A token to report.\n     * @returns {void}\n     */\n    function checkSpacingAround(token) {\n      checkSpacingBefore(token);\n      checkSpacingAfter(token);\n    }\n\n    /**\n     * Reports the first token of a given node if the first token is a keyword\n     * and usage of spacing around the token is invalid.\n     * @param {ASTNode|null} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingAroundFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingAround(firstToken);\n      }\n    }\n\n    /**\n     * Reports the first token of a given node if the first token is a keyword\n     * and usage of spacing followed by the token is invalid.\n     *\n     * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n     * Other rules are handling usage of spacing preceded by those keywords.\n     * @param {ASTNode|null} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingBeforeFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingBefore(firstToken);\n      }\n    }\n\n    /**\n     * Reports the previous token of a given node if the token is a keyword and\n     * usage of spacing around the token is invalid.\n     * @param {ASTNode|null} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingAroundTokenBefore(node) {\n      if (node) {\n        const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n        checkSpacingAround(token);\n      }\n    }\n\n    /**\n     * Reports `async` or `function` keywords of a given node if usage of\n     * spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForFunction(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n      if (firstToken && (firstToken.type === \"Keyword\" && firstToken.value === \"function\" || firstToken.value === \"async\")) {\n        checkSpacingBefore(firstToken);\n      }\n    }\n\n    /**\n     * Reports `class` and `extends` keywords of a given node if usage of\n     * spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForClass(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.superClass);\n    }\n\n    /**\n     * Reports `if` and `else` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForIfStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.alternate);\n    }\n\n    /**\n     * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n     * of spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForTryStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundFirstToken(node.handler);\n      checkSpacingAroundTokenBefore(node.finalizer);\n    }\n\n    /**\n     * Reports `do` and `while` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForDoWhileStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.test);\n    }\n\n    /**\n     * Reports `for` and `in` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForForInStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      const inToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n      const previousToken = sourceCode.getTokenBefore(inToken);\n      if (previousToken.type !== \"PrivateIdentifier\") {\n        checkSpacingBefore(inToken);\n      }\n      checkSpacingAfter(inToken);\n    }\n\n    /**\n     * Reports `for` and `of` keywords of a given node if usage of spacing\n     * around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForForOfStatement(node) {\n      if (node.await) {\n        checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n        checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n      } else {\n        checkSpacingAroundFirstToken(node);\n      }\n      const ofToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n      const previousToken = sourceCode.getTokenBefore(ofToken);\n      if (previousToken.type !== \"PrivateIdentifier\") {\n        checkSpacingBefore(ofToken);\n      }\n      checkSpacingAfter(ofToken);\n    }\n\n    /**\n     * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n     * usage of spacing around those keywords is invalid.\n     *\n     * This rule handles the `*` token in module declarations.\n     *\n     *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n     *                               error Expected space(s) before \"as\".\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForModuleDeclaration(node) {\n      const firstToken = sourceCode.getFirstToken(node);\n      checkSpacingBefore(firstToken, PREV_TOKEN_M);\n      checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n      if (node.type === \"ExportDefaultDeclaration\") {\n        checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n      }\n      if (node.type === \"ExportAllDeclaration\" && node.exported) {\n        const asToken = sourceCode.getTokenBefore(node.exported);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n        checkSpacingAfter(asToken, NEXT_TOKEN_M);\n      }\n      if (node.source) {\n        const fromToken = sourceCode.getTokenBefore(node.source);\n        checkSpacingBefore(fromToken, PREV_TOKEN_M);\n        checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n      }\n    }\n\n    /**\n     * Reports `as` keyword of a given node if usage of spacing around this\n     * keyword is invalid.\n     * @param {ASTNode} node An `ImportSpecifier` node to check.\n     * @returns {void}\n     */\n    function checkSpacingForImportSpecifier(node) {\n      if (node.imported.range[0] !== node.local.range[0]) {\n        const asToken = sourceCode.getTokenBefore(node.local);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n      }\n    }\n\n    /**\n     * Reports `as` keyword of a given node if usage of spacing around this\n     * keyword is invalid.\n     * @param {ASTNode} node An `ExportSpecifier` node to check.\n     * @returns {void}\n     */\n    function checkSpacingForExportSpecifier(node) {\n      if (node.local.range[0] !== node.exported.range[0]) {\n        const asToken = sourceCode.getTokenBefore(node.exported);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n        checkSpacingAfter(asToken, NEXT_TOKEN_M);\n      }\n    }\n\n    /**\n     * Reports `as` keyword of a given node if usage of spacing around this\n     * keyword is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForImportNamespaceSpecifier(node) {\n      const asToken = sourceCode.getFirstToken(node, 1);\n      checkSpacingBefore(asToken, PREV_TOKEN_M);\n    }\n\n    /**\n     * Reports `static`, `get`, and `set` keywords of a given node if usage of\n     * spacing around those keywords is invalid.\n     * @param {ASTNode} node A node to report.\n     * @throws {Error} If unable to find token get, set, or async beside method name.\n     * @returns {void}\n     */\n    function checkSpacingForProperty(node) {\n      if (node.static) {\n        checkSpacingAroundFirstToken(node);\n      }\n      if (node.kind === \"get\" || node.kind === \"set\" || (node.method || node.type === \"MethodDefinition\") && node.value.async) {\n        const token = sourceCode.getTokenBefore(node.key, tok => {\n          switch (tok.value) {\n            case \"get\":\n            case \"set\":\n            case \"async\":\n              return true;\n            default:\n              return false;\n          }\n        });\n        if (!token) {\n          throw new Error(\"Failed to find token get, set, or async beside method name\");\n        }\n        checkSpacingAround(token);\n      }\n    }\n\n    /**\n     * Reports `await` keyword of a given node if usage of spacing before\n     * this keyword is invalid.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function checkSpacingForAwaitExpression(node) {\n      checkSpacingBefore(sourceCode.getFirstToken(node));\n    }\n    return {\n      // Statements\n      DebuggerStatement: checkSpacingAroundFirstToken,\n      WithStatement: checkSpacingAroundFirstToken,\n      // Statements - Control flow\n      BreakStatement: checkSpacingAroundFirstToken,\n      ContinueStatement: checkSpacingAroundFirstToken,\n      ReturnStatement: checkSpacingAroundFirstToken,\n      ThrowStatement: checkSpacingAroundFirstToken,\n      TryStatement: checkSpacingForTryStatement,\n      // Statements - Choice\n      IfStatement: checkSpacingForIfStatement,\n      SwitchStatement: checkSpacingAroundFirstToken,\n      SwitchCase: checkSpacingAroundFirstToken,\n      // Statements - Loops\n      DoWhileStatement: checkSpacingForDoWhileStatement,\n      ForInStatement: checkSpacingForForInStatement,\n      ForOfStatement: checkSpacingForForOfStatement,\n      ForStatement: checkSpacingAroundFirstToken,\n      WhileStatement: checkSpacingAroundFirstToken,\n      // Statements - Declarations\n      ClassDeclaration: checkSpacingForClass,\n      ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n      ExportAllDeclaration: checkSpacingForModuleDeclaration,\n      FunctionDeclaration: checkSpacingForFunction,\n      ImportDeclaration: checkSpacingForModuleDeclaration,\n      VariableDeclaration: checkSpacingAroundFirstToken,\n      // Expressions\n      ArrowFunctionExpression: checkSpacingForFunction,\n      AwaitExpression: checkSpacingForAwaitExpression,\n      ClassExpression: checkSpacingForClass,\n      FunctionExpression: checkSpacingForFunction,\n      NewExpression: checkSpacingBeforeFirstToken,\n      Super: checkSpacingBeforeFirstToken,\n      ThisExpression: checkSpacingBeforeFirstToken,\n      UnaryExpression: checkSpacingBeforeFirstToken,\n      YieldExpression: checkSpacingBeforeFirstToken,\n      // Others\n      ImportSpecifier: checkSpacingForImportSpecifier,\n      ExportSpecifier: checkSpacingForExportSpecifier,\n      ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n      MethodDefinition: checkSpacingForProperty,\n      PropertyDefinition: checkSpacingForProperty,\n      StaticBlock: checkSpacingAroundFirstToken,\n      Property: checkSpacingForProperty,\n      // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`\n      \"BinaryExpression[operator='>']\"(node) {\n        const operatorToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n        tokensToIgnore.add(operatorToken);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","keywords","PREV_TOKEN","NEXT_TOKEN","PREV_TOKEN_M","NEXT_TOKEN_M","TEMPLATE_OPEN_PAREN","TEMPLATE_CLOSE_PAREN","CHECK_TYPE","KEYS","concat","sort","i","length","Error","isOpenParenOfTemplate","token","type","test","value","isCloseParenOfTemplate","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","fixable","schema","properties","before","default","after","overrides","reduce","retv","key","additionalProperties","messages","expectedBefore","expectedAfter","unexpectedBefore","unexpectedAfter","create","context","sourceCode","tokensToIgnore","WeakSet","expectSpaceBefore","pattern","prevToken","getTokenBefore","has","isTokenOnSameLine","isSpaceBetweenTokens","report","loc","messageId","data","fix","fixer","insertTextBefore","unexpectSpaceBefore","start","end","removeRange","range","expectSpaceAfter","nextToken","getTokenAfter","insertTextAfter","unexpectSpaceAfter","parseOptions","options","defaultValue","Object","override","thisBefore","thisAfter","checkMethodMap","checkSpacingBefore","checkSpacingAfter","checkSpacingAround","checkSpacingAroundFirstToken","node","firstToken","getFirstToken","checkSpacingBeforeFirstToken","checkSpacingAroundTokenBefore","isKeywordToken","checkSpacingForFunction","checkSpacingForClass","superClass","checkSpacingForIfStatement","alternate","checkSpacingForTryStatement","handler","finalizer","checkSpacingForDoWhileStatement","checkSpacingForForInStatement","inToken","right","isNotOpeningParenToken","previousToken","checkSpacingForForOfStatement","await","ofToken","checkSpacingForModuleDeclaration","exported","asToken","source","fromToken","checkSpacingForImportSpecifier","imported","local","checkSpacingForExportSpecifier","checkSpacingForImportNamespaceSpecifier","checkSpacingForProperty","static","kind","method","async","tok","checkSpacingForAwaitExpression","DebuggerStatement","WithStatement","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","TryStatement","IfStatement","SwitchStatement","SwitchCase","DoWhileStatement","ForInStatement","ForOfStatement","ForStatement","WhileStatement","ClassDeclaration","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","FunctionDeclaration","ImportDeclaration","VariableDeclaration","ArrowFunctionExpression","AwaitExpression","ClassExpression","FunctionExpression","NewExpression","Super","ThisExpression","UnaryExpression","YieldExpression","ImportSpecifier","ExportSpecifier","ImportNamespaceSpecifier","MethodDefinition","PropertyDefinition","StaticBlock","Property","BinaryExpression[operator='>']","operatorToken","add"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/keyword-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (let i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent spacing before and after keywords\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/keyword-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: true },\n                    after: { type: \"boolean\", default: true },\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce((retv, key) => {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: { type: \"boolean\" },\n                                    after: { type: \"boolean\" }\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n            expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n            unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n            unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        const tokensToIgnore = new WeakSet();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                !tokensToIgnore.has(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc,\n                    messageId: \"expectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                !tokensToIgnore.has(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: { start: prevToken.loc.end, end: token.loc.start },\n                    messageId: \"unexpectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the next token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                !tokensToIgnore.has(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc,\n                    messageId: \"expectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the next token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                !tokensToIgnore.has(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n\n                context.report({\n                    loc: { start: token.loc.end, end: nextToken.loc.start },\n                    messageId: \"unexpectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         * @param {Object|undefined} options The option object to parse.\n         * @returns {Object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options = {}) {\n            const before = options.before !== false;\n            const after = options.after !== false;\n            const defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            const overrides = (options && options.overrides) || {};\n            const retv = Object.create(null);\n\n            for (let i = 0; i < KEYS.length; ++i) {\n                const key = KEYS[i];\n                const override = overrides[key];\n\n                if (override) {\n                    const thisBefore = (\"before\" in override) ? override.before : before;\n                    const thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        const checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         * @param {Token} token A token to report.\n         * @param {RegExp} [pattern] Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         * @param {Token} token A token to report.\n         * @param {RegExp} [pattern] Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         * @param {Token} token A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `async` or `function` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForFunction(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken &&\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\n                firstToken.value === \"async\")\n            ) {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n\n            const inToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n            const previousToken = sourceCode.getTokenBefore(inToken);\n\n            if (previousToken.type !== \"PrivateIdentifier\") {\n                checkSpacingBefore(inToken);\n            }\n\n            checkSpacingAfter(inToken);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            if (node.await) {\n                checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n                checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n            } else {\n                checkSpacingAroundFirstToken(node);\n            }\n\n            const ofToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n            const previousToken = sourceCode.getTokenBefore(ofToken);\n\n            if (previousToken.type !== \"PrivateIdentifier\") {\n                checkSpacingBefore(ofToken);\n            }\n\n            checkSpacingAfter(ofToken);\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.type === \"ExportDefaultDeclaration\") {\n                checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n            }\n\n            if (node.type === \"ExportAllDeclaration\" && node.exported) {\n                const asToken = sourceCode.getTokenBefore(node.exported);\n\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\n                checkSpacingAfter(asToken, NEXT_TOKEN_M);\n            }\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         * @param {ASTNode} node An `ImportSpecifier` node to check.\n         * @returns {void}\n         */\n        function checkSpacingForImportSpecifier(node) {\n            if (node.imported.range[0] !== node.local.range[0]) {\n                const asToken = sourceCode.getTokenBefore(node.local);\n\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         * @param {ASTNode} node An `ExportSpecifier` node to check.\n         * @returns {void}\n         */\n        function checkSpacingForExportSpecifier(node) {\n            if (node.local.range[0] !== node.exported.range[0]) {\n                const asToken = sourceCode.getTokenBefore(node.exported);\n\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\n                checkSpacingAfter(asToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            const asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @throws {Error} If unable to find token get, set, or async beside method name.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" ||\n                node.kind === \"set\" ||\n                (\n                    (node.method || node.type === \"MethodDefinition\") &&\n                    node.value.async\n                )\n            ) {\n                const token = sourceCode.getTokenBefore(\n                    node.key,\n                    tok => {\n                        switch (tok.value) {\n                            case \"get\":\n                            case \"set\":\n                            case \"async\":\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                );\n\n                if (!token) {\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\n                }\n\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `await` keyword of a given node if usage of spacing before\n         * this keyword is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForAwaitExpression(node) {\n            checkSpacingBefore(sourceCode.getFirstToken(node));\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingForFunction,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ArrowFunctionExpression: checkSpacingForFunction,\n            AwaitExpression: checkSpacingForAwaitExpression,\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingForFunction,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportSpecifier: checkSpacingForImportSpecifier,\n            ExportSpecifier: checkSpacingForExportSpecifier,\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            PropertyDefinition: checkSpacingForProperty,\n            StaticBlock: checkSpacingAroundFirstToken,\n            Property: checkSpacingForProperty,\n\n            // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`\n            \"BinaryExpression[operator='>']\"(node) {\n                const operatorToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n\n                tokensToIgnore.add(operatorToken);\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}