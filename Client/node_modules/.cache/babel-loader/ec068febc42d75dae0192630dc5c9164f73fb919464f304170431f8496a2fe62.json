{"ast":null,"code":"/**\n * @fileoverview Rule to replace assignment expressions with logical operator assignment\n * @author Daniel Martens\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst baseTypes = new Set([\"Identifier\", \"Super\", \"ThisExpression\"]);\n\n/**\n * Returns true iff either \"undefined\" or a void expression (eg. \"void 0\")\n * @param {ASTNode} expression Expression to check\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff \"undefined\" or \"void ...\"\n */\nfunction isUndefined(expression, scope) {\n  if (expression.type === \"Identifier\" && expression.name === \"undefined\") {\n    return astUtils.isReferenceToGlobalVariable(scope, expression);\n  }\n  return expression.type === \"UnaryExpression\" && expression.operator === \"void\" && expression.argument.type === \"Literal\" && expression.argument.value === 0;\n}\n\n/**\n * Returns true iff the reference is either an identifier or member expression\n * @param {ASTNode} expression Expression to check\n * @returns {boolean} True for identifiers and member expressions\n */\nfunction isReference(expression) {\n  return expression.type === \"Identifier\" && expression.name !== \"undefined\" || expression.type === \"MemberExpression\";\n}\n\n/**\n * Returns true iff the expression checks for nullish with loose equals.\n * Examples: value == null, value == void 0\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff implicit nullish comparison\n */\nfunction isImplicitNullishComparison(expression, scope) {\n  if (expression.type !== \"BinaryExpression\" || expression.operator !== \"==\") {\n    return false;\n  }\n  const reference = isReference(expression.left) ? \"left\" : \"right\";\n  const nullish = reference === \"left\" ? \"right\" : \"left\";\n  return isReference(expression[reference]) && (astUtils.isNullLiteral(expression[nullish]) || isUndefined(expression[nullish], scope));\n}\n\n/**\n * Condition with two equal comparisons.\n * @param {ASTNode} expression Condition\n * @returns {boolean} True iff matches ? === ? || ? === ?\n */\nfunction isDoubleComparison(expression) {\n  return expression.type === \"LogicalExpression\" && expression.operator === \"||\" && expression.left.type === \"BinaryExpression\" && expression.left.operator === \"===\" && expression.right.type === \"BinaryExpression\" && expression.right.operator === \"===\";\n}\n\n/**\n * Returns true iff the expression checks for undefined and null.\n * Example: value === null || value === undefined\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff explicit nullish comparison\n */\nfunction isExplicitNullishComparison(expression, scope) {\n  if (!isDoubleComparison(expression)) {\n    return false;\n  }\n  const leftReference = isReference(expression.left.left) ? \"left\" : \"right\";\n  const leftNullish = leftReference === \"left\" ? \"right\" : \"left\";\n  const rightReference = isReference(expression.right.left) ? \"left\" : \"right\";\n  const rightNullish = rightReference === \"left\" ? \"right\" : \"left\";\n  return astUtils.isSameReference(expression.left[leftReference], expression.right[rightReference]) && (astUtils.isNullLiteral(expression.left[leftNullish]) && isUndefined(expression.right[rightNullish], scope) || isUndefined(expression.left[leftNullish], scope) && astUtils.isNullLiteral(expression.right[rightNullish]));\n}\n\n/**\n * Returns true for Boolean(arg) calls\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} Whether the expression is a boolean cast\n */\nfunction isBooleanCast(expression, scope) {\n  return expression.type === \"CallExpression\" && expression.callee.name === \"Boolean\" && expression.arguments.length === 1 && astUtils.isReferenceToGlobalVariable(scope, expression.callee);\n}\n\n/**\n * Returns true for:\n * truthiness checks:  value, Boolean(value), !!value\n * falsiness checks:   !value, !Boolean(value)\n * nullish checks:     value == null, value === undefined || value === null\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {?{ reference: ASTNode, operator: '??'|'||'|'&&'}} Null if not a known existence\n */\nfunction getExistence(expression, scope) {\n  const isNegated = expression.type === \"UnaryExpression\" && expression.operator === \"!\";\n  const base = isNegated ? expression.argument : expression;\n  switch (true) {\n    case isReference(base):\n      return {\n        reference: base,\n        operator: isNegated ? \"||\" : \"&&\"\n      };\n    case base.type === \"UnaryExpression\" && base.operator === \"!\" && isReference(base.argument):\n      return {\n        reference: base.argument,\n        operator: \"&&\"\n      };\n    case isBooleanCast(base, scope) && isReference(base.arguments[0]):\n      return {\n        reference: base.arguments[0],\n        operator: isNegated ? \"||\" : \"&&\"\n      };\n    case isImplicitNullishComparison(expression, scope):\n      return {\n        reference: isReference(expression.left) ? expression.left : expression.right,\n        operator: \"??\"\n      };\n    case isExplicitNullishComparison(expression, scope):\n      return {\n        reference: isReference(expression.left.left) ? expression.left.left : expression.left.right,\n        operator: \"??\"\n      };\n    default:\n      return null;\n  }\n}\n\n/**\n * Returns true iff the node is inside a with block\n * @param {ASTNode} node Node to check\n * @returns {boolean} True iff passed node is inside a with block\n */\nfunction isInsideWithBlock(node) {\n  if (node.type === \"Program\") {\n    return false;\n  }\n  return node.parent.type === \"WithStatement\" && node.parent.body === node ? true : isInsideWithBlock(node.parent);\n}\n\n/**\n * Gets the leftmost operand of a consecutive logical expression.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {LogicalExpression} node LogicalExpression\n * @returns {Expression} Leftmost operand\n */\nfunction getLeftmostOperand(sourceCode, node) {\n  let left = node.left;\n  while (left.type === \"LogicalExpression\" && left.operator === node.operator) {\n    if (astUtils.isParenthesised(sourceCode, left)) {\n      /*\n       * It should have associativity,\n       * but ignore it if use parentheses to make the evaluation order clear.\n       */\n      return left;\n    }\n    left = left.left;\n  }\n  return left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require or disallow logical assignment operator shorthand\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/logical-assignment-operators\"\n    },\n    schema: {\n      type: \"array\",\n      oneOf: [{\n        items: [{\n          const: \"always\"\n        }, {\n          type: \"object\",\n          properties: {\n            enforceForIfStatements: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        // 0 for allowing passing no options\n        maxItems: 2\n      }, {\n        items: [{\n          const: \"never\"\n        }],\n        minItems: 1,\n        maxItems: 1\n      }]\n    },\n    fixable: \"code\",\n    hasSuggestions: true,\n    messages: {\n      assignment: \"Assignment (=) can be replaced with operator assignment ({{operator}}).\",\n      useLogicalOperator: \"Convert this assignment to use the operator {{ operator }}.\",\n      logical: \"Logical expression can be replaced with an assignment ({{ operator }}).\",\n      convertLogical: \"Replace this logical expression with an assignment with the operator {{ operator }}.\",\n      if: \"'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.\",\n      convertIf: \"Replace this 'if' statement with a logical assignment with operator {{ operator }}.\",\n      unexpected: \"Unexpected logical operator assignment ({{operator}}) shorthand.\",\n      separate: \"Separate the logical assignment into an assignment with a logical operator.\"\n    }\n  },\n  create(context) {\n    const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n    const checkIf = mode === \"always\" && context.options.length > 1 && context.options[1].enforceForIfStatements;\n    const sourceCode = context.sourceCode;\n    const isStrict = sourceCode.getScope(sourceCode.ast).isStrict;\n\n    /**\n     * Returns false if the access could be a getter\n     * @param {ASTNode} node Assignment expression\n     * @returns {boolean} True iff the fix is safe\n     */\n    function cannotBeGetter(node) {\n      return node.type === \"Identifier\" && (isStrict || !isInsideWithBlock(node));\n    }\n\n    /**\n     * Check whether only a single property is accessed\n     * @param {ASTNode} node reference\n     * @returns {boolean} True iff a single property is accessed\n     */\n    function accessesSingleProperty(node) {\n      if (!isStrict && isInsideWithBlock(node)) {\n        return node.type === \"Identifier\";\n      }\n      return node.type === \"MemberExpression\" && baseTypes.has(node.object.type) && (!node.computed || node.property.type !== \"MemberExpression\" && node.property.type !== \"ChainExpression\");\n    }\n\n    /**\n     * Adds a fixer or suggestion whether on the fix is safe.\n     * @param {{ messageId: string, node: ASTNode }} descriptor Report descriptor without fix or suggest\n     * @param {{ messageId: string, fix: Function }} suggestion Adds the fix or the whole suggestion as only element in \"suggest\" to suggestion\n     * @param {boolean} shouldBeFixed Fix iff the condition is true\n     * @returns {Object} Descriptor with either an added fix or suggestion\n     */\n    function createConditionalFixer(descriptor, suggestion, shouldBeFixed) {\n      if (shouldBeFixed) {\n        return {\n          ...descriptor,\n          fix: suggestion.fix\n        };\n      }\n      return {\n        ...descriptor,\n        suggest: [suggestion]\n      };\n    }\n\n    /**\n     * Returns the operator token for assignments and binary expressions\n     * @param {ASTNode} node AssignmentExpression or BinaryExpression\n     * @returns {import('eslint').AST.Token} Operator token between the left and right expression\n     */\n    function getOperatorToken(node) {\n      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n    }\n    if (mode === \"never\") {\n      return {\n        // foo ||= bar\n        \"AssignmentExpression\"(assignment) {\n          if (!astUtils.isLogicalAssignmentOperator(assignment.operator)) {\n            return;\n          }\n          const descriptor = {\n            messageId: \"unexpected\",\n            node: assignment,\n            data: {\n              operator: assignment.operator\n            }\n          };\n          const suggestion = {\n            messageId: \"separate\",\n            *fix(ruleFixer) {\n              if (sourceCode.getCommentsInside(assignment).length > 0) {\n                return;\n              }\n              const operatorToken = getOperatorToken(assignment);\n\n              // -> foo = bar\n              yield ruleFixer.replaceText(operatorToken, \"=\");\n              const assignmentText = sourceCode.getText(assignment.left);\n              const operator = assignment.operator.slice(0, -1);\n\n              // -> foo = foo || bar\n              yield ruleFixer.insertTextAfter(operatorToken, ` ${assignmentText} ${operator}`);\n              const precedence = astUtils.getPrecedence(assignment.right) <= astUtils.getPrecedence({\n                type: \"LogicalExpression\",\n                operator\n              });\n\n              // ?? and || / && cannot be mixed but have same precedence\n              const mixed = assignment.operator === \"??=\" && astUtils.isLogicalExpression(assignment.right);\n              if (!astUtils.isParenthesised(sourceCode, assignment.right) && (precedence || mixed)) {\n                // -> foo = foo || (bar)\n                yield ruleFixer.insertTextBefore(assignment.right, \"(\");\n                yield ruleFixer.insertTextAfter(assignment.right, \")\");\n              }\n            }\n          };\n          context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));\n        }\n      };\n    }\n    return {\n      // foo = foo || bar\n      \"AssignmentExpression[operator='='][right.type='LogicalExpression']\"(assignment) {\n        const leftOperand = getLeftmostOperand(sourceCode, assignment.right);\n        if (!astUtils.isSameReference(assignment.left, leftOperand)) {\n          return;\n        }\n        const descriptor = {\n          messageId: \"assignment\",\n          node: assignment,\n          data: {\n            operator: `${assignment.right.operator}=`\n          }\n        };\n        const suggestion = {\n          messageId: \"useLogicalOperator\",\n          data: {\n            operator: `${assignment.right.operator}=`\n          },\n          *fix(ruleFixer) {\n            if (sourceCode.getCommentsInside(assignment).length > 0) {\n              return;\n            }\n\n            // No need for parenthesis around the assignment based on precedence as the precedence stays the same even with changed operator\n            const assignmentOperatorToken = getOperatorToken(assignment);\n\n            // -> foo ||= foo || bar\n            yield ruleFixer.insertTextBefore(assignmentOperatorToken, assignment.right.operator);\n\n            // -> foo ||= bar\n            const logicalOperatorToken = getOperatorToken(leftOperand.parent);\n            const firstRightOperandToken = sourceCode.getTokenAfter(logicalOperatorToken);\n            yield ruleFixer.removeRange([leftOperand.parent.range[0], firstRightOperandToken.range[0]]);\n          }\n        };\n        context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));\n      },\n      // foo || (foo = bar)\n      'LogicalExpression[right.type=\"AssignmentExpression\"][right.operator=\"=\"]'(logical) {\n        // Right side has to be parenthesized, otherwise would be parsed as (foo || foo) = bar which is illegal\n        if (isReference(logical.left) && astUtils.isSameReference(logical.left, logical.right.left)) {\n          const descriptor = {\n            messageId: \"logical\",\n            node: logical,\n            data: {\n              operator: `${logical.operator}=`\n            }\n          };\n          const suggestion = {\n            messageId: \"convertLogical\",\n            data: {\n              operator: `${logical.operator}=`\n            },\n            *fix(ruleFixer) {\n              if (sourceCode.getCommentsInside(logical).length > 0) {\n                return;\n              }\n              const parentPrecedence = astUtils.getPrecedence(logical.parent);\n              const requiresOuterParenthesis = logical.parent.type !== \"ExpressionStatement\" && (parentPrecedence === -1 || astUtils.getPrecedence({\n                type: \"AssignmentExpression\"\n              }) < parentPrecedence);\n              if (!astUtils.isParenthesised(sourceCode, logical) && requiresOuterParenthesis) {\n                yield ruleFixer.insertTextBefore(logical, \"(\");\n                yield ruleFixer.insertTextAfter(logical, \")\");\n              }\n\n              // Also removes all opening parenthesis\n              yield ruleFixer.removeRange([logical.range[0], logical.right.range[0]]); // -> foo = bar)\n\n              // Also removes all ending parenthesis\n              yield ruleFixer.removeRange([logical.right.range[1], logical.range[1]]); // -> foo = bar\n\n              const operatorToken = getOperatorToken(logical.right);\n              yield ruleFixer.insertTextBefore(operatorToken, logical.operator); // -> foo ||= bar\n            }\n          };\n          const fix = cannotBeGetter(logical.left) || accessesSingleProperty(logical.left);\n          context.report(createConditionalFixer(descriptor, suggestion, fix));\n        }\n      },\n      // if (foo) foo = bar\n      \"IfStatement[alternate=null]\"(ifNode) {\n        if (!checkIf) {\n          return;\n        }\n        const hasBody = ifNode.consequent.type === \"BlockStatement\";\n        if (hasBody && ifNode.consequent.body.length !== 1) {\n          return;\n        }\n        const body = hasBody ? ifNode.consequent.body[0] : ifNode.consequent;\n        const scope = sourceCode.getScope(ifNode);\n        const existence = getExistence(ifNode.test, scope);\n        if (body.type === \"ExpressionStatement\" && body.expression.type === \"AssignmentExpression\" && body.expression.operator === \"=\" && existence !== null && astUtils.isSameReference(existence.reference, body.expression.left)) {\n          const descriptor = {\n            messageId: \"if\",\n            node: ifNode,\n            data: {\n              operator: `${existence.operator}=`\n            }\n          };\n          const suggestion = {\n            messageId: \"convertIf\",\n            data: {\n              operator: `${existence.operator}=`\n            },\n            *fix(ruleFixer) {\n              if (sourceCode.getCommentsInside(ifNode).length > 0) {\n                return;\n              }\n              const firstBodyToken = sourceCode.getFirstToken(body);\n              const prevToken = sourceCode.getTokenBefore(ifNode);\n              if (prevToken !== null && prevToken.value !== \";\" && prevToken.value !== \"{\" && firstBodyToken.type !== \"Identifier\" && firstBodyToken.type !== \"Keyword\") {\n                // Do not fix if the fixed statement could be part of the previous statement (eg. fn() if (a == null) (a) = b --> fn()(a) ??= b)\n                return;\n              }\n              const operatorToken = getOperatorToken(body.expression);\n              yield ruleFixer.insertTextBefore(operatorToken, existence.operator); // -> if (foo) foo ||= bar\n\n              yield ruleFixer.removeRange([ifNode.range[0], body.range[0]]); // -> foo ||= bar\n\n              yield ruleFixer.removeRange([body.range[1], ifNode.range[1]]); // -> foo ||= bar, only present if \"if\" had a body\n\n              const nextToken = sourceCode.getTokenAfter(body.expression);\n              if (hasBody && nextToken !== null && nextToken.value !== \";\") {\n                yield ruleFixer.insertTextAfter(ifNode, \";\");\n              }\n            }\n          };\n          const shouldBeFixed = cannotBeGetter(existence.reference) || ifNode.test.type !== \"LogicalExpression\" && accessesSingleProperty(existence.reference);\n          context.report(createConditionalFixer(descriptor, suggestion, shouldBeFixed));\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","baseTypes","Set","isUndefined","expression","scope","type","name","isReferenceToGlobalVariable","operator","argument","value","isReference","isImplicitNullishComparison","reference","left","nullish","isNullLiteral","isDoubleComparison","right","isExplicitNullishComparison","leftReference","leftNullish","rightReference","rightNullish","isSameReference","isBooleanCast","callee","arguments","length","getExistence","isNegated","base","isInsideWithBlock","node","parent","body","getLeftmostOperand","sourceCode","isParenthesised","module","exports","meta","docs","description","recommended","url","schema","oneOf","items","const","properties","enforceForIfStatements","additionalProperties","minItems","maxItems","fixable","hasSuggestions","messages","assignment","useLogicalOperator","logical","convertLogical","if","convertIf","unexpected","separate","create","context","mode","options","checkIf","isStrict","getScope","ast","cannotBeGetter","accessesSingleProperty","has","object","computed","property","createConditionalFixer","descriptor","suggestion","shouldBeFixed","fix","suggest","getOperatorToken","getFirstTokenBetween","token","AssignmentExpression","isLogicalAssignmentOperator","messageId","data","ruleFixer","getCommentsInside","operatorToken","replaceText","assignmentText","getText","slice","insertTextAfter","precedence","getPrecedence","mixed","isLogicalExpression","insertTextBefore","report","AssignmentExpression[operator='='][right.type='LogicalExpression']","leftOperand","assignmentOperatorToken","logicalOperatorToken","firstRightOperandToken","getTokenAfter","removeRange","range","LogicalExpression[right.type=\"AssignmentExpression\"][right.operator=\"=\"]","parentPrecedence","requiresOuterParenthesis","IfStatement[alternate=null]","ifNode","hasBody","consequent","existence","test","firstBodyToken","getFirstToken","prevToken","getTokenBefore","nextToken"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/logical-assignment-operators.js"],"sourcesContent":["/**\n * @fileoverview Rule to replace assignment expressions with logical operator assignment\n * @author Daniel Martens\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst baseTypes = new Set([\"Identifier\", \"Super\", \"ThisExpression\"]);\n\n/**\n * Returns true iff either \"undefined\" or a void expression (eg. \"void 0\")\n * @param {ASTNode} expression Expression to check\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff \"undefined\" or \"void ...\"\n */\nfunction isUndefined(expression, scope) {\n    if (expression.type === \"Identifier\" && expression.name === \"undefined\") {\n        return astUtils.isReferenceToGlobalVariable(scope, expression);\n    }\n\n    return expression.type === \"UnaryExpression\" &&\n           expression.operator === \"void\" &&\n           expression.argument.type === \"Literal\" &&\n           expression.argument.value === 0;\n}\n\n/**\n * Returns true iff the reference is either an identifier or member expression\n * @param {ASTNode} expression Expression to check\n * @returns {boolean} True for identifiers and member expressions\n */\nfunction isReference(expression) {\n    return (expression.type === \"Identifier\" && expression.name !== \"undefined\") ||\n           expression.type === \"MemberExpression\";\n}\n\n/**\n * Returns true iff the expression checks for nullish with loose equals.\n * Examples: value == null, value == void 0\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff implicit nullish comparison\n */\nfunction isImplicitNullishComparison(expression, scope) {\n    if (expression.type !== \"BinaryExpression\" || expression.operator !== \"==\") {\n        return false;\n    }\n\n    const reference = isReference(expression.left) ? \"left\" : \"right\";\n    const nullish = reference === \"left\" ? \"right\" : \"left\";\n\n    return isReference(expression[reference]) &&\n           (astUtils.isNullLiteral(expression[nullish]) || isUndefined(expression[nullish], scope));\n}\n\n/**\n * Condition with two equal comparisons.\n * @param {ASTNode} expression Condition\n * @returns {boolean} True iff matches ? === ? || ? === ?\n */\nfunction isDoubleComparison(expression) {\n    return expression.type === \"LogicalExpression\" &&\n           expression.operator === \"||\" &&\n           expression.left.type === \"BinaryExpression\" &&\n           expression.left.operator === \"===\" &&\n           expression.right.type === \"BinaryExpression\" &&\n           expression.right.operator === \"===\";\n}\n\n/**\n * Returns true iff the expression checks for undefined and null.\n * Example: value === null || value === undefined\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff explicit nullish comparison\n */\nfunction isExplicitNullishComparison(expression, scope) {\n    if (!isDoubleComparison(expression)) {\n        return false;\n    }\n    const leftReference = isReference(expression.left.left) ? \"left\" : \"right\";\n    const leftNullish = leftReference === \"left\" ? \"right\" : \"left\";\n    const rightReference = isReference(expression.right.left) ? \"left\" : \"right\";\n    const rightNullish = rightReference === \"left\" ? \"right\" : \"left\";\n\n    return astUtils.isSameReference(expression.left[leftReference], expression.right[rightReference]) &&\n           ((astUtils.isNullLiteral(expression.left[leftNullish]) && isUndefined(expression.right[rightNullish], scope)) ||\n           (isUndefined(expression.left[leftNullish], scope) && astUtils.isNullLiteral(expression.right[rightNullish])));\n}\n\n/**\n * Returns true for Boolean(arg) calls\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} Whether the expression is a boolean cast\n */\nfunction isBooleanCast(expression, scope) {\n    return expression.type === \"CallExpression\" &&\n           expression.callee.name === \"Boolean\" &&\n           expression.arguments.length === 1 &&\n           astUtils.isReferenceToGlobalVariable(scope, expression.callee);\n}\n\n/**\n * Returns true for:\n * truthiness checks:  value, Boolean(value), !!value\n * falsiness checks:   !value, !Boolean(value)\n * nullish checks:     value == null, value === undefined || value === null\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {?{ reference: ASTNode, operator: '??'|'||'|'&&'}} Null if not a known existence\n */\nfunction getExistence(expression, scope) {\n    const isNegated = expression.type === \"UnaryExpression\" && expression.operator === \"!\";\n    const base = isNegated ? expression.argument : expression;\n\n    switch (true) {\n        case isReference(base):\n            return { reference: base, operator: isNegated ? \"||\" : \"&&\" };\n        case base.type === \"UnaryExpression\" && base.operator === \"!\" && isReference(base.argument):\n            return { reference: base.argument, operator: \"&&\" };\n        case isBooleanCast(base, scope) && isReference(base.arguments[0]):\n            return { reference: base.arguments[0], operator: isNegated ? \"||\" : \"&&\" };\n        case isImplicitNullishComparison(expression, scope):\n            return { reference: isReference(expression.left) ? expression.left : expression.right, operator: \"??\" };\n        case isExplicitNullishComparison(expression, scope):\n            return { reference: isReference(expression.left.left) ? expression.left.left : expression.left.right, operator: \"??\" };\n        default: return null;\n    }\n}\n\n/**\n * Returns true iff the node is inside a with block\n * @param {ASTNode} node Node to check\n * @returns {boolean} True iff passed node is inside a with block\n */\nfunction isInsideWithBlock(node) {\n    if (node.type === \"Program\") {\n        return false;\n    }\n\n    return node.parent.type === \"WithStatement\" && node.parent.body === node ? true : isInsideWithBlock(node.parent);\n}\n\n/**\n * Gets the leftmost operand of a consecutive logical expression.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {LogicalExpression} node LogicalExpression\n * @returns {Expression} Leftmost operand\n */\nfunction getLeftmostOperand(sourceCode, node) {\n    let left = node.left;\n\n    while (left.type === \"LogicalExpression\" && left.operator === node.operator) {\n\n        if (astUtils.isParenthesised(sourceCode, left)) {\n\n            /*\n             * It should have associativity,\n             * but ignore it if use parentheses to make the evaluation order clear.\n             */\n            return left;\n        }\n        left = left.left;\n    }\n    return left;\n\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require or disallow logical assignment operator shorthand\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/logical-assignment-operators\"\n        },\n\n        schema: {\n            type: \"array\",\n            oneOf: [{\n                items: [\n                    { const: \"always\" },\n                    {\n                        type: \"object\",\n                        properties: {\n                            enforceForIfStatements: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ],\n                minItems: 0, // 0 for allowing passing no options\n                maxItems: 2\n            }, {\n                items: [{ const: \"never\" }],\n                minItems: 1,\n                maxItems: 1\n            }]\n        },\n        fixable: \"code\",\n        hasSuggestions: true,\n        messages: {\n            assignment: \"Assignment (=) can be replaced with operator assignment ({{operator}}).\",\n            useLogicalOperator: \"Convert this assignment to use the operator {{ operator }}.\",\n            logical: \"Logical expression can be replaced with an assignment ({{ operator }}).\",\n            convertLogical: \"Replace this logical expression with an assignment with the operator {{ operator }}.\",\n            if: \"'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.\",\n            convertIf: \"Replace this 'if' statement with a logical assignment with operator {{ operator }}.\",\n            unexpected: \"Unexpected logical operator assignment ({{operator}}) shorthand.\",\n            separate: \"Separate the logical assignment into an assignment with a logical operator.\"\n        }\n    },\n\n    create(context) {\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n        const checkIf = mode === \"always\" && context.options.length > 1 && context.options[1].enforceForIfStatements;\n        const sourceCode = context.sourceCode;\n        const isStrict = sourceCode.getScope(sourceCode.ast).isStrict;\n\n        /**\n         * Returns false if the access could be a getter\n         * @param {ASTNode} node Assignment expression\n         * @returns {boolean} True iff the fix is safe\n         */\n        function cannotBeGetter(node) {\n            return node.type === \"Identifier\" &&\n                   (isStrict || !isInsideWithBlock(node));\n        }\n\n        /**\n         * Check whether only a single property is accessed\n         * @param {ASTNode} node reference\n         * @returns {boolean} True iff a single property is accessed\n         */\n        function accessesSingleProperty(node) {\n            if (!isStrict && isInsideWithBlock(node)) {\n                return node.type === \"Identifier\";\n            }\n\n            return node.type === \"MemberExpression\" &&\n                   baseTypes.has(node.object.type) &&\n                   (!node.computed || (node.property.type !== \"MemberExpression\" && node.property.type !== \"ChainExpression\"));\n        }\n\n        /**\n         * Adds a fixer or suggestion whether on the fix is safe.\n         * @param {{ messageId: string, node: ASTNode }} descriptor Report descriptor without fix or suggest\n         * @param {{ messageId: string, fix: Function }} suggestion Adds the fix or the whole suggestion as only element in \"suggest\" to suggestion\n         * @param {boolean} shouldBeFixed Fix iff the condition is true\n         * @returns {Object} Descriptor with either an added fix or suggestion\n         */\n        function createConditionalFixer(descriptor, suggestion, shouldBeFixed) {\n            if (shouldBeFixed) {\n                return {\n                    ...descriptor,\n                    fix: suggestion.fix\n                };\n            }\n\n            return {\n                ...descriptor,\n                suggest: [suggestion]\n            };\n        }\n\n\n        /**\n         * Returns the operator token for assignments and binary expressions\n         * @param {ASTNode} node AssignmentExpression or BinaryExpression\n         * @returns {import('eslint').AST.Token} Operator token between the left and right expression\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        if (mode === \"never\") {\n            return {\n\n                // foo ||= bar\n                \"AssignmentExpression\"(assignment) {\n                    if (!astUtils.isLogicalAssignmentOperator(assignment.operator)) {\n                        return;\n                    }\n\n                    const descriptor = {\n                        messageId: \"unexpected\",\n                        node: assignment,\n                        data: { operator: assignment.operator }\n                    };\n                    const suggestion = {\n                        messageId: \"separate\",\n                        *fix(ruleFixer) {\n                            if (sourceCode.getCommentsInside(assignment).length > 0) {\n                                return;\n                            }\n\n                            const operatorToken = getOperatorToken(assignment);\n\n                            // -> foo = bar\n                            yield ruleFixer.replaceText(operatorToken, \"=\");\n\n                            const assignmentText = sourceCode.getText(assignment.left);\n                            const operator = assignment.operator.slice(0, -1);\n\n                            // -> foo = foo || bar\n                            yield ruleFixer.insertTextAfter(operatorToken, ` ${assignmentText} ${operator}`);\n\n                            const precedence = astUtils.getPrecedence(assignment.right) <= astUtils.getPrecedence({ type: \"LogicalExpression\", operator });\n\n                            // ?? and || / && cannot be mixed but have same precedence\n                            const mixed = assignment.operator === \"??=\" && astUtils.isLogicalExpression(assignment.right);\n\n                            if (!astUtils.isParenthesised(sourceCode, assignment.right) && (precedence || mixed)) {\n\n                                // -> foo = foo || (bar)\n                                yield ruleFixer.insertTextBefore(assignment.right, \"(\");\n                                yield ruleFixer.insertTextAfter(assignment.right, \")\");\n                            }\n                        }\n                    };\n\n                    context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));\n                }\n            };\n        }\n\n        return {\n\n            // foo = foo || bar\n            \"AssignmentExpression[operator='='][right.type='LogicalExpression']\"(assignment) {\n                const leftOperand = getLeftmostOperand(sourceCode, assignment.right);\n\n                if (!astUtils.isSameReference(assignment.left, leftOperand)\n                ) {\n                    return;\n                }\n\n                const descriptor = {\n                    messageId: \"assignment\",\n                    node: assignment,\n                    data: { operator: `${assignment.right.operator}=` }\n                };\n                const suggestion = {\n                    messageId: \"useLogicalOperator\",\n                    data: { operator: `${assignment.right.operator}=` },\n                    *fix(ruleFixer) {\n                        if (sourceCode.getCommentsInside(assignment).length > 0) {\n                            return;\n                        }\n\n                        // No need for parenthesis around the assignment based on precedence as the precedence stays the same even with changed operator\n                        const assignmentOperatorToken = getOperatorToken(assignment);\n\n                        // -> foo ||= foo || bar\n                        yield ruleFixer.insertTextBefore(assignmentOperatorToken, assignment.right.operator);\n\n                        // -> foo ||= bar\n                        const logicalOperatorToken = getOperatorToken(leftOperand.parent);\n                        const firstRightOperandToken = sourceCode.getTokenAfter(logicalOperatorToken);\n\n                        yield ruleFixer.removeRange([leftOperand.parent.range[0], firstRightOperandToken.range[0]]);\n                    }\n                };\n\n                context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));\n            },\n\n            // foo || (foo = bar)\n            'LogicalExpression[right.type=\"AssignmentExpression\"][right.operator=\"=\"]'(logical) {\n\n                // Right side has to be parenthesized, otherwise would be parsed as (foo || foo) = bar which is illegal\n                if (isReference(logical.left) && astUtils.isSameReference(logical.left, logical.right.left)) {\n                    const descriptor = {\n                        messageId: \"logical\",\n                        node: logical,\n                        data: { operator: `${logical.operator}=` }\n                    };\n                    const suggestion = {\n                        messageId: \"convertLogical\",\n                        data: { operator: `${logical.operator}=` },\n                        *fix(ruleFixer) {\n                            if (sourceCode.getCommentsInside(logical).length > 0) {\n                                return;\n                            }\n\n                            const parentPrecedence = astUtils.getPrecedence(logical.parent);\n                            const requiresOuterParenthesis = logical.parent.type !== \"ExpressionStatement\" && (\n                                parentPrecedence === -1 ||\n                                astUtils.getPrecedence({ type: \"AssignmentExpression\" }) < parentPrecedence\n                            );\n\n                            if (!astUtils.isParenthesised(sourceCode, logical) && requiresOuterParenthesis) {\n                                yield ruleFixer.insertTextBefore(logical, \"(\");\n                                yield ruleFixer.insertTextAfter(logical, \")\");\n                            }\n\n                            // Also removes all opening parenthesis\n                            yield ruleFixer.removeRange([logical.range[0], logical.right.range[0]]); // -> foo = bar)\n\n                            // Also removes all ending parenthesis\n                            yield ruleFixer.removeRange([logical.right.range[1], logical.range[1]]); // -> foo = bar\n\n                            const operatorToken = getOperatorToken(logical.right);\n\n                            yield ruleFixer.insertTextBefore(operatorToken, logical.operator); // -> foo ||= bar\n                        }\n                    };\n                    const fix = cannotBeGetter(logical.left) || accessesSingleProperty(logical.left);\n\n                    context.report(createConditionalFixer(descriptor, suggestion, fix));\n                }\n            },\n\n            // if (foo) foo = bar\n            \"IfStatement[alternate=null]\"(ifNode) {\n                if (!checkIf) {\n                    return;\n                }\n\n                const hasBody = ifNode.consequent.type === \"BlockStatement\";\n\n                if (hasBody && ifNode.consequent.body.length !== 1) {\n                    return;\n                }\n\n                const body = hasBody ? ifNode.consequent.body[0] : ifNode.consequent;\n                const scope = sourceCode.getScope(ifNode);\n                const existence = getExistence(ifNode.test, scope);\n\n                if (\n                    body.type === \"ExpressionStatement\" &&\n                    body.expression.type === \"AssignmentExpression\" &&\n                    body.expression.operator === \"=\" &&\n                    existence !== null &&\n                    astUtils.isSameReference(existence.reference, body.expression.left)\n                ) {\n                    const descriptor = {\n                        messageId: \"if\",\n                        node: ifNode,\n                        data: { operator: `${existence.operator}=` }\n                    };\n                    const suggestion = {\n                        messageId: \"convertIf\",\n                        data: { operator: `${existence.operator}=` },\n                        *fix(ruleFixer) {\n                            if (sourceCode.getCommentsInside(ifNode).length > 0) {\n                                return;\n                            }\n\n                            const firstBodyToken = sourceCode.getFirstToken(body);\n                            const prevToken = sourceCode.getTokenBefore(ifNode);\n\n                            if (\n                                prevToken !== null &&\n                                prevToken.value !== \";\" &&\n                                prevToken.value !== \"{\" &&\n                                firstBodyToken.type !== \"Identifier\" &&\n                                firstBodyToken.type !== \"Keyword\"\n                            ) {\n\n                                // Do not fix if the fixed statement could be part of the previous statement (eg. fn() if (a == null) (a) = b --> fn()(a) ??= b)\n                                return;\n                            }\n\n\n                            const operatorToken = getOperatorToken(body.expression);\n\n                            yield ruleFixer.insertTextBefore(operatorToken, existence.operator); // -> if (foo) foo ||= bar\n\n                            yield ruleFixer.removeRange([ifNode.range[0], body.range[0]]); // -> foo ||= bar\n\n                            yield ruleFixer.removeRange([body.range[1], ifNode.range[1]]); // -> foo ||= bar, only present if \"if\" had a body\n\n                            const nextToken = sourceCode.getTokenAfter(body.expression);\n\n                            if (hasBody && (nextToken !== null && nextToken.value !== \";\")) {\n                                yield ruleFixer.insertTextAfter(ifNode, \";\");\n                            }\n                        }\n                    };\n                    const shouldBeFixed = cannotBeGetter(existence.reference) ||\n                                          (ifNode.test.type !== \"LogicalExpression\" && accessesSingleProperty(existence.reference));\n\n                    context.report(createConditionalFixer(descriptor, suggestion, shouldBeFixed));\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}