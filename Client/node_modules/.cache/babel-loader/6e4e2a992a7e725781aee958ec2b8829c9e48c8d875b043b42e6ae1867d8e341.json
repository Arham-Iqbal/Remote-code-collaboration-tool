{"ast":null,"code":"/**\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({\n  type: \"BinaryExpression\",\n  operator: \"**\"\n});\n\n/**\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\n * @param {ASTNode} base The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesBaseNeedParens(base) {\n  return (\n    // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n    astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\n    // An unary operator cannot be used immediately before an exponentiation expression\n    base.type === \"AwaitExpression\" || base.type === \"UnaryExpression\"\n  );\n}\n\n/**\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\n * @param {ASTNode} exponent The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesExponentNeedParens(exponent) {\n  // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n  return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\n/**\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\n * @param {SourceCode} sourceCode A SourceCode object.\n * @returns {boolean} `true` if the expression needs to be parenthesised.\n */\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n  const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n  const parentPrecedence = astUtils.getPrecedence(parent);\n  const needsParens = parent.type === \"ClassDeclaration\" || parent.type.endsWith(\"Expression\") && (parentPrecedence === -1 || parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) && !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) && !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) && !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) && !(parent.type === \"ArrayExpression\");\n  return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Optionally parenthesizes given text.\n * @param {string} text The text to parenthesize.\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\n * @returns {string} parenthesised or unchanged text.\n */\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n  return shouldParenthesize ? `(${text})` : text;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow the use of `Math.pow` in favor of the `**` operator\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/prefer-exponentiation-operator\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Reports the given node.\n     * @param {ASTNode} node 'Math.pow()' node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"useExponentiation\",\n        fix(fixer) {\n          if (node.arguments.length !== 2 || node.arguments.some(arg => arg.type === \"SpreadElement\") || sourceCode.getCommentsInside(node).length > 0) {\n            return null;\n          }\n          const base = node.arguments[0],\n            exponent = node.arguments[1],\n            baseText = sourceCode.getText(base),\n            exponentText = sourceCode.getText(exponent),\n            shouldParenthesizeBase = doesBaseNeedParens(base),\n            shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n            shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n          let prefix = \"\",\n            suffix = \"\";\n          if (!shouldParenthesizeAll) {\n            if (!shouldParenthesizeBase) {\n              const firstReplacementToken = sourceCode.getFirstToken(base),\n                tokenBefore = sourceCode.getTokenBefore(node);\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n              }\n            }\n            if (!shouldParenthesizeExponent) {\n              const lastReplacementToken = sourceCode.getLastToken(exponent),\n                tokenAfter = sourceCode.getTokenAfter(node);\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {\n                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n              }\n            }\n          }\n          const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n            exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n            replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n          return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n        }\n      });\n    }\n    return {\n      Program(node) {\n        const scope = sourceCode.getScope(node);\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Math: {\n            pow: {\n              [CALL]: true\n            }\n          }\n        };\n        for (const {\n          node: refNode\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          report(refNode);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","CALL","ReferenceTracker","PRECEDENCE_OF_EXPONENTIATION_EXPR","getPrecedence","type","operator","doesBaseNeedParens","base","doesExponentNeedParens","exponent","doesExponentiationExpressionNeedParens","node","sourceCode","parent","parentPrecedence","needsParens","endsWith","right","arguments","includes","computed","property","isParenthesised","parenthesizeIfShould","text","shouldParenthesize","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","useExponentiation","create","context","report","messageId","fix","fixer","length","some","arg","getCommentsInside","baseText","getText","exponentText","shouldParenthesizeBase","shouldParenthesizeExponent","shouldParenthesizeAll","prefix","suffix","firstReplacementToken","getFirstToken","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","lastReplacementToken","getLastToken","tokenAfter","getTokenAfter","baseReplacement","exponentReplacement","replacement","replaceText","Program","scope","getScope","tracker","trackMap","Math","pow","refNode","iterateGlobalReferences"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/prefer-exponentiation-operator.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, ReferenceTracker } = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({ type: \"BinaryExpression\", operator: \"**\" });\n\n/**\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\n * @param {ASTNode} base The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesBaseNeedParens(base) {\n    return (\n\n        // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n        astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\n\n        // An unary operator cannot be used immediately before an exponentiation expression\n        base.type === \"AwaitExpression\" ||\n        base.type === \"UnaryExpression\"\n    );\n}\n\n/**\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\n * @param {ASTNode} exponent The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesExponentNeedParens(exponent) {\n\n    // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n    return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\n/**\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\n * @param {SourceCode} sourceCode A SourceCode object.\n * @returns {boolean} `true` if the expression needs to be parenthesised.\n */\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n    const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n\n    const parentPrecedence = astUtils.getPrecedence(parent);\n    const needsParens = (\n        parent.type === \"ClassDeclaration\" ||\n        (\n            parent.type.endsWith(\"Expression\") &&\n            (parentPrecedence === -1 || parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) &&\n            !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) &&\n            !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) &&\n            !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) &&\n            !(parent.type === \"ArrayExpression\")\n        )\n    );\n\n    return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Optionally parenthesizes given text.\n * @param {string} text The text to parenthesize.\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\n * @returns {string} parenthesised or unchanged text.\n */\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n    return shouldParenthesize ? `(${text})` : text;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow the use of `Math.pow` in favor of the `**` operator\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-exponentiation-operator\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node 'Math.pow()' node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"useExponentiation\",\n                fix(fixer) {\n                    if (\n                        node.arguments.length !== 2 ||\n                        node.arguments.some(arg => arg.type === \"SpreadElement\") ||\n                        sourceCode.getCommentsInside(node).length > 0\n                    ) {\n                        return null;\n                    }\n\n                    const base = node.arguments[0],\n                        exponent = node.arguments[1],\n                        baseText = sourceCode.getText(base),\n                        exponentText = sourceCode.getText(exponent),\n                        shouldParenthesizeBase = doesBaseNeedParens(base),\n                        shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n                        shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n\n                    let prefix = \"\",\n                        suffix = \"\";\n\n                    if (!shouldParenthesizeAll) {\n                        if (!shouldParenthesizeBase) {\n                            const firstReplacementToken = sourceCode.getFirstToken(base),\n                                tokenBefore = sourceCode.getTokenBefore(node);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n                            }\n                        }\n                        if (!shouldParenthesizeExponent) {\n                            const lastReplacementToken = sourceCode.getLastToken(exponent),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)\n                            ) {\n                                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n                            }\n                        }\n                    }\n\n                    const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n                        exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n                        replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n\n                    return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                }\n            });\n        }\n\n        return {\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Math: {\n                        pow: { [CALL]: true }\n                    }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {\n                    report(refNode);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}