{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of console object\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow the use of `console`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-console\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    hasSuggestions: true,\n    messages: {\n      unexpected: \"Unexpected console statement.\",\n      removeConsole: \"Remove the console.{{ propertyName }}().\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const allowed = options.allow || [];\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Checks whether the given reference is 'console' or not.\n     * @param {eslint-scope.Reference} reference The reference to check.\n     * @returns {boolean} `true` if the reference is 'console'.\n     */\n    function isConsole(reference) {\n      const id = reference.identifier;\n      return id && id.name === \"console\";\n    }\n\n    /**\n     * Checks whether the property name of the given MemberExpression node\n     * is allowed by options or not.\n     * @param {ASTNode} node The MemberExpression node to check.\n     * @returns {boolean} `true` if the property name of the node is allowed.\n     */\n    function isAllowed(node) {\n      const propertyName = astUtils.getStaticPropertyName(node);\n      return propertyName && allowed.includes(propertyName);\n    }\n\n    /**\n     * Checks whether the given reference is a member access which is not\n     * allowed by options or not.\n     * @param {eslint-scope.Reference} reference The reference to check.\n     * @returns {boolean} `true` if the reference is a member access which\n     *      is not allowed by options.\n     */\n    function isMemberAccessExceptAllowed(reference) {\n      const node = reference.identifier;\n      const parent = node.parent;\n      return parent.type === \"MemberExpression\" && parent.object === node && !isAllowed(parent);\n    }\n\n    /**\n     * Checks if removing the ExpressionStatement node will cause ASI to\n     * break.\n     * eg.\n     * foo()\n     * console.log();\n     * [1, 2, 3].forEach(a => doSomething(a))\n     *\n     * Removing the console.log(); statement should leave two statements, but\n     * here the two statements will become one because [ causes continuation after\n     * foo().\n     * @param {ASTNode} node The ExpressionStatement node to check.\n     * @returns {boolean} `true` if ASI will break after removing the ExpressionStatement\n     *      node.\n     */\n    function maybeAsiHazard(node) {\n      const SAFE_TOKENS_BEFORE = /^[:;{]$/u; // One of :;{\n      const UNSAFE_CHARS_AFTER = /^[-[(/+`]/u; // One of [(/+-`\n\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      return Boolean(tokenAfter) && UNSAFE_CHARS_AFTER.test(tokenAfter.value) && tokenAfter.value !== \"++\" && tokenAfter.value !== \"--\" && Boolean(tokenBefore) && !SAFE_TOKENS_BEFORE.test(tokenBefore.value);\n    }\n\n    /**\n     * Checks if the MemberExpression node's parent.parent.parent is a\n     * Program, BlockStatement, StaticBlock, or SwitchCase node. This check\n     * is necessary to avoid providing a suggestion that might cause a syntax error.\n     *\n     * eg. if (a) console.log(b), removing console.log() here will lead to a\n     *     syntax error.\n     *     if (a) { console.log(b) }, removing console.log() here is acceptable.\n     *\n     * Additionally, it checks if the callee of the CallExpression node is\n     * the node itself.\n     *\n     * eg. foo(console.log), cannot provide a suggestion here.\n     * @param {ASTNode} node The MemberExpression node to check.\n     * @returns {boolean} `true` if a suggestion can be provided for a node.\n     */\n    function canProvideSuggestions(node) {\n      return node.parent.type === \"CallExpression\" && node.parent.callee === node && node.parent.parent.type === \"ExpressionStatement\" && astUtils.STATEMENT_LIST_PARENTS.has(node.parent.parent.parent.type) && !maybeAsiHazard(node.parent.parent);\n    }\n\n    /**\n     * Reports the given reference as a violation.\n     * @param {eslint-scope.Reference} reference The reference to report.\n     * @returns {void}\n     */\n    function report(reference) {\n      const node = reference.identifier.parent;\n      const propertyName = astUtils.getStaticPropertyName(node);\n      context.report({\n        node,\n        loc: node.loc,\n        messageId: \"unexpected\",\n        suggest: canProvideSuggestions(node) ? [{\n          messageId: \"removeConsole\",\n          data: {\n            propertyName\n          },\n          fix(fixer) {\n            return fixer.remove(node.parent.parent);\n          }\n        }] : []\n      });\n    }\n    return {\n      \"Program:exit\"(node) {\n        const scope = sourceCode.getScope(node);\n        const consoleVar = astUtils.getVariableByName(scope, \"console\");\n        const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n        /*\n         * 'scope.through' includes all references to undefined\n         * variables. If the variable 'console' is not defined, it uses\n         * 'scope.through'.\n         */\n        const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);\n        if (!shadowed) {\n          references.filter(isMemberAccessExceptAllowed).forEach(report);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","allow","items","minItems","uniqueItems","additionalProperties","hasSuggestions","messages","unexpected","removeConsole","create","context","options","allowed","sourceCode","isConsole","reference","id","identifier","name","isAllowed","node","propertyName","getStaticPropertyName","includes","isMemberAccessExceptAllowed","parent","object","maybeAsiHazard","SAFE_TOKENS_BEFORE","UNSAFE_CHARS_AFTER","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","Boolean","test","value","canProvideSuggestions","callee","STATEMENT_LIST_PARENTS","has","report","loc","messageId","suggest","data","fix","fixer","remove","Program:exit","scope","getScope","consoleVar","getVariableByName","shadowed","defs","length","references","through","filter","forEach"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-console.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of console object\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow the use of `console`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-console\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        hasSuggestions: true,\n\n        messages: {\n            unexpected: \"Unexpected console statement.\",\n            removeConsole: \"Remove the console.{{ propertyName }}().\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks whether the given reference is 'console' or not.\n         * @param {eslint-scope.Reference} reference The reference to check.\n         * @returns {boolean} `true` if the reference is 'console'.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id && id.name === \"console\";\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName && allowed.includes(propertyName);\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         * @param {eslint-scope.Reference} reference The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Checks if removing the ExpressionStatement node will cause ASI to\n         * break.\n         * eg.\n         * foo()\n         * console.log();\n         * [1, 2, 3].forEach(a => doSomething(a))\n         *\n         * Removing the console.log(); statement should leave two statements, but\n         * here the two statements will become one because [ causes continuation after\n         * foo().\n         * @param {ASTNode} node The ExpressionStatement node to check.\n         * @returns {boolean} `true` if ASI will break after removing the ExpressionStatement\n         *      node.\n         */\n        function maybeAsiHazard(node) {\n            const SAFE_TOKENS_BEFORE = /^[:;{]$/u; // One of :;{\n            const UNSAFE_CHARS_AFTER = /^[-[(/+`]/u; // One of [(/+-`\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n\n            return (\n                Boolean(tokenAfter) &&\n                UNSAFE_CHARS_AFTER.test(tokenAfter.value) &&\n                tokenAfter.value !== \"++\" &&\n                tokenAfter.value !== \"--\" &&\n                Boolean(tokenBefore) &&\n                !SAFE_TOKENS_BEFORE.test(tokenBefore.value)\n            );\n        }\n\n        /**\n         * Checks if the MemberExpression node's parent.parent.parent is a\n         * Program, BlockStatement, StaticBlock, or SwitchCase node. This check\n         * is necessary to avoid providing a suggestion that might cause a syntax error.\n         *\n         * eg. if (a) console.log(b), removing console.log() here will lead to a\n         *     syntax error.\n         *     if (a) { console.log(b) }, removing console.log() here is acceptable.\n         *\n         * Additionally, it checks if the callee of the CallExpression node is\n         * the node itself.\n         *\n         * eg. foo(console.log), cannot provide a suggestion here.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} `true` if a suggestion can be provided for a node.\n         */\n        function canProvideSuggestions(node) {\n            return (\n                node.parent.type === \"CallExpression\" &&\n                node.parent.callee === node &&\n                node.parent.parent.type === \"ExpressionStatement\" &&\n                astUtils.STATEMENT_LIST_PARENTS.has(node.parent.parent.parent.type) &&\n                !maybeAsiHazard(node.parent.parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         * @param {eslint-scope.Reference} reference The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            context.report({\n                node,\n                loc: node.loc,\n                messageId: \"unexpected\",\n                suggest: canProvideSuggestions(node)\n                    ? [{\n                        messageId: \"removeConsole\",\n                        data: { propertyName },\n                        fix(fixer) {\n                            return fixer.remove(node.parent.parent);\n                        }\n                    }]\n                    : []\n            });\n        }\n\n        return {\n            \"Program:exit\"(node) {\n                const scope = sourceCode.getScope(node);\n                const consoleVar = astUtils.getVariableByName(scope, \"console\");\n                const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n                /*\n                 * 'scope.through' includes all references to undefined\n                 * variables. If the variable 'console' is not defined, it uses\n                 * 'scope.through'.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}