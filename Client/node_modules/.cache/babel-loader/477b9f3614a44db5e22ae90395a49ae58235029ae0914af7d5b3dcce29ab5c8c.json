{"ast":null,"code":"/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  getGraphemeCount\n} = require(\"../shared/string-utils\");\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n  return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n  return node.loc.end.line === node.loc.start.line;\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n  const [firstProp] = properties,\n    lastProp = last(properties);\n  return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n  toOptions.mode = fromOptions.mode || \"strict\";\n\n  // Set value of beforeColon\n  if (typeof fromOptions.beforeColon !== \"undefined\") {\n    toOptions.beforeColon = +fromOptions.beforeColon;\n  } else {\n    toOptions.beforeColon = 0;\n  }\n\n  // Set value of afterColon\n  if (typeof fromOptions.afterColon !== \"undefined\") {\n    toOptions.afterColon = +fromOptions.afterColon;\n  } else {\n    toOptions.afterColon = 1;\n  }\n\n  // Set align if exists\n  if (typeof fromOptions.align !== \"undefined\") {\n    if (typeof fromOptions.align === \"object\") {\n      toOptions.align = fromOptions.align;\n    } else {\n      // \"string\"\n      toOptions.align = {\n        on: fromOptions.align,\n        mode: toOptions.mode,\n        beforeColon: toOptions.beforeColon,\n        afterColon: toOptions.afterColon\n      };\n    }\n  }\n  return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n  if (typeof fromOptions.align === \"object\") {\n    // Initialize the alignment configuration\n    toOptions.align = initOptionProperty({}, fromOptions.align);\n    toOptions.align.on = fromOptions.align.on || \"colon\";\n    toOptions.align.mode = fromOptions.align.mode || \"strict\";\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n  } else {\n    // string or undefined\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n\n    // If alignment options are defined in multiLine, pull them out into the general align configuration\n    if (toOptions.multiLine.align) {\n      toOptions.align = {\n        on: toOptions.multiLine.align.on,\n        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n        beforeColon: toOptions.multiLine.align.beforeColon,\n        afterColon: toOptions.multiLine.align.afterColon\n      };\n    }\n  }\n  return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent spacing between keys and values in object literal properties\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/key-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          align: {\n            anyOf: [{\n              enum: [\"colon\", \"value\"]\n            }, {\n              type: \"object\",\n              properties: {\n                mode: {\n                  enum: [\"strict\", \"minimum\"]\n                },\n                on: {\n                  enum: [\"colon\", \"value\"]\n                },\n                beforeColon: {\n                  type: \"boolean\"\n                },\n                afterColon: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            }]\n          },\n          mode: {\n            enum: [\"strict\", \"minimum\"]\n          },\n          beforeColon: {\n            type: \"boolean\"\n          },\n          afterColon: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              align: {\n                anyOf: [{\n                  enum: [\"colon\", \"value\"]\n                }, {\n                  type: \"object\",\n                  properties: {\n                    mode: {\n                      enum: [\"strict\", \"minimum\"]\n                    },\n                    on: {\n                      enum: [\"colon\", \"value\"]\n                    },\n                    beforeColon: {\n                      type: \"boolean\"\n                    },\n                    afterColon: {\n                      type: \"boolean\"\n                    }\n                  },\n                  additionalProperties: false\n                }]\n              },\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          align: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              on: {\n                enum: [\"colon\", \"value\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n      extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n      missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n      missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n    }\n  },\n  create(context) {\n    /**\n     * OPTIONS\n     * \"key-spacing\": [2, {\n     *     beforeColon: false,\n     *     afterColon: true,\n     *     align: \"colon\" // Optional, or \"value\"\n     * }\n     */\n    const options = context.options[0] || {},\n      ruleOptions = initOptions({}, options),\n      multiLineOptions = ruleOptions.multiLine,\n      singleLineOptions = ruleOptions.singleLine,\n      alignmentOptions = ruleOptions.align || null;\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Determines if the given property is key-value property.\n     * @param {ASTNode} property Property node to check.\n     * @returns {boolean} Whether the property is a key-value property.\n     */\n    function isKeyValueProperty(property) {\n      return !(property.method || property.shorthand || property.kind !== \"init\" || property.type !== \"Property\" // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n      );\n    }\n\n    /**\n     * Starting from the given node (a property.key node here) looks forward\n     * until it finds the colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The colon punctuator.\n     */\n    function getNextColon(node) {\n      return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n    }\n\n    /**\n     * Starting from the given node (a property.key node here) looks forward\n     * until it finds the last token before a colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The last token before a colon punctuator.\n     */\n    function getLastTokenBeforeColon(node) {\n      const colonToken = getNextColon(node);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n\n    /**\n     * Starting from the given node (a property.key node here) looks forward\n     * until it finds the first token after a colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The first token after a colon punctuator.\n     */\n    function getFirstTokenAfterColon(node) {\n      const colonToken = getNextColon(node);\n      return sourceCode.getTokenAfter(colonToken);\n    }\n\n    /**\n     * Checks whether a property is a member of the property group it follows.\n     * @param {ASTNode} lastMember The last Property known to be in the group.\n     * @param {ASTNode} candidate The next Property that might be in the group.\n     * @returns {boolean} True if the candidate property is part of the group.\n     */\n    function continuesPropertyGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line,\n        candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;\n      if (candidateValueStartLine - groupEndLine <= 1) {\n        return true;\n      }\n\n      /*\n       * Check that the first comment is adjacent to the end of the group, the\n       * last comment is adjacent to the candidate property, and that successive\n       * comments are adjacent to each other.\n       */\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateValueStartLine - last(leadingComments).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Gets an object literal property's key as the identifier name or string value.\n     * @param {ASTNode} property Property node whose key to retrieve.\n     * @returns {string} The property's key.\n     */\n    function getKey(property) {\n      const key = property.key;\n      if (property.computed) {\n        return sourceCode.getText().slice(key.range[0], key.range[1]);\n      }\n      return astUtils.getStaticPropertyName(property);\n    }\n\n    /**\n     * Reports an appropriately-formatted error if spacing is incorrect on one\n     * side of the colon.\n     * @param {ASTNode} property Key-value pair in an object literal.\n     * @param {string} side Side being verified - either \"key\" or \"value\".\n     * @param {string} whitespace Actual whitespace string.\n     * @param {int} expected Expected whitespace length.\n     * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n     * @returns {void}\n     */\n    function report(property, side, whitespace, expected, mode) {\n      const diff = whitespace.length - expected;\n      if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\" || diff > 0 && !expected && mode === \"minimum\") && !(expected && containsLineTerminator(whitespace))) {\n        const nextColon = getNextColon(property.key),\n          tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {\n            includeComments: true\n          }),\n          tokenAfterColon = sourceCode.getTokenAfter(nextColon, {\n            includeComments: true\n          }),\n          isKeySide = side === \"key\",\n          isExtra = diff > 0,\n          diffAbs = Math.abs(diff),\n          spaces = Array(diffAbs + 1).join(\" \");\n        const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n        const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n        const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n        const loc = isExtra ? {\n          start: locStart,\n          end: locEnd\n        } : missingLoc;\n        let fix;\n        if (isExtra) {\n          let range;\n\n          // Remove whitespace\n          if (isKeySide) {\n            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n          } else {\n            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n          }\n          fix = function (fixer) {\n            return fixer.removeRange(range);\n          };\n        } else {\n          // Add whitespace\n          if (isKeySide) {\n            fix = function (fixer) {\n              return fixer.insertTextAfter(tokenBeforeColon, spaces);\n            };\n          } else {\n            fix = function (fixer) {\n              return fixer.insertTextBefore(tokenAfterColon, spaces);\n            };\n          }\n        }\n        let messageId = \"\";\n        if (isExtra) {\n          messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n        } else {\n          messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n        }\n        context.report({\n          node: property[side],\n          loc,\n          messageId,\n          data: {\n            computed: property.computed ? \"computed \" : \"\",\n            key: getKey(property)\n          },\n          fix\n        });\n      }\n    }\n\n    /**\n     * Gets the number of characters in a key, including quotes around string\n     * keys and braces around computed property keys.\n     * @param {ASTNode} property Property of on object literal.\n     * @returns {int} Width of the key.\n     */\n    function getKeyWidth(property) {\n      const startToken = sourceCode.getFirstToken(property);\n      const endToken = getLastTokenBeforeColon(property.key);\n      return getGraphemeCount(sourceCode.getText().slice(startToken.range[0], endToken.range[1]));\n    }\n\n    /**\n     * Gets the whitespace around the colon in an object literal property.\n     * @param {ASTNode} property Property node from an object literal.\n     * @returns {Object} Whitespace before and after the property's colon.\n     */\n    function getPropertyWhitespace(property) {\n      const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));\n      if (whitespace) {\n        return {\n          beforeColon: whitespace[1],\n          afterColon: whitespace[2]\n        };\n      }\n      return null;\n    }\n\n    /**\n     * Creates groups of properties.\n     * @param {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {Array<ASTNode[]>} Groups of property AST node lists.\n     */\n    function createGroups(node) {\n      if (node.properties.length === 1) {\n        return [node.properties];\n      }\n      return node.properties.reduce((groups, property) => {\n        const currentGroup = last(groups),\n          prev = last(currentGroup);\n        if (!prev || continuesPropertyGroup(prev, property)) {\n          currentGroup.push(property);\n        } else {\n          groups.push([property]);\n        }\n        return groups;\n      }, [[]]);\n    }\n\n    /**\n     * Verifies correct vertical alignment of a group of properties.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @returns {void}\n     */\n    function verifyGroupAlignment(properties) {\n      const length = properties.length,\n        widths = properties.map(getKeyWidth),\n        // Width of keys, including quotes\n        align = alignmentOptions.on; // \"value\" or \"colon\"\n      let targetWidth = Math.max(...widths),\n        beforeColon,\n        afterColon,\n        mode;\n      if (alignmentOptions && length > 1) {\n        // When aligning values within a group, use the alignment configuration.\n        beforeColon = alignmentOptions.beforeColon;\n        afterColon = alignmentOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } else {\n        beforeColon = multiLineOptions.beforeColon;\n        afterColon = multiLineOptions.afterColon;\n        mode = alignmentOptions.mode;\n      }\n\n      // Conditionally include one space before or after colon\n      targetWidth += align === \"colon\" ? beforeColon : afterColon;\n      for (let i = 0; i < length; i++) {\n        const property = properties[i];\n        const whitespace = getPropertyWhitespace(property);\n        if (whitespace) {\n          // Object literal getters/setters lack a colon\n          const width = widths[i];\n          if (align === \"value\") {\n            report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n            report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n          } else {\n            // align = \"colon\"\n            report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n            report(property, \"value\", whitespace.afterColon, afterColon, mode);\n          }\n        }\n      }\n    }\n\n    /**\n     * Verifies spacing of property conforms to specified options.\n     * @param {ASTNode} node Property node being evaluated.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n    function verifySpacing(node, lineOptions) {\n      const actual = getPropertyWhitespace(node);\n      if (actual) {\n        // Object literal getters/setters lack colons\n        report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n        report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n      }\n    }\n\n    /**\n     * Verifies spacing of each property in a list.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n    function verifyListSpacing(properties, lineOptions) {\n      const length = properties.length;\n      for (let i = 0; i < length; i++) {\n        verifySpacing(properties[i], lineOptions);\n      }\n    }\n\n    /**\n     * Verifies vertical alignment, taking into account groups of properties.\n     * @param {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {void}\n     */\n    function verifyAlignment(node) {\n      createGroups(node).forEach(group => {\n        const properties = group.filter(isKeyValueProperty);\n        if (properties.length > 0 && isSingleLineProperties(properties)) {\n          verifyListSpacing(properties, multiLineOptions);\n        } else {\n          verifyGroupAlignment(properties);\n        }\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    if (alignmentOptions) {\n      // Verify vertical alignment\n\n      return {\n        ObjectExpression(node) {\n          if (isSingleLine(node)) {\n            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n          } else {\n            verifyAlignment(node);\n          }\n        }\n      };\n    }\n\n    // Obey beforeColon and afterColon in each property as configured\n    return {\n      Property(node) {\n        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","getGraphemeCount","containsLineTerminator","str","LINEBREAK_MATCHER","test","last","arr","length","isSingleLine","node","loc","end","line","start","isSingleLineProperties","properties","firstProp","lastProp","initOptionProperty","toOptions","fromOptions","mode","beforeColon","afterColon","align","on","initOptions","multiLine","singleLine","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","fixable","schema","anyOf","enum","additionalProperties","messages","extraKey","extraValue","missingKey","missingValue","create","context","options","ruleOptions","multiLineOptions","singleLineOptions","alignmentOptions","sourceCode","isKeyValueProperty","property","method","shorthand","kind","getNextColon","getTokenAfter","isColonToken","getLastTokenBeforeColon","colonToken","getTokenBefore","getFirstTokenAfterColon","continuesPropertyGroup","lastMember","candidate","groupEndLine","candidateValueStartLine","key","leadingComments","getCommentsBefore","i","getKey","computed","getText","slice","range","getStaticPropertyName","report","side","whitespace","expected","diff","nextColon","tokenBeforeColon","includeComments","tokenAfterColon","isKeySide","isExtra","diffAbs","Math","abs","spaces","Array","join","locStart","locEnd","missingLoc","fix","fixer","removeRange","insertTextAfter","insertTextBefore","messageId","data","getKeyWidth","startToken","getFirstToken","endToken","getPropertyWhitespace","exec","value","createGroups","reduce","groups","currentGroup","prev","push","verifyGroupAlignment","widths","map","targetWidth","max","width","verifySpacing","lineOptions","actual","verifyListSpacing","verifyAlignment","forEach","group","filter","ObjectExpression","Property","parent"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/key-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { getGraphemeCount } = require(\"../shared/string-utils\");\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n    const [firstProp] = properties,\n        lastProp = last(properties);\n\n    return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent spacing between keys and values in object literal properties\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/key-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        messages: {\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Starting from the given node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Starting from the given node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = getNextColon(node);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given node (a property.key node here) looks forward\n         * until it finds the first token after a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The first token after a colon punctuator.\n         */\n        function getFirstTokenAfterColon(node) {\n            const colonToken = getNextColon(node);\n\n            return sourceCode.getTokenAfter(colonToken);\n        }\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;\n\n            if (candidateValueStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateValueStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n            return astUtils.getStaticPropertyName(property);\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected;\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                const nextColon = getNextColon(property.key),\n                    tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                    tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                    isKeySide = side === \"key\",\n                    isExtra = diff > 0,\n                    diffAbs = Math.abs(diff),\n                    spaces = Array(diffAbs + 1).join(\" \");\n\n                const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n                const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n                const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n                const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;\n\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                let messageId = \"\";\n\n                if (isExtra) {\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n                } else {\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n                }\n\n                context.report({\n                    node: property[side],\n                    loc,\n                    messageId,\n                    data: {\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return getGraphemeCount(sourceCode.getText().slice(startToken.range[0], endToken.range[1]));\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max(...widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifyListSpacing(properties, lineOptions) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], lineOptions);\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                const properties = group.filter(isKeyValueProperty);\n\n                if (properties.length > 0 && isSingleLineProperties(properties)) {\n                    verifyListSpacing(properties, multiLineOptions);\n                } else {\n                    verifyGroupAlignment(properties);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}