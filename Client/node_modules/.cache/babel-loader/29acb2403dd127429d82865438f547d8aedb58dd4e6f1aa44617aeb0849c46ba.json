{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Types of class members.\n * Those have `test` method to check it matches to the given class member.\n * @private\n */\nconst ClassMemberTypes = {\n  \"*\": {\n    test: () => true\n  },\n  field: {\n    test: node => node.type === \"PropertyDefinition\"\n  },\n  method: {\n    test: node => node.type === \"MethodDefinition\"\n  }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Require or disallow an empty line between class members\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          enforce: {\n            type: \"array\",\n            items: {\n              type: \"object\",\n              properties: {\n                blankLine: {\n                  enum: [\"always\", \"never\"]\n                },\n                prev: {\n                  enum: [\"method\", \"field\", \"*\"]\n                },\n                next: {\n                  enum: [\"method\", \"field\", \"*\"]\n                }\n              },\n              additionalProperties: false,\n              required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            minItems: 1\n          }\n        },\n        additionalProperties: false,\n        required: [\"enforce\"]\n      }, {\n        enum: [\"always\", \"never\"]\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const configureList = typeof options[0] === \"object\" ? options[0].enforce : [{\n      blankLine: options[0],\n      prev: \"*\",\n      next: \"*\"\n    }];\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Gets a pair of tokens that should be used to check lines between two class member nodes.\n     *\n     * In most cases, this returns the very last token of the current node and\n     * the very first token of the next node.\n     * For example:\n     *\n     *     class C {\n     *         x = 1;   // curLast: `;` nextFirst: `in`\n     *         in = 2\n     *     }\n     *\n     * There is only one exception. If the given node ends with a semicolon, and it looks like\n     * a semicolon-less style's semicolon - one that is not on the same line as the preceding\n     * token, but is on the line where the next class member starts - this returns the preceding\n     * token and the semicolon as boundary tokens.\n     * For example:\n     *\n     *     class C {\n     *         x = 1    // curLast: `1` nextFirst: `;`\n     *         ;in = 2\n     *     }\n     * When determining the desired layout of the code, we should treat this semicolon as\n     * a part of the next class member node instead of the one it technically belongs to.\n     * @param {ASTNode} curNode Current class member node.\n     * @param {ASTNode} nextNode Next class member node.\n     * @returns {Token} The actual last token of `node`.\n     * @private\n     */\n    function getBoundaryTokens(curNode, nextNode) {\n      const lastToken = sourceCode.getLastToken(curNode);\n      const prevToken = sourceCode.getTokenBefore(lastToken);\n      const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\n\n      const isSemicolonLessStyle = astUtils.isSemicolonToken(lastToken) && !astUtils.isTokenOnSameLine(prevToken, lastToken) && astUtils.isTokenOnSameLine(lastToken, nextToken);\n      return isSemicolonLessStyle ? {\n        curLast: prevToken,\n        nextFirst: lastToken\n      } : {\n        curLast: lastToken,\n        nextFirst: nextToken\n      };\n    }\n\n    /**\n     * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The last token among the consecutive tokens.\n     */\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n      return prevLastToken;\n    }\n\n    /**\n     * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The first token among the consecutive tokens.\n     */\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n      return nextFirstToken;\n    }\n\n    /**\n     * Checks if there is a token or comment between two tokens.\n     * @param {Token} before The token before.\n     * @param {Token} after The token after.\n     * @returns {boolean} True if there is a token or comment between two tokens.\n     */\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n\n    /**\n     * Checks whether the given node matches the given type.\n     * @param {ASTNode} node The class member node to check.\n     * @param {string} type The class member type to check.\n     * @returns {boolean} `true` if the class member node matched the type.\n     * @private\n     */\n    function match(node, type) {\n      return ClassMemberTypes[type].test(node);\n    }\n\n    /**\n     * Finds the last matched configuration from the configureList.\n     * @param {ASTNode} prevNode The previous node to match.\n     * @param {ASTNode} nextNode The current node to match.\n     * @returns {string|null} Padding type or `null` if no matches were found.\n     * @private\n     */\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n        if (matched) {\n          return configure.blankLine;\n        }\n      }\n      return null;\n    }\n    return {\n      ClassBody(node) {\n        const body = node.body;\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const {\n            curLast,\n            nextFirst\n          } = getBoundaryTokens(body[i], body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n          const paddingType = getPaddingType(body[i], body[i + 1]);\n          if (paddingType === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: \"never\",\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n                return fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\");\n              }\n            });\n          } else if (paddingType === \"always\" && !skip && !isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: \"always\",\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n                return fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","ClassMemberTypes","test","field","node","type","method","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","fixable","schema","anyOf","properties","enforce","items","blankLine","enum","prev","next","additionalProperties","required","minItems","exceptAfterSingleLine","default","messages","never","always","create","context","options","configureList","sourceCode","getBoundaryTokens","curNode","nextNode","lastToken","getLastToken","prevToken","getTokenBefore","nextToken","getFirstToken","isSemicolonLessStyle","isSemicolonToken","isTokenOnSameLine","curLast","nextFirst","findLastConsecutiveTokenAfter","prevLastToken","nextFirstToken","maxLine","after","getTokenAfter","includeComments","loc","start","line","end","findFirstConsecutiveTokenBefore","before","hasTokenOrCommentBetween","getTokensBetween","length","match","getPaddingType","prevNode","i","configure","matched","ClassBody","body","curFirst","isMulti","skip","beforePadding","afterPadding","isPadded","hasTokenInPadding","curLineLastToken","paddingType","report","messageId","fix","fixer","replaceTextRange","range","insertTextAfter"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/lines-between-class-members.js"],"sourcesContent":["/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Types of class members.\n * Those have `test` method to check it matches to the given class member.\n * @private\n */\nconst ClassMemberTypes = {\n    \"*\": { test: () => true },\n    field: { test: node => node.type === \"PropertyDefinition\" },\n    method: { test: node => node.type === \"MethodDefinition\" }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow an empty line between class members\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                anyOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            enforce: {\n                                type: \"array\",\n                                items: {\n                                    type: \"object\",\n                                    properties: {\n                                        blankLine: { enum: [\"always\", \"never\"] },\n                                        prev: { enum: [\"method\", \"field\", \"*\"] },\n                                        next: { enum: [\"method\", \"field\", \"*\"] }\n                                    },\n                                    additionalProperties: false,\n                                    required: [\"blankLine\", \"prev\", \"next\"]\n                                },\n                                minItems: 1\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"enforce\"]\n                    },\n                    {\n                        enum: [\"always\", \"never\"]\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const configureList = typeof options[0] === \"object\" ? options[0].enforce : [{ blankLine: options[0], prev: \"*\", next: \"*\" }];\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Gets a pair of tokens that should be used to check lines between two class member nodes.\n         *\n         * In most cases, this returns the very last token of the current node and\n         * the very first token of the next node.\n         * For example:\n         *\n         *     class C {\n         *         x = 1;   // curLast: `;` nextFirst: `in`\n         *         in = 2\n         *     }\n         *\n         * There is only one exception. If the given node ends with a semicolon, and it looks like\n         * a semicolon-less style's semicolon - one that is not on the same line as the preceding\n         * token, but is on the line where the next class member starts - this returns the preceding\n         * token and the semicolon as boundary tokens.\n         * For example:\n         *\n         *     class C {\n         *         x = 1    // curLast: `1` nextFirst: `;`\n         *         ;in = 2\n         *     }\n         * When determining the desired layout of the code, we should treat this semicolon as\n         * a part of the next class member node instead of the one it technically belongs to.\n         * @param {ASTNode} curNode Current class member node.\n         * @param {ASTNode} nextNode Next class member node.\n         * @returns {Token} The actual last token of `node`.\n         * @private\n         */\n        function getBoundaryTokens(curNode, nextNode) {\n            const lastToken = sourceCode.getLastToken(curNode);\n            const prevToken = sourceCode.getTokenBefore(lastToken);\n            const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\n\n            const isSemicolonLessStyle = (\n                astUtils.isSemicolonToken(lastToken) &&\n                !astUtils.isTokenOnSameLine(prevToken, lastToken) &&\n                astUtils.isTokenOnSameLine(lastToken, nextToken)\n            );\n\n            return isSemicolonLessStyle\n                ? { curLast: prevToken, nextFirst: lastToken }\n                : { curLast: lastToken, nextFirst: nextToken };\n        }\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The class member node to check.\n         * @param {string} type The class member type to check.\n         * @returns {boolean} `true` if the class member node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            return ClassMemberTypes[type].test(node);\n        }\n\n        /**\n         * Finds the last matched configuration from the configureList.\n         * @param {ASTNode} prevNode The previous node to match.\n         * @param {ASTNode} nextNode The current node to match.\n         * @returns {string|null} Padding type or `null` if no matches were found.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return configure.blankLine;\n                }\n            }\n            return null;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const { curLast, nextFirst } = getBoundaryTokens(body[i], body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n                    const paddingType = getPaddingType(body[i], body[i + 1]);\n\n                    if (paddingType === \"never\" && isPadded) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: \"never\",\n\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\");\n                            }\n                        });\n                    } else if (paddingType === \"always\" && !skip && !isPadded) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: \"always\",\n\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}