{"ast":null,"code":"/**\n * @fileoverview Helper functions for ESLint class\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fsp = fs.promises;\nconst isGlob = require(\"is-glob\");\nconst hash = require(\"../cli-engine/hash\");\nconst minimatch = require(\"minimatch\");\nconst fswalk = require(\"@nodelib/fs.walk\");\nconst globParent = require(\"glob-parent\");\nconst isPathInside = require(\"is-path-inside\");\n\n//-----------------------------------------------------------------------------\n// Fixup references\n//-----------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst MINIMATCH_OPTIONS = {\n  dot: true\n};\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} GlobSearch\n * @property {Array<string>} patterns The normalized patterns to use for a search.\n * @property {Array<string>} rawPatterns The patterns as entered by the user\n *      before doing any normalization.\n */\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   * @param {boolean} globEnabled If `false` then the pattern was a glob pattern, but glob was disabled.\n   */\n  constructor(pattern, globEnabled) {\n    super(`No files matching '${pattern}' were found${!globEnabled ? \" (glob was disabled)\" : \"\"}.`);\n    this.messageTemplate = \"file-not-found\";\n    this.messageData = {\n      pattern,\n      globDisabled: !globEnabled\n    };\n  }\n}\n\n/**\n * The error type when a search fails to match multiple patterns.\n */\nclass UnmatchedSearchPatternsError extends Error {\n  /**\n   * @param {Object} options The options for the error.\n   * @param {string} options.basePath The directory that was searched.\n   * @param {Array<string>} options.unmatchedPatterns The glob patterns\n   *      which were not found.\n   * @param {Array<string>} options.patterns The glob patterns that were\n   *      searched.\n   * @param {Array<string>} options.rawPatterns The raw glob patterns that\n   *      were searched.\n   */\n  constructor({\n    basePath,\n    unmatchedPatterns,\n    patterns,\n    rawPatterns\n  }) {\n    super(`No files matching '${rawPatterns}' in '${basePath}' were found.`);\n    this.basePath = basePath;\n    this.unmatchedPatterns = unmatchedPatterns;\n    this.patterns = patterns;\n    this.rawPatterns = rawPatterns;\n  }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   */\n  constructor(pattern) {\n    super(`All files matched by '${pattern}' are ignored.`);\n    this.messageTemplate = \"all-files-ignored\";\n    this.messageData = {\n      pattern\n    };\n  }\n}\n\n//-----------------------------------------------------------------------------\n// General Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\nfunction isNonEmptyString(x) {\n  return typeof x === \"string\" && x.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty strings or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty strings.\n */\nfunction isArrayOfNonEmptyString(x) {\n  return Array.isArray(x) && x.every(isNonEmptyString);\n}\n\n//-----------------------------------------------------------------------------\n// File-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes slashes in a file pattern to posix-style.\n * @param {string} pattern The pattern to replace slashes in.\n * @returns {string} The pattern with slashes normalized.\n */\nfunction normalizeToPosix(pattern) {\n  return pattern.replace(/\\\\/gu, \"/\");\n}\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n  return isGlob(path.sep === \"\\\\\" ? normalizeToPosix(pattern) : pattern);\n}\n\n/**\n * Determines if a given glob pattern will return any results.\n * Used primarily to help with useful error messages.\n * @param {Object} options The options for the function.\n * @param {string} options.basePath The directory to search.\n * @param {string} options.pattern A glob pattern to match.\n * @returns {Promise<boolean>} True if there is a glob match, false if not.\n */\nfunction globMatch({\n  basePath,\n  pattern\n}) {\n  let found = false;\n  const patternToUse = path.isAbsolute(pattern) ? normalizeToPosix(path.relative(basePath, pattern)) : pattern;\n  const matcher = new Minimatch(patternToUse, MINIMATCH_OPTIONS);\n  const fsWalkSettings = {\n    deepFilter(entry) {\n      const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n      return !found && matcher.match(relativePath, true);\n    },\n    entryFilter(entry) {\n      if (found || entry.dirent.isDirectory()) {\n        return false;\n      }\n      const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n      if (matcher.match(relativePath)) {\n        found = true;\n        return true;\n      }\n      return false;\n    }\n  };\n  return new Promise(resolve => {\n    // using a stream so we can exit early because we just need one match\n    const globStream = fswalk.walkStream(basePath, fsWalkSettings);\n    globStream.on(\"data\", () => {\n      globStream.destroy();\n      resolve(true);\n    });\n\n    // swallow errors as they're not important here\n    globStream.on(\"error\", () => {});\n    globStream.on(\"end\", () => {\n      resolve(false);\n    });\n    globStream.read();\n  });\n}\n\n/**\n * Searches a directory looking for matching glob patterns. This uses\n * the config array's logic to determine if a directory or file should\n * be ignored, so it is consistent with how ignoring works throughout\n * ESLint.\n * @param {Object} options The options for this function.\n * @param {string} options.basePath The directory to search.\n * @param {Array<string>} options.patterns An array of glob patterns\n *      to match.\n * @param {Array<string>} options.rawPatterns An array of glob patterns\n *      as the user inputted them. Used for errors.\n * @param {FlatConfigArray} options.configs The config array to use for\n *      determining what to ignore.\n * @param {boolean} options.errorOnUnmatchedPattern Determines if an error\n *      should be thrown when a pattern is unmatched.\n * @returns {Promise<Array<string>>} An array of matching file paths\n *      or an empty array if there are no matches.\n * @throws {UnmatchedSearchPatternsError} If there is a pattern that doesn't\n *      match any files.\n */\nasync function globSearch({\n  basePath,\n  patterns,\n  rawPatterns,\n  configs,\n  errorOnUnmatchedPattern\n}) {\n  if (patterns.length === 0) {\n    return [];\n  }\n\n  /*\n   * In this section we are converting the patterns into Minimatch\n   * instances for performance reasons. Because we are doing the same\n   * matches repeatedly, it's best to compile those patterns once and\n   * reuse them multiple times.\n   *\n   * To do that, we convert any patterns with an absolute path into a\n   * relative path and normalize it to Posix-style slashes. We also keep\n   * track of the relative patterns to map them back to the original\n   * patterns, which we need in order to throw an error if there are any\n   * unmatched patterns.\n   */\n  const relativeToPatterns = new Map();\n  const matchers = patterns.map((pattern, i) => {\n    const patternToUse = path.isAbsolute(pattern) ? normalizeToPosix(path.relative(basePath, pattern)) : pattern;\n    relativeToPatterns.set(patternToUse, patterns[i]);\n    return new Minimatch(patternToUse, MINIMATCH_OPTIONS);\n  });\n\n  /*\n   * We track unmatched patterns because we may want to throw an error when\n   * they occur. To start, this set is initialized with all of the patterns.\n   * Every time a match occurs, the pattern is removed from the set, making\n   * it easy to tell if we have any unmatched patterns left at the end of\n   * search.\n   */\n  const unmatchedPatterns = new Set([...relativeToPatterns.keys()]);\n  const filePaths = (await new Promise((resolve, reject) => {\n    let promiseRejected = false;\n\n    /**\n     * Wraps a boolean-returning filter function. The wrapped function will reject the promise if an error occurs.\n     * @param {Function} filter A filter function to wrap.\n     * @returns {Function} A function similar to the wrapped filter that rejects the promise if an error occurs.\n     */\n    function wrapFilter(filter) {\n      return (...args) => {\n        // No need to run the filter if an error has been thrown.\n        if (!promiseRejected) {\n          try {\n            return filter(...args);\n          } catch (error) {\n            promiseRejected = true;\n            reject(error);\n          }\n        }\n        return false;\n      };\n    }\n    fswalk.walk(basePath, {\n      deepFilter: wrapFilter(entry => {\n        const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n        const matchesPattern = matchers.some(matcher => matcher.match(relativePath, true));\n        return matchesPattern && !configs.isDirectoryIgnored(entry.path);\n      }),\n      entryFilter: wrapFilter(entry => {\n        const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n\n        // entries may be directories or files so filter out directories\n        if (entry.dirent.isDirectory()) {\n          return false;\n        }\n\n        /*\n         * Optimization: We need to track when patterns are left unmatched\n         * and so we use `unmatchedPatterns` to do that. There is a bit of\n         * complexity here because the same file can be matched by more than\n         * one pattern. So, when we start, we actually need to test every\n         * pattern against every file. Once we know there are no remaining\n         * unmatched patterns, then we can switch to just looking for the\n         * first matching pattern for improved speed.\n         */\n        const matchesPattern = unmatchedPatterns.size > 0 ? matchers.reduce((previousValue, matcher) => {\n          const pathMatches = matcher.match(relativePath);\n\n          /*\n           * We updated the unmatched patterns set only if the path\n           * matches and the file isn't ignored. If the file is\n           * ignored, that means there wasn't a match for the\n           * pattern so it should not be removed.\n           *\n           * Performance note: isFileIgnored() aggressively caches\n           * results so there is no performance penalty for calling\n           * it twice with the same argument.\n           */\n          if (pathMatches && !configs.isFileIgnored(entry.path)) {\n            unmatchedPatterns.delete(matcher.pattern);\n          }\n          return pathMatches || previousValue;\n        }, false) : matchers.some(matcher => matcher.match(relativePath));\n        return matchesPattern && !configs.isFileIgnored(entry.path);\n      })\n    }, (error, entries) => {\n      // If the promise is already rejected, calling `resolve` or `reject` will do nothing.\n      if (error) {\n        reject(error);\n      } else {\n        resolve(entries);\n      }\n    });\n  })).map(entry => entry.path);\n\n  // now check to see if we have any unmatched patterns\n  if (errorOnUnmatchedPattern && unmatchedPatterns.size > 0) {\n    throw new UnmatchedSearchPatternsError({\n      basePath,\n      unmatchedPatterns: [...unmatchedPatterns].map(pattern => relativeToPatterns.get(pattern)),\n      patterns,\n      rawPatterns\n    });\n  }\n  return filePaths;\n}\n\n/**\n * Throws an error for unmatched patterns. The error will only contain information about the first one.\n * Checks to see if there are any ignored results for a given search.\n * @param {Object} options The options for this function.\n * @param {string} options.basePath The directory to search.\n * @param {Array<string>} options.patterns An array of glob patterns\n *      that were used in the original search.\n * @param {Array<string>} options.rawPatterns An array of glob patterns\n *      as the user inputted them. Used for errors.\n * @param {Array<string>} options.unmatchedPatterns A non-empty array of glob patterns\n *      that were unmatched in the original search.\n * @returns {void} Always throws an error.\n * @throws {NoFilesFoundError} If the first unmatched pattern\n *      doesn't match any files even when there are no ignores.\n * @throws {AllFilesIgnoredError} If the first unmatched pattern\n *      matches some files when there are no ignores.\n */\nasync function throwErrorForUnmatchedPatterns({\n  basePath,\n  patterns,\n  rawPatterns,\n  unmatchedPatterns\n}) {\n  const pattern = unmatchedPatterns[0];\n  const rawPattern = rawPatterns[patterns.indexOf(pattern)];\n  const patternHasMatch = await globMatch({\n    basePath,\n    pattern\n  });\n  if (patternHasMatch) {\n    throw new AllFilesIgnoredError(rawPattern);\n  }\n\n  // if we get here there are truly no matches\n  throw new NoFilesFoundError(rawPattern, true);\n}\n\n/**\n * Performs multiple glob searches in parallel.\n * @param {Object} options The options for this function.\n * @param {Map<string,GlobSearch>} options.searches\n *      An array of glob patterns to match.\n * @param {FlatConfigArray} options.configs The config array to use for\n *      determining what to ignore.\n * @param {boolean} options.errorOnUnmatchedPattern Determines if an\n *      unmatched glob pattern should throw an error.\n * @returns {Promise<Array<string>>} An array of matching file paths\n *      or an empty array if there are no matches.\n */\nasync function globMultiSearch({\n  searches,\n  configs,\n  errorOnUnmatchedPattern\n}) {\n  /*\n   * For convenience, we normalized the search map into an array of objects.\n   * Next, we filter out all searches that have no patterns. This happens\n   * primarily for the cwd, which is prepopulated in the searches map as an\n   * optimization. However, if it has no patterns, it means all patterns\n   * occur outside of the cwd and we can safely filter out that search.\n   */\n  const normalizedSearches = [...searches].map(([basePath, {\n    patterns,\n    rawPatterns\n  }]) => ({\n    basePath,\n    patterns,\n    rawPatterns\n  })).filter(({\n    patterns\n  }) => patterns.length > 0);\n  const results = await Promise.allSettled(normalizedSearches.map(({\n    basePath,\n    patterns,\n    rawPatterns\n  }) => globSearch({\n    basePath,\n    patterns,\n    rawPatterns,\n    configs,\n    errorOnUnmatchedPattern\n  })));\n  const filePaths = [];\n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n    const currentSearch = normalizedSearches[i];\n    if (result.status === \"fulfilled\") {\n      // if the search was successful just add the results\n      if (result.value.length > 0) {\n        filePaths.push(...result.value);\n      }\n      continue;\n    }\n\n    // if we make it here then there was an error\n    const error = result.reason;\n\n    // unexpected errors should be re-thrown\n    if (!error.basePath) {\n      throw error;\n    }\n    if (errorOnUnmatchedPattern) {\n      await throwErrorForUnmatchedPatterns({\n        ...currentSearch,\n        unmatchedPatterns: error.unmatchedPatterns\n      });\n    }\n  }\n  return filePaths;\n}\n\n/**\n * Finds all files matching the options specified.\n * @param {Object} args The arguments objects.\n * @param {Array<string>} args.patterns An array of glob patterns.\n * @param {boolean} args.globInputPaths true to interpret glob patterns,\n *      false to not interpret glob patterns.\n * @param {string} args.cwd The current working directory to find from.\n * @param {FlatConfigArray} args.configs The configs for the current run.\n * @param {boolean} args.errorOnUnmatchedPattern Determines if an unmatched pattern\n *      should throw an error.\n * @returns {Promise<Array<string>>} The fully resolved file paths.\n * @throws {AllFilesIgnoredError} If there are no results due to an ignore pattern.\n * @throws {NoFilesFoundError} If no files matched the given patterns.\n */\nasync function findFiles({\n  patterns,\n  globInputPaths,\n  cwd,\n  configs,\n  errorOnUnmatchedPattern\n}) {\n  const results = [];\n  const missingPatterns = [];\n  let globbyPatterns = [];\n  let rawPatterns = [];\n  const searches = new Map([[cwd, {\n    patterns: globbyPatterns,\n    rawPatterns: []\n  }]]);\n\n  // check to see if we have explicit files and directories\n  const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));\n  const stats = await Promise.all(filePaths.map(filePath => fsp.stat(filePath).catch(() => {})));\n  stats.forEach((stat, index) => {\n    const filePath = filePaths[index];\n    const pattern = normalizeToPosix(patterns[index]);\n    if (stat) {\n      // files are added directly to the list\n      if (stat.isFile()) {\n        results.push(filePath);\n      }\n\n      // directories need extensions attached\n      if (stat.isDirectory()) {\n        // group everything in cwd together and split out others\n        if (isPathInside(filePath, cwd)) {\n          ({\n            patterns: globbyPatterns,\n            rawPatterns\n          } = searches.get(cwd));\n        } else {\n          if (!searches.has(filePath)) {\n            searches.set(filePath, {\n              patterns: [],\n              rawPatterns: []\n            });\n          }\n          ({\n            patterns: globbyPatterns,\n            rawPatterns\n          } = searches.get(filePath));\n        }\n        globbyPatterns.push(`${normalizeToPosix(filePath)}/**`);\n        rawPatterns.push(pattern);\n      }\n      return;\n    }\n\n    // save patterns for later use based on whether globs are enabled\n    if (globInputPaths && isGlobPattern(pattern)) {\n      const basePath = path.resolve(cwd, globParent(pattern));\n\n      // group in cwd if possible and split out others\n      if (isPathInside(basePath, cwd)) {\n        ({\n          patterns: globbyPatterns,\n          rawPatterns\n        } = searches.get(cwd));\n      } else {\n        if (!searches.has(basePath)) {\n          searches.set(basePath, {\n            patterns: [],\n            rawPatterns: []\n          });\n        }\n        ({\n          patterns: globbyPatterns,\n          rawPatterns\n        } = searches.get(basePath));\n      }\n      globbyPatterns.push(filePath);\n      rawPatterns.push(pattern);\n    } else {\n      missingPatterns.push(pattern);\n    }\n  });\n\n  // there were patterns that didn't match anything, tell the user\n  if (errorOnUnmatchedPattern && missingPatterns.length) {\n    throw new NoFilesFoundError(missingPatterns[0], globInputPaths);\n  }\n\n  // now we are safe to do the search\n  const globbyResults = await globMultiSearch({\n    searches,\n    configs,\n    errorOnUnmatchedPattern\n  });\n  return [...new Set([...results, ...globbyResults.map(filePath => path.resolve(filePath))])];\n}\n\n//-----------------------------------------------------------------------------\n// Results-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n  return message.severity === 2;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n  let message;\n  const isInNodeModules = baseDir && path.dirname(path.relative(baseDir, filePath)).split(path.sep).includes(\"node_modules\");\n  if (isInNodeModules) {\n    message = \"File ignored by default because it is located under the node_modules directory. Use ignore pattern \\\"!**/node_modules/\\\" to disable file ignore settings or use \\\"--no-warn-ignored\\\" to suppress this warning.\";\n  } else {\n    message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to disable file ignore settings or use \\\"--no-warn-ignored\\\" to suppress this warning.\";\n  }\n  return {\n    filePath: path.resolve(filePath),\n    messages: [{\n      ruleId: null,\n      fatal: false,\n      severity: 1,\n      message,\n      nodeType: null\n    }],\n    suppressedMessages: [],\n    errorCount: 0,\n    warningCount: 1,\n    fatalErrorCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  };\n}\n\n//-----------------------------------------------------------------------------\n// Options-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n  return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n  return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n  constructor(messages) {\n    super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n    this.code = \"ESLINT_INVALID_OPTIONS\";\n    Error.captureStackTrace(this, ESLintInvalidOptionsError);\n  }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {FlatESLintOptions} options The options to process.\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\n * @returns {FlatESLintOptions} The normalized options.\n */\nfunction processOptions({\n  allowInlineConfig = true,\n  // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n  baseConfig = null,\n  cache = false,\n  cacheLocation = \".eslintcache\",\n  cacheStrategy = \"metadata\",\n  cwd = process.cwd(),\n  errorOnUnmatchedPattern = true,\n  fix = false,\n  fixTypes = null,\n  // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n  globInputPaths = true,\n  ignore = true,\n  ignorePatterns = null,\n  overrideConfig = null,\n  overrideConfigFile = null,\n  plugins = {},\n  warnIgnored = true,\n  ...unknownOptions\n}) {\n  const errors = [];\n  const unknownOptionKeys = Object.keys(unknownOptions);\n  if (unknownOptionKeys.length >= 1) {\n    errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n    if (unknownOptionKeys.includes(\"cacheFile\")) {\n      errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"configFile\")) {\n      errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"envs\")) {\n      errors.push(\"'envs' has been removed.\");\n    }\n    if (unknownOptionKeys.includes(\"extensions\")) {\n      errors.push(\"'extensions' has been removed.\");\n    }\n    if (unknownOptionKeys.includes(\"resolvePluginsRelativeTo\")) {\n      errors.push(\"'resolvePluginsRelativeTo' has been removed.\");\n    }\n    if (unknownOptionKeys.includes(\"globals\")) {\n      errors.push(\"'globals' has been removed. Please use the 'overrideConfig.languageOptions.globals' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"ignorePath\")) {\n      errors.push(\"'ignorePath' has been removed.\");\n    }\n    if (unknownOptionKeys.includes(\"ignorePattern\")) {\n      errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"parser\")) {\n      errors.push(\"'parser' has been removed. Please use the 'overrideConfig.languageOptions.parser' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"parserOptions\")) {\n      errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.languageOptions.parserOptions' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"rules\")) {\n      errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"rulePaths\")) {\n      errors.push(\"'rulePaths' has been removed. Please define your rules using plugins.\");\n    }\n    if (unknownOptionKeys.includes(\"reportUnusedDisableDirectives\")) {\n      errors.push(\"'reportUnusedDisableDirectives' has been removed. Please use the 'overrideConfig.linterOptions.reportUnusedDisableDirectives' option instead.\");\n    }\n  }\n  if (typeof allowInlineConfig !== \"boolean\") {\n    errors.push(\"'allowInlineConfig' must be a boolean.\");\n  }\n  if (typeof baseConfig !== \"object\") {\n    errors.push(\"'baseConfig' must be an object or null.\");\n  }\n  if (typeof cache !== \"boolean\") {\n    errors.push(\"'cache' must be a boolean.\");\n  }\n  if (!isNonEmptyString(cacheLocation)) {\n    errors.push(\"'cacheLocation' must be a non-empty string.\");\n  }\n  if (cacheStrategy !== \"metadata\" && cacheStrategy !== \"content\") {\n    errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n  }\n  if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n    errors.push(\"'cwd' must be an absolute path.\");\n  }\n  if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n    errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n  }\n  if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n    errors.push(\"'fix' must be a boolean or a function.\");\n  }\n  if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n    errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n  }\n  if (typeof globInputPaths !== \"boolean\") {\n    errors.push(\"'globInputPaths' must be a boolean.\");\n  }\n  if (typeof ignore !== \"boolean\") {\n    errors.push(\"'ignore' must be a boolean.\");\n  }\n  if (!isArrayOfNonEmptyString(ignorePatterns) && ignorePatterns !== null) {\n    errors.push(\"'ignorePatterns' must be an array of non-empty strings or null.\");\n  }\n  if (typeof overrideConfig !== \"object\") {\n    errors.push(\"'overrideConfig' must be an object or null.\");\n  }\n  if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null && overrideConfigFile !== true) {\n    errors.push(\"'overrideConfigFile' must be a non-empty string, null, or true.\");\n  }\n  if (typeof plugins !== \"object\") {\n    errors.push(\"'plugins' must be an object or null.\");\n  } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n    errors.push(\"'plugins' must not include an empty string.\");\n  }\n  if (Array.isArray(plugins)) {\n    errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n  }\n  if (typeof warnIgnored !== \"boolean\") {\n    errors.push(\"'warnIgnored' must be a boolean.\");\n  }\n  if (errors.length > 0) {\n    throw new ESLintInvalidOptionsError(errors);\n  }\n  return {\n    allowInlineConfig,\n    baseConfig,\n    cache,\n    cacheLocation,\n    cacheStrategy,\n    // when overrideConfigFile is true that means don't do config file lookup\n    configFile: overrideConfigFile === true ? false : overrideConfigFile,\n    overrideConfig,\n    cwd: path.normalize(cwd),\n    errorOnUnmatchedPattern,\n    fix,\n    fixTypes,\n    globInputPaths,\n    ignore,\n    ignorePatterns,\n    warnIgnored\n  };\n}\n\n//-----------------------------------------------------------------------------\n// Cache-related helpers\n//-----------------------------------------------------------------------------\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n  /*\n   * make sure the path separators are normalized for the environment/os\n   * keeping the trailing path separator if present\n   */\n  const normalizedCacheFile = path.normalize(cacheFile);\n  const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n  const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n  /**\n   * return the name for the cache file in case the provided parameter is a directory\n   * @returns {string} the resolved path to the cacheFile\n   */\n  function getCacheFileForDirectory() {\n    return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n  }\n  let fileStats;\n  try {\n    fileStats = fs.lstatSync(resolvedCacheFile);\n  } catch {\n    fileStats = null;\n  }\n\n  /*\n   * in case the file exists we need to verify if the provided path\n   * is a directory or a file. If it is a directory we want to create a file\n   * inside that directory\n   */\n  if (fileStats) {\n    /*\n     * is a directory or is a file, but the original file the user provided\n     * looks like a directory but `path.resolve` removed the `last path.sep`\n     * so we need to still treat this like a directory\n     */\n    if (fileStats.isDirectory() || looksLikeADirectory) {\n      return getCacheFileForDirectory();\n    }\n\n    // is file so just use that file\n    return resolvedCacheFile;\n  }\n\n  /*\n   * here we known the file or directory doesn't exist,\n   * so we will try to infer if its a directory if it looks like a directory\n   * for the current operating system.\n   */\n\n  // if the last character passed is a path separator we assume is a directory\n  if (looksLikeADirectory) {\n    return getCacheFileForDirectory();\n  }\n  return resolvedCacheFile;\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n  isGlobPattern,\n  findFiles,\n  isNonEmptyString,\n  isArrayOfNonEmptyString,\n  createIgnoreResult,\n  isErrorMessage,\n  processOptions,\n  getCacheFile\n};","map":{"version":3,"names":["path","require","fs","fsp","promises","isGlob","hash","minimatch","fswalk","globParent","isPathInside","Minimatch","MINIMATCH_OPTIONS","dot","NoFilesFoundError","Error","constructor","pattern","globEnabled","messageTemplate","messageData","globDisabled","UnmatchedSearchPatternsError","basePath","unmatchedPatterns","patterns","rawPatterns","AllFilesIgnoredError","isNonEmptyString","x","trim","isArrayOfNonEmptyString","Array","isArray","every","normalizeToPosix","replace","isGlobPattern","sep","globMatch","found","patternToUse","isAbsolute","relative","matcher","fsWalkSettings","deepFilter","entry","relativePath","match","entryFilter","dirent","isDirectory","Promise","resolve","globStream","walkStream","on","destroy","read","globSearch","configs","errorOnUnmatchedPattern","length","relativeToPatterns","Map","matchers","map","i","set","Set","keys","filePaths","reject","promiseRejected","wrapFilter","filter","args","error","walk","matchesPattern","some","isDirectoryIgnored","size","reduce","previousValue","pathMatches","isFileIgnored","delete","entries","get","throwErrorForUnmatchedPatterns","rawPattern","indexOf","patternHasMatch","globMultiSearch","searches","normalizedSearches","results","allSettled","result","currentSearch","status","value","push","reason","findFiles","globInputPaths","cwd","missingPatterns","globbyPatterns","filePath","stats","all","stat","catch","forEach","index","isFile","has","globbyResults","isErrorMessage","message","severity","createIgnoreResult","baseDir","isInNodeModules","dirname","split","includes","messages","ruleId","fatal","nodeType","suppressedMessages","errorCount","warningCount","fatalErrorCount","fixableErrorCount","fixableWarningCount","isFixType","isFixTypeArray","ESLintInvalidOptionsError","join","code","captureStackTrace","processOptions","allowInlineConfig","baseConfig","cache","cacheLocation","cacheStrategy","process","fix","fixTypes","ignore","ignorePatterns","overrideConfig","overrideConfigFile","plugins","warnIgnored","unknownOptions","errors","unknownOptionKeys","Object","configFile","normalize","getCacheFile","cacheFile","normalizedCacheFile","resolvedCacheFile","looksLikeADirectory","slice","getCacheFileForDirectory","fileStats","lstatSync","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/eslint/eslint-helpers.js"],"sourcesContent":["/**\n * @fileoverview Helper functions for ESLint class\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fsp = fs.promises;\nconst isGlob = require(\"is-glob\");\nconst hash = require(\"../cli-engine/hash\");\nconst minimatch = require(\"minimatch\");\nconst fswalk = require(\"@nodelib/fs.walk\");\nconst globParent = require(\"glob-parent\");\nconst isPathInside = require(\"is-path-inside\");\n\n//-----------------------------------------------------------------------------\n// Fixup references\n//-----------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst MINIMATCH_OPTIONS = { dot: true };\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} GlobSearch\n * @property {Array<string>} patterns The normalized patterns to use for a search.\n * @property {Array<string>} rawPatterns The patterns as entered by the user\n *      before doing any normalization.\n */\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     * @param {boolean} globEnabled If `false` then the pattern was a glob pattern, but glob was disabled.\n     */\n    constructor(pattern, globEnabled) {\n        super(`No files matching '${pattern}' were found${!globEnabled ? \" (glob was disabled)\" : \"\"}.`);\n        this.messageTemplate = \"file-not-found\";\n        this.messageData = { pattern, globDisabled: !globEnabled };\n    }\n}\n\n/**\n * The error type when a search fails to match multiple patterns.\n */\nclass UnmatchedSearchPatternsError extends Error {\n\n    /**\n     * @param {Object} options The options for the error.\n     * @param {string} options.basePath The directory that was searched.\n     * @param {Array<string>} options.unmatchedPatterns The glob patterns\n     *      which were not found.\n     * @param {Array<string>} options.patterns The glob patterns that were\n     *      searched.\n     * @param {Array<string>} options.rawPatterns The raw glob patterns that\n     *      were searched.\n     */\n    constructor({ basePath, unmatchedPatterns, patterns, rawPatterns }) {\n        super(`No files matching '${rawPatterns}' in '${basePath}' were found.`);\n        this.basePath = basePath;\n        this.unmatchedPatterns = unmatchedPatterns;\n        this.patterns = patterns;\n        this.rawPatterns = rawPatterns;\n    }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`All files matched by '${pattern}' are ignored.`);\n        this.messageTemplate = \"all-files-ignored\";\n        this.messageData = { pattern };\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// General Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\nfunction isNonEmptyString(x) {\n    return typeof x === \"string\" && x.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty strings or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty strings.\n */\nfunction isArrayOfNonEmptyString(x) {\n    return Array.isArray(x) && x.every(isNonEmptyString);\n}\n\n//-----------------------------------------------------------------------------\n// File-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes slashes in a file pattern to posix-style.\n * @param {string} pattern The pattern to replace slashes in.\n * @returns {string} The pattern with slashes normalized.\n */\nfunction normalizeToPosix(pattern) {\n    return pattern.replace(/\\\\/gu, \"/\");\n}\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n    return isGlob(path.sep === \"\\\\\" ? normalizeToPosix(pattern) : pattern);\n}\n\n\n/**\n * Determines if a given glob pattern will return any results.\n * Used primarily to help with useful error messages.\n * @param {Object} options The options for the function.\n * @param {string} options.basePath The directory to search.\n * @param {string} options.pattern A glob pattern to match.\n * @returns {Promise<boolean>} True if there is a glob match, false if not.\n */\nfunction globMatch({ basePath, pattern }) {\n\n    let found = false;\n    const patternToUse = path.isAbsolute(pattern)\n        ? normalizeToPosix(path.relative(basePath, pattern))\n        : pattern;\n\n    const matcher = new Minimatch(patternToUse, MINIMATCH_OPTIONS);\n\n    const fsWalkSettings = {\n\n        deepFilter(entry) {\n            const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n\n            return !found && matcher.match(relativePath, true);\n        },\n\n        entryFilter(entry) {\n            if (found || entry.dirent.isDirectory()) {\n                return false;\n            }\n\n            const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n\n            if (matcher.match(relativePath)) {\n                found = true;\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    return new Promise(resolve => {\n\n        // using a stream so we can exit early because we just need one match\n        const globStream = fswalk.walkStream(basePath, fsWalkSettings);\n\n        globStream.on(\"data\", () => {\n            globStream.destroy();\n            resolve(true);\n        });\n\n        // swallow errors as they're not important here\n        globStream.on(\"error\", () => { });\n\n        globStream.on(\"end\", () => {\n            resolve(false);\n        });\n        globStream.read();\n    });\n\n}\n\n/**\n * Searches a directory looking for matching glob patterns. This uses\n * the config array's logic to determine if a directory or file should\n * be ignored, so it is consistent with how ignoring works throughout\n * ESLint.\n * @param {Object} options The options for this function.\n * @param {string} options.basePath The directory to search.\n * @param {Array<string>} options.patterns An array of glob patterns\n *      to match.\n * @param {Array<string>} options.rawPatterns An array of glob patterns\n *      as the user inputted them. Used for errors.\n * @param {FlatConfigArray} options.configs The config array to use for\n *      determining what to ignore.\n * @param {boolean} options.errorOnUnmatchedPattern Determines if an error\n *      should be thrown when a pattern is unmatched.\n * @returns {Promise<Array<string>>} An array of matching file paths\n *      or an empty array if there are no matches.\n * @throws {UnmatchedSearchPatternsError} If there is a pattern that doesn't\n *      match any files.\n */\nasync function globSearch({\n    basePath,\n    patterns,\n    rawPatterns,\n    configs,\n    errorOnUnmatchedPattern\n}) {\n\n    if (patterns.length === 0) {\n        return [];\n    }\n\n    /*\n     * In this section we are converting the patterns into Minimatch\n     * instances for performance reasons. Because we are doing the same\n     * matches repeatedly, it's best to compile those patterns once and\n     * reuse them multiple times.\n     *\n     * To do that, we convert any patterns with an absolute path into a\n     * relative path and normalize it to Posix-style slashes. We also keep\n     * track of the relative patterns to map them back to the original\n     * patterns, which we need in order to throw an error if there are any\n     * unmatched patterns.\n     */\n    const relativeToPatterns = new Map();\n    const matchers = patterns.map((pattern, i) => {\n        const patternToUse = path.isAbsolute(pattern)\n            ? normalizeToPosix(path.relative(basePath, pattern))\n            : pattern;\n\n        relativeToPatterns.set(patternToUse, patterns[i]);\n\n        return new Minimatch(patternToUse, MINIMATCH_OPTIONS);\n    });\n\n    /*\n     * We track unmatched patterns because we may want to throw an error when\n     * they occur. To start, this set is initialized with all of the patterns.\n     * Every time a match occurs, the pattern is removed from the set, making\n     * it easy to tell if we have any unmatched patterns left at the end of\n     * search.\n     */\n    const unmatchedPatterns = new Set([...relativeToPatterns.keys()]);\n\n    const filePaths = (await new Promise((resolve, reject) => {\n\n        let promiseRejected = false;\n\n        /**\n         * Wraps a boolean-returning filter function. The wrapped function will reject the promise if an error occurs.\n         * @param {Function} filter A filter function to wrap.\n         * @returns {Function} A function similar to the wrapped filter that rejects the promise if an error occurs.\n         */\n        function wrapFilter(filter) {\n            return (...args) => {\n\n                // No need to run the filter if an error has been thrown.\n                if (!promiseRejected) {\n                    try {\n                        return filter(...args);\n                    } catch (error) {\n                        promiseRejected = true;\n                        reject(error);\n                    }\n                }\n                return false;\n            };\n        }\n\n        fswalk.walk(\n            basePath,\n            {\n                deepFilter: wrapFilter(entry => {\n                    const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n                    const matchesPattern = matchers.some(matcher => matcher.match(relativePath, true));\n\n                    return matchesPattern && !configs.isDirectoryIgnored(entry.path);\n                }),\n                entryFilter: wrapFilter(entry => {\n                    const relativePath = normalizeToPosix(path.relative(basePath, entry.path));\n\n                    // entries may be directories or files so filter out directories\n                    if (entry.dirent.isDirectory()) {\n                        return false;\n                    }\n\n                    /*\n                     * Optimization: We need to track when patterns are left unmatched\n                     * and so we use `unmatchedPatterns` to do that. There is a bit of\n                     * complexity here because the same file can be matched by more than\n                     * one pattern. So, when we start, we actually need to test every\n                     * pattern against every file. Once we know there are no remaining\n                     * unmatched patterns, then we can switch to just looking for the\n                     * first matching pattern for improved speed.\n                     */\n                    const matchesPattern = unmatchedPatterns.size > 0\n                        ? matchers.reduce((previousValue, matcher) => {\n                            const pathMatches = matcher.match(relativePath);\n\n                            /*\n                             * We updated the unmatched patterns set only if the path\n                             * matches and the file isn't ignored. If the file is\n                             * ignored, that means there wasn't a match for the\n                             * pattern so it should not be removed.\n                             *\n                             * Performance note: isFileIgnored() aggressively caches\n                             * results so there is no performance penalty for calling\n                             * it twice with the same argument.\n                             */\n                            if (pathMatches && !configs.isFileIgnored(entry.path)) {\n                                unmatchedPatterns.delete(matcher.pattern);\n                            }\n\n                            return pathMatches || previousValue;\n                        }, false)\n                        : matchers.some(matcher => matcher.match(relativePath));\n\n                    return matchesPattern && !configs.isFileIgnored(entry.path);\n                })\n            },\n            (error, entries) => {\n\n                // If the promise is already rejected, calling `resolve` or `reject` will do nothing.\n                if (error) {\n                    reject(error);\n                } else {\n                    resolve(entries);\n                }\n            }\n        );\n    })).map(entry => entry.path);\n\n    // now check to see if we have any unmatched patterns\n    if (errorOnUnmatchedPattern && unmatchedPatterns.size > 0) {\n        throw new UnmatchedSearchPatternsError({\n            basePath,\n            unmatchedPatterns: [...unmatchedPatterns].map(\n                pattern => relativeToPatterns.get(pattern)\n            ),\n            patterns,\n            rawPatterns\n        });\n    }\n\n    return filePaths;\n}\n\n/**\n * Throws an error for unmatched patterns. The error will only contain information about the first one.\n * Checks to see if there are any ignored results for a given search.\n * @param {Object} options The options for this function.\n * @param {string} options.basePath The directory to search.\n * @param {Array<string>} options.patterns An array of glob patterns\n *      that were used in the original search.\n * @param {Array<string>} options.rawPatterns An array of glob patterns\n *      as the user inputted them. Used for errors.\n * @param {Array<string>} options.unmatchedPatterns A non-empty array of glob patterns\n *      that were unmatched in the original search.\n * @returns {void} Always throws an error.\n * @throws {NoFilesFoundError} If the first unmatched pattern\n *      doesn't match any files even when there are no ignores.\n * @throws {AllFilesIgnoredError} If the first unmatched pattern\n *      matches some files when there are no ignores.\n */\nasync function throwErrorForUnmatchedPatterns({\n    basePath,\n    patterns,\n    rawPatterns,\n    unmatchedPatterns\n}) {\n\n    const pattern = unmatchedPatterns[0];\n    const rawPattern = rawPatterns[patterns.indexOf(pattern)];\n\n    const patternHasMatch = await globMatch({\n        basePath,\n        pattern\n    });\n\n    if (patternHasMatch) {\n        throw new AllFilesIgnoredError(rawPattern);\n    }\n\n    // if we get here there are truly no matches\n    throw new NoFilesFoundError(rawPattern, true);\n}\n\n/**\n * Performs multiple glob searches in parallel.\n * @param {Object} options The options for this function.\n * @param {Map<string,GlobSearch>} options.searches\n *      An array of glob patterns to match.\n * @param {FlatConfigArray} options.configs The config array to use for\n *      determining what to ignore.\n * @param {boolean} options.errorOnUnmatchedPattern Determines if an\n *      unmatched glob pattern should throw an error.\n * @returns {Promise<Array<string>>} An array of matching file paths\n *      or an empty array if there are no matches.\n */\nasync function globMultiSearch({ searches, configs, errorOnUnmatchedPattern }) {\n\n    /*\n     * For convenience, we normalized the search map into an array of objects.\n     * Next, we filter out all searches that have no patterns. This happens\n     * primarily for the cwd, which is prepopulated in the searches map as an\n     * optimization. However, if it has no patterns, it means all patterns\n     * occur outside of the cwd and we can safely filter out that search.\n     */\n    const normalizedSearches = [...searches].map(\n        ([basePath, { patterns, rawPatterns }]) => ({ basePath, patterns, rawPatterns })\n    ).filter(({ patterns }) => patterns.length > 0);\n\n    const results = await Promise.allSettled(\n        normalizedSearches.map(\n            ({ basePath, patterns, rawPatterns }) => globSearch({\n                basePath,\n                patterns,\n                rawPatterns,\n                configs,\n                errorOnUnmatchedPattern\n            })\n        )\n    );\n\n    const filePaths = [];\n\n    for (let i = 0; i < results.length; i++) {\n\n        const result = results[i];\n        const currentSearch = normalizedSearches[i];\n\n        if (result.status === \"fulfilled\") {\n\n            // if the search was successful just add the results\n            if (result.value.length > 0) {\n                filePaths.push(...result.value);\n            }\n\n            continue;\n        }\n\n        // if we make it here then there was an error\n        const error = result.reason;\n\n        // unexpected errors should be re-thrown\n        if (!error.basePath) {\n            throw error;\n        }\n\n        if (errorOnUnmatchedPattern) {\n\n            await throwErrorForUnmatchedPatterns({\n                ...currentSearch,\n                unmatchedPatterns: error.unmatchedPatterns\n            });\n\n        }\n\n    }\n\n    return filePaths;\n\n}\n\n/**\n * Finds all files matching the options specified.\n * @param {Object} args The arguments objects.\n * @param {Array<string>} args.patterns An array of glob patterns.\n * @param {boolean} args.globInputPaths true to interpret glob patterns,\n *      false to not interpret glob patterns.\n * @param {string} args.cwd The current working directory to find from.\n * @param {FlatConfigArray} args.configs The configs for the current run.\n * @param {boolean} args.errorOnUnmatchedPattern Determines if an unmatched pattern\n *      should throw an error.\n * @returns {Promise<Array<string>>} The fully resolved file paths.\n * @throws {AllFilesIgnoredError} If there are no results due to an ignore pattern.\n * @throws {NoFilesFoundError} If no files matched the given patterns.\n */\nasync function findFiles({\n    patterns,\n    globInputPaths,\n    cwd,\n    configs,\n    errorOnUnmatchedPattern\n}) {\n\n    const results = [];\n    const missingPatterns = [];\n    let globbyPatterns = [];\n    let rawPatterns = [];\n    const searches = new Map([[cwd, { patterns: globbyPatterns, rawPatterns: [] }]]);\n\n    // check to see if we have explicit files and directories\n    const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));\n    const stats = await Promise.all(\n        filePaths.map(\n            filePath => fsp.stat(filePath).catch(() => { })\n        )\n    );\n\n    stats.forEach((stat, index) => {\n\n        const filePath = filePaths[index];\n        const pattern = normalizeToPosix(patterns[index]);\n\n        if (stat) {\n\n            // files are added directly to the list\n            if (stat.isFile()) {\n                results.push(filePath);\n            }\n\n            // directories need extensions attached\n            if (stat.isDirectory()) {\n\n                // group everything in cwd together and split out others\n                if (isPathInside(filePath, cwd)) {\n                    ({ patterns: globbyPatterns, rawPatterns } = searches.get(cwd));\n                } else {\n                    if (!searches.has(filePath)) {\n                        searches.set(filePath, { patterns: [], rawPatterns: [] });\n                    }\n                    ({ patterns: globbyPatterns, rawPatterns } = searches.get(filePath));\n                }\n\n                globbyPatterns.push(`${normalizeToPosix(filePath)}/**`);\n                rawPatterns.push(pattern);\n            }\n\n            return;\n        }\n\n        // save patterns for later use based on whether globs are enabled\n        if (globInputPaths && isGlobPattern(pattern)) {\n\n            const basePath = path.resolve(cwd, globParent(pattern));\n\n            // group in cwd if possible and split out others\n            if (isPathInside(basePath, cwd)) {\n                ({ patterns: globbyPatterns, rawPatterns } = searches.get(cwd));\n            } else {\n                if (!searches.has(basePath)) {\n                    searches.set(basePath, { patterns: [], rawPatterns: [] });\n                }\n                ({ patterns: globbyPatterns, rawPatterns } = searches.get(basePath));\n            }\n\n            globbyPatterns.push(filePath);\n            rawPatterns.push(pattern);\n        } else {\n            missingPatterns.push(pattern);\n        }\n    });\n\n    // there were patterns that didn't match anything, tell the user\n    if (errorOnUnmatchedPattern && missingPatterns.length) {\n        throw new NoFilesFoundError(missingPatterns[0], globInputPaths);\n    }\n\n    // now we are safe to do the search\n    const globbyResults = await globMultiSearch({\n        searches,\n        configs,\n        errorOnUnmatchedPattern\n    });\n\n    return [\n        ...new Set([\n            ...results,\n            ...globbyResults.map(filePath => path.resolve(filePath))\n        ])\n    ];\n}\n\n//-----------------------------------------------------------------------------\n// Results-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isInNodeModules = baseDir && path.dirname(path.relative(baseDir, filePath)).split(path.sep).includes(\"node_modules\");\n\n    if (isInNodeModules) {\n        message = \"File ignored by default because it is located under the node_modules directory. Use ignore pattern \\\"!**/node_modules/\\\" to disable file ignore settings or use \\\"--no-warn-ignored\\\" to suppress this warning.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to disable file ignore settings or use \\\"--no-warn-ignored\\\" to suppress this warning.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                ruleId: null,\n                fatal: false,\n                severity: 1,\n                message,\n                nodeType: null\n            }\n        ],\n        suppressedMessages: [],\n        errorCount: 0,\n        warningCount: 1,\n        fatalErrorCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n}\n\n//-----------------------------------------------------------------------------\n// Options-related Helpers\n//-----------------------------------------------------------------------------\n\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n    return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n    return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n    constructor(messages) {\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n        this.code = \"ESLINT_INVALID_OPTIONS\";\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\n    }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {FlatESLintOptions} options The options to process.\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\n * @returns {FlatESLintOptions} The normalized options.\n */\nfunction processOptions({\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    fix = false,\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePatterns = null,\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    warnIgnored = true,\n    ...unknownOptions\n}) {\n    const errors = [];\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length >= 1) {\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"configFile\")) {\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"envs\")) {\n            errors.push(\"'envs' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"extensions\")) {\n            errors.push(\"'extensions' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"resolvePluginsRelativeTo\")) {\n            errors.push(\"'resolvePluginsRelativeTo' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"globals\")) {\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.languageOptions.globals' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePath\")) {\n            errors.push(\"'ignorePath' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parser\")) {\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.languageOptions.parser' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.languageOptions.parserOptions' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rules\")) {\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rulePaths\")) {\n            errors.push(\"'rulePaths' has been removed. Please define your rules using plugins.\");\n        }\n        if (unknownOptionKeys.includes(\"reportUnusedDisableDirectives\")) {\n            errors.push(\"'reportUnusedDisableDirectives' has been removed. Please use the 'overrideConfig.linterOptions.reportUnusedDisableDirectives' option instead.\");\n        }\n    }\n    if (typeof allowInlineConfig !== \"boolean\") {\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\n    }\n    if (typeof baseConfig !== \"object\") {\n        errors.push(\"'baseConfig' must be an object or null.\");\n    }\n    if (typeof cache !== \"boolean\") {\n        errors.push(\"'cache' must be a boolean.\");\n    }\n    if (!isNonEmptyString(cacheLocation)) {\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\n    }\n    if (\n        cacheStrategy !== \"metadata\" &&\n        cacheStrategy !== \"content\"\n    ) {\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n    }\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n        errors.push(\"'cwd' must be an absolute path.\");\n    }\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n    }\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n        errors.push(\"'fix' must be a boolean or a function.\");\n    }\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n        errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n    }\n    if (typeof globInputPaths !== \"boolean\") {\n        errors.push(\"'globInputPaths' must be a boolean.\");\n    }\n    if (typeof ignore !== \"boolean\") {\n        errors.push(\"'ignore' must be a boolean.\");\n    }\n    if (!isArrayOfNonEmptyString(ignorePatterns) && ignorePatterns !== null) {\n        errors.push(\"'ignorePatterns' must be an array of non-empty strings or null.\");\n    }\n    if (typeof overrideConfig !== \"object\") {\n        errors.push(\"'overrideConfig' must be an object or null.\");\n    }\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null && overrideConfigFile !== true) {\n        errors.push(\"'overrideConfigFile' must be a non-empty string, null, or true.\");\n    }\n    if (typeof plugins !== \"object\") {\n        errors.push(\"'plugins' must be an object or null.\");\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n        errors.push(\"'plugins' must not include an empty string.\");\n    }\n    if (Array.isArray(plugins)) {\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n    }\n    if (typeof warnIgnored !== \"boolean\") {\n        errors.push(\"'warnIgnored' must be a boolean.\");\n    }\n    if (errors.length > 0) {\n        throw new ESLintInvalidOptionsError(errors);\n    }\n\n    return {\n        allowInlineConfig,\n        baseConfig,\n        cache,\n        cacheLocation,\n        cacheStrategy,\n\n        // when overrideConfigFile is true that means don't do config file lookup\n        configFile: overrideConfigFile === true ? false : overrideConfigFile,\n        overrideConfig,\n        cwd: path.normalize(cwd),\n        errorOnUnmatchedPattern,\n        fix,\n        fixTypes,\n        globInputPaths,\n        ignore,\n        ignorePatterns,\n        warnIgnored\n    };\n}\n\n\n//-----------------------------------------------------------------------------\n// Cache-related helpers\n//-----------------------------------------------------------------------------\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    const normalizedCacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    isGlobPattern,\n    findFiles,\n\n    isNonEmptyString,\n    isArrayOfNonEmptyString,\n\n    createIgnoreResult,\n    isErrorMessage,\n\n    processOptions,\n\n    getCacheFile\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;AACxB,MAAME,GAAG,GAAGD,EAAE,CAACE,QAAQ;AACvB,MAAMC,MAAM,GAAGJ,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMK,IAAI,GAAGL,OAAO,CAAC,oBAAoB,CAAC;AAC1C,MAAMM,SAAS,GAAGN,OAAO,CAAC,WAAW,CAAC;AACtC,MAAMO,MAAM,GAAGP,OAAO,CAAC,kBAAkB,CAAC;AAC1C,MAAMQ,UAAU,GAAGR,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMS,YAAY,GAAGT,OAAO,CAAC,gBAAgB,CAAC;;AAE9C;AACA;AACA;;AAEA,MAAMU,SAAS,GAAGJ,SAAS,CAACI,SAAS;AACrC,MAAMC,iBAAiB,GAAG;EAAEC,GAAG,EAAE;AAAK,CAAC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMC,iBAAiB,SAASC,KAAK,CAAC;EAElC;AACJ;AACA;AACA;EACIC,WAAWA,CAACC,OAAO,EAAEC,WAAW,EAAE;IAC9B,KAAK,CAAC,sBAAsBD,OAAO,eAAe,CAACC,WAAW,GAAG,sBAAsB,GAAG,EAAE,GAAG,CAAC;IAChG,IAAI,CAACC,eAAe,GAAG,gBAAgB;IACvC,IAAI,CAACC,WAAW,GAAG;MAAEH,OAAO;MAAEI,YAAY,EAAE,CAACH;IAAY,CAAC;EAC9D;AACJ;;AAEA;AACA;AACA;AACA,MAAMI,4BAA4B,SAASP,KAAK,CAAC;EAE7C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAAC;IAAEO,QAAQ;IAAEC,iBAAiB;IAAEC,QAAQ;IAAEC;EAAY,CAAC,EAAE;IAChE,KAAK,CAAC,sBAAsBA,WAAW,SAASH,QAAQ,eAAe,CAAC;IACxE,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,WAAW,GAAGA,WAAW;EAClC;AACJ;;AAEA;AACA;AACA;AACA,MAAMC,oBAAoB,SAASZ,KAAK,CAAC;EAErC;AACJ;AACA;EACIC,WAAWA,CAACC,OAAO,EAAE;IACjB,KAAK,CAAC,yBAAyBA,OAAO,gBAAgB,CAAC;IACvD,IAAI,CAACE,eAAe,GAAG,mBAAmB;IAC1C,IAAI,CAACC,WAAW,GAAG;MAAEH;IAAQ,CAAC;EAClC;AACJ;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASW,gBAAgBA,CAACC,CAAC,EAAE;EACzB,OAAO,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,uBAAuBA,CAACF,CAAC,EAAE;EAChC,OAAOG,KAAK,CAACC,OAAO,CAACJ,CAAC,CAAC,IAAIA,CAAC,CAACK,KAAK,CAACN,gBAAgB,CAAC;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASO,gBAAgBA,CAAClB,OAAO,EAAE;EAC/B,OAAOA,OAAO,CAACmB,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACpB,OAAO,EAAE;EAC5B,OAAOZ,MAAM,CAACL,IAAI,CAACsC,GAAG,KAAK,IAAI,GAAGH,gBAAgB,CAAClB,OAAO,CAAC,GAAGA,OAAO,CAAC;AAC1E;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsB,SAASA,CAAC;EAAEhB,QAAQ;EAAEN;AAAQ,CAAC,EAAE;EAEtC,IAAIuB,KAAK,GAAG,KAAK;EACjB,MAAMC,YAAY,GAAGzC,IAAI,CAAC0C,UAAU,CAACzB,OAAO,CAAC,GACvCkB,gBAAgB,CAACnC,IAAI,CAAC2C,QAAQ,CAACpB,QAAQ,EAAEN,OAAO,CAAC,CAAC,GAClDA,OAAO;EAEb,MAAM2B,OAAO,GAAG,IAAIjC,SAAS,CAAC8B,YAAY,EAAE7B,iBAAiB,CAAC;EAE9D,MAAMiC,cAAc,GAAG;IAEnBC,UAAUA,CAACC,KAAK,EAAE;MACd,MAAMC,YAAY,GAAGb,gBAAgB,CAACnC,IAAI,CAAC2C,QAAQ,CAACpB,QAAQ,EAAEwB,KAAK,CAAC/C,IAAI,CAAC,CAAC;MAE1E,OAAO,CAACwC,KAAK,IAAII,OAAO,CAACK,KAAK,CAACD,YAAY,EAAE,IAAI,CAAC;IACtD,CAAC;IAEDE,WAAWA,CAACH,KAAK,EAAE;MACf,IAAIP,KAAK,IAAIO,KAAK,CAACI,MAAM,CAACC,WAAW,CAAC,CAAC,EAAE;QACrC,OAAO,KAAK;MAChB;MAEA,MAAMJ,YAAY,GAAGb,gBAAgB,CAACnC,IAAI,CAAC2C,QAAQ,CAACpB,QAAQ,EAAEwB,KAAK,CAAC/C,IAAI,CAAC,CAAC;MAE1E,IAAI4C,OAAO,CAACK,KAAK,CAACD,YAAY,CAAC,EAAE;QAC7BR,KAAK,GAAG,IAAI;QACZ,OAAO,IAAI;MACf;MAEA,OAAO,KAAK;IAChB;EACJ,CAAC;EAED,OAAO,IAAIa,OAAO,CAACC,OAAO,IAAI;IAE1B;IACA,MAAMC,UAAU,GAAG/C,MAAM,CAACgD,UAAU,CAACjC,QAAQ,EAAEsB,cAAc,CAAC;IAE9DU,UAAU,CAACE,EAAE,CAAC,MAAM,EAAE,MAAM;MACxBF,UAAU,CAACG,OAAO,CAAC,CAAC;MACpBJ,OAAO,CAAC,IAAI,CAAC;IACjB,CAAC,CAAC;;IAEF;IACAC,UAAU,CAACE,EAAE,CAAC,OAAO,EAAE,MAAM,CAAE,CAAC,CAAC;IAEjCF,UAAU,CAACE,EAAE,CAAC,KAAK,EAAE,MAAM;MACvBH,OAAO,CAAC,KAAK,CAAC;IAClB,CAAC,CAAC;IACFC,UAAU,CAACI,IAAI,CAAC,CAAC;EACrB,CAAC,CAAC;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,UAAUA,CAAC;EACtBrC,QAAQ;EACRE,QAAQ;EACRC,WAAW;EACXmC,OAAO;EACPC;AACJ,CAAC,EAAE;EAEC,IAAIrC,QAAQ,CAACsC,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO,EAAE;EACb;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,kBAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC;EACpC,MAAMC,QAAQ,GAAGzC,QAAQ,CAAC0C,GAAG,CAAC,CAAClD,OAAO,EAAEmD,CAAC,KAAK;IAC1C,MAAM3B,YAAY,GAAGzC,IAAI,CAAC0C,UAAU,CAACzB,OAAO,CAAC,GACvCkB,gBAAgB,CAACnC,IAAI,CAAC2C,QAAQ,CAACpB,QAAQ,EAAEN,OAAO,CAAC,CAAC,GAClDA,OAAO;IAEb+C,kBAAkB,CAACK,GAAG,CAAC5B,YAAY,EAAEhB,QAAQ,CAAC2C,CAAC,CAAC,CAAC;IAEjD,OAAO,IAAIzD,SAAS,CAAC8B,YAAY,EAAE7B,iBAAiB,CAAC;EACzD,CAAC,CAAC;;EAEF;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMY,iBAAiB,GAAG,IAAI8C,GAAG,CAAC,CAAC,GAAGN,kBAAkB,CAACO,IAAI,CAAC,CAAC,CAAC,CAAC;EAEjE,MAAMC,SAAS,GAAG,CAAC,MAAM,IAAInB,OAAO,CAAC,CAACC,OAAO,EAAEmB,MAAM,KAAK;IAEtD,IAAIC,eAAe,GAAG,KAAK;;IAE3B;AACR;AACA;AACA;AACA;IACQ,SAASC,UAAUA,CAACC,MAAM,EAAE;MACxB,OAAO,CAAC,GAAGC,IAAI,KAAK;QAEhB;QACA,IAAI,CAACH,eAAe,EAAE;UAClB,IAAI;YACA,OAAOE,MAAM,CAAC,GAAGC,IAAI,CAAC;UAC1B,CAAC,CAAC,OAAOC,KAAK,EAAE;YACZJ,eAAe,GAAG,IAAI;YACtBD,MAAM,CAACK,KAAK,CAAC;UACjB;QACJ;QACA,OAAO,KAAK;MAChB,CAAC;IACL;IAEAtE,MAAM,CAACuE,IAAI,CACPxD,QAAQ,EACR;MACIuB,UAAU,EAAE6B,UAAU,CAAC5B,KAAK,IAAI;QAC5B,MAAMC,YAAY,GAAGb,gBAAgB,CAACnC,IAAI,CAAC2C,QAAQ,CAACpB,QAAQ,EAAEwB,KAAK,CAAC/C,IAAI,CAAC,CAAC;QAC1E,MAAMgF,cAAc,GAAGd,QAAQ,CAACe,IAAI,CAACrC,OAAO,IAAIA,OAAO,CAACK,KAAK,CAACD,YAAY,EAAE,IAAI,CAAC,CAAC;QAElF,OAAOgC,cAAc,IAAI,CAACnB,OAAO,CAACqB,kBAAkB,CAACnC,KAAK,CAAC/C,IAAI,CAAC;MACpE,CAAC,CAAC;MACFkD,WAAW,EAAEyB,UAAU,CAAC5B,KAAK,IAAI;QAC7B,MAAMC,YAAY,GAAGb,gBAAgB,CAACnC,IAAI,CAAC2C,QAAQ,CAACpB,QAAQ,EAAEwB,KAAK,CAAC/C,IAAI,CAAC,CAAC;;QAE1E;QACA,IAAI+C,KAAK,CAACI,MAAM,CAACC,WAAW,CAAC,CAAC,EAAE;UAC5B,OAAO,KAAK;QAChB;;QAEA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACoB,MAAM4B,cAAc,GAAGxD,iBAAiB,CAAC2D,IAAI,GAAG,CAAC,GAC3CjB,QAAQ,CAACkB,MAAM,CAAC,CAACC,aAAa,EAAEzC,OAAO,KAAK;UAC1C,MAAM0C,WAAW,GAAG1C,OAAO,CAACK,KAAK,CAACD,YAAY,CAAC;;UAE/C;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UAC4B,IAAIsC,WAAW,IAAI,CAACzB,OAAO,CAAC0B,aAAa,CAACxC,KAAK,CAAC/C,IAAI,CAAC,EAAE;YACnDwB,iBAAiB,CAACgE,MAAM,CAAC5C,OAAO,CAAC3B,OAAO,CAAC;UAC7C;UAEA,OAAOqE,WAAW,IAAID,aAAa;QACvC,CAAC,EAAE,KAAK,CAAC,GACPnB,QAAQ,CAACe,IAAI,CAACrC,OAAO,IAAIA,OAAO,CAACK,KAAK,CAACD,YAAY,CAAC,CAAC;QAE3D,OAAOgC,cAAc,IAAI,CAACnB,OAAO,CAAC0B,aAAa,CAACxC,KAAK,CAAC/C,IAAI,CAAC;MAC/D,CAAC;IACL,CAAC,EACD,CAAC8E,KAAK,EAAEW,OAAO,KAAK;MAEhB;MACA,IAAIX,KAAK,EAAE;QACPL,MAAM,CAACK,KAAK,CAAC;MACjB,CAAC,MAAM;QACHxB,OAAO,CAACmC,OAAO,CAAC;MACpB;IACJ,CACJ,CAAC;EACL,CAAC,CAAC,EAAEtB,GAAG,CAACpB,KAAK,IAAIA,KAAK,CAAC/C,IAAI,CAAC;;EAE5B;EACA,IAAI8D,uBAAuB,IAAItC,iBAAiB,CAAC2D,IAAI,GAAG,CAAC,EAAE;IACvD,MAAM,IAAI7D,4BAA4B,CAAC;MACnCC,QAAQ;MACRC,iBAAiB,EAAE,CAAC,GAAGA,iBAAiB,CAAC,CAAC2C,GAAG,CACzClD,OAAO,IAAI+C,kBAAkB,CAAC0B,GAAG,CAACzE,OAAO,CAC7C,CAAC;MACDQ,QAAQ;MACRC;IACJ,CAAC,CAAC;EACN;EAEA,OAAO8C,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAemB,8BAA8BA,CAAC;EAC1CpE,QAAQ;EACRE,QAAQ;EACRC,WAAW;EACXF;AACJ,CAAC,EAAE;EAEC,MAAMP,OAAO,GAAGO,iBAAiB,CAAC,CAAC,CAAC;EACpC,MAAMoE,UAAU,GAAGlE,WAAW,CAACD,QAAQ,CAACoE,OAAO,CAAC5E,OAAO,CAAC,CAAC;EAEzD,MAAM6E,eAAe,GAAG,MAAMvD,SAAS,CAAC;IACpChB,QAAQ;IACRN;EACJ,CAAC,CAAC;EAEF,IAAI6E,eAAe,EAAE;IACjB,MAAM,IAAInE,oBAAoB,CAACiE,UAAU,CAAC;EAC9C;;EAEA;EACA,MAAM,IAAI9E,iBAAiB,CAAC8E,UAAU,EAAE,IAAI,CAAC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeG,eAAeA,CAAC;EAAEC,QAAQ;EAAEnC,OAAO;EAAEC;AAAwB,CAAC,EAAE;EAE3E;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMmC,kBAAkB,GAAG,CAAC,GAAGD,QAAQ,CAAC,CAAC7B,GAAG,CACxC,CAAC,CAAC5C,QAAQ,EAAE;IAAEE,QAAQ;IAAEC;EAAY,CAAC,CAAC,MAAM;IAAEH,QAAQ;IAAEE,QAAQ;IAAEC;EAAY,CAAC,CACnF,CAAC,CAACkD,MAAM,CAAC,CAAC;IAAEnD;EAAS,CAAC,KAAKA,QAAQ,CAACsC,MAAM,GAAG,CAAC,CAAC;EAE/C,MAAMmC,OAAO,GAAG,MAAM7C,OAAO,CAAC8C,UAAU,CACpCF,kBAAkB,CAAC9B,GAAG,CAClB,CAAC;IAAE5C,QAAQ;IAAEE,QAAQ;IAAEC;EAAY,CAAC,KAAKkC,UAAU,CAAC;IAChDrC,QAAQ;IACRE,QAAQ;IACRC,WAAW;IACXmC,OAAO;IACPC;EACJ,CAAC,CACL,CACJ,CAAC;EAED,MAAMU,SAAS,GAAG,EAAE;EAEpB,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,OAAO,CAACnC,MAAM,EAAEK,CAAC,EAAE,EAAE;IAErC,MAAMgC,MAAM,GAAGF,OAAO,CAAC9B,CAAC,CAAC;IACzB,MAAMiC,aAAa,GAAGJ,kBAAkB,CAAC7B,CAAC,CAAC;IAE3C,IAAIgC,MAAM,CAACE,MAAM,KAAK,WAAW,EAAE;MAE/B;MACA,IAAIF,MAAM,CAACG,KAAK,CAACxC,MAAM,GAAG,CAAC,EAAE;QACzBS,SAAS,CAACgC,IAAI,CAAC,GAAGJ,MAAM,CAACG,KAAK,CAAC;MACnC;MAEA;IACJ;;IAEA;IACA,MAAMzB,KAAK,GAAGsB,MAAM,CAACK,MAAM;;IAE3B;IACA,IAAI,CAAC3B,KAAK,CAACvD,QAAQ,EAAE;MACjB,MAAMuD,KAAK;IACf;IAEA,IAAIhB,uBAAuB,EAAE;MAEzB,MAAM6B,8BAA8B,CAAC;QACjC,GAAGU,aAAa;QAChB7E,iBAAiB,EAAEsD,KAAK,CAACtD;MAC7B,CAAC,CAAC;IAEN;EAEJ;EAEA,OAAOgD,SAAS;AAEpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAekC,SAASA,CAAC;EACrBjF,QAAQ;EACRkF,cAAc;EACdC,GAAG;EACH/C,OAAO;EACPC;AACJ,CAAC,EAAE;EAEC,MAAMoC,OAAO,GAAG,EAAE;EAClB,MAAMW,eAAe,GAAG,EAAE;EAC1B,IAAIC,cAAc,GAAG,EAAE;EACvB,IAAIpF,WAAW,GAAG,EAAE;EACpB,MAAMsE,QAAQ,GAAG,IAAI/B,GAAG,CAAC,CAAC,CAAC2C,GAAG,EAAE;IAAEnF,QAAQ,EAAEqF,cAAc;IAAEpF,WAAW,EAAE;EAAG,CAAC,CAAC,CAAC,CAAC;;EAEhF;EACA,MAAM8C,SAAS,GAAG/C,QAAQ,CAAC0C,GAAG,CAAC4C,QAAQ,IAAI/G,IAAI,CAACsD,OAAO,CAACsD,GAAG,EAAEG,QAAQ,CAAC,CAAC;EACvE,MAAMC,KAAK,GAAG,MAAM3D,OAAO,CAAC4D,GAAG,CAC3BzC,SAAS,CAACL,GAAG,CACT4C,QAAQ,IAAI5G,GAAG,CAAC+G,IAAI,CAACH,QAAQ,CAAC,CAACI,KAAK,CAAC,MAAM,CAAE,CAAC,CAClD,CACJ,CAAC;EAEDH,KAAK,CAACI,OAAO,CAAC,CAACF,IAAI,EAAEG,KAAK,KAAK;IAE3B,MAAMN,QAAQ,GAAGvC,SAAS,CAAC6C,KAAK,CAAC;IACjC,MAAMpG,OAAO,GAAGkB,gBAAgB,CAACV,QAAQ,CAAC4F,KAAK,CAAC,CAAC;IAEjD,IAAIH,IAAI,EAAE;MAEN;MACA,IAAIA,IAAI,CAACI,MAAM,CAAC,CAAC,EAAE;QACfpB,OAAO,CAACM,IAAI,CAACO,QAAQ,CAAC;MAC1B;;MAEA;MACA,IAAIG,IAAI,CAAC9D,WAAW,CAAC,CAAC,EAAE;QAEpB;QACA,IAAI1C,YAAY,CAACqG,QAAQ,EAAEH,GAAG,CAAC,EAAE;UAC7B,CAAC;YAAEnF,QAAQ,EAAEqF,cAAc;YAAEpF;UAAY,CAAC,GAAGsE,QAAQ,CAACN,GAAG,CAACkB,GAAG,CAAC;QAClE,CAAC,MAAM;UACH,IAAI,CAACZ,QAAQ,CAACuB,GAAG,CAACR,QAAQ,CAAC,EAAE;YACzBf,QAAQ,CAAC3B,GAAG,CAAC0C,QAAQ,EAAE;cAAEtF,QAAQ,EAAE,EAAE;cAAEC,WAAW,EAAE;YAAG,CAAC,CAAC;UAC7D;UACA,CAAC;YAAED,QAAQ,EAAEqF,cAAc;YAAEpF;UAAY,CAAC,GAAGsE,QAAQ,CAACN,GAAG,CAACqB,QAAQ,CAAC;QACvE;QAEAD,cAAc,CAACN,IAAI,CAAC,GAAGrE,gBAAgB,CAAC4E,QAAQ,CAAC,KAAK,CAAC;QACvDrF,WAAW,CAAC8E,IAAI,CAACvF,OAAO,CAAC;MAC7B;MAEA;IACJ;;IAEA;IACA,IAAI0F,cAAc,IAAItE,aAAa,CAACpB,OAAO,CAAC,EAAE;MAE1C,MAAMM,QAAQ,GAAGvB,IAAI,CAACsD,OAAO,CAACsD,GAAG,EAAEnG,UAAU,CAACQ,OAAO,CAAC,CAAC;;MAEvD;MACA,IAAIP,YAAY,CAACa,QAAQ,EAAEqF,GAAG,CAAC,EAAE;QAC7B,CAAC;UAAEnF,QAAQ,EAAEqF,cAAc;UAAEpF;QAAY,CAAC,GAAGsE,QAAQ,CAACN,GAAG,CAACkB,GAAG,CAAC;MAClE,CAAC,MAAM;QACH,IAAI,CAACZ,QAAQ,CAACuB,GAAG,CAAChG,QAAQ,CAAC,EAAE;UACzByE,QAAQ,CAAC3B,GAAG,CAAC9C,QAAQ,EAAE;YAAEE,QAAQ,EAAE,EAAE;YAAEC,WAAW,EAAE;UAAG,CAAC,CAAC;QAC7D;QACA,CAAC;UAAED,QAAQ,EAAEqF,cAAc;UAAEpF;QAAY,CAAC,GAAGsE,QAAQ,CAACN,GAAG,CAACnE,QAAQ,CAAC;MACvE;MAEAuF,cAAc,CAACN,IAAI,CAACO,QAAQ,CAAC;MAC7BrF,WAAW,CAAC8E,IAAI,CAACvF,OAAO,CAAC;IAC7B,CAAC,MAAM;MACH4F,eAAe,CAACL,IAAI,CAACvF,OAAO,CAAC;IACjC;EACJ,CAAC,CAAC;;EAEF;EACA,IAAI6C,uBAAuB,IAAI+C,eAAe,CAAC9C,MAAM,EAAE;IACnD,MAAM,IAAIjD,iBAAiB,CAAC+F,eAAe,CAAC,CAAC,CAAC,EAAEF,cAAc,CAAC;EACnE;;EAEA;EACA,MAAMa,aAAa,GAAG,MAAMzB,eAAe,CAAC;IACxCC,QAAQ;IACRnC,OAAO;IACPC;EACJ,CAAC,CAAC;EAEF,OAAO,CACH,GAAG,IAAIQ,GAAG,CAAC,CACP,GAAG4B,OAAO,EACV,GAAGsB,aAAa,CAACrD,GAAG,CAAC4C,QAAQ,IAAI/G,IAAI,CAACsD,OAAO,CAACyD,QAAQ,CAAC,CAAC,CAC3D,CAAC,CACL;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,cAAcA,CAACC,OAAO,EAAE;EAC7B,OAAOA,OAAO,CAACC,QAAQ,KAAK,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACb,QAAQ,EAAEc,OAAO,EAAE;EAC3C,IAAIH,OAAO;EACX,MAAMI,eAAe,GAAGD,OAAO,IAAI7H,IAAI,CAAC+H,OAAO,CAAC/H,IAAI,CAAC2C,QAAQ,CAACkF,OAAO,EAAEd,QAAQ,CAAC,CAAC,CAACiB,KAAK,CAAChI,IAAI,CAACsC,GAAG,CAAC,CAAC2F,QAAQ,CAAC,cAAc,CAAC;EAE1H,IAAIH,eAAe,EAAE;IACjBJ,OAAO,GAAG,iNAAiN;EAC/N,CAAC,MAAM;IACHA,OAAO,GAAG,+JAA+J;EAC7K;EAEA,OAAO;IACHX,QAAQ,EAAE/G,IAAI,CAACsD,OAAO,CAACyD,QAAQ,CAAC;IAChCmB,QAAQ,EAAE,CACN;MACIC,MAAM,EAAE,IAAI;MACZC,KAAK,EAAE,KAAK;MACZT,QAAQ,EAAE,CAAC;MACXD,OAAO;MACPW,QAAQ,EAAE;IACd,CAAC,CACJ;IACDC,kBAAkB,EAAE,EAAE;IACtBC,UAAU,EAAE,CAAC;IACbC,YAAY,EAAE,CAAC;IACfC,eAAe,EAAE,CAAC;IAClBC,iBAAiB,EAAE,CAAC;IACpBC,mBAAmB,EAAE;EACzB,CAAC;AACL;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAC/G,CAAC,EAAE;EAClB,OAAOA,CAAC,KAAK,WAAW,IAAIA,CAAC,KAAK,SAAS,IAAIA,CAAC,KAAK,YAAY,IAAIA,CAAC,KAAK,QAAQ;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASgH,cAAcA,CAAChH,CAAC,EAAE;EACvB,OAAOG,KAAK,CAACC,OAAO,CAACJ,CAAC,CAAC,IAAIA,CAAC,CAACK,KAAK,CAAC0G,SAAS,CAAC;AACjD;;AAEA;AACA;AACA;AACA,MAAME,yBAAyB,SAAS/H,KAAK,CAAC;EAC1CC,WAAWA,CAACkH,QAAQ,EAAE;IAClB,KAAK,CAAC,uBAAuBA,QAAQ,CAACa,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;IACrD,IAAI,CAACC,IAAI,GAAG,wBAAwB;IACpCjI,KAAK,CAACkI,iBAAiB,CAAC,IAAI,EAAEH,yBAAyB,CAAC;EAC5D;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,cAAcA,CAAC;EACpBC,iBAAiB,GAAG,IAAI;EAAE;EAC1BC,UAAU,GAAG,IAAI;EACjBC,KAAK,GAAG,KAAK;EACbC,aAAa,GAAG,cAAc;EAC9BC,aAAa,GAAG,UAAU;EAC1B3C,GAAG,GAAG4C,OAAO,CAAC5C,GAAG,CAAC,CAAC;EACnB9C,uBAAuB,GAAG,IAAI;EAC9B2F,GAAG,GAAG,KAAK;EACXC,QAAQ,GAAG,IAAI;EAAE;EACjB/C,cAAc,GAAG,IAAI;EACrBgD,MAAM,GAAG,IAAI;EACbC,cAAc,GAAG,IAAI;EACrBC,cAAc,GAAG,IAAI;EACrBC,kBAAkB,GAAG,IAAI;EACzBC,OAAO,GAAG,CAAC,CAAC;EACZC,WAAW,GAAG,IAAI;EAClB,GAAGC;AACP,CAAC,EAAE;EACC,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,iBAAiB,GAAGC,MAAM,CAAC7F,IAAI,CAAC0F,cAAc,CAAC;EAErD,IAAIE,iBAAiB,CAACpG,MAAM,IAAI,CAAC,EAAE;IAC/BmG,MAAM,CAAC1D,IAAI,CAAC,oBAAoB2D,iBAAiB,CAACpB,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IAC/D,IAAIoB,iBAAiB,CAAClC,QAAQ,CAAC,WAAW,CAAC,EAAE;MACzCiC,MAAM,CAAC1D,IAAI,CAAC,8EAA8E,CAAC;IAC/F;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,YAAY,CAAC,EAAE;MAC1CiC,MAAM,CAAC1D,IAAI,CAAC,oFAAoF,CAAC;IACrG;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,MAAM,CAAC,EAAE;MACpCiC,MAAM,CAAC1D,IAAI,CAAC,0BAA0B,CAAC;IAC3C;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,YAAY,CAAC,EAAE;MAC1CiC,MAAM,CAAC1D,IAAI,CAAC,gCAAgC,CAAC;IACjD;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,0BAA0B,CAAC,EAAE;MACxDiC,MAAM,CAAC1D,IAAI,CAAC,8CAA8C,CAAC;IAC/D;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,SAAS,CAAC,EAAE;MACvCiC,MAAM,CAAC1D,IAAI,CAAC,qGAAqG,CAAC;IACtH;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,YAAY,CAAC,EAAE;MAC1CiC,MAAM,CAAC1D,IAAI,CAAC,gCAAgC,CAAC;IACjD;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,eAAe,CAAC,EAAE;MAC7CiC,MAAM,CAAC1D,IAAI,CAAC,kGAAkG,CAAC;IACnH;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,QAAQ,CAAC,EAAE;MACtCiC,MAAM,CAAC1D,IAAI,CAAC,mGAAmG,CAAC;IACpH;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,eAAe,CAAC,EAAE;MAC7CiC,MAAM,CAAC1D,IAAI,CAAC,iHAAiH,CAAC;IAClI;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,OAAO,CAAC,EAAE;MACrCiC,MAAM,CAAC1D,IAAI,CAAC,iFAAiF,CAAC;IAClG;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,WAAW,CAAC,EAAE;MACzCiC,MAAM,CAAC1D,IAAI,CAAC,uEAAuE,CAAC;IACxF;IACA,IAAI2D,iBAAiB,CAAClC,QAAQ,CAAC,+BAA+B,CAAC,EAAE;MAC7DiC,MAAM,CAAC1D,IAAI,CAAC,+IAA+I,CAAC;IAChK;EACJ;EACA,IAAI,OAAO2C,iBAAiB,KAAK,SAAS,EAAE;IACxCe,MAAM,CAAC1D,IAAI,CAAC,wCAAwC,CAAC;EACzD;EACA,IAAI,OAAO4C,UAAU,KAAK,QAAQ,EAAE;IAChCc,MAAM,CAAC1D,IAAI,CAAC,yCAAyC,CAAC;EAC1D;EACA,IAAI,OAAO6C,KAAK,KAAK,SAAS,EAAE;IAC5Ba,MAAM,CAAC1D,IAAI,CAAC,4BAA4B,CAAC;EAC7C;EACA,IAAI,CAAC5E,gBAAgB,CAAC0H,aAAa,CAAC,EAAE;IAClCY,MAAM,CAAC1D,IAAI,CAAC,6CAA6C,CAAC;EAC9D;EACA,IACI+C,aAAa,KAAK,UAAU,IAC5BA,aAAa,KAAK,SAAS,EAC7B;IACEW,MAAM,CAAC1D,IAAI,CAAC,2DAA2D,CAAC;EAC5E;EACA,IAAI,CAAC5E,gBAAgB,CAACgF,GAAG,CAAC,IAAI,CAAC5G,IAAI,CAAC0C,UAAU,CAACkE,GAAG,CAAC,EAAE;IACjDsD,MAAM,CAAC1D,IAAI,CAAC,iCAAiC,CAAC;EAClD;EACA,IAAI,OAAO1C,uBAAuB,KAAK,SAAS,EAAE;IAC9CoG,MAAM,CAAC1D,IAAI,CAAC,8CAA8C,CAAC;EAC/D;EACA,IAAI,OAAOiD,GAAG,KAAK,SAAS,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;IACvDS,MAAM,CAAC1D,IAAI,CAAC,wCAAwC,CAAC;EACzD;EACA,IAAIkD,QAAQ,KAAK,IAAI,IAAI,CAACb,cAAc,CAACa,QAAQ,CAAC,EAAE;IAChDQ,MAAM,CAAC1D,IAAI,CAAC,mGAAmG,CAAC;EACpH;EACA,IAAI,OAAOG,cAAc,KAAK,SAAS,EAAE;IACrCuD,MAAM,CAAC1D,IAAI,CAAC,qCAAqC,CAAC;EACtD;EACA,IAAI,OAAOmD,MAAM,KAAK,SAAS,EAAE;IAC7BO,MAAM,CAAC1D,IAAI,CAAC,6BAA6B,CAAC;EAC9C;EACA,IAAI,CAACzE,uBAAuB,CAAC6H,cAAc,CAAC,IAAIA,cAAc,KAAK,IAAI,EAAE;IACrEM,MAAM,CAAC1D,IAAI,CAAC,iEAAiE,CAAC;EAClF;EACA,IAAI,OAAOqD,cAAc,KAAK,QAAQ,EAAE;IACpCK,MAAM,CAAC1D,IAAI,CAAC,6CAA6C,CAAC;EAC9D;EACA,IAAI,CAAC5E,gBAAgB,CAACkI,kBAAkB,CAAC,IAAIA,kBAAkB,KAAK,IAAI,IAAIA,kBAAkB,KAAK,IAAI,EAAE;IACrGI,MAAM,CAAC1D,IAAI,CAAC,iEAAiE,CAAC;EAClF;EACA,IAAI,OAAOuD,OAAO,KAAK,QAAQ,EAAE;IAC7BG,MAAM,CAAC1D,IAAI,CAAC,sCAAsC,CAAC;EACvD,CAAC,MAAM,IAAIuD,OAAO,KAAK,IAAI,IAAIK,MAAM,CAAC7F,IAAI,CAACwF,OAAO,CAAC,CAAC9B,QAAQ,CAAC,EAAE,CAAC,EAAE;IAC9DiC,MAAM,CAAC1D,IAAI,CAAC,6CAA6C,CAAC;EAC9D;EACA,IAAIxE,KAAK,CAACC,OAAO,CAAC8H,OAAO,CAAC,EAAE;IACxBG,MAAM,CAAC1D,IAAI,CAAC,iHAAiH,CAAC;EAClI;EACA,IAAI,OAAOwD,WAAW,KAAK,SAAS,EAAE;IAClCE,MAAM,CAAC1D,IAAI,CAAC,kCAAkC,CAAC;EACnD;EACA,IAAI0D,MAAM,CAACnG,MAAM,GAAG,CAAC,EAAE;IACnB,MAAM,IAAI+E,yBAAyB,CAACoB,MAAM,CAAC;EAC/C;EAEA,OAAO;IACHf,iBAAiB;IACjBC,UAAU;IACVC,KAAK;IACLC,aAAa;IACbC,aAAa;IAEb;IACAc,UAAU,EAAEP,kBAAkB,KAAK,IAAI,GAAG,KAAK,GAAGA,kBAAkB;IACpED,cAAc;IACdjD,GAAG,EAAE5G,IAAI,CAACsK,SAAS,CAAC1D,GAAG,CAAC;IACxB9C,uBAAuB;IACvB2F,GAAG;IACHC,QAAQ;IACR/C,cAAc;IACdgD,MAAM;IACNC,cAAc;IACdI;EACJ,CAAC;AACL;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,YAAYA,CAACC,SAAS,EAAE5D,GAAG,EAAE;EAElC;AACJ;AACA;AACA;EACI,MAAM6D,mBAAmB,GAAGzK,IAAI,CAACsK,SAAS,CAACE,SAAS,CAAC;EAErD,MAAME,iBAAiB,GAAG1K,IAAI,CAACsD,OAAO,CAACsD,GAAG,EAAE6D,mBAAmB,CAAC;EAChE,MAAME,mBAAmB,GAAGF,mBAAmB,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK5K,IAAI,CAACsC,GAAG;;EAEtE;AACJ;AACA;AACA;EACI,SAASuI,wBAAwBA,CAAA,EAAG;IAChC,OAAO7K,IAAI,CAAC+I,IAAI,CAAC2B,iBAAiB,EAAE,UAAUpK,IAAI,CAACsG,GAAG,CAAC,EAAE,CAAC;EAC9D;EAEA,IAAIkE,SAAS;EAEb,IAAI;IACAA,SAAS,GAAG5K,EAAE,CAAC6K,SAAS,CAACL,iBAAiB,CAAC;EAC/C,CAAC,CAAC,MAAM;IACJI,SAAS,GAAG,IAAI;EACpB;;EAGA;AACJ;AACA;AACA;AACA;EACI,IAAIA,SAAS,EAAE;IAEX;AACR;AACA;AACA;AACA;IACQ,IAAIA,SAAS,CAAC1H,WAAW,CAAC,CAAC,IAAIuH,mBAAmB,EAAE;MAChD,OAAOE,wBAAwB,CAAC,CAAC;IACrC;;IAEA;IACA,OAAOH,iBAAiB;EAC5B;;EAEA;AACJ;AACA;AACA;AACA;;EAEI;EACA,IAAIC,mBAAmB,EAAE;IACrB,OAAOE,wBAAwB,CAAC,CAAC;EACrC;EAEA,OAAOH,iBAAiB;AAC5B;;AAGA;AACA;AACA;;AAEAM,MAAM,CAACC,OAAO,GAAG;EACb5I,aAAa;EACbqE,SAAS;EAET9E,gBAAgB;EAChBG,uBAAuB;EAEvB6F,kBAAkB;EAClBH,cAAc;EAEdyB,cAAc;EAEdqB;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}