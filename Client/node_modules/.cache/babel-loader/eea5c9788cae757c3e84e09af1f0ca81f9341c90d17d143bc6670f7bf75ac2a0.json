{"ast":null,"code":"/**\n * @fileoverview A rule to disallow `this` keywords in contexts where the value of `this` is `undefined`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given code path is a code path with lexical `this` binding.\n * That is, if `this` within the code path refers to `this` of surrounding code path.\n * @param {CodePath} codePath Code path.\n * @param {ASTNode} node Node that started the code path.\n * @returns {boolean} `true` if it is a code path with lexical `this` binding.\n */\nfunction isCodePathWithLexicalThis(codePath, node) {\n  return codePath.origin === \"function\" && node.type === \"ArrowFunctionExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow use of `this` in contexts where the value of `this` is `undefined`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-invalid-this\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        capIsConstructor: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedThis: \"Unexpected 'this'.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const capIsConstructor = options.capIsConstructor !== false;\n    const stack = [],\n      sourceCode = context.sourceCode;\n\n    /**\n     * Gets the current checking context.\n     *\n     * The return value has a flag that whether or not `this` keyword is valid.\n     * The flag is initialized when got at the first time.\n     * @returns {{valid: boolean}}\n     *   an object which has a flag that whether or not `this` keyword is valid.\n     */\n    stack.getCurrent = function () {\n      const current = this[this.length - 1];\n      if (!current.init) {\n        current.init = true;\n        current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode, {\n          capIsConstructor\n        });\n      }\n      return current;\n    };\n    return {\n      onCodePathStart(codePath, node) {\n        if (isCodePathWithLexicalThis(codePath, node)) {\n          return;\n        }\n        if (codePath.origin === \"program\") {\n          const scope = sourceCode.getScope(node);\n          const features = context.languageOptions.parserOptions.ecmaFeatures || {};\n\n          // `this` at the top level of scripts always refers to the global object\n          stack.push({\n            init: true,\n            node,\n            valid: !(node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict)\n          });\n          return;\n        }\n\n        /*\n         * `init: false` means that `valid` isn't determined yet.\n         * Most functions don't use `this`, and the calculation for `valid`\n         * is relatively costly, so we'll calculate it lazily when the first\n         * `this` within the function is traversed. A special case are non-strict\n         * functions, because `this` refers to the global object and therefore is\n         * always valid, so we can set `init: true` right away.\n         */\n        stack.push({\n          init: !sourceCode.getScope(node).isStrict,\n          node,\n          valid: true\n        });\n      },\n      onCodePathEnd(codePath, node) {\n        if (isCodePathWithLexicalThis(codePath, node)) {\n          return;\n        }\n        stack.pop();\n      },\n      // Reports if `this` of the current context is invalid.\n      ThisExpression(node) {\n        const current = stack.getCurrent();\n        if (current && !current.valid) {\n          context.report({\n            node,\n            messageId: \"unexpectedThis\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isCodePathWithLexicalThis","codePath","node","origin","type","module","exports","meta","docs","description","recommended","url","schema","properties","capIsConstructor","default","additionalProperties","messages","unexpectedThis","create","context","options","stack","sourceCode","getCurrent","current","length","init","valid","isDefaultThisBinding","onCodePathStart","scope","getScope","features","languageOptions","parserOptions","ecmaFeatures","push","sourceType","globalReturn","childScopes","isStrict","onCodePathEnd","pop","ThisExpression","report","messageId"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-invalid-this.js"],"sourcesContent":["/**\n * @fileoverview A rule to disallow `this` keywords in contexts where the value of `this` is `undefined`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given code path is a code path with lexical `this` binding.\n * That is, if `this` within the code path refers to `this` of surrounding code path.\n * @param {CodePath} codePath Code path.\n * @param {ASTNode} node Node that started the code path.\n * @returns {boolean} `true` if it is a code path with lexical `this` binding.\n */\nfunction isCodePathWithLexicalThis(codePath, node) {\n    return codePath.origin === \"function\" && node.type === \"ArrowFunctionExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow use of `this` in contexts where the value of `this` is `undefined`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-invalid-this\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    capIsConstructor: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedThis: \"Unexpected 'this'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const capIsConstructor = options.capIsConstructor !== false;\n        const stack = [],\n            sourceCode = context.sourceCode;\n\n        /**\n         * Gets the current checking context.\n         *\n         * The return value has a flag that whether or not `this` keyword is valid.\n         * The flag is initialized when got at the first time.\n         * @returns {{valid: boolean}}\n         *   an object which has a flag that whether or not `this` keyword is valid.\n         */\n        stack.getCurrent = function() {\n            const current = this[this.length - 1];\n\n            if (!current.init) {\n                current.init = true;\n                current.valid = !astUtils.isDefaultThisBinding(\n                    current.node,\n                    sourceCode,\n                    { capIsConstructor }\n                );\n            }\n            return current;\n        };\n\n        return {\n\n            onCodePathStart(codePath, node) {\n                if (isCodePathWithLexicalThis(codePath, node)) {\n                    return;\n                }\n\n                if (codePath.origin === \"program\") {\n                    const scope = sourceCode.getScope(node);\n                    const features = context.languageOptions.parserOptions.ecmaFeatures || {};\n\n                    // `this` at the top level of scripts always refers to the global object\n                    stack.push({\n                        init: true,\n                        node,\n                        valid: !(\n                            node.sourceType === \"module\" ||\n                            (features.globalReturn && scope.childScopes[0].isStrict)\n                        )\n                    });\n\n                    return;\n                }\n\n                /*\n                 * `init: false` means that `valid` isn't determined yet.\n                 * Most functions don't use `this`, and the calculation for `valid`\n                 * is relatively costly, so we'll calculate it lazily when the first\n                 * `this` within the function is traversed. A special case are non-strict\n                 * functions, because `this` refers to the global object and therefore is\n                 * always valid, so we can set `init: true` right away.\n                 */\n                stack.push({\n                    init: !sourceCode.getScope(node).isStrict,\n                    node,\n                    valid: true\n                });\n            },\n\n            onCodePathEnd(codePath, node) {\n                if (isCodePathWithLexicalThis(codePath, node)) {\n                    return;\n                }\n\n                stack.pop();\n            },\n\n            // Reports if `this` of the current context is invalid.\n            ThisExpression(node) {\n                const current = stack.getCurrent();\n\n                if (current && !current.valid) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedThis\"\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}