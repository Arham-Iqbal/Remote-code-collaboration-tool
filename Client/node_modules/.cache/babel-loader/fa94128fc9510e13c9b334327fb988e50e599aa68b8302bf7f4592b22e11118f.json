{"ast":null,"code":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjectPatterns = {\n  anyOf: [{\n    type: \"array\",\n    items: {\n      type: \"string\"\n    },\n    uniqueItems: true\n  }, {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        group: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        importNamePattern: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        caseSensitive: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false,\n      required: [\"group\"]\n    },\n    uniqueItems: true\n  }]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow specified modules when loaded by `import`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n      patternAndImportName: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternAndImportNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n      patternAndEverything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.\",\n      patternAndEverythingWithRegexImportName: \"* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternAndEverythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternAndEverythingWithRegexImportNameAndCustomMessage: \"* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used. {{customMessage}}\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n      importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStringsOrObjectPatterns\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n      return memo;\n    }, {});\n\n    // Handle patterns too, either as strings or groups\n    let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n    // standardize to array of objects if we have an array of strings\n    if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\n      restrictedPatterns = [{\n        group: restrictedPatterns\n      }];\n    }\n\n    // relative paths are supported for this rule\n    const restrictedPatternGroups = restrictedPatterns.map(({\n      group,\n      message,\n      caseSensitive,\n      importNames,\n      importNamePattern\n    }) => ({\n      matcher: ignore({\n        allowRelativePaths: true,\n        ignorecase: !caseSensitive\n      }).add(group),\n      customMessage: message,\n      importNames,\n      importNamePattern\n    }));\n\n    // if no imports are restricted we don't need to check\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n      return {};\n    }\n\n    /**\n     * Report a restricted path.\n     * @param {string} importSource path of the import\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n    function checkRestrictedPathAndReport(importSource, importNames, node) {\n      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        return;\n      }\n      const customMessage = restrictedPathMessages[importSource].message;\n      const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n      if (restrictedImportNames) {\n        if (importNames.has(\"*\")) {\n          const specifierData = importNames.get(\"*\")[0];\n          context.report({\n            node,\n            messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n            loc: specifierData.loc,\n            data: {\n              importSource,\n              importNames: restrictedImportNames,\n              customMessage\n            }\n          });\n        }\n        restrictedImportNames.forEach(importName => {\n          if (importNames.has(importName)) {\n            const specifiers = importNames.get(importName);\n            specifiers.forEach(specifier => {\n              context.report({\n                node,\n                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                loc: specifier.loc,\n                data: {\n                  importSource,\n                  customMessage,\n                  importName\n                }\n              });\n            });\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n      }\n    }\n\n    /**\n     * Report a restricted path specifically for patterns.\n     * @param {node} node representing the restricted path reference\n     * @param {Object} group contains an Ignore instance for paths, the customMessage to show on failure,\n     * and any restricted import names that have been specified in the config\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n     * @returns {void}\n     * @private\n     */\n    function reportPathForPatterns(node, group, importNames) {\n      const importSource = node.source.value.trim();\n      const customMessage = group.customMessage;\n      const restrictedImportNames = group.importNames;\n      const restrictedImportNamePattern = group.importNamePattern ? new RegExp(group.importNamePattern, \"u\") : null;\n\n      /*\n       * If we are not restricting to any specific import names and just the pattern itself,\n       * report the error and move on\n       */\n      if (!restrictedImportNames && !restrictedImportNamePattern) {\n        context.report({\n          node,\n          messageId: customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n        return;\n      }\n      importNames.forEach((specifiers, importName) => {\n        if (importName === \"*\") {\n          const [specifier] = specifiers;\n          if (restrictedImportNames) {\n            context.report({\n              node,\n              messageId: customMessage ? \"patternAndEverythingWithCustomMessage\" : \"patternAndEverything\",\n              loc: specifier.loc,\n              data: {\n                importSource,\n                importNames: restrictedImportNames,\n                customMessage\n              }\n            });\n          } else {\n            context.report({\n              node,\n              messageId: customMessage ? \"patternAndEverythingWithRegexImportNameAndCustomMessage\" : \"patternAndEverythingWithRegexImportName\",\n              loc: specifier.loc,\n              data: {\n                importSource,\n                importNames: restrictedImportNamePattern,\n                customMessage\n              }\n            });\n          }\n          return;\n        }\n        if (restrictedImportNames && restrictedImportNames.includes(importName) || restrictedImportNamePattern && restrictedImportNamePattern.test(importName)) {\n          specifiers.forEach(specifier => {\n            context.report({\n              node,\n              messageId: customMessage ? \"patternAndImportNameWithCustomMessage\" : \"patternAndImportName\",\n              loc: specifier.loc,\n              data: {\n                importSource,\n                customMessage,\n                importName\n              }\n            });\n          });\n        }\n      });\n    }\n\n    /**\n     * Check if the given importSource is restricted by a pattern.\n     * @param {string} importSource path of the import\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n     * @returns {boolean} whether the variable is a restricted pattern or not\n     * @private\n     */\n    function isRestrictedPattern(importSource, group) {\n      return group.matcher.ignores(importSource);\n    }\n\n    /**\n     * Checks a node to see if any problems should be reported.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = new Map();\n      if (node.type === \"ExportAllDeclaration\") {\n        const starToken = sourceCode.getFirstToken(node, 1);\n        importNames.set(\"*\", [{\n          loc: starToken.loc\n        }]);\n      } else if (node.specifiers) {\n        for (const specifier of node.specifiers) {\n          let name;\n          const specifierData = {\n            loc: specifier.loc\n          };\n          if (specifier.type === \"ImportDefaultSpecifier\") {\n            name = \"default\";\n          } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n            name = \"*\";\n          } else if (specifier.imported) {\n            name = astUtils.getModuleExportName(specifier.imported);\n          } else if (specifier.local) {\n            name = astUtils.getModuleExportName(specifier.local);\n          }\n          if (typeof name === \"string\") {\n            if (importNames.has(name)) {\n              importNames.get(name).push(specifierData);\n            } else {\n              importNames.set(name, [specifierData]);\n            }\n          }\n        }\n      }\n      checkRestrictedPathAndReport(importSource, importNames, node);\n      restrictedPatternGroups.forEach(group => {\n        if (isRestrictedPattern(importSource, group)) {\n          reportPathForPatterns(node, group, importNames);\n        }\n      });\n    }\n    return {\n      ImportDeclaration: checkNode,\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n      ExportAllDeclaration: checkNode\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","ignore","arrayOfStringsOrObjects","type","items","anyOf","properties","name","message","minLength","importNames","additionalProperties","required","uniqueItems","arrayOfStringsOrObjectPatterns","minItems","group","importNamePattern","caseSensitive","module","exports","meta","docs","description","recommended","url","messages","path","pathWithCustomMessage","patterns","patternWithCustomMessage","patternAndImportName","patternAndImportNameWithCustomMessage","patternAndEverything","patternAndEverythingWithRegexImportName","patternAndEverythingWithCustomMessage","patternAndEverythingWithRegexImportNameAndCustomMessage","everything","everythingWithCustomMessage","importName","importNameWithCustomMessage","schema","paths","additionalItems","create","context","sourceCode","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPathMessages","reduce","memo","importSource","restrictedPatterns","length","restrictedPatternGroups","map","matcher","allowRelativePaths","ignorecase","add","customMessage","keys","checkRestrictedPathAndReport","node","restrictedImportNames","has","specifierData","get","report","messageId","loc","data","forEach","specifiers","specifier","reportPathForPatterns","source","value","trim","restrictedImportNamePattern","RegExp","includes","test","isRestrictedPattern","ignores","checkNode","Map","starToken","getFirstToken","set","imported","getModuleExportName","local","push","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-restricted-imports.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjectPatterns = {\n    anyOf: [\n        {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    group: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    importNamePattern: {\n                        type: \"string\"\n                    },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    caseSensitive: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false,\n                required: [\"group\"]\n            },\n            uniqueItems: true\n        }\n    ]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified modules when loaded by `import`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n\n            patternAndImportName: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndImportNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n\n            patternAndEverything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.\",\n\n            patternAndEverythingWithRegexImportName: \"* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndEverythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndEverythingWithRegexImportNameAndCustomMessage: \"* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used. {{customMessage}}\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStringsOrObjectPatterns\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        // Handle patterns too, either as strings or groups\n        let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        // standardize to array of objects if we have an array of strings\n        if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\n            restrictedPatterns = [{ group: restrictedPatterns }];\n        }\n\n        // relative paths are supported for this rule\n        const restrictedPatternGroups = restrictedPatterns.map(({ group, message, caseSensitive, importNames, importNamePattern }) => ({\n            matcher: ignore({ allowRelativePaths: true, ignorecase: !caseSensitive }).add(group),\n            customMessage: message,\n            importNames,\n            importNamePattern\n        }));\n\n        // if no imports are restricted we don't need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n            return {};\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\n            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                return;\n            }\n\n            const customMessage = restrictedPathMessages[importSource].message;\n            const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n            if (restrictedImportNames) {\n                if (importNames.has(\"*\")) {\n                    const specifierData = importNames.get(\"*\")[0];\n\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                        loc: specifierData.loc,\n                        data: {\n                            importSource,\n                            importNames: restrictedImportNames,\n                            customMessage\n                        }\n                    });\n                }\n\n                restrictedImportNames.forEach(importName => {\n                    if (importNames.has(importName)) {\n                        const specifiers = importNames.get(importName);\n\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName\n                                }\n                            });\n                        });\n                    }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n            }\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @param {Object} group contains an Ignore instance for paths, the customMessage to show on failure,\n         * and any restricted import names that have been specified in the config\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node, group, importNames) {\n            const importSource = node.source.value.trim();\n\n            const customMessage = group.customMessage;\n            const restrictedImportNames = group.importNames;\n            const restrictedImportNamePattern = group.importNamePattern ? new RegExp(group.importNamePattern, \"u\") : null;\n\n            /*\n             * If we are not restricting to any specific import names and just the pattern itself,\n             * report the error and move on\n             */\n            if (!restrictedImportNames && !restrictedImportNamePattern) {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n                return;\n            }\n\n            importNames.forEach((specifiers, importName) => {\n                if (importName === \"*\") {\n                    const [specifier] = specifiers;\n\n                    if (restrictedImportNames) {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"patternAndEverythingWithCustomMessage\" : \"patternAndEverything\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                importNames: restrictedImportNames,\n                                customMessage\n                            }\n                        });\n                    } else {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"patternAndEverythingWithRegexImportNameAndCustomMessage\" : \"patternAndEverythingWithRegexImportName\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                importNames: restrictedImportNamePattern,\n                                customMessage\n                            }\n                        });\n                    }\n\n                    return;\n                }\n\n                if (\n                    (restrictedImportNames && restrictedImportNames.includes(importName)) ||\n                    (restrictedImportNamePattern && restrictedImportNamePattern.test(importName))\n                ) {\n                    specifiers.forEach(specifier => {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"patternAndImportNameWithCustomMessage\" : \"patternAndImportName\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                customMessage,\n                                importName\n                            }\n                        });\n                    });\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource, group) {\n            return group.matcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = new Map();\n\n            if (node.type === \"ExportAllDeclaration\") {\n                const starToken = sourceCode.getFirstToken(node, 1);\n\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\n            } else if (node.specifiers) {\n                for (const specifier of node.specifiers) {\n                    let name;\n                    const specifierData = { loc: specifier.loc };\n\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        name = \"default\";\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        name = \"*\";\n                    } else if (specifier.imported) {\n                        name = astUtils.getModuleExportName(specifier.imported);\n                    } else if (specifier.local) {\n                        name = astUtils.getModuleExportName(specifier.local);\n                    }\n\n                    if (typeof name === \"string\") {\n                        if (importNames.has(name)) {\n                            importNames.get(name).push(specifierData);\n                        } else {\n                            importNames.set(name, [specifierData]);\n                        }\n                    }\n                }\n            }\n\n            checkRestrictedPathAndReport(importSource, importNames, node);\n            restrictedPatternGroups.forEach(group => {\n                if (isRestrictedPattern(importSource, group)) {\n                    reportPathForPatterns(node, group, importNames);\n                }\n            });\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}