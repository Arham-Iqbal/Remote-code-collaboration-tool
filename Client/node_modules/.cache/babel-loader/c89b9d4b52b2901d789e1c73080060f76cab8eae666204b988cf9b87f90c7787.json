{"ast":null,"code":"/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n  return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n  if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n    return \"Array.\".concat(arrayMethodName);\n  }\n  return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n  let currentNode = node;\n  while (currentNode) {\n    const parent = currentNode.parent;\n    switch (parent.type) {\n      /*\n       * Looks up the destination. e.g.,\n       * foo.every(nativeFoo || function foo() { ... });\n       */\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n      case \"ChainExpression\":\n        currentNode = parent;\n        break;\n\n      /*\n       * If the upper function is IIFE, checks the destination of the return value.\n       * e.g.\n       *   foo.every((function() {\n       *     // setup...\n       *     return function callback() { ... };\n       *   })());\n       */\n      case \"ReturnStatement\":\n        {\n          const func = astUtils.getUpperFunction(parent);\n          if (func === null || !astUtils.isCallee(func)) {\n            return null;\n          }\n          currentNode = func.parent;\n          break;\n        }\n\n      /*\n       * e.g.\n       *   Array.from([], function() {});\n       *   list.every(function() {});\n       */\n      case \"CallExpression\":\n        if (astUtils.isArrayFromMethod(parent.callee)) {\n          if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {\n            return \"from\";\n          }\n        }\n        if (isTargetMethod(parent.callee)) {\n          if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {\n            return astUtils.getStaticPropertyName(parent.callee);\n          }\n        }\n        return null;\n\n      // Otherwise this node is not target.\n      default:\n        return null;\n    }\n  }\n\n  /* c8 ignore next */\n  return null;\n}\n\n/**\n * Checks if the given node is a void expression.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} - `true` if the node is a void expression\n */\nfunction isExpressionVoid(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Fixes the linting error by prepending \"void \" to the given node\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction voidPrependFixer(sourceCode, node, fixer) {\n  const requiresParens =\n  // prepending `void ` will fail if the node has a lower precedence than void\n  astUtils.getPrecedence(node) < astUtils.getPrecedence({\n    type: \"UnaryExpression\",\n    operator: \"void\"\n  }) &&\n  // check if there are parentheses around the node to avoid redundant parentheses\n  !astUtils.isParenthesised(sourceCode, node);\n\n  // avoid parentheses issues\n  const returnOrArrowToken = sourceCode.getTokenBefore(node, node.parent.type === \"ArrowFunctionExpression\" ? astUtils.isArrowToken\n\n  // isReturnToken\n  : token => token.type === \"Keyword\" && token.value === \"return\");\n  const firstToken = sourceCode.getTokenAfter(returnOrArrowToken);\n  const prependSpace =\n  // is return token, as => allows void to be adjacent\n  returnOrArrowToken.value === \"return\" &&\n  // If two tokens (return and \"(\") are adjacent\n  returnOrArrowToken.range[1] === firstToken.range[0];\n  return [fixer.insertTextBefore(firstToken, `${prependSpace ? \" \" : \"\"}void ${requiresParens ? \"(\" : \"\"}`), fixer.insertTextAfter(node, requiresParens ? \")\" : \"\")];\n}\n\n/**\n * Fixes the linting error by `wrapping {}` around the given node's body.\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction curlyWrapFixer(sourceCode, node, fixer) {\n  const arrowToken = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n  const firstToken = sourceCode.getTokenAfter(arrowToken);\n  const lastToken = sourceCode.getLastToken(node);\n  return [fixer.insertTextBefore(firstToken, \"{\"), fixer.insertTextAfter(lastToken, \"}\")];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Enforce `return` statements in callbacks of array methods\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/array-callback-return\"\n    },\n    // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- false positive\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        },\n        checkForEach: {\n          type: \"boolean\",\n          default: false\n        },\n        allowVoid: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n      expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\",\n      wrapBraces: \"Wrap the expression in `{}`.\",\n      prependVoid: \"Prepend `void` to the expression.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false,\n      checkForEach: false,\n      allowVoid: false\n    };\n    const sourceCode = context.sourceCode;\n    let funcInfo = {\n      arrayMethodName: null,\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n    function checkLastSegment(node) {\n      if (!funcInfo.shouldCheck) {\n        return;\n      }\n      const messageAndSuggestions = {\n        messageId: \"\",\n        suggest: []\n      };\n      if (funcInfo.arrayMethodName === \"forEach\") {\n        if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n          if (options.allowVoid) {\n            if (isExpressionVoid(node.body)) {\n              return;\n            }\n            messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n            messageAndSuggestions.suggest = [{\n              messageId: \"wrapBraces\",\n              fix(fixer) {\n                return curlyWrapFixer(sourceCode, node, fixer);\n              }\n            }, {\n              messageId: \"prependVoid\",\n              fix(fixer) {\n                return voidPrependFixer(sourceCode, node.body, fixer);\n              }\n            }];\n          } else {\n            messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n            messageAndSuggestions.suggest = [{\n              messageId: \"wrapBraces\",\n              fix(fixer) {\n                return curlyWrapFixer(sourceCode, node, fixer);\n              }\n            }];\n          }\n        }\n      } else {\n        if (node.body.type === \"BlockStatement\" && isAnySegmentReachable(funcInfo.currentSegments)) {\n          messageAndSuggestions.messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n        }\n      }\n      if (messageAndSuggestions.messageId) {\n        const name = astUtils.getFunctionNameWithKind(node);\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: messageAndSuggestions.messageId,\n          data: {\n            name,\n            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n          },\n          suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null\n        });\n      }\n    }\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        let methodName = null;\n        if (TARGET_NODE_TYPE.test(node.type)) {\n          methodName = getArrayMethodName(node);\n        }\n        funcInfo = {\n          arrayMethodName: methodName,\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: methodName && !node.async && !node.generator,\n          node,\n          currentSegments: new Set()\n        };\n      },\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      onCodePathSegmentStart(segment) {\n        funcInfo.currentSegments.add(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        funcInfo.currentSegments.delete(segment);\n      },\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (!funcInfo.shouldCheck) {\n          return;\n        }\n        funcInfo.hasReturn = true;\n        const messageAndSuggestions = {\n          messageId: \"\",\n          suggest: []\n        };\n        if (funcInfo.arrayMethodName === \"forEach\") {\n          // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n          if (options.checkForEach && node.argument) {\n            if (options.allowVoid) {\n              if (isExpressionVoid(node.argument)) {\n                return;\n              }\n              messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n              messageAndSuggestions.suggest = [{\n                messageId: \"prependVoid\",\n                fix(fixer) {\n                  return voidPrependFixer(sourceCode, node.argument, fixer);\n                }\n              }];\n            } else {\n              messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n            }\n          }\n        } else {\n          // if allowImplicit: false, should also check node.argument\n          if (!options.allowImplicit && !node.argument) {\n            messageAndSuggestions.messageId = \"expectedReturnValue\";\n          }\n        }\n        if (messageAndSuggestions.messageId) {\n          context.report({\n            node,\n            messageId: messageAndSuggestions.messageId,\n            data: {\n              name: astUtils.getFunctionNameWithKind(funcInfo.node),\n              arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n            },\n            suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null\n          });\n        }\n      },\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","TARGET_NODE_TYPE","TARGET_METHODS","isTargetMethod","node","isSpecificMemberAccess","isAnySegmentReachable","segments","segment","reachable","fullMethodName","arrayMethodName","includes","concat","getArrayMethodName","currentNode","parent","type","func","getUpperFunction","isCallee","isArrayFromMethod","callee","arguments","length","getStaticPropertyName","isExpressionVoid","operator","voidPrependFixer","sourceCode","fixer","requiresParens","getPrecedence","isParenthesised","returnOrArrowToken","getTokenBefore","isArrowToken","token","value","firstToken","getTokenAfter","prependSpace","range","insertTextBefore","insertTextAfter","curlyWrapFixer","arrowToken","body","lastToken","getLastToken","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","allowImplicit","default","checkForEach","allowVoid","additionalProperties","messages","expectedAtEnd","expectedInside","expectedReturnValue","expectedNoReturnValue","wrapBraces","prependVoid","create","context","options","funcInfo","upper","codePath","hasReturn","shouldCheck","checkLastSegment","messageAndSuggestions","messageId","suggest","expression","fix","currentSegments","name","getFunctionNameWithKind","report","loc","getFunctionHeadLoc","data","onCodePathStart","methodName","test","async","generator","Set","onCodePathEnd","onUnreachableCodePathSegmentStart","add","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentStart","onCodePathSegmentEnd","ReturnStatement","argument"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/array-callback-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n    if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n        return \"Array.\".concat(arrayMethodName);\n    }\n    return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n            case \"ChainExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return null;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    ) {\n                        return \"from\";\n                    }\n                }\n                if (isTargetMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    ) {\n                        return astUtils.getStaticPropertyName(parent.callee);\n                    }\n                }\n                return null;\n\n            // Otherwise this node is not target.\n            default:\n                return null;\n        }\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Checks if the given node is a void expression.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} - `true` if the node is a void expression\n */\nfunction isExpressionVoid(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Fixes the linting error by prepending \"void \" to the given node\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction voidPrependFixer(sourceCode, node, fixer) {\n\n    const requiresParens =\n\n        // prepending `void ` will fail if the node has a lower precedence than void\n        astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\", operator: \"void\" }) &&\n\n        // check if there are parentheses around the node to avoid redundant parentheses\n        !astUtils.isParenthesised(sourceCode, node);\n\n    // avoid parentheses issues\n    const returnOrArrowToken = sourceCode.getTokenBefore(\n        node,\n        node.parent.type === \"ArrowFunctionExpression\"\n            ? astUtils.isArrowToken\n\n            // isReturnToken\n            : token => token.type === \"Keyword\" && token.value === \"return\"\n    );\n\n    const firstToken = sourceCode.getTokenAfter(returnOrArrowToken);\n\n    const prependSpace =\n\n        // is return token, as => allows void to be adjacent\n        returnOrArrowToken.value === \"return\" &&\n\n        // If two tokens (return and \"(\") are adjacent\n        returnOrArrowToken.range[1] === firstToken.range[0];\n\n    return [\n        fixer.insertTextBefore(firstToken, `${prependSpace ? \" \" : \"\"}void ${requiresParens ? \"(\" : \"\"}`),\n        fixer.insertTextAfter(node, requiresParens ? \")\" : \"\")\n    ];\n}\n\n/**\n * Fixes the linting error by `wrapping {}` around the given node's body.\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction curlyWrapFixer(sourceCode, node, fixer) {\n    const arrowToken = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n    const firstToken = sourceCode.getTokenAfter(arrowToken);\n    const lastToken = sourceCode.getLastToken(node);\n\n    return [\n        fixer.insertTextBefore(firstToken, \"{\"),\n        fixer.insertTextAfter(lastToken, \"}\")\n    ];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Enforce `return` statements in callbacks of array methods\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/array-callback-return\"\n        },\n\n        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- false positive\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    checkForEach: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowVoid: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n            expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\",\n            wrapBraces: \"Wrap the expression in `{}`.\",\n            prependVoid: \"Prepend `void` to the expression.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false, checkForEach: false, allowVoid: false };\n        const sourceCode = context.sourceCode;\n\n        let funcInfo = {\n            arrayMethodName: null,\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n\n            if (!funcInfo.shouldCheck) {\n                return;\n            }\n\n            const messageAndSuggestions = { messageId: \"\", suggest: [] };\n\n            if (funcInfo.arrayMethodName === \"forEach\") {\n                if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n\n                    if (options.allowVoid) {\n                        if (isExpressionVoid(node.body)) {\n                            return;\n                        }\n\n                        messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                        messageAndSuggestions.suggest = [\n                            {\n                                messageId: \"wrapBraces\",\n                                fix(fixer) {\n                                    return curlyWrapFixer(sourceCode, node, fixer);\n                                }\n                            },\n                            {\n                                messageId: \"prependVoid\",\n                                fix(fixer) {\n                                    return voidPrependFixer(sourceCode, node.body, fixer);\n                                }\n                            }\n                        ];\n                    } else {\n                        messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                        messageAndSuggestions.suggest = [{\n                            messageId: \"wrapBraces\",\n                            fix(fixer) {\n                                return curlyWrapFixer(sourceCode, node, fixer);\n                            }\n                        }];\n                    }\n                }\n            } else {\n                if (node.body.type === \"BlockStatement\" && isAnySegmentReachable(funcInfo.currentSegments)) {\n                    messageAndSuggestions.messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n                }\n            }\n\n            if (messageAndSuggestions.messageId) {\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: messageAndSuggestions.messageId,\n                    data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) },\n                    suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n\n                let methodName = null;\n\n                if (TARGET_NODE_TYPE.test(node.type)) {\n                    methodName = getArrayMethodName(node);\n                }\n\n                funcInfo = {\n                    arrayMethodName: methodName,\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        methodName &&\n                        !node.async &&\n                        !node.generator,\n                    node,\n                    currentSegments: new Set()\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n\n                if (!funcInfo.shouldCheck) {\n                    return;\n                }\n\n                funcInfo.hasReturn = true;\n\n                const messageAndSuggestions = { messageId: \"\", suggest: [] };\n\n                if (funcInfo.arrayMethodName === \"forEach\") {\n\n                    // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n                    if (options.checkForEach && node.argument) {\n\n                        if (options.allowVoid) {\n                            if (isExpressionVoid(node.argument)) {\n                                return;\n                            }\n\n                            messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                            messageAndSuggestions.suggest = [{\n                                messageId: \"prependVoid\",\n                                fix(fixer) {\n                                    return voidPrependFixer(sourceCode, node.argument, fixer);\n                                }\n                            }];\n                        } else {\n                            messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                        }\n                    }\n                } else {\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        messageAndSuggestions.messageId = \"expectedReturnValue\";\n                    }\n                }\n\n                if (messageAndSuggestions.messageId) {\n                    context.report({\n                        node,\n                        messageId: messageAndSuggestions.messageId,\n                        data: {\n                            name: astUtils.getFunctionNameWithKind(funcInfo.node),\n                            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n                        },\n                        suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null\n                    });\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}