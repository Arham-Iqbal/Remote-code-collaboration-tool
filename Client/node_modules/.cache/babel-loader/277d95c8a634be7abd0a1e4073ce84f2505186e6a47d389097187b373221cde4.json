{"ast":null,"code":"/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"@eslint-community/regexpp\");\n\n/**\n * @typedef {import('@eslint-community/regexpp').AST.CharacterClass} CharacterClass\n * @typedef {import('@eslint-community/regexpp').AST.ExpressionCharacterClass} ExpressionCharacterClass\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n  return new Set(function* () {\n    yield* setA;\n    yield* setB;\n  }());\n}\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/*\n * Set of characters that require escaping in character classes in `unicodeSets` mode.\n * ( ) [ ] { } / - \\ | are ClassSetSyntaxCharacter\n */\nconst REGEX_CLASSSET_CHARACTER_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"q/[{}|()-\"));\n\n/*\n * A single character set of ClassSetReservedDoublePunctuator.\n * && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~ are ClassSetReservedDoublePunctuator\n */\nconst REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR = new Set(\"!#$%&*+,.:;<=>?@^`~\");\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unnecessary escape characters\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-useless-escape\"\n    },\n    hasSuggestions: true,\n    messages: {\n      unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n      removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n      removeEscapeDoNotKeepSemantics: \"Remove the `\\\\` if it was inserted by mistake.\",\n      escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n    },\n    schema: []\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    const parser = new RegExpParser();\n\n    /**\n     * Reports a node\n     * @param {ASTNode} node The node to report\n     * @param {number} startOffset The backslash's offset from the start of the node\n     * @param {string} character The uselessly escaped character (not including the backslash)\n     * @param {boolean} [disableEscapeBackslashSuggest] `true` if escapeBackslash suggestion should be turned off.\n     * @returns {void}\n     */\n    function report(node, startOffset, character, disableEscapeBackslashSuggest) {\n      const rangeStart = node.range[0] + startOffset;\n      const range = [rangeStart, rangeStart + 1];\n      const start = sourceCode.getLocFromIndex(rangeStart);\n      context.report({\n        node,\n        loc: {\n          start,\n          end: {\n            line: start.line,\n            column: start.column + 1\n          }\n        },\n        messageId: \"unnecessaryEscape\",\n        data: {\n          character\n        },\n        suggest: [{\n          // Removing unnecessary `\\` characters in a directive is not guaranteed to maintain functionality.\n          messageId: astUtils.isDirective(node.parent) ? \"removeEscapeDoNotKeepSemantics\" : \"removeEscape\",\n          fix(fixer) {\n            return fixer.removeRange(range);\n          }\n        }, ...(disableEscapeBackslashSuggest ? [] : [{\n          messageId: \"escapeBackslash\",\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\\\\");\n          }\n        }])]\n      });\n    }\n\n    /**\n     * Checks if the escape character in given string slice is unnecessary.\n     * @private\n     * @param {ASTNode} node node to validate.\n     * @param {string} match string slice to validate.\n     * @returns {void}\n     */\n    function validateString(node, match) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      const escapedChar = match[0][1];\n      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n      let isQuoteEscape;\n      if (isTemplateElement) {\n        isQuoteEscape = escapedChar === \"`\";\n        if (escapedChar === \"$\") {\n          // Warn if `\\$` is not followed by `{`\n          isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n        } else if (escapedChar === \"{\") {\n          /*\n           * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n           * is necessary and the rule should not warn. If preceded by `/$`, the rule\n           * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n           */\n          isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n        }\n      } else {\n        isQuoteEscape = escapedChar === node.raw[0];\n      }\n      if (isUnnecessaryEscape && !isQuoteEscape) {\n        report(node, match.index, match[0].slice(1));\n      }\n    }\n\n    /**\n     * Checks if the escape character in given regexp is unnecessary.\n     * @private\n     * @param {ASTNode} node node to validate.\n     * @returns {void}\n     */\n    function validateRegExp(node) {\n      const {\n        pattern,\n        flags\n      } = node.regex;\n      let patternNode;\n      const unicode = flags.includes(\"u\");\n      const unicodeSets = flags.includes(\"v\");\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, {\n          unicode,\n          unicodeSets\n        });\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      /** @type {(CharacterClass | ExpressionCharacterClass)[]} */\n      const characterClassStack = [];\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),\n        onCharacterClassLeave: () => characterClassStack.shift(),\n        onExpressionCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),\n        onExpressionCharacterClassLeave: () => characterClassStack.shift(),\n        onCharacterEnter(characterNode) {\n          if (!characterNode.raw.startsWith(\"\\\\\")) {\n            // It's not an escaped character.\n            return;\n          }\n          const escapedChar = characterNode.raw.slice(1);\n          if (escapedChar !== String.fromCodePoint(characterNode.value)) {\n            // It's a valid escape.\n            return;\n          }\n          let allowedEscapes;\n          if (characterClassStack.length) {\n            allowedEscapes = unicodeSets ? REGEX_CLASSSET_CHARACTER_ESCAPES : REGEX_GENERAL_ESCAPES;\n          } else {\n            allowedEscapes = REGEX_NON_CHARCLASS_ESCAPES;\n          }\n          if (allowedEscapes.has(escapedChar)) {\n            return;\n          }\n          const reportedIndex = characterNode.start + 1;\n          let disableEscapeBackslashSuggest = false;\n          if (characterClassStack.length) {\n            const characterClassNode = characterClassStack[0];\n            if (escapedChar === \"^\") {\n              /*\n               * The '^' character is also a special case; it must always be escaped outside of character classes, but\n               * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n               * account for this, consider it to be a valid escape character outside of character classes, and filter\n               * out '^' characters that appear at the start of a character class.\n               */\n              if (characterClassNode.start + 1 === characterNode.start) {\n                return;\n              }\n            }\n            if (!unicodeSets) {\n              if (escapedChar === \"-\") {\n                /*\n                 * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                 * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                 * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                 * character class.\n                 */\n                if (characterClassNode.start + 1 !== characterNode.start && characterNode.end !== characterClassNode.end - 1) {\n                  return;\n                }\n              }\n            } else {\n              // unicodeSets mode\n              if (REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR.has(escapedChar)) {\n                // Escaping is valid if it is a ClassSetReservedDoublePunctuator.\n                if (pattern[characterNode.end] === escapedChar) {\n                  return;\n                }\n                if (pattern[characterNode.start - 1] === escapedChar) {\n                  if (escapedChar !== \"^\") {\n                    return;\n                  }\n\n                  // If the previous character is a `negate` caret(`^`), escape to caret is unnecessary.\n\n                  if (!characterClassNode.negate) {\n                    return;\n                  }\n                  const negateCaretIndex = characterClassNode.start + 1;\n                  if (negateCaretIndex < characterNode.start - 1) {\n                    return;\n                  }\n                }\n              }\n              if (characterNode.parent.type === \"ClassIntersection\" || characterNode.parent.type === \"ClassSubtraction\") {\n                disableEscapeBackslashSuggest = true;\n              }\n            }\n          }\n          report(node, reportedIndex, escapedChar, disableEscapeBackslashSuggest);\n        }\n      });\n    }\n\n    /**\n     * Checks if a node has an escape.\n     * @param {ASTNode} node node to check.\n     * @returns {void}\n     */\n    function check(node) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === \"TaggedTemplateExpression\" && node.parent === node.parent.parent.quasi) {\n        // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n        return;\n      }\n      if (typeof node.value === \"string\" || isTemplateElement) {\n        /*\n         * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n         * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n         */\n        if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n          return;\n        }\n        const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n        const pattern = /\\\\[^\\d]/gu;\n        let match;\n        while (match = pattern.exec(value)) {\n          validateString(node, match);\n        }\n      } else if (node.regex) {\n        validateRegExp(node);\n      }\n    }\n    return {\n      Literal: check,\n      TemplateElement: check\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","RegExpParser","visitRegExpAST","union","setA","setB","Set","VALID_STRING_ESCAPES","LINEBREAKS","REGEX_GENERAL_ESCAPES","REGEX_NON_CHARCLASS_ESCAPES","REGEX_CLASSSET_CHARACTER_ESCAPES","REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR","module","exports","meta","type","docs","description","recommended","url","hasSuggestions","messages","unnecessaryEscape","removeEscape","removeEscapeDoNotKeepSemantics","escapeBackslash","schema","create","context","sourceCode","parser","report","node","startOffset","character","disableEscapeBackslashSuggest","rangeStart","range","start","getLocFromIndex","loc","end","line","column","messageId","data","suggest","isDirective","parent","fix","fixer","removeRange","insertTextBeforeRange","validateString","match","isTemplateElement","escapedChar","isUnnecessaryEscape","has","isQuoteEscape","input","index","raw","slice","validateRegExp","pattern","flags","regex","patternNode","unicode","includes","unicodeSets","parsePattern","length","characterClassStack","onCharacterClassEnter","characterClassNode","unshift","onCharacterClassLeave","shift","onExpressionCharacterClassEnter","onExpressionCharacterClassLeave","onCharacterEnter","characterNode","startsWith","String","fromCodePoint","value","allowedEscapes","reportedIndex","negate","negateCaretIndex","check","quasi","getText","exec","Literal","TemplateElement"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-useless-escape.js"],"sourcesContent":["/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"@eslint-community/regexpp\");\n\n/**\n * @typedef {import('@eslint-community/regexpp').AST.CharacterClass} CharacterClass\n * @typedef {import('@eslint-community/regexpp').AST.ExpressionCharacterClass} ExpressionCharacterClass\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/*\n * Set of characters that require escaping in character classes in `unicodeSets` mode.\n * ( ) [ ] { } / - \\ | are ClassSetSyntaxCharacter\n */\nconst REGEX_CLASSSET_CHARACTER_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"q/[{}|()-\"));\n\n/*\n * A single character set of ClassSetReservedDoublePunctuator.\n * && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~ are ClassSetReservedDoublePunctuator\n */\nconst REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR = new Set(\"!#$%&*+,.:;<=>?@^`~\");\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary escape characters\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-escape\"\n        },\n\n        hasSuggestions: true,\n\n        messages: {\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n            removeEscapeDoNotKeepSemantics: \"Remove the `\\\\` if it was inserted by mistake.\",\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const parser = new RegExpParser();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @param {boolean} [disableEscapeBackslashSuggest] `true` if escapeBackslash suggestion should be turned off.\n         * @returns {void}\n         */\n        function report(node, startOffset, character, disableEscapeBackslashSuggest) {\n            const rangeStart = node.range[0] + startOffset;\n            const range = [rangeStart, rangeStart + 1];\n            const start = sourceCode.getLocFromIndex(rangeStart);\n\n            context.report({\n                node,\n                loc: {\n                    start,\n                    end: { line: start.line, column: start.column + 1 }\n                },\n                messageId: \"unnecessaryEscape\",\n                data: { character },\n                suggest: [\n                    {\n\n                        // Removing unnecessary `\\` characters in a directive is not guaranteed to maintain functionality.\n                        messageId: astUtils.isDirective(node.parent)\n                            ? \"removeEscapeDoNotKeepSemantics\" : \"removeEscape\",\n                        fix(fixer) {\n                            return fixer.removeRange(range);\n                        }\n                    },\n                    ...disableEscapeBackslashSuggest\n                        ? []\n                        : [\n                            {\n                                messageId: \"escapeBackslash\",\n                                fix(fixer) {\n                                    return fixer.insertTextBeforeRange(range, \"\\\\\");\n                                }\n                            }\n                        ]\n                ]\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @param {string} match string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if the escape character in given regexp is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @returns {void}\n         */\n        function validateRegExp(node) {\n            const { pattern, flags } = node.regex;\n            let patternNode;\n            const unicode = flags.includes(\"u\");\n            const unicodeSets = flags.includes(\"v\");\n\n            try {\n                patternNode = parser.parsePattern(pattern, 0, pattern.length, { unicode, unicodeSets });\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            /** @type {(CharacterClass | ExpressionCharacterClass)[]} */\n            const characterClassStack = [];\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),\n                onCharacterClassLeave: () => characterClassStack.shift(),\n                onExpressionCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),\n                onExpressionCharacterClassLeave: () => characterClassStack.shift(),\n                onCharacterEnter(characterNode) {\n                    if (!characterNode.raw.startsWith(\"\\\\\")) {\n\n                        // It's not an escaped character.\n                        return;\n                    }\n\n                    const escapedChar = characterNode.raw.slice(1);\n\n                    if (escapedChar !== String.fromCodePoint(characterNode.value)) {\n\n                        // It's a valid escape.\n                        return;\n                    }\n                    let allowedEscapes;\n\n                    if (characterClassStack.length) {\n                        allowedEscapes = unicodeSets ? REGEX_CLASSSET_CHARACTER_ESCAPES : REGEX_GENERAL_ESCAPES;\n                    } else {\n                        allowedEscapes = REGEX_NON_CHARCLASS_ESCAPES;\n                    }\n                    if (allowedEscapes.has(escapedChar)) {\n                        return;\n                    }\n\n                    const reportedIndex = characterNode.start + 1;\n                    let disableEscapeBackslashSuggest = false;\n\n                    if (characterClassStack.length) {\n                        const characterClassNode = characterClassStack[0];\n\n                        if (escapedChar === \"^\") {\n\n                            /*\n                             * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                             * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                             * account for this, consider it to be a valid escape character outside of character classes, and filter\n                             * out '^' characters that appear at the start of a character class.\n                             */\n                            if (characterClassNode.start + 1 === characterNode.start) {\n\n                                return;\n                            }\n                        }\n                        if (!unicodeSets) {\n                            if (escapedChar === \"-\") {\n\n                                /*\n                                 * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                                 * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                                 * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                                 * character class.\n                                 */\n                                if (characterClassNode.start + 1 !== characterNode.start && characterNode.end !== characterClassNode.end - 1) {\n\n                                    return;\n                                }\n                            }\n                        } else { // unicodeSets mode\n                            if (REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR.has(escapedChar)) {\n\n                                // Escaping is valid if it is a ClassSetReservedDoublePunctuator.\n                                if (pattern[characterNode.end] === escapedChar) {\n                                    return;\n                                }\n                                if (pattern[characterNode.start - 1] === escapedChar) {\n                                    if (escapedChar !== \"^\") {\n                                        return;\n                                    }\n\n                                    // If the previous character is a `negate` caret(`^`), escape to caret is unnecessary.\n\n                                    if (!characterClassNode.negate) {\n                                        return;\n                                    }\n                                    const negateCaretIndex = characterClassNode.start + 1;\n\n                                    if (negateCaretIndex < characterNode.start - 1) {\n                                        return;\n                                    }\n                                }\n                            }\n\n                            if (characterNode.parent.type === \"ClassIntersection\" || characterNode.parent.type === \"ClassSubtraction\") {\n                                disableEscapeBackslashSuggest = true;\n                            }\n                        }\n                    }\n\n                    report(\n                        node,\n                        reportedIndex,\n                        escapedChar,\n                        disableEscapeBackslashSuggest\n                    );\n                }\n            });\n        }\n\n        /**\n         * Checks if a node has an escape.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                validateRegExp(node);\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAC7C,MAAM;EAAEC,YAAY;EAAEC;AAAe,CAAC,GAAGF,OAAO,CAAC,2BAA2B,CAAC;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,KAAKA,CAACC,IAAI,EAAEC,IAAI,EAAE;EACvB,OAAO,IAAIC,GAAG,CAAC,aAAa;IACxB,OAAOF,IAAI;IACX,OAAOC,IAAI;EACf,CAAC,CAAC,CAAC,CAAC;AACR;AAEA,MAAME,oBAAoB,GAAGJ,KAAK,CAAC,IAAIG,GAAG,CAAC,YAAY,CAAC,EAAEP,QAAQ,CAACS,UAAU,CAAC;AAC9E,MAAMC,qBAAqB,GAAG,IAAIH,GAAG,CAAC,gCAAgC,CAAC;AACvE,MAAMI,2BAA2B,GAAGP,KAAK,CAACM,qBAAqB,EAAE,IAAIH,GAAG,CAAC,iBAAiB,CAAC,CAAC;;AAE5F;AACA;AACA;AACA;AACA,MAAMK,gCAAgC,GAAGR,KAAK,CAACM,qBAAqB,EAAE,IAAIH,GAAG,CAAC,WAAW,CAAC,CAAC;;AAE3F;AACA;AACA;AACA;AACA,MAAMM,0CAA0C,GAAG,IAAIN,GAAG,CAAC,qBAAqB,CAAC;;AAEjF;AACAO,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YAAY;IAElBC,IAAI,EAAE;MACFC,WAAW,EAAE,wCAAwC;MACrDC,WAAW,EAAE,IAAI;MACjBC,GAAG,EAAE;IACT,CAAC;IAEDC,cAAc,EAAE,IAAI;IAEpBC,QAAQ,EAAE;MACNC,iBAAiB,EAAE,gDAAgD;MACnEC,YAAY,EAAE,4DAA4D;MAC1EC,8BAA8B,EAAE,gDAAgD;MAChFC,eAAe,EAAE;IACrB,CAAC;IAEDC,MAAM,EAAE;EACZ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACC,UAAU;IACrC,MAAMC,MAAM,GAAG,IAAI9B,YAAY,CAAC,CAAC;;IAEjC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAAS+B,MAAMA,CAACC,IAAI,EAAEC,WAAW,EAAEC,SAAS,EAAEC,6BAA6B,EAAE;MACzE,MAAMC,UAAU,GAAGJ,IAAI,CAACK,KAAK,CAAC,CAAC,CAAC,GAAGJ,WAAW;MAC9C,MAAMI,KAAK,GAAG,CAACD,UAAU,EAAEA,UAAU,GAAG,CAAC,CAAC;MAC1C,MAAME,KAAK,GAAGT,UAAU,CAACU,eAAe,CAACH,UAAU,CAAC;MAEpDR,OAAO,CAACG,MAAM,CAAC;QACXC,IAAI;QACJQ,GAAG,EAAE;UACDF,KAAK;UACLG,GAAG,EAAE;YAAEC,IAAI,EAAEJ,KAAK,CAACI,IAAI;YAAEC,MAAM,EAAEL,KAAK,CAACK,MAAM,GAAG;UAAE;QACtD,CAAC;QACDC,SAAS,EAAE,mBAAmB;QAC9BC,IAAI,EAAE;UAAEX;QAAU,CAAC;QACnBY,OAAO,EAAE,CACL;UAEI;UACAF,SAAS,EAAE9C,QAAQ,CAACiD,WAAW,CAACf,IAAI,CAACgB,MAAM,CAAC,GACtC,gCAAgC,GAAG,cAAc;UACvDC,GAAGA,CAACC,KAAK,EAAE;YACP,OAAOA,KAAK,CAACC,WAAW,CAACd,KAAK,CAAC;UACnC;QACJ,CAAC,EACD,IAAGF,6BAA6B,GAC1B,EAAE,GACF,CACE;UACIS,SAAS,EAAE,iBAAiB;UAC5BK,GAAGA,CAACC,KAAK,EAAE;YACP,OAAOA,KAAK,CAACE,qBAAqB,CAACf,KAAK,EAAE,IAAI,CAAC;UACnD;QACJ,CAAC,CACJ;MAEb,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASgB,cAAcA,CAACrB,IAAI,EAAEsB,KAAK,EAAE;MACjC,MAAMC,iBAAiB,GAAGvB,IAAI,CAACjB,IAAI,KAAK,iBAAiB;MACzD,MAAMyC,WAAW,GAAGF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC/B,IAAIG,mBAAmB,GAAG,CAACnD,oBAAoB,CAACoD,GAAG,CAACF,WAAW,CAAC;MAChE,IAAIG,aAAa;MAEjB,IAAIJ,iBAAiB,EAAE;QACnBI,aAAa,GAAGH,WAAW,KAAK,GAAG;QAEnC,IAAIA,WAAW,KAAK,GAAG,EAAE;UAErB;UACAC,mBAAmB,GAAGH,KAAK,CAACM,KAAK,CAACN,KAAK,CAACO,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG;QAC9D,CAAC,MAAM,IAAIL,WAAW,KAAK,GAAG,EAAE;UAE5B;AACpB;AACA;AACA;AACA;UACoBC,mBAAmB,GAAGH,KAAK,CAACM,KAAK,CAACN,KAAK,CAACO,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG;QAC9D;MACJ,CAAC,MAAM;QACHF,aAAa,GAAGH,WAAW,KAAKxB,IAAI,CAAC8B,GAAG,CAAC,CAAC,CAAC;MAC/C;MAEA,IAAIL,mBAAmB,IAAI,CAACE,aAAa,EAAE;QACvC5B,MAAM,CAACC,IAAI,EAAEsB,KAAK,CAACO,KAAK,EAAEP,KAAK,CAAC,CAAC,CAAC,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC;MAChD;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASC,cAAcA,CAAChC,IAAI,EAAE;MAC1B,MAAM;QAAEiC,OAAO;QAAEC;MAAM,CAAC,GAAGlC,IAAI,CAACmC,KAAK;MACrC,IAAIC,WAAW;MACf,MAAMC,OAAO,GAAGH,KAAK,CAACI,QAAQ,CAAC,GAAG,CAAC;MACnC,MAAMC,WAAW,GAAGL,KAAK,CAACI,QAAQ,CAAC,GAAG,CAAC;MAEvC,IAAI;QACAF,WAAW,GAAGtC,MAAM,CAAC0C,YAAY,CAACP,OAAO,EAAE,CAAC,EAAEA,OAAO,CAACQ,MAAM,EAAE;UAAEJ,OAAO;UAAEE;QAAY,CAAC,CAAC;MAC3F,CAAC,CAAC,MAAM;QAEJ;QACA;MACJ;;MAEA;MACA,MAAMG,mBAAmB,GAAG,EAAE;MAE9BzE,cAAc,CAACmE,WAAW,EAAE;QACxBO,qBAAqB,EAAEC,kBAAkB,IAAIF,mBAAmB,CAACG,OAAO,CAACD,kBAAkB,CAAC;QAC5FE,qBAAqB,EAAEA,CAAA,KAAMJ,mBAAmB,CAACK,KAAK,CAAC,CAAC;QACxDC,+BAA+B,EAAEJ,kBAAkB,IAAIF,mBAAmB,CAACG,OAAO,CAACD,kBAAkB,CAAC;QACtGK,+BAA+B,EAAEA,CAAA,KAAMP,mBAAmB,CAACK,KAAK,CAAC,CAAC;QAClEG,gBAAgBA,CAACC,aAAa,EAAE;UAC5B,IAAI,CAACA,aAAa,CAACrB,GAAG,CAACsB,UAAU,CAAC,IAAI,CAAC,EAAE;YAErC;YACA;UACJ;UAEA,MAAM5B,WAAW,GAAG2B,aAAa,CAACrB,GAAG,CAACC,KAAK,CAAC,CAAC,CAAC;UAE9C,IAAIP,WAAW,KAAK6B,MAAM,CAACC,aAAa,CAACH,aAAa,CAACI,KAAK,CAAC,EAAE;YAE3D;YACA;UACJ;UACA,IAAIC,cAAc;UAElB,IAAId,mBAAmB,CAACD,MAAM,EAAE;YAC5Be,cAAc,GAAGjB,WAAW,GAAG7D,gCAAgC,GAAGF,qBAAqB;UAC3F,CAAC,MAAM;YACHgF,cAAc,GAAG/E,2BAA2B;UAChD;UACA,IAAI+E,cAAc,CAAC9B,GAAG,CAACF,WAAW,CAAC,EAAE;YACjC;UACJ;UAEA,MAAMiC,aAAa,GAAGN,aAAa,CAAC7C,KAAK,GAAG,CAAC;UAC7C,IAAIH,6BAA6B,GAAG,KAAK;UAEzC,IAAIuC,mBAAmB,CAACD,MAAM,EAAE;YAC5B,MAAMG,kBAAkB,GAAGF,mBAAmB,CAAC,CAAC,CAAC;YAEjD,IAAIlB,WAAW,KAAK,GAAG,EAAE;cAErB;AAC5B;AACA;AACA;AACA;AACA;cAC4B,IAAIoB,kBAAkB,CAACtC,KAAK,GAAG,CAAC,KAAK6C,aAAa,CAAC7C,KAAK,EAAE;gBAEtD;cACJ;YACJ;YACA,IAAI,CAACiC,WAAW,EAAE;cACd,IAAIf,WAAW,KAAK,GAAG,EAAE;gBAErB;AAChC;AACA;AACA;AACA;AACA;gBACgC,IAAIoB,kBAAkB,CAACtC,KAAK,GAAG,CAAC,KAAK6C,aAAa,CAAC7C,KAAK,IAAI6C,aAAa,CAAC1C,GAAG,KAAKmC,kBAAkB,CAACnC,GAAG,GAAG,CAAC,EAAE;kBAE1G;gBACJ;cACJ;YACJ,CAAC,MAAM;cAAE;cACL,IAAI9B,0CAA0C,CAAC+C,GAAG,CAACF,WAAW,CAAC,EAAE;gBAE7D;gBACA,IAAIS,OAAO,CAACkB,aAAa,CAAC1C,GAAG,CAAC,KAAKe,WAAW,EAAE;kBAC5C;gBACJ;gBACA,IAAIS,OAAO,CAACkB,aAAa,CAAC7C,KAAK,GAAG,CAAC,CAAC,KAAKkB,WAAW,EAAE;kBAClD,IAAIA,WAAW,KAAK,GAAG,EAAE;oBACrB;kBACJ;;kBAEA;;kBAEA,IAAI,CAACoB,kBAAkB,CAACc,MAAM,EAAE;oBAC5B;kBACJ;kBACA,MAAMC,gBAAgB,GAAGf,kBAAkB,CAACtC,KAAK,GAAG,CAAC;kBAErD,IAAIqD,gBAAgB,GAAGR,aAAa,CAAC7C,KAAK,GAAG,CAAC,EAAE;oBAC5C;kBACJ;gBACJ;cACJ;cAEA,IAAI6C,aAAa,CAACnC,MAAM,CAACjC,IAAI,KAAK,mBAAmB,IAAIoE,aAAa,CAACnC,MAAM,CAACjC,IAAI,KAAK,kBAAkB,EAAE;gBACvGoB,6BAA6B,GAAG,IAAI;cACxC;YACJ;UACJ;UAEAJ,MAAM,CACFC,IAAI,EACJyD,aAAa,EACbjC,WAAW,EACXrB,6BACJ,CAAC;QACL;MACJ,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASyD,KAAKA,CAAC5D,IAAI,EAAE;MACjB,MAAMuB,iBAAiB,GAAGvB,IAAI,CAACjB,IAAI,KAAK,iBAAiB;MAEzD,IACIwC,iBAAiB,IACjBvB,IAAI,CAACgB,MAAM,IACXhB,IAAI,CAACgB,MAAM,CAACA,MAAM,IAClBhB,IAAI,CAACgB,MAAM,CAACA,MAAM,CAACjC,IAAI,KAAK,0BAA0B,IACtDiB,IAAI,CAACgB,MAAM,KAAKhB,IAAI,CAACgB,MAAM,CAACA,MAAM,CAAC6C,KAAK,EAC1C;QAEE;QACA;MACJ;MAEA,IAAI,OAAO7D,IAAI,CAACuD,KAAK,KAAK,QAAQ,IAAIhC,iBAAiB,EAAE;QAErD;AAChB;AACA;AACA;QACgB,IAAIvB,IAAI,CAACgB,MAAM,CAACjC,IAAI,KAAK,cAAc,IAAIiB,IAAI,CAACgB,MAAM,CAACjC,IAAI,KAAK,YAAY,IAAIiB,IAAI,CAACgB,MAAM,CAACjC,IAAI,KAAK,aAAa,EAAE;UAChH;QACJ;QAEA,MAAMwE,KAAK,GAAGhC,iBAAiB,GAAG1B,UAAU,CAACiE,OAAO,CAAC9D,IAAI,CAAC,GAAGA,IAAI,CAAC8B,GAAG;QACrE,MAAMG,OAAO,GAAG,WAAW;QAC3B,IAAIX,KAAK;QAET,OAAQA,KAAK,GAAGW,OAAO,CAAC8B,IAAI,CAACR,KAAK,CAAC,EAAG;UAClClC,cAAc,CAACrB,IAAI,EAAEsB,KAAK,CAAC;QAC/B;MACJ,CAAC,MAAM,IAAItB,IAAI,CAACmC,KAAK,EAAE;QACnBH,cAAc,CAAChC,IAAI,CAAC;MACxB;IAEJ;IAEA,OAAO;MACHgE,OAAO,EAAEJ,KAAK;MACdK,eAAe,EAAEL;IACrB,CAAC;EACL;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}