{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require identifiers to match a specified regular expression\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/id-match\"\n    },\n    schema: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        properties: {\n          type: \"boolean\",\n          default: false\n        },\n        classFields: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyDeclarations: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\",\n      notMatchPrivate: \"Identifier '#{{name}}' does not match the pattern '{{pattern}}'.\"\n    }\n  },\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n    const pattern = context.options[0] || \"^.+$\",\n      regexp = new RegExp(pattern, \"u\");\n    const options = context.options[1] || {},\n      checkProperties = !!options.properties,\n      checkClassFields = !!options.classFields,\n      onlyDeclarations = !!options.onlyDeclarations,\n      ignoreDestructuring = !!options.ignoreDestructuring;\n    const sourceCode = context.sourceCode;\n    let globalScope;\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n    const reportedNodes = new Set();\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n    const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n    const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n    /**\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a reference to a global variable.\n     */\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n\n    /**\n     * Checks if a string matches the provided pattern\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is a match\n     * @private\n     */\n    function isInvalid(name) {\n      return !regexp.test(name);\n    }\n\n    /**\n     * Checks if a parent of a node is an ObjectPattern.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} if the node is inside an ObjectPattern\n     * @private\n     */\n    function isInsideObjectPattern(node) {\n      let {\n        parent\n      } = node;\n      while (parent) {\n        if (parent.type === \"ObjectPattern\") {\n          return true;\n        }\n        parent = parent.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Verifies if we should report an error or not based on the effective\n     * parent node and the identifier name.\n     * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n     * @param {string} name The identifier name of the identifier node\n     * @returns {boolean} whether an error should be reported or not\n     */\n    function shouldReport(effectiveParent, name) {\n      return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n    }\n\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n    function report(node) {\n      /*\n       * We used the range instead of the node because it's possible\n       * for the same identifier to be represented by two different\n       * nodes, with the most clear example being shorthand properties:\n       * { foo }\n       * In this case, \"foo\" is represented by one node for the name\n       * and one for the value. The only way to know they are the same\n       * is to look at the range.\n       */\n      if (!reportedNodes.has(node.range.toString())) {\n        const messageId = node.type === \"PrivateIdentifier\" ? \"notMatchPrivate\" : \"notMatch\";\n        context.report({\n          node,\n          messageId,\n          data: {\n            name: node.name,\n            pattern\n          }\n        });\n        reportedNodes.add(node.range.toString());\n      }\n    }\n    return {\n      Program(node) {\n        globalScope = sourceCode.getScope(node);\n      },\n      Identifier(node) {\n        const name = node.name,\n          parent = node.parent,\n          effectiveParent = parent.type === \"MemberExpression\" ? parent.parent : parent;\n        if (isReferenceToGlobalVariable(node)) {\n          return;\n        }\n        if (parent.type === \"MemberExpression\") {\n          if (!checkProperties) {\n            return;\n          }\n\n          // Always check object names\n          if (parent.object.type === \"Identifier\" && parent.object.name === name) {\n            if (isInvalid(name)) {\n              report(node);\n            }\n\n            // Report AssignmentExpressions left side's assigned variable id\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name) {\n            if (isInvalid(name)) {\n              report(node);\n            }\n\n            // Report AssignmentExpressions only if they are the left side of the assignment\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n            if (isInvalid(name)) {\n              report(node);\n            }\n          }\n\n          // For https://github.com/eslint/eslint/issues/15123\n        } else if (parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && parent.key === node && !parent.computed) {\n          if (checkProperties && isInvalid(name)) {\n            report(node);\n          }\n\n          /*\n           * Properties have their own rules, and\n           * AssignmentPattern nodes can be treated like Properties:\n           * e.g.: const { no_camelcased = false } = bar;\n           */\n        } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n          if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n            if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name)) {\n              report(node);\n            }\n            const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n            // prevent checking righthand side of destructured object\n            if (!assignmentKeyEqualsValue && parent.key === node) {\n              return;\n            }\n            const valueIsInvalid = parent.value.name && isInvalid(name);\n\n            // ignore destructuring if the option is set, unless a new identifier is created\n            if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          }\n\n          // never check properties or always ignore destructuring\n          if (!checkProperties && !parent.computed || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          }\n\n          // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n          if (parent.right !== node && shouldReport(effectiveParent, name)) {\n            report(node);\n          }\n\n          // Check if it's an import specifier\n        } else if (IMPORT_TYPES.has(parent.type)) {\n          // Report only if the local imported identifier is invalid\n          if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n            report(node);\n          }\n        } else if (parent.type === \"PropertyDefinition\") {\n          if (checkClassFields && isInvalid(name)) {\n            report(node);\n          }\n\n          // Report anything that is invalid that isn't a CallExpression\n        } else if (shouldReport(effectiveParent, name)) {\n          report(node);\n        }\n      },\n      \"PrivateIdentifier\"(node) {\n        const isClassField = node.parent.type === \"PropertyDefinition\";\n        if (isClassField && !checkClassFields) {\n          return;\n        }\n        if (isInvalid(node.name)) {\n          report(node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","default","classFields","onlyDeclarations","ignoreDestructuring","additionalProperties","messages","notMatch","notMatchPrivate","create","context","pattern","options","regexp","RegExp","checkProperties","checkClassFields","sourceCode","globalScope","reportedNodes","Set","ALLOWED_PARENT_TYPES","DECLARATION_TYPES","IMPORT_TYPES","isReferenceToGlobalVariable","node","variable","set","get","name","defs","length","references","some","ref","identifier","isInvalid","test","isInsideObjectPattern","parent","shouldReport","effectiveParent","has","report","range","toString","messageId","data","add","Program","getScope","Identifier","object","left","property","right","key","computed","shorthand","value","assignmentKeyEqualsValue","valueIsInvalid","local","PrivateIdentifier","isClassField"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/id-match.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require identifiers to match a specified regular expression\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/id-match\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    classFields: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyDeclarations: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\",\n            notMatchPrivate: \"Identifier '#{{name}}' does not match the pattern '{{pattern}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Options\n        //--------------------------------------------------------------------------\n        const pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern, \"u\");\n\n        const options = context.options[1] || {},\n            checkProperties = !!options.properties,\n            checkClassFields = !!options.classFields,\n            onlyDeclarations = !!options.onlyDeclarations,\n            ignoreDestructuring = !!options.ignoreDestructuring;\n\n        const sourceCode = context.sourceCode;\n        let globalScope;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reportedNodes = new Set();\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n        const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n        const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let { parent } = node;\n\n            while (parent) {\n                if (parent.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) &&\n                !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n\n            /*\n             * We used the range instead of the node because it's possible\n             * for the same identifier to be represented by two different\n             * nodes, with the most clear example being shorthand properties:\n             * { foo }\n             * In this case, \"foo\" is represented by one node for the name\n             * and one for the value. The only way to know they are the same\n             * is to look at the range.\n             */\n            if (!reportedNodes.has(node.range.toString())) {\n\n                const messageId = (node.type === \"PrivateIdentifier\")\n                    ? \"notMatchPrivate\" : \"notMatch\";\n\n                context.report({\n                    node,\n                    messageId,\n                    data: {\n                        name: node.name,\n                        pattern\n                    }\n                });\n                reportedNodes.add(node.range.toString());\n            }\n        }\n\n        return {\n\n            Program(node) {\n                globalScope = sourceCode.getScope(node);\n            },\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (isReferenceToGlobalVariable(node)) {\n                    return;\n                }\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!checkProperties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions left side's assigned variable id\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                // For https://github.com/eslint/eslint/issues/15123\n                } else if (\n                    parent.type === \"Property\" &&\n                    parent.parent.type === \"ObjectExpression\" &&\n                    parent.key === node &&\n                    !parent.computed\n                ) {\n                    if (checkProperties && isInvalid(name)) {\n                        report(node);\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n\n                    if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n                        if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name)) {\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n                        // prevent checking righthand side of destructured object\n                        if (!assignmentKeyEqualsValue && parent.key === node) {\n                            return;\n                        }\n\n                        const valueIsInvalid = parent.value.name && isInvalid(name);\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // never check properties or always ignore destructuring\n                    if ((!checkProperties && !parent.computed) || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (parent.right !== node && shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if (IMPORT_TYPES.has(parent.type)) {\n\n                    // Report only if the local imported identifier is invalid\n                    if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n                        report(node);\n                    }\n\n                } else if (parent.type === \"PropertyDefinition\") {\n\n                    if (checkClassFields && isInvalid(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is invalid that isn't a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            },\n\n            \"PrivateIdentifier\"(node) {\n\n                const isClassField = node.parent.type === \"PropertyDefinition\";\n\n                if (isClassField && !checkClassFields) {\n                    return;\n                }\n\n                if (isInvalid(node.name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}