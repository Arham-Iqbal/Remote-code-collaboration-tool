{"ast":null,"code":"/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst RegExpValidator = require(\"@eslint-community/regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[dgimsuvy]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow invalid regular expression strings in `RegExp` constructors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-invalid-regexp\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowConstructorFlags: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      regexMessage: \"{{message}}.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0];\n    let allowedFlags = null;\n    if (options && options.allowConstructorFlags) {\n      const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n      if (temp) {\n        allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n      }\n    }\n\n    /**\n     * Reports error with the provided message.\n     * @param {ASTNode} node The node holding the invalid RegExp\n     * @param {string} message The message to report.\n     * @returns {void}\n     */\n    function report(node, message) {\n      context.report({\n        node,\n        messageId: \"regexMessage\",\n        data: {\n          message\n        }\n      });\n    }\n\n    /**\n     * Check if node is a string\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if its a string\n     * @private\n     */\n    function isString(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    /**\n     * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n     * Examples:\n     *     new RegExp(\".\")         // => \"\"\n     *     new RegExp(\".\", \"gu\")   // => \"gu\"\n     *     new RegExp(\".\", flags)  // => null\n     * @param {ASTNode} node `CallExpression` or `NewExpression` node\n     * @returns {string|null} flags if they can be determined, `null` otherwise\n     * @private\n     */\n    function getFlags(node) {\n      if (node.arguments.length < 2) {\n        return \"\";\n      }\n      if (isString(node.arguments[1])) {\n        return node.arguments[1].value;\n      }\n      return null;\n    }\n\n    /**\n     * Check syntax error in a given pattern.\n     * @param {string} pattern The RegExp pattern to validate.\n     * @param {Object} flags The RegExp flags to validate.\n     * @param {boolean} [flags.unicode] The Unicode flag.\n     * @param {boolean} [flags.unicodeSets] The UnicodeSets flag.\n     * @returns {string|null} The syntax error.\n     */\n    function validateRegExpPattern(pattern, flags) {\n      try {\n        validator.validatePattern(pattern, undefined1, undefined1, flags);\n        return null;\n      } catch (err) {\n        return err.message;\n      }\n    }\n\n    /**\n     * Check syntax error in a given flags.\n     * @param {string|null} flags The RegExp flags to validate.\n     * @returns {string|null} The syntax error.\n     */\n    function validateRegExpFlags(flags) {\n      if (!flags) {\n        return null;\n      }\n      try {\n        validator.validateFlags(flags);\n      } catch {\n        return `Invalid flags supplied to RegExp constructor '${flags}'`;\n      }\n\n      /*\n       * `regexpp` checks the combination of `u` and `v` flags when parsing `Pattern` according to `ecma262`,\n       * but this rule may check only the flag when the pattern is unidentifiable, so check it here.\n       * https://tc39.es/ecma262/multipage/text-processing.html#sec-parsepattern\n       */\n      if (flags.includes(\"u\") && flags.includes(\"v\")) {\n        return \"Regex 'u' and 'v' flags cannot be used together\";\n      }\n      return null;\n    }\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\") {\n          return;\n        }\n        let flags = getFlags(node);\n        if (flags && allowedFlags) {\n          flags = flags.replace(allowedFlags, \"\");\n        }\n        let message = validateRegExpFlags(flags);\n        if (message) {\n          report(node, message);\n          return;\n        }\n        if (!isString(node.arguments[0])) {\n          return;\n        }\n        const pattern = node.arguments[0].value;\n        message =\n        // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n        flags === null ? validateRegExpPattern(pattern, {\n          unicode: true,\n          unicodeSets: false\n        }) && validateRegExpPattern(pattern, {\n          unicode: false,\n          unicodeSets: true\n        }) && validateRegExpPattern(pattern, {\n          unicode: false,\n          unicodeSets: false\n        }) : validateRegExpPattern(pattern, {\n          unicode: flags.includes(\"u\"),\n          unicodeSets: flags.includes(\"v\")\n        });\n        if (message) {\n          report(node, message);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["RegExpValidator","require","validator","validFlags","undefined1","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowConstructorFlags","items","additionalProperties","messages","regexMessage","create","context","options","allowedFlags","temp","join","replace","RegExp","report","node","message","messageId","data","isString","value","getFlags","arguments","length","validateRegExpPattern","pattern","flags","validatePattern","err","validateRegExpFlags","validateFlags","includes","CallExpression, NewExpression","callee","name","unicode","unicodeSets"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-invalid-regexp.js"],"sourcesContent":["/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"@eslint-community/regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[dgimsuvy]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow invalid regular expression strings in `RegExp` constructors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            regexMessage: \"{{message}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = null;\n\n        if (options && options.allowConstructorFlags) {\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n            if (temp) {\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n            }\n        }\n\n        /**\n         * Reports error with the provided message.\n         * @param {ASTNode} node The node holding the invalid RegExp\n         * @param {string} message The message to report.\n         * @returns {void}\n         */\n        function report(node, message) {\n            context.report({\n                node,\n                messageId: \"regexMessage\",\n                data: { message }\n            });\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n         * Examples:\n         *     new RegExp(\".\")         // => \"\"\n         *     new RegExp(\".\", \"gu\")   // => \"gu\"\n         *     new RegExp(\".\", flags)  // => null\n         * @param {ASTNode} node `CallExpression` or `NewExpression` node\n         * @returns {string|null} flags if they can be determined, `null` otherwise\n         * @private\n         */\n        function getFlags(node) {\n            if (node.arguments.length < 2) {\n                return \"\";\n            }\n\n            if (isString(node.arguments[1])) {\n                return node.arguments[1].value;\n            }\n\n            return null;\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {Object} flags The RegExp flags to validate.\n         * @param {boolean} [flags.unicode] The Unicode flag.\n         * @param {boolean} [flags.unicodeSets] The UnicodeSets flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, flags) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, flags);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string|null} flags The RegExp flags to validate.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags) {\n            if (!flags) {\n                return null;\n            }\n            try {\n                validator.validateFlags(flags);\n            } catch {\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\n            }\n\n            /*\n             * `regexpp` checks the combination of `u` and `v` flags when parsing `Pattern` according to `ecma262`,\n             * but this rule may check only the flag when the pattern is unidentifiable, so check it here.\n             * https://tc39.es/ecma262/multipage/text-processing.html#sec-parsepattern\n             */\n            if (flags.includes(\"u\") && flags.includes(\"v\")) {\n                return \"Regex 'u' and 'v' flags cannot be used together\";\n            }\n            return null;\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\") {\n                    return;\n                }\n\n                let flags = getFlags(node);\n\n                if (flags && allowedFlags) {\n                    flags = flags.replace(allowedFlags, \"\");\n                }\n\n                let message = validateRegExpFlags(flags);\n\n                if (message) {\n                    report(node, message);\n                    return;\n                }\n\n                if (!isString(node.arguments[0])) {\n                    return;\n                }\n\n                const pattern = node.arguments[0].value;\n\n                message = (\n\n                    // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n                    flags === null\n                        ? (\n                            validateRegExpPattern(pattern, { unicode: true, unicodeSets: false }) &&\n                            validateRegExpPattern(pattern, { unicode: false, unicodeSets: true }) &&\n                            validateRegExpPattern(pattern, { unicode: false, unicodeSets: false })\n                        )\n                        : validateRegExpPattern(pattern, { unicode: flags.includes(\"u\"), unicodeSets: flags.includes(\"v\") })\n                );\n\n                if (message) {\n                    report(node, message);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}