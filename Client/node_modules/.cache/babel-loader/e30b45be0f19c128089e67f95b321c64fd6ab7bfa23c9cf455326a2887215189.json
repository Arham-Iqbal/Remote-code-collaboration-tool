{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unused labels\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-unused-labels\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unused: \"'{{name}}:' is defined but never used.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    let scopeInfo = null;\n\n    /**\n     * Adds a scope info to the stack.\n     * @param {ASTNode} node A node to add. This is a LabeledStatement.\n     * @returns {void}\n     */\n    function enterLabeledScope(node) {\n      scopeInfo = {\n        label: node.label.name,\n        used: false,\n        upper: scopeInfo\n      };\n    }\n\n    /**\n     * Checks if a `LabeledStatement` node is fixable.\n     * For a node to be fixable, there must be no comments between the label and the body.\n     * Furthermore, is must be possible to remove the label without turning the body statement into a\n     * directive after other fixes are applied.\n     * @param {ASTNode} node The node to evaluate.\n     * @returns {boolean} Whether or not the node is fixable.\n     */\n    function isFixable(node) {\n      /*\n       * Only perform a fix if there are no comments between the label and the body. This will be the case\n       * when there is exactly one token/comment (the \":\") between the label and the body.\n       */\n      if (sourceCode.getTokenAfter(node.label, {\n        includeComments: true\n      }) !== sourceCode.getTokenBefore(node.body, {\n        includeComments: true\n      })) {\n        return false;\n      }\n\n      // Looking for the node's deepest ancestor which is not a `LabeledStatement`.\n      let ancestor = node.parent;\n      while (ancestor.type === \"LabeledStatement\") {\n        ancestor = ancestor.parent;\n      }\n      if (ancestor.type === \"Program\" || ancestor.type === \"BlockStatement\" && astUtils.isFunction(ancestor.parent)) {\n        const {\n          body\n        } = node;\n        if (body.type === \"ExpressionStatement\" && (body.expression.type === \"Literal\" && typeof body.expression.value === \"string\" || astUtils.isStaticTemplateLiteral(body.expression))) {\n          return false; // potential directive\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Removes the top of the stack.\n     * At the same time, this reports the label if it's never used.\n     * @param {ASTNode} node A node to report. This is a LabeledStatement.\n     * @returns {void}\n     */\n    function exitLabeledScope(node) {\n      if (!scopeInfo.used) {\n        context.report({\n          node: node.label,\n          messageId: \"unused\",\n          data: node.label,\n          fix: isFixable(node) ? fixer => fixer.removeRange([node.range[0], node.body.range[0]]) : null\n        });\n      }\n      scopeInfo = scopeInfo.upper;\n    }\n\n    /**\n     * Marks the label of a given node as used.\n     * @param {ASTNode} node A node to mark. This is a BreakStatement or\n     *      ContinueStatement.\n     * @returns {void}\n     */\n    function markAsUsed(node) {\n      if (!node.label) {\n        return;\n      }\n      const label = node.label.name;\n      let info = scopeInfo;\n      while (info) {\n        if (info.label === label) {\n          info.used = true;\n          break;\n        }\n        info = info.upper;\n      }\n    }\n    return {\n      LabeledStatement: enterLabeledScope,\n      \"LabeledStatement:exit\": exitLabeledScope,\n      BreakStatement: markAsUsed,\n      ContinueStatement: markAsUsed\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","fixable","messages","unused","create","context","sourceCode","scopeInfo","enterLabeledScope","node","label","name","used","upper","isFixable","getTokenAfter","includeComments","getTokenBefore","body","ancestor","parent","isFunction","expression","value","isStaticTemplateLiteral","exitLabeledScope","report","messageId","data","fix","fixer","removeRange","range","markAsUsed","info","LabeledStatement","BreakStatement","ContinueStatement"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-unused-labels.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unused labels\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-labels\"\n        },\n\n        schema: [],\n\n        fixable: \"code\",\n\n        messages: {\n            unused: \"'{{name}}:' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        let scopeInfo = null;\n\n        /**\n         * Adds a scope info to the stack.\n         * @param {ASTNode} node A node to add. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledScope(node) {\n            scopeInfo = {\n                label: node.label.name,\n                used: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Checks if a `LabeledStatement` node is fixable.\n         * For a node to be fixable, there must be no comments between the label and the body.\n         * Furthermore, is must be possible to remove the label without turning the body statement into a\n         * directive after other fixes are applied.\n         * @param {ASTNode} node The node to evaluate.\n         * @returns {boolean} Whether or not the node is fixable.\n         */\n        function isFixable(node) {\n\n            /*\n             * Only perform a fix if there are no comments between the label and the body. This will be the case\n             * when there is exactly one token/comment (the \":\") between the label and the body.\n             */\n            if (sourceCode.getTokenAfter(node.label, { includeComments: true }) !==\n                sourceCode.getTokenBefore(node.body, { includeComments: true })) {\n                return false;\n            }\n\n            // Looking for the node's deepest ancestor which is not a `LabeledStatement`.\n            let ancestor = node.parent;\n\n            while (ancestor.type === \"LabeledStatement\") {\n                ancestor = ancestor.parent;\n            }\n\n            if (ancestor.type === \"Program\" ||\n                (ancestor.type === \"BlockStatement\" && astUtils.isFunction(ancestor.parent))) {\n                const { body } = node;\n\n                if (body.type === \"ExpressionStatement\" &&\n                    ((body.expression.type === \"Literal\" && typeof body.expression.value === \"string\") ||\n                    astUtils.isStaticTemplateLiteral(body.expression))) {\n                    return false; // potential directive\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Removes the top of the stack.\n         * At the same time, this reports the label if it's never used.\n         * @param {ASTNode} node A node to report. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledScope(node) {\n            if (!scopeInfo.used) {\n                context.report({\n                    node: node.label,\n                    messageId: \"unused\",\n                    data: node.label,\n                    fix: isFixable(node) ? fixer => fixer.removeRange([node.range[0], node.body.range[0]]) : null\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Marks the label of a given node as used.\n         * @param {ASTNode} node A node to mark. This is a BreakStatement or\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function markAsUsed(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const label = node.label.name;\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    info.used = true;\n                    break;\n                }\n                info = info.upper;\n            }\n        }\n\n        return {\n            LabeledStatement: enterLabeledScope,\n            \"LabeledStatement:exit\": exitLabeledScope,\n            BreakStatement: markAsUsed,\n            ContinueStatement: markAsUsed\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}