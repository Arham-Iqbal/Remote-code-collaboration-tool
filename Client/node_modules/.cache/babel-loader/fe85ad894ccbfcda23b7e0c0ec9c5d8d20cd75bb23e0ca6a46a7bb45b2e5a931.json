{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n  if (typeof x === \"string\") {\n    return BigInt(x.slice(0, -1));\n  }\n  return x;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow magic numbers\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-magic-numbers\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        detectObjects: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceConst: {\n          type: \"boolean\",\n          default: false\n        },\n        ignore: {\n          type: \"array\",\n          items: {\n            anyOf: [{\n              type: \"number\"\n            }, {\n              type: \"string\",\n              pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\"\n            }]\n          },\n          uniqueItems: true\n        },\n        ignoreArrayIndexes: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDefaultValues: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreClassFieldInitialValues: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"Number constants declarations must use 'const'.\",\n      noMagic: \"No magic number: {{raw}}.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || {},\n      detectObjects = !!config.detectObjects,\n      enforceConst = !!config.enforceConst,\n      ignore = new Set((config.ignore || []).map(normalizeIgnoreValue)),\n      ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n      ignoreDefaultValues = !!config.ignoreDefaultValues,\n      ignoreClassFieldInitialValues = !!config.ignoreClassFieldInitialValues;\n    const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n    /**\n     * Returns whether the rule is configured to ignore the given value\n     * @param {bigint|number} value The value to check\n     * @returns {boolean} true if the value is ignored\n     */\n    function isIgnoredValue(value) {\n      return ignore.has(value);\n    }\n\n    /**\n     * Returns whether the number is a default value assignment.\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the number is a default value\n     */\n    function isDefaultValue(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n    }\n\n    /**\n     * Returns whether the number is the initial value of a class field.\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the number is the initial value of a class field.\n     */\n    function isClassFieldInitialValue(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"PropertyDefinition\" && parent.value === fullNumberNode;\n    }\n\n    /**\n     * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the node is radix\n     */\n    function isParseIntRadix(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, \"parseInt\") || astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\"));\n    }\n\n    /**\n     * Returns whether the given node is a direct child of a JSX node.\n     * In particular, it aims to detect numbers used as prop values in JSX tags.\n     * Example: <input maxLength={10} />\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the node is a JSX number\n     */\n    function isJSXNumber(fullNumberNode) {\n      return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n    }\n\n    /**\n     * Returns whether the given node is used as an array index.\n     * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n     *\n     * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n     * which can be created and accessed on an array in addition to the array index properties,\n     * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n     *\n     * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n     * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n     *\n     * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n     *\n     * Valid examples:\n     * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n     * a[-0] (same as a[0] because -0 coerces to \"0\")\n     * a[-0n] (-0n evaluates to 0n)\n     *\n     * Invalid examples:\n     * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n     * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n     * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n     * a[1e310] (same as a[\"Infinity\"])\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @param {bigint|number} value Value expressed by the fullNumberNode\n     * @returns {boolean} true if the node is a valid array index\n     */\n    function isArrayIndex(fullNumberNode, value) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"MemberExpression\" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === \"bigint\") && value >= 0 && value < MAX_ARRAY_LENGTH;\n    }\n    return {\n      Literal(node) {\n        if (!astUtils.isNumericLiteral(node)) {\n          return;\n        }\n        let fullNumberNode;\n        let value;\n        let raw;\n\n        // Treat unary minus as a part of the number\n        if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n          fullNumberNode = node.parent;\n          value = -node.value;\n          raw = `-${node.raw}`;\n        } else {\n          fullNumberNode = node;\n          value = node.value;\n          raw = node.raw;\n        }\n        const parent = fullNumberNode.parent;\n\n        // Always allow radix arguments and JSX props\n        if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || ignoreClassFieldInitialValues && isClassFieldInitialValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {\n          return;\n        }\n        if (parent.type === \"VariableDeclarator\") {\n          if (enforceConst && parent.parent.kind !== \"const\") {\n            context.report({\n              node: fullNumberNode,\n              messageId: \"useConst\"\n            });\n          }\n        } else if (!okTypes.includes(parent.type) || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\") {\n          context.report({\n            node: fullNumberNode,\n            messageId: \"noMagic\",\n            data: {\n              raw\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","MAX_ARRAY_LENGTH","normalizeIgnoreValue","x","BigInt","slice","module","exports","meta","type","docs","description","recommended","url","schema","properties","detectObjects","default","enforceConst","ignore","items","anyOf","pattern","uniqueItems","ignoreArrayIndexes","ignoreDefaultValues","ignoreClassFieldInitialValues","additionalProperties","messages","useConst","noMagic","create","context","config","options","Set","map","okTypes","isIgnoredValue","value","has","isDefaultValue","fullNumberNode","parent","right","isClassFieldInitialValue","isParseIntRadix","arguments","isSpecificId","callee","isSpecificMemberAccess","isJSXNumber","indexOf","isArrayIndex","property","Number","isInteger","Literal","node","isNumericLiteral","raw","operator","kind","report","messageId","includes","left","data"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-magic-numbers.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n    if (typeof x === \"string\") {\n        return BigInt(x.slice(0, -1));\n    }\n    return x;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow magic numbers\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-magic-numbers\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\",\n                    default: false\n                },\n                enforceConst: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        anyOf: [\n                            { type: \"number\" },\n                            { type: \"string\", pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\" }\n                        ]\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreDefaultValues: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreClassFieldInitialValues: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useConst: \"Number constants declarations must use 'const'.\",\n            noMagic: \"No magic number: {{raw}}.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = new Set((config.ignore || []).map(normalizeIgnoreValue)),\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n            ignoreDefaultValues = !!config.ignoreDefaultValues,\n            ignoreClassFieldInitialValues = !!config.ignoreClassFieldInitialValues;\n\n        const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n        /**\n         * Returns whether the rule is configured to ignore the given value\n         * @param {bigint|number} value The value to check\n         * @returns {boolean} true if the value is ignored\n         */\n        function isIgnoredValue(value) {\n            return ignore.has(value);\n        }\n\n        /**\n         * Returns whether the number is a default value assignment.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is a default value\n         */\n        function isDefaultValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the number is the initial value of a class field.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is the initial value of a class field.\n         */\n        function isClassFieldInitialValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"PropertyDefinition\" && parent.value === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is radix\n         */\n        function isParseIntRadix(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] &&\n                (\n                    astUtils.isSpecificId(parent.callee, \"parseInt\") ||\n                    astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\")\n                );\n        }\n\n        /**\n         * Returns whether the given node is a direct child of a JSX node.\n         * In particular, it aims to detect numbers used as prop values in JSX tags.\n         * Example: <input maxLength={10} />\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is a JSX number\n         */\n        function isJSXNumber(fullNumberNode) {\n            return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the given node is used as an array index.\n         * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n         * which can be created and accessed on an array in addition to the array index properties,\n         * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n         *\n         * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n         * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n         *\n         * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * Valid examples:\n         * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n         * a[-0] (same as a[0] because -0 coerces to \"0\")\n         * a[-0n] (-0n evaluates to 0n)\n         *\n         * Invalid examples:\n         * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n         * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n         * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n         * a[1e310] (same as a[\"Infinity\"])\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @param {bigint|number} value Value expressed by the fullNumberNode\n         * @returns {boolean} true if the node is a valid array index\n         */\n        function isArrayIndex(fullNumberNode, value) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"MemberExpression\" && parent.property === fullNumberNode &&\n                (Number.isInteger(value) || typeof value === \"bigint\") &&\n                value >= 0 && value < MAX_ARRAY_LENGTH;\n        }\n\n        return {\n            Literal(node) {\n                if (!astUtils.isNumericLiteral(node)) {\n                    return;\n                }\n\n                let fullNumberNode;\n                let value;\n                let raw;\n\n                // Treat unary minus as a part of the number\n                if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n                    fullNumberNode = node.parent;\n                    value = -node.value;\n                    raw = `-${node.raw}`;\n                } else {\n                    fullNumberNode = node;\n                    value = node.value;\n                    raw = node.raw;\n                }\n\n                const parent = fullNumberNode.parent;\n\n                // Always allow radix arguments and JSX props\n                if (\n                    isIgnoredValue(value) ||\n                    (ignoreDefaultValues && isDefaultValue(fullNumberNode)) ||\n                    (ignoreClassFieldInitialValues && isClassFieldInitialValue(fullNumberNode)) ||\n                    isParseIntRadix(fullNumberNode) ||\n                    isJSXNumber(fullNumberNode) ||\n                    (ignoreArrayIndexes && isArrayIndex(fullNumberNode, value))\n                ) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node: fullNumberNode,\n                            messageId: \"useConst\"\n                        });\n                    }\n                } else if (\n                    !okTypes.includes(parent.type) ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: \"noMagic\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}