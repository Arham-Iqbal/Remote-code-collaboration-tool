{"ast":null,"code":"/**\n * @fileoverview Main class using flat config\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// Note: Node.js 12 does not support fs/promises.\nconst fs = require(\"fs\").promises;\nconst {\n  existsSync\n} = require(\"fs\");\nconst path = require(\"path\");\nconst findUp = require(\"find-up\");\nconst {\n  version\n} = require(\"../../package.json\");\nconst {\n  Linter\n} = require(\"../linter\");\nconst {\n  getRuleFromConfig\n} = require(\"../config/flat-config-helpers\");\nconst {\n  Legacy: {\n    ConfigOps: {\n      getRuleSeverity\n    },\n    ModuleResolver,\n    naming\n  }\n} = require(\"@eslint/eslintrc\");\nconst {\n  findFiles,\n  getCacheFile,\n  isNonEmptyString,\n  isArrayOfNonEmptyString,\n  createIgnoreResult,\n  isErrorMessage,\n  processOptions\n} = require(\"./eslint-helpers\");\nconst {\n  pathToFileURL\n} = require(\"url\");\nconst {\n  FlatConfigArray\n} = require(\"../config/flat-config-array\");\nconst LintResultCache = require(\"../cli-engine/lint-result-cache\");\n\n/*\n * This is necessary to allow overwriting writeFile for testing purposes.\n * We can just use fs/promises once we drop Node.js 12 support.\n */\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").LintResult} LintResult */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").ResultsMeta} ResultsMeta */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} FlatESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables all ignore patterns except for the default ones.\n * @property {string[]} [ignorePatterns] Ignore file patterns to use in addition to config ignores. These patterns are relative to `cwd`.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {boolean|string} [overrideConfigFile] Searches for default config file when falsy;\n *      doesn't do any config file lookup when `true`; considered to be a config filename\n *      when a string.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {boolean} warnIgnored Show warnings when the file list includes ignored files\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FLAT_CONFIG_FILENAMES = [\"eslint.config.js\", \"eslint.config.mjs\", \"eslint.config.cjs\"];\nconst debug = require(\"debug\")(\"eslint:flat-eslint\");\nconst removedFormatters = new Set([\"table\", \"codeframe\"]);\nconst privateMembers = new WeakMap();\nconst importedConfigFileModificationTime = new Map();\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n  const stat = {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  };\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    if (message.fatal || message.severity === 2) {\n      stat.errorCount++;\n      if (message.fatal) {\n        stat.fatalErrorCount++;\n      }\n      if (message.fix) {\n        stat.fixableErrorCount++;\n      }\n    } else {\n      stat.warningCount++;\n      if (message.fix) {\n        stat.fixableWarningCount++;\n      }\n    }\n  }\n  return stat;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n  return Array.from(rules).reduce((retVal, [id, rule]) => {\n    retVal[id] = rule.meta;\n    return retVal;\n  }, {});\n}\n\n/**\n * Return the absolute path of a file named `\"__placeholder__.js\"` in a given directory.\n * This is used as a replacement for a missing file path.\n * @param {string} cwd An absolute directory path.\n * @returns {string} The absolute path of a file named `\"__placeholder__.js\"` in the given directory.\n */\nfunction getPlaceholderPath(cwd) {\n  return path.join(cwd, \"__placeholder__.js\");\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {\n  const {\n    configs,\n    options: {\n      cwd\n    }\n  } = privateMembers.get(eslint);\n  const filePath = path.isAbsolute(maybeFilePath) ? maybeFilePath : getPlaceholderPath(cwd);\n  const config = configs.getConfig(filePath);\n\n  // Most files use the same config, so cache it.\n  if (config && !usedDeprecatedRulesCache.has(config)) {\n    const retv = [];\n    if (config.rules) {\n      for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n        if (getRuleSeverity(ruleConf) === 0) {\n          continue;\n        }\n        const rule = getRuleFromConfig(ruleId, config);\n        const meta = rule && rule.meta;\n        if (meta && meta.deprecated) {\n          retv.push({\n            ruleId,\n            replacedBy: meta.replacedBy || []\n          });\n        }\n      }\n    }\n    usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n  }\n  return config ? usedDeprecatedRulesCache.get(config) : Object.freeze([]);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processLintReport(eslint, {\n  results\n}) {\n  const descriptor = {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return getOrFindUsedDeprecatedRules(eslint, this.filePath);\n    }\n  };\n  for (const result of results) {\n    Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n  }\n  return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n  if (a.filePath < b.filePath) {\n    return -1;\n  }\n  if (a.filePath > b.filePath) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Searches from the current working directory up until finding the\n * given flat config filename.\n * @param {string} cwd The current working directory to search from.\n * @returns {Promise<string|undefined>} The filename if found or `undefined` if not.\n */\nfunction findFlatConfigFile(cwd) {\n  return findUp(FLAT_CONFIG_FILENAMES, {\n    cwd\n  });\n}\n\n/**\n * Load the config array from the given filename.\n * @param {string} filePath The filename to load from.\n * @returns {Promise<any>} The config loaded from the config file.\n */\nasync function loadFlatConfigFile(filePath) {\n  debug(`Loading config from ${filePath}`);\n  const fileURL = pathToFileURL(filePath);\n  debug(`Config file URL is ${fileURL}`);\n  const mtime = (await fs.stat(filePath)).mtime.getTime();\n\n  /*\n   * Append a query with the config file's modification time (`mtime`) in order\n   * to import the current version of the config file. Without the query, `import()` would\n   * cache the config file module by the pathname only, and then always return\n   * the same version (the one that was actual when the module was imported for the first time).\n   *\n   * This ensures that the config file module is loaded and executed again\n   * if it has been changed since the last time it was imported.\n   * If it hasn't been changed, `import()` will just return the cached version.\n   *\n   * Note that we should not overuse queries (e.g., by appending the current time\n   * to always reload the config file module) as that could cause memory leaks\n   * because entries are never removed from the import cache.\n   */\n  fileURL.searchParams.append(\"mtime\", mtime);\n\n  /*\n   * With queries, we can bypass the import cache. However, when import-ing a CJS module,\n   * Node.js uses the require infrastructure under the hood. That includes the require cache,\n   * which caches the config file module by its file path (queries have no effect).\n   * Therefore, we also need to clear the require cache before importing the config file module.\n   * In order to get the same behavior with ESM and CJS config files, in particular - to reload\n   * the config file only if it has been changed, we track file modification times and clear\n   * the require cache only if the file has been changed.\n   */\n  if (importedConfigFileModificationTime.get(filePath) !== mtime) {\n    delete require.cache[filePath];\n  }\n  const config = (await import(fileURL)).default;\n  importedConfigFileModificationTime.set(filePath, mtime);\n  return config;\n}\n\n/**\n * Determines which config file to use. This is determined by seeing if an\n * override config file was passed, and if so, using it; otherwise, as long\n * as override config file is not explicitly set to `false`, it will search\n * upwards from the cwd for a file named `eslint.config.js`.\n * @param {import(\"./eslint\").ESLintOptions} options The ESLint instance options.\n * @returns {{configFilePath:string|undefined,basePath:string,error:Error|null}} Location information for\n *      the config file.\n */\nasync function locateConfigFileToUse({\n  configFile,\n  cwd\n}) {\n  // determine where to load config file from\n  let configFilePath;\n  let basePath = cwd;\n  let error = null;\n  if (typeof configFile === \"string\") {\n    debug(`Override config file path is ${configFile}`);\n    configFilePath = path.resolve(cwd, configFile);\n  } else if (configFile !== false) {\n    debug(\"Searching for eslint.config.js\");\n    configFilePath = await findFlatConfigFile(cwd);\n    if (configFilePath) {\n      basePath = path.resolve(path.dirname(configFilePath));\n    } else {\n      error = new Error(\"Could not find config file.\");\n    }\n  }\n  return {\n    configFilePath,\n    basePath,\n    error\n  };\n}\n\n/**\n * Calculates the config array for this run based on inputs.\n * @param {FlatESLint} eslint The instance to create the config array for.\n * @param {import(\"./eslint\").ESLintOptions} options The ESLint instance options.\n * @returns {FlatConfigArray} The config array for `eslint``.\n */\nasync function calculateConfigArray(eslint, {\n  cwd,\n  baseConfig,\n  overrideConfig,\n  configFile,\n  ignore: shouldIgnore,\n  ignorePatterns\n}) {\n  // check for cached instance\n  const slots = privateMembers.get(eslint);\n  if (slots.configs) {\n    return slots.configs;\n  }\n  const {\n    configFilePath,\n    basePath,\n    error\n  } = await locateConfigFileToUse({\n    configFile,\n    cwd\n  });\n\n  // config file is required to calculate config\n  if (error) {\n    throw error;\n  }\n  const configs = new FlatConfigArray(baseConfig || [], {\n    basePath,\n    shouldIgnore\n  });\n\n  // load config file\n  if (configFilePath) {\n    const fileConfig = await loadFlatConfigFile(configFilePath);\n    if (Array.isArray(fileConfig)) {\n      configs.push(...fileConfig);\n    } else {\n      configs.push(fileConfig);\n    }\n  }\n\n  // add in any configured defaults\n  configs.push(...slots.defaultConfigs);\n\n  // append command line ignore patterns\n  if (ignorePatterns && ignorePatterns.length > 0) {\n    let relativeIgnorePatterns;\n\n    /*\n     * If the config file basePath is different than the cwd, then\n     * the ignore patterns won't work correctly. Here, we adjust the\n     * ignore pattern to include the correct relative path. Patterns\n     * passed as `ignorePatterns` are relative to the cwd, whereas\n     * the config file basePath can be an ancestor of the cwd.\n     */\n    if (basePath === cwd) {\n      relativeIgnorePatterns = ignorePatterns;\n    } else {\n      const relativeIgnorePath = path.relative(basePath, cwd);\n      relativeIgnorePatterns = ignorePatterns.map(pattern => {\n        const negated = pattern.startsWith(\"!\");\n        const basePattern = negated ? pattern.slice(1) : pattern;\n        return (negated ? \"!\" : \"\") + path.posix.join(relativeIgnorePath, basePattern);\n      });\n    }\n\n    /*\n     * Ignore patterns are added to the end of the config array\n     * so they can override default ignores.\n     */\n    configs.push({\n      ignores: relativeIgnorePatterns\n    });\n  }\n  if (overrideConfig) {\n    if (Array.isArray(overrideConfig)) {\n      configs.push(...overrideConfig);\n    } else {\n      configs.push(overrideConfig);\n    }\n  }\n  await configs.normalize();\n\n  // cache the config array for this instance\n  slots.configs = configs;\n  return configs;\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {FlatConfigArray} config.configs The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n  text,\n  cwd,\n  filePath: providedFilePath,\n  configs,\n  fix,\n  allowInlineConfig,\n  linter\n}) {\n  const filePath = providedFilePath || \"<text>\";\n  debug(`Lint ${filePath}`);\n\n  /*\n   * Verify.\n   * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n   * doesn't know CWD, so it gives `linter` an absolute path always.\n   */\n  const filePathToVerify = filePath === \"<text>\" ? getPlaceholderPath(cwd) : filePath;\n  const {\n    fixed,\n    messages,\n    output\n  } = linter.verifyAndFix(text, configs, {\n    allowInlineConfig,\n    filename: filePathToVerify,\n    fix,\n    /**\n     * Check if the linter should adopt a given code block or not.\n     * @param {string} blockFilename The virtual filename of a code block.\n     * @returns {boolean} `true` if the linter should adopt the code block.\n     */\n    filterCodeBlock(blockFilename) {\n      return configs.getConfig(blockFilename) !== void 0;\n    }\n  });\n\n  // Tweak and return.\n  const result = {\n    filePath: filePath === \"<text>\" ? filePath : path.resolve(filePath),\n    messages,\n    suppressedMessages: linter.getSuppressedMessages(),\n    ...calculateStatsPerFile(messages)\n  };\n  if (fixed) {\n    result.output = output;\n  }\n  if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n    result.source = text;\n  }\n  return result;\n}\n\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\nfunction shouldMessageBeFixed(message, config, fixTypes) {\n  if (!message.ruleId) {\n    return fixTypes.has(\"directive\");\n  }\n  const rule = message.ruleId && getRuleFromConfig(message.ruleId, config);\n  return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n\n/**\n * Creates an error to be thrown when an array of results passed to `getRulesMetaForResults` was not created by the current engine.\n * @returns {TypeError} An error object.\n */\nfunction createExtraneousResultsError() {\n  return new TypeError(\"Results object was not created from this ESLint instance.\");\n}\n\n/**\n * Creates a fixer function based on the provided fix, fixTypesSet, and config.\n * @param {Function|boolean} fix The original fix option.\n * @param {Set<string>} fixTypesSet A set of fix types to filter messages for fixing.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @returns {Function|boolean} The fixer function or the original fix value.\n */\nfunction getFixerForFixTypes(fix, fixTypesSet, config) {\n  if (!fix || !fixTypesSet) {\n    return fix;\n  }\n  const originalFix = typeof fix === \"function\" ? fix : () => true;\n  return message => shouldMessageBeFixed(message, config, fixTypesSet) && originalFix(message);\n}\n\n//-----------------------------------------------------------------------------\n// Main API\n//-----------------------------------------------------------------------------\n\n/**\n * Primary Node.js API for ESLint.\n */\nclass FlatESLint {\n  /**\n   * Creates a new instance of the main ESLint API.\n   * @param {FlatESLintOptions} options The options for this instance.\n   */\n  constructor(options = {}) {\n    const defaultConfigs = [];\n    const processedOptions = processOptions(options);\n    const linter = new Linter({\n      cwd: processedOptions.cwd,\n      configType: \"flat\"\n    });\n    const cacheFilePath = getCacheFile(processedOptions.cacheLocation, processedOptions.cwd);\n    const lintResultCache = processedOptions.cache ? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy) : null;\n    privateMembers.set(this, {\n      options: processedOptions,\n      linter,\n      cacheFilePath,\n      lintResultCache,\n      defaultConfigs,\n      configs: null\n    });\n\n    /**\n     * If additional plugins are passed in, add that to the default\n     * configs for this instance.\n     */\n    if (options.plugins) {\n      const plugins = {};\n      for (const [pluginName, plugin] of Object.entries(options.plugins)) {\n        plugins[naming.getShorthandName(pluginName, \"eslint-plugin\")] = plugin;\n      }\n      defaultConfigs.push({\n        plugins\n      });\n    }\n  }\n\n  /**\n   * The version text.\n   * @type {string}\n   */\n  static get version() {\n    return version;\n  }\n\n  /**\n   * Outputs fixes from the given results to files.\n   * @param {LintResult[]} results The lint results.\n   * @returns {Promise<void>} Returns a promise that is used to track side effects.\n   */\n  static async outputFixes(results) {\n    if (!Array.isArray(results)) {\n      throw new Error(\"'results' must be an array\");\n    }\n    await Promise.all(results.filter(result => {\n      if (typeof result !== \"object\" || result === null) {\n        throw new Error(\"'results' must include only objects\");\n      }\n      return typeof result.output === \"string\" && path.isAbsolute(result.filePath);\n    }).map(r => fs.writeFile(r.filePath, r.output)));\n  }\n\n  /**\n   * Returns results that only contains errors.\n   * @param {LintResult[]} results The results to filter.\n   * @returns {LintResult[]} The filtered results.\n   */\n  static getErrorResults(results) {\n    const filtered = [];\n    results.forEach(result => {\n      const filteredMessages = result.messages.filter(isErrorMessage);\n      const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n      if (filteredMessages.length > 0) {\n        filtered.push({\n          ...result,\n          messages: filteredMessages,\n          suppressedMessages: filteredSuppressedMessages,\n          errorCount: filteredMessages.length,\n          warningCount: 0,\n          fixableErrorCount: result.fixableErrorCount,\n          fixableWarningCount: 0\n        });\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * Returns meta objects for each rule represented in the lint results.\n   * @param {LintResult[]} results The results to fetch rules meta for.\n   * @returns {Object} A mapping of ruleIds to rule meta objects.\n   * @throws {TypeError} When the results object wasn't created from this ESLint instance.\n   * @throws {TypeError} When a plugin or rule is missing.\n   */\n  getRulesMetaForResults(results) {\n    // short-circuit simple case\n    if (results.length === 0) {\n      return {};\n    }\n    const resultRules = new Map();\n    const {\n      configs,\n      options: {\n        cwd\n      }\n    } = privateMembers.get(this);\n\n    /*\n     * We can only accurately return rules meta information for linting results if the\n     * results were created by this instance. Otherwise, the necessary rules data is\n     * not available. So if the config array doesn't already exist, just throw an error\n     * to let the user know we can't do anything here.\n     */\n    if (!configs) {\n      throw createExtraneousResultsError();\n    }\n    for (const result of results) {\n      /*\n       * Normalize filename for <text>.\n       */\n      const filePath = result.filePath === \"<text>\" ? getPlaceholderPath(cwd) : result.filePath;\n      const allMessages = result.messages.concat(result.suppressedMessages);\n      for (const {\n        ruleId\n      } of allMessages) {\n        if (!ruleId) {\n          continue;\n        }\n\n        /*\n         * All of the plugin and rule information is contained within the\n         * calculated config for the given file.\n         */\n        const config = configs.getConfig(filePath);\n        if (!config) {\n          throw createExtraneousResultsError();\n        }\n        const rule = getRuleFromConfig(ruleId, config);\n\n        // ignore unknown rules\n        if (rule) {\n          resultRules.set(ruleId, rule);\n        }\n      }\n    }\n    return createRulesMeta(resultRules);\n  }\n\n  /**\n   * Executes the current configuration on an array of file and directory names.\n   * @param {string|string[]} patterns An array of file and directory names.\n   * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n   */\n  async lintFiles(patterns) {\n    if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n      throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n    }\n    const {\n      cacheFilePath,\n      lintResultCache,\n      linter,\n      options: eslintOptions\n    } = privateMembers.get(this);\n    const configs = await calculateConfigArray(this, eslintOptions);\n    const {\n      allowInlineConfig,\n      cache,\n      cwd,\n      fix,\n      fixTypes,\n      globInputPaths,\n      errorOnUnmatchedPattern,\n      warnIgnored\n    } = eslintOptions;\n    const startTime = Date.now();\n    const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n\n    // Delete cache file; should this be done here?\n    if (!cache && cacheFilePath) {\n      debug(`Deleting cache file at ${cacheFilePath}`);\n      try {\n        await fs.unlink(cacheFilePath);\n      } catch (error) {\n        const errorCode = error && error.code;\n\n        // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n        if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !existsSync(cacheFilePath))) {\n          throw error;\n        }\n      }\n    }\n    const filePaths = await findFiles({\n      patterns: typeof patterns === \"string\" ? [patterns] : patterns,\n      cwd,\n      globInputPaths,\n      configs,\n      errorOnUnmatchedPattern\n    });\n    debug(`${filePaths.length} files found in: ${Date.now() - startTime}ms`);\n\n    /*\n     * Because we need to process multiple files, including reading from disk,\n     * it is most efficient to start by reading each file via promises so that\n     * they can be done in parallel. Then, we can lint the returned text. This\n     * ensures we are waiting the minimum amount of time in between lints.\n     */\n    const results = await Promise.all(filePaths.map(filePath => {\n      const config = configs.getConfig(filePath);\n\n      /*\n       * If a filename was entered that cannot be matched\n       * to a config, then notify the user.\n       */\n      if (!config) {\n        if (warnIgnored) {\n          return createIgnoreResult(filePath, cwd);\n        }\n        return void 0;\n      }\n\n      // Skip if there is cached result.\n      if (lintResultCache) {\n        const cachedResult = lintResultCache.getCachedLintResults(filePath, config);\n        if (cachedResult) {\n          const hadMessages = cachedResult.messages && cachedResult.messages.length > 0;\n          if (hadMessages && fix) {\n            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n          } else {\n            debug(`Skipping file since it hasn't changed: ${filePath}`);\n            return cachedResult;\n          }\n        }\n      }\n\n      // set up fixer for fixTypes if necessary\n      const fixer = getFixerForFixTypes(fix, fixTypesSet, config);\n      return fs.readFile(filePath, \"utf8\").then(text => {\n        // do the linting\n        const result = verifyText({\n          text,\n          filePath,\n          configs,\n          cwd,\n          fix: fixer,\n          allowInlineConfig,\n          linter\n        });\n\n        /*\n         * Store the lint result in the LintResultCache.\n         * NOTE: The LintResultCache will remove the file source and any\n         * other properties that are difficult to serialize, and will\n         * hydrate those properties back in on future lint runs.\n         */\n        if (lintResultCache) {\n          lintResultCache.setCachedLintResults(filePath, config, result);\n        }\n        return result;\n      });\n    }));\n\n    // Persist the cache to disk.\n    if (lintResultCache) {\n      lintResultCache.reconcile();\n    }\n    const finalResults = results.filter(result => !!result);\n    return processLintReport(this, {\n      results: finalResults\n    });\n  }\n\n  /**\n   * Executes the current configuration on text.\n   * @param {string} code A string of JavaScript code to lint.\n   * @param {Object} [options] The options.\n   * @param {string} [options.filePath] The path to the file of the source code.\n   * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n   * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n   */\n  async lintText(code, options = {}) {\n    // Parameter validation\n\n    if (typeof code !== \"string\") {\n      throw new Error(\"'code' must be a string\");\n    }\n    if (typeof options !== \"object\") {\n      throw new Error(\"'options' must be an object, null, or undefined\");\n    }\n\n    // Options validation\n\n    const {\n      filePath,\n      warnIgnored,\n      ...unknownOptions\n    } = options || {};\n    const unknownOptionKeys = Object.keys(unknownOptions);\n    if (unknownOptionKeys.length > 0) {\n      throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n    }\n    if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n      throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n    }\n    if (typeof warnIgnored !== \"boolean\" && typeof warnIgnored !== \"undefined\") {\n      throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n    }\n\n    // Now we can get down to linting\n\n    const {\n      linter,\n      options: eslintOptions\n    } = privateMembers.get(this);\n    const configs = await calculateConfigArray(this, eslintOptions);\n    const {\n      allowInlineConfig,\n      cwd,\n      fix,\n      fixTypes,\n      warnIgnored: constructorWarnIgnored\n    } = eslintOptions;\n    const results = [];\n    const startTime = Date.now();\n    const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n    const resolvedFilename = path.resolve(cwd, filePath || \"__placeholder__.js\");\n    const config = configs.getConfig(resolvedFilename);\n    const fixer = getFixerForFixTypes(fix, fixTypesSet, config);\n\n    // Clear the last used config arrays.\n    if (resolvedFilename && (await this.isPathIgnored(resolvedFilename))) {\n      const shouldWarnIgnored = typeof warnIgnored === \"boolean\" ? warnIgnored : constructorWarnIgnored;\n      if (shouldWarnIgnored) {\n        results.push(createIgnoreResult(resolvedFilename, cwd));\n      }\n    } else {\n      // Do lint.\n      results.push(verifyText({\n        text: code,\n        filePath: resolvedFilename.endsWith(\"__placeholder__.js\") ? \"<text>\" : resolvedFilename,\n        configs,\n        cwd,\n        fix: fixer,\n        allowInlineConfig,\n        linter\n      }));\n    }\n    debug(`Linting complete in: ${Date.now() - startTime}ms`);\n    return processLintReport(this, {\n      results\n    });\n  }\n\n  /**\n   * Returns the formatter representing the given formatter name.\n   * @param {string} [name] The name of the formatter to load.\n   * The following values are allowed:\n   * - `undefined` ... Load `stylish` builtin formatter.\n   * - A builtin formatter name ... Load the builtin formatter.\n   * - A third-party formatter name:\n   *   - `foo` → `eslint-formatter-foo`\n   *   - `@foo` → `@foo/eslint-formatter`\n   *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n   * - A file path ... Load the file.\n   * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n   * This promise will be rejected if the given formatter was not found or not\n   * a function.\n   */\n  async loadFormatter(name = \"stylish\") {\n    if (typeof name !== \"string\") {\n      throw new Error(\"'name' must be a string\");\n    }\n\n    // replace \\ with / for Windows compatibility\n    const normalizedFormatName = name.replace(/\\\\/gu, \"/\");\n    const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n    // grab our options\n    const {\n      cwd\n    } = privateMembers.get(this).options;\n    let formatterPath;\n\n    // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n    if (!namespace && normalizedFormatName.includes(\"/\")) {\n      formatterPath = path.resolve(cwd, normalizedFormatName);\n    } else {\n      try {\n        const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n        // TODO: This is pretty dirty...would be nice to clean up at some point.\n        formatterPath = ModuleResolver.resolve(npmFormat, getPlaceholderPath(cwd));\n      } catch {\n        formatterPath = path.resolve(__dirname, \"../\", \"cli-engine\", \"formatters\", `${normalizedFormatName}.js`);\n      }\n    }\n    let formatter;\n    try {\n      formatter = (await import(pathToFileURL(formatterPath))).default;\n    } catch (ex) {\n      // check for formatters that have been removed\n      if (removedFormatters.has(name)) {\n        ex.message = `The ${name} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${name}\\``;\n      } else {\n        ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n      }\n      throw ex;\n    }\n    if (typeof formatter !== \"function\") {\n      throw new TypeError(`Formatter must be a function, but got a ${typeof formatter}.`);\n    }\n    const eslint = this;\n    return {\n      /**\n       * The main formatter method.\n       * @param {LintResults[]} results The lint results to format.\n       * @param {ResultsMeta} resultsMeta Warning count and max threshold.\n       * @returns {string} The formatted lint results.\n       */\n      format(results, resultsMeta) {\n        let rulesMeta = null;\n        results.sort(compareResultsByFilePath);\n        return formatter(results, {\n          ...resultsMeta,\n          cwd,\n          get rulesMeta() {\n            if (!rulesMeta) {\n              rulesMeta = eslint.getRulesMetaForResults(results);\n            }\n            return rulesMeta;\n          }\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a configuration object for the given file based on the CLI options.\n   * This is the same logic used by the ESLint CLI executable to determine\n   * configuration for each file it processes.\n   * @param {string} filePath The path of the file to retrieve a config object for.\n   * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n   *      or `undefined` if there is no configuration data for the object.\n   */\n  async calculateConfigForFile(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n    const options = privateMembers.get(this).options;\n    const absolutePath = path.resolve(options.cwd, filePath);\n    const configs = await calculateConfigArray(this, options);\n    return configs.getConfig(absolutePath);\n  }\n\n  /**\n   * Finds the config file being used by this instance based on the options\n   * passed to the constructor.\n   * @returns {string|undefined} The path to the config file being used or\n   *      `undefined` if no config file is being used.\n   */\n  async findConfigFile() {\n    const options = privateMembers.get(this).options;\n    const {\n      configFilePath\n    } = await locateConfigFileToUse(options);\n    return configFilePath;\n  }\n\n  /**\n   * Checks if a given path is ignored by ESLint.\n   * @param {string} filePath The path of the file to check.\n   * @returns {Promise<boolean>} Whether or not the given path is ignored.\n   */\n  async isPathIgnored(filePath) {\n    const config = await this.calculateConfigForFile(filePath);\n    return config === void 0;\n  }\n}\n\n/**\n * The type of configuration used by this class.\n * @type {string}\n * @static\n */\nFlatESLint.configType = \"flat\";\n\n/**\n * Returns whether flat config should be used.\n * @param {Object} [options] The options for this function.\n * @param {string} [options.cwd] The current working directory.\n * @returns {Promise<boolean>} Whether flat config should be used.\n */\nasync function shouldUseFlatConfig({\n  cwd = process.cwd()\n} = {}) {\n  switch (process.env.ESLINT_USE_FLAT_CONFIG) {\n    case \"true\":\n      return true;\n    case \"false\":\n      return false;\n    default:\n      /*\n       * If neither explicitly enabled nor disabled, then use the presence\n       * of a flat config file to determine enablement.\n       */\n      return !!(await findFlatConfigFile(cwd));\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  FlatESLint,\n  shouldUseFlatConfig\n};","map":{"version":3,"names":["fs","require","promises","existsSync","path","findUp","version","Linter","getRuleFromConfig","Legacy","ConfigOps","getRuleSeverity","ModuleResolver","naming","findFiles","getCacheFile","isNonEmptyString","isArrayOfNonEmptyString","createIgnoreResult","isErrorMessage","processOptions","pathToFileURL","FlatConfigArray","LintResultCache","FLAT_CONFIG_FILENAMES","debug","removedFormatters","Set","privateMembers","WeakMap","importedConfigFileModificationTime","Map","calculateStatsPerFile","messages","stat","errorCount","fatalErrorCount","warningCount","fixableErrorCount","fixableWarningCount","i","length","message","fatal","severity","fix","createRulesMeta","rules","Array","from","reduce","retVal","id","rule","meta","getPlaceholderPath","cwd","join","usedDeprecatedRulesCache","getOrFindUsedDeprecatedRules","eslint","maybeFilePath","configs","options","get","filePath","isAbsolute","config","getConfig","has","retv","ruleId","ruleConf","Object","entries","deprecated","push","replacedBy","set","freeze","processLintReport","results","descriptor","configurable","enumerable","result","defineProperty","compareResultsByFilePath","a","b","findFlatConfigFile","loadFlatConfigFile","fileURL","mtime","getTime","searchParams","append","cache","default","locateConfigFileToUse","configFile","configFilePath","basePath","error","resolve","dirname","Error","calculateConfigArray","baseConfig","overrideConfig","ignore","shouldIgnore","ignorePatterns","slots","fileConfig","isArray","defaultConfigs","relativeIgnorePatterns","relativeIgnorePath","relative","map","pattern","negated","startsWith","basePattern","slice","posix","ignores","normalize","verifyText","text","providedFilePath","allowInlineConfig","linter","filePathToVerify","fixed","output","verifyAndFix","filename","filterCodeBlock","blockFilename","suppressedMessages","getSuppressedMessages","source","shouldMessageBeFixed","fixTypes","Boolean","type","createExtraneousResultsError","TypeError","getFixerForFixTypes","fixTypesSet","originalFix","FlatESLint","constructor","processedOptions","configType","cacheFilePath","cacheLocation","lintResultCache","cacheStrategy","plugins","pluginName","plugin","getShorthandName","outputFixes","Promise","all","filter","r","writeFile","getErrorResults","filtered","forEach","filteredMessages","filteredSuppressedMessages","getRulesMetaForResults","resultRules","allMessages","concat","lintFiles","patterns","eslintOptions","globInputPaths","errorOnUnmatchedPattern","warnIgnored","startTime","Date","now","unlink","errorCode","code","filePaths","cachedResult","getCachedLintResults","hadMessages","fixer","readFile","then","setCachedLintResults","reconcile","finalResults","lintText","unknownOptions","unknownOptionKeys","keys","constructorWarnIgnored","resolvedFilename","isPathIgnored","shouldWarnIgnored","endsWith","loadFormatter","name","normalizedFormatName","replace","namespace","getNamespaceFromTerm","formatterPath","includes","npmFormat","normalizePackageName","__dirname","formatter","ex","format","resultsMeta","rulesMeta","sort","calculateConfigForFile","absolutePath","findConfigFile","shouldUseFlatConfig","process","env","ESLINT_USE_FLAT_CONFIG","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/eslint/flat-eslint.js"],"sourcesContent":["/**\n * @fileoverview Main class using flat config\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// Note: Node.js 12 does not support fs/promises.\nconst fs = require(\"fs\").promises;\nconst { existsSync } = require(\"fs\");\nconst path = require(\"path\");\nconst findUp = require(\"find-up\");\nconst { version } = require(\"../../package.json\");\nconst { Linter } = require(\"../linter\");\nconst { getRuleFromConfig } = require(\"../config/flat-config-helpers\");\nconst {\n    Legacy: {\n        ConfigOps: {\n            getRuleSeverity\n        },\n        ModuleResolver,\n        naming\n    }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n    findFiles,\n    getCacheFile,\n\n    isNonEmptyString,\n    isArrayOfNonEmptyString,\n\n    createIgnoreResult,\n    isErrorMessage,\n\n    processOptions\n} = require(\"./eslint-helpers\");\nconst { pathToFileURL } = require(\"url\");\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\nconst LintResultCache = require(\"../cli-engine/lint-result-cache\");\n\n/*\n * This is necessary to allow overwriting writeFile for testing purposes.\n * We can just use fs/promises once we drop Node.js 12 support.\n */\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").LintResult} LintResult */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").ResultsMeta} ResultsMeta */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} FlatESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables all ignore patterns except for the default ones.\n * @property {string[]} [ignorePatterns] Ignore file patterns to use in addition to config ignores. These patterns are relative to `cwd`.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {boolean|string} [overrideConfigFile] Searches for default config file when falsy;\n *      doesn't do any config file lookup when `true`; considered to be a config filename\n *      when a string.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {boolean} warnIgnored Show warnings when the file list includes ignored files\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FLAT_CONFIG_FILENAMES = [\n    \"eslint.config.js\",\n    \"eslint.config.mjs\",\n    \"eslint.config.cjs\"\n];\nconst debug = require(\"debug\")(\"eslint:flat-eslint\");\nconst removedFormatters = new Set([\"table\", \"codeframe\"]);\nconst privateMembers = new WeakMap();\nconst importedConfigFileModificationTime = new Map();\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    const stat = {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n\n    for (let i = 0; i < messages.length; i++) {\n        const message = messages[i];\n\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n            if (message.fatal) {\n                stat.fatalErrorCount++;\n            }\n            if (message.fix) {\n                stat.fixableErrorCount++;\n            }\n        } else {\n            stat.warningCount++;\n            if (message.fix) {\n                stat.fixableWarningCount++;\n            }\n        }\n    }\n    return stat;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\n        retVal[id] = rule.meta;\n        return retVal;\n    }, {});\n}\n\n/**\n * Return the absolute path of a file named `\"__placeholder__.js\"` in a given directory.\n * This is used as a replacement for a missing file path.\n * @param {string} cwd An absolute directory path.\n * @returns {string} The absolute path of a file named `\"__placeholder__.js\"` in the given directory.\n */\nfunction getPlaceholderPath(cwd) {\n    return path.join(cwd, \"__placeholder__.js\");\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {\n    const {\n        configs,\n        options: { cwd }\n    } = privateMembers.get(eslint);\n    const filePath = path.isAbsolute(maybeFilePath)\n        ? maybeFilePath\n        : getPlaceholderPath(cwd);\n    const config = configs.getConfig(filePath);\n\n    // Most files use the same config, so cache it.\n    if (config && !usedDeprecatedRulesCache.has(config)) {\n        const retv = [];\n\n        if (config.rules) {\n            for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n                if (getRuleSeverity(ruleConf) === 0) {\n                    continue;\n                }\n                const rule = getRuleFromConfig(ruleId, config);\n                const meta = rule && rule.meta;\n\n                if (meta && meta.deprecated) {\n                    retv.push({ ruleId, replacedBy: meta.replacedBy || [] });\n                }\n            }\n        }\n\n\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n    }\n\n    return config ? usedDeprecatedRulesCache.get(config) : Object.freeze([]);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processLintReport(eslint, { results }) {\n    const descriptor = {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return getOrFindUsedDeprecatedRules(eslint, this.filePath);\n        }\n    };\n\n    for (const result of results) {\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n    }\n\n    return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n    if (a.filePath < b.filePath) {\n        return -1;\n    }\n\n    if (a.filePath > b.filePath) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Searches from the current working directory up until finding the\n * given flat config filename.\n * @param {string} cwd The current working directory to search from.\n * @returns {Promise<string|undefined>} The filename if found or `undefined` if not.\n */\nfunction findFlatConfigFile(cwd) {\n    return findUp(\n        FLAT_CONFIG_FILENAMES,\n        { cwd }\n    );\n}\n\n/**\n * Load the config array from the given filename.\n * @param {string} filePath The filename to load from.\n * @returns {Promise<any>} The config loaded from the config file.\n */\nasync function loadFlatConfigFile(filePath) {\n    debug(`Loading config from ${filePath}`);\n\n    const fileURL = pathToFileURL(filePath);\n\n    debug(`Config file URL is ${fileURL}`);\n\n    const mtime = (await fs.stat(filePath)).mtime.getTime();\n\n    /*\n     * Append a query with the config file's modification time (`mtime`) in order\n     * to import the current version of the config file. Without the query, `import()` would\n     * cache the config file module by the pathname only, and then always return\n     * the same version (the one that was actual when the module was imported for the first time).\n     *\n     * This ensures that the config file module is loaded and executed again\n     * if it has been changed since the last time it was imported.\n     * If it hasn't been changed, `import()` will just return the cached version.\n     *\n     * Note that we should not overuse queries (e.g., by appending the current time\n     * to always reload the config file module) as that could cause memory leaks\n     * because entries are never removed from the import cache.\n     */\n    fileURL.searchParams.append(\"mtime\", mtime);\n\n    /*\n     * With queries, we can bypass the import cache. However, when import-ing a CJS module,\n     * Node.js uses the require infrastructure under the hood. That includes the require cache,\n     * which caches the config file module by its file path (queries have no effect).\n     * Therefore, we also need to clear the require cache before importing the config file module.\n     * In order to get the same behavior with ESM and CJS config files, in particular - to reload\n     * the config file only if it has been changed, we track file modification times and clear\n     * the require cache only if the file has been changed.\n     */\n    if (importedConfigFileModificationTime.get(filePath) !== mtime) {\n        delete require.cache[filePath];\n    }\n\n    const config = (await import(fileURL)).default;\n\n    importedConfigFileModificationTime.set(filePath, mtime);\n\n    return config;\n}\n\n/**\n * Determines which config file to use. This is determined by seeing if an\n * override config file was passed, and if so, using it; otherwise, as long\n * as override config file is not explicitly set to `false`, it will search\n * upwards from the cwd for a file named `eslint.config.js`.\n * @param {import(\"./eslint\").ESLintOptions} options The ESLint instance options.\n * @returns {{configFilePath:string|undefined,basePath:string,error:Error|null}} Location information for\n *      the config file.\n */\nasync function locateConfigFileToUse({ configFile, cwd }) {\n\n    // determine where to load config file from\n    let configFilePath;\n    let basePath = cwd;\n    let error = null;\n\n    if (typeof configFile === \"string\") {\n        debug(`Override config file path is ${configFile}`);\n        configFilePath = path.resolve(cwd, configFile);\n    } else if (configFile !== false) {\n        debug(\"Searching for eslint.config.js\");\n        configFilePath = await findFlatConfigFile(cwd);\n\n        if (configFilePath) {\n            basePath = path.resolve(path.dirname(configFilePath));\n        } else {\n            error = new Error(\"Could not find config file.\");\n        }\n\n    }\n\n    return {\n        configFilePath,\n        basePath,\n        error\n    };\n\n}\n\n/**\n * Calculates the config array for this run based on inputs.\n * @param {FlatESLint} eslint The instance to create the config array for.\n * @param {import(\"./eslint\").ESLintOptions} options The ESLint instance options.\n * @returns {FlatConfigArray} The config array for `eslint``.\n */\nasync function calculateConfigArray(eslint, {\n    cwd,\n    baseConfig,\n    overrideConfig,\n    configFile,\n    ignore: shouldIgnore,\n    ignorePatterns\n}) {\n\n    // check for cached instance\n    const slots = privateMembers.get(eslint);\n\n    if (slots.configs) {\n        return slots.configs;\n    }\n\n    const { configFilePath, basePath, error } = await locateConfigFileToUse({ configFile, cwd });\n\n    // config file is required to calculate config\n    if (error) {\n        throw error;\n    }\n\n    const configs = new FlatConfigArray(baseConfig || [], { basePath, shouldIgnore });\n\n    // load config file\n    if (configFilePath) {\n        const fileConfig = await loadFlatConfigFile(configFilePath);\n\n        if (Array.isArray(fileConfig)) {\n            configs.push(...fileConfig);\n        } else {\n            configs.push(fileConfig);\n        }\n    }\n\n    // add in any configured defaults\n    configs.push(...slots.defaultConfigs);\n\n    // append command line ignore patterns\n    if (ignorePatterns && ignorePatterns.length > 0) {\n\n        let relativeIgnorePatterns;\n\n        /*\n         * If the config file basePath is different than the cwd, then\n         * the ignore patterns won't work correctly. Here, we adjust the\n         * ignore pattern to include the correct relative path. Patterns\n         * passed as `ignorePatterns` are relative to the cwd, whereas\n         * the config file basePath can be an ancestor of the cwd.\n         */\n        if (basePath === cwd) {\n            relativeIgnorePatterns = ignorePatterns;\n        } else {\n\n            const relativeIgnorePath = path.relative(basePath, cwd);\n\n            relativeIgnorePatterns = ignorePatterns.map(pattern => {\n                const negated = pattern.startsWith(\"!\");\n                const basePattern = negated ? pattern.slice(1) : pattern;\n\n                return (negated ? \"!\" : \"\") +\n                path.posix.join(relativeIgnorePath, basePattern);\n            });\n        }\n\n        /*\n         * Ignore patterns are added to the end of the config array\n         * so they can override default ignores.\n         */\n        configs.push({\n            ignores: relativeIgnorePatterns\n        });\n    }\n\n    if (overrideConfig) {\n        if (Array.isArray(overrideConfig)) {\n            configs.push(...overrideConfig);\n        } else {\n            configs.push(overrideConfig);\n        }\n    }\n\n    await configs.normalize();\n\n    // cache the config array for this instance\n    slots.configs = configs;\n\n    return configs;\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {FlatConfigArray} config.configs The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n    text,\n    cwd,\n    filePath: providedFilePath,\n    configs,\n    fix,\n    allowInlineConfig,\n    linter\n}) {\n    const filePath = providedFilePath || \"<text>\";\n\n    debug(`Lint ${filePath}`);\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n    const filePathToVerify = filePath === \"<text>\" ? getPlaceholderPath(cwd) : filePath;\n    const { fixed, messages, output } = linter.verifyAndFix(\n        text,\n        configs,\n        {\n            allowInlineConfig,\n            filename: filePathToVerify,\n            fix,\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n            filterCodeBlock(blockFilename) {\n                return configs.getConfig(blockFilename) !== void 0;\n            }\n        }\n    );\n\n    // Tweak and return.\n    const result = {\n        filePath: filePath === \"<text>\" ? filePath : path.resolve(filePath),\n        messages,\n        suppressedMessages: linter.getSuppressedMessages(),\n        ...calculateStatsPerFile(messages)\n    };\n\n    if (fixed) {\n        result.output = output;\n    }\n\n    if (\n        result.errorCount + result.warningCount > 0 &&\n        typeof result.output === \"undefined\"\n    ) {\n        result.source = text;\n    }\n\n    return result;\n}\n\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\nfunction shouldMessageBeFixed(message, config, fixTypes) {\n    if (!message.ruleId) {\n        return fixTypes.has(\"directive\");\n    }\n\n    const rule = message.ruleId && getRuleFromConfig(message.ruleId, config);\n\n    return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n\n/**\n * Creates an error to be thrown when an array of results passed to `getRulesMetaForResults` was not created by the current engine.\n * @returns {TypeError} An error object.\n */\nfunction createExtraneousResultsError() {\n    return new TypeError(\"Results object was not created from this ESLint instance.\");\n}\n\n/**\n * Creates a fixer function based on the provided fix, fixTypesSet, and config.\n * @param {Function|boolean} fix The original fix option.\n * @param {Set<string>} fixTypesSet A set of fix types to filter messages for fixing.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @returns {Function|boolean} The fixer function or the original fix value.\n */\nfunction getFixerForFixTypes(fix, fixTypesSet, config) {\n    if (!fix || !fixTypesSet) {\n        return fix;\n    }\n\n    const originalFix = (typeof fix === \"function\") ? fix : () => true;\n\n    return message => shouldMessageBeFixed(message, config, fixTypesSet) && originalFix(message);\n}\n\n//-----------------------------------------------------------------------------\n// Main API\n//-----------------------------------------------------------------------------\n\n/**\n * Primary Node.js API for ESLint.\n */\nclass FlatESLint {\n\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param {FlatESLintOptions} options The options for this instance.\n     */\n    constructor(options = {}) {\n\n        const defaultConfigs = [];\n        const processedOptions = processOptions(options);\n        const linter = new Linter({\n            cwd: processedOptions.cwd,\n            configType: \"flat\"\n        });\n\n        const cacheFilePath = getCacheFile(\n            processedOptions.cacheLocation,\n            processedOptions.cwd\n        );\n\n        const lintResultCache = processedOptions.cache\n            ? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy)\n            : null;\n\n        privateMembers.set(this, {\n            options: processedOptions,\n            linter,\n            cacheFilePath,\n            lintResultCache,\n            defaultConfigs,\n            configs: null\n        });\n\n        /**\n         * If additional plugins are passed in, add that to the default\n         * configs for this instance.\n         */\n        if (options.plugins) {\n\n            const plugins = {};\n\n            for (const [pluginName, plugin] of Object.entries(options.plugins)) {\n                plugins[naming.getShorthandName(pluginName, \"eslint-plugin\")] = plugin;\n            }\n\n            defaultConfigs.push({\n                plugins\n            });\n        }\n\n    }\n\n    /**\n     * The version text.\n     * @type {string}\n     */\n    static get version() {\n        return version;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintResult[]} results The lint results.\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\n     */\n    static async outputFixes(results) {\n        if (!Array.isArray(results)) {\n            throw new Error(\"'results' must be an array\");\n        }\n\n        await Promise.all(\n            results\n                .filter(result => {\n                    if (typeof result !== \"object\" || result === null) {\n                        throw new Error(\"'results' must include only objects\");\n                    }\n                    return (\n                        typeof result.output === \"string\" &&\n                        path.isAbsolute(result.filePath)\n                    );\n                })\n                .map(r => fs.writeFile(r.filePath, r.output))\n        );\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        const filtered = [];\n\n        results.forEach(result => {\n            const filteredMessages = result.messages.filter(isErrorMessage);\n            const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n\n            if (filteredMessages.length > 0) {\n                filtered.push({\n                    ...result,\n                    messages: filteredMessages,\n                    suppressedMessages: filteredSuppressedMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0,\n                    fixableErrorCount: result.fixableErrorCount,\n                    fixableWarningCount: 0\n                });\n            }\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Returns meta objects for each rule represented in the lint results.\n     * @param {LintResult[]} results The results to fetch rules meta for.\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\n     * @throws {TypeError} When the results object wasn't created from this ESLint instance.\n     * @throws {TypeError} When a plugin or rule is missing.\n     */\n    getRulesMetaForResults(results) {\n\n        // short-circuit simple case\n        if (results.length === 0) {\n            return {};\n        }\n\n        const resultRules = new Map();\n        const {\n            configs,\n            options: { cwd }\n        } = privateMembers.get(this);\n\n        /*\n         * We can only accurately return rules meta information for linting results if the\n         * results were created by this instance. Otherwise, the necessary rules data is\n         * not available. So if the config array doesn't already exist, just throw an error\n         * to let the user know we can't do anything here.\n         */\n        if (!configs) {\n            throw createExtraneousResultsError();\n        }\n\n        for (const result of results) {\n\n            /*\n             * Normalize filename for <text>.\n             */\n            const filePath = result.filePath === \"<text>\"\n                ? getPlaceholderPath(cwd) : result.filePath;\n            const allMessages = result.messages.concat(result.suppressedMessages);\n\n            for (const { ruleId } of allMessages) {\n                if (!ruleId) {\n                    continue;\n                }\n\n                /*\n                 * All of the plugin and rule information is contained within the\n                 * calculated config for the given file.\n                 */\n                const config = configs.getConfig(filePath);\n\n                if (!config) {\n                    throw createExtraneousResultsError();\n                }\n                const rule = getRuleFromConfig(ruleId, config);\n\n                // ignore unknown rules\n                if (rule) {\n                    resultRules.set(ruleId, rule);\n                }\n            }\n        }\n\n        return createRulesMeta(resultRules);\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string|string[]} patterns An array of file and directory names.\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n     */\n    async lintFiles(patterns) {\n        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n            throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n        }\n\n        const {\n            cacheFilePath,\n            lintResultCache,\n            linter,\n            options: eslintOptions\n        } = privateMembers.get(this);\n        const configs = await calculateConfigArray(this, eslintOptions);\n        const {\n            allowInlineConfig,\n            cache,\n            cwd,\n            fix,\n            fixTypes,\n            globInputPaths,\n            errorOnUnmatchedPattern,\n            warnIgnored\n        } = eslintOptions;\n        const startTime = Date.now();\n        const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n\n        // Delete cache file; should this be done here?\n        if (!cache && cacheFilePath) {\n            debug(`Deleting cache file at ${cacheFilePath}`);\n\n            try {\n                await fs.unlink(cacheFilePath);\n            } catch (error) {\n                const errorCode = error && error.code;\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n                if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !existsSync(cacheFilePath))) {\n                    throw error;\n                }\n            }\n        }\n\n        const filePaths = await findFiles({\n            patterns: typeof patterns === \"string\" ? [patterns] : patterns,\n            cwd,\n            globInputPaths,\n            configs,\n            errorOnUnmatchedPattern\n        });\n\n        debug(`${filePaths.length} files found in: ${Date.now() - startTime}ms`);\n\n        /*\n         * Because we need to process multiple files, including reading from disk,\n         * it is most efficient to start by reading each file via promises so that\n         * they can be done in parallel. Then, we can lint the returned text. This\n         * ensures we are waiting the minimum amount of time in between lints.\n         */\n        const results = await Promise.all(\n\n            filePaths.map(filePath => {\n\n                const config = configs.getConfig(filePath);\n\n                /*\n                 * If a filename was entered that cannot be matched\n                 * to a config, then notify the user.\n                 */\n                if (!config) {\n                    if (warnIgnored) {\n                        return createIgnoreResult(filePath, cwd);\n                    }\n\n                    return void 0;\n                }\n\n                // Skip if there is cached result.\n                if (lintResultCache) {\n                    const cachedResult =\n                        lintResultCache.getCachedLintResults(filePath, config);\n\n                    if (cachedResult) {\n                        const hadMessages =\n                            cachedResult.messages &&\n                            cachedResult.messages.length > 0;\n\n                        if (hadMessages && fix) {\n                            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n                        } else {\n                            debug(`Skipping file since it hasn't changed: ${filePath}`);\n                            return cachedResult;\n                        }\n                    }\n                }\n\n\n                // set up fixer for fixTypes if necessary\n                const fixer = getFixerForFixTypes(fix, fixTypesSet, config);\n\n                return fs.readFile(filePath, \"utf8\")\n                    .then(text => {\n\n                        // do the linting\n                        const result = verifyText({\n                            text,\n                            filePath,\n                            configs,\n                            cwd,\n                            fix: fixer,\n                            allowInlineConfig,\n                            linter\n                        });\n\n                        /*\n                         * Store the lint result in the LintResultCache.\n                         * NOTE: The LintResultCache will remove the file source and any\n                         * other properties that are difficult to serialize, and will\n                         * hydrate those properties back in on future lint runs.\n                         */\n                        if (lintResultCache) {\n                            lintResultCache.setCachedLintResults(filePath, config, result);\n                        }\n\n                        return result;\n                    });\n\n            })\n        );\n\n        // Persist the cache to disk.\n        if (lintResultCache) {\n            lintResultCache.reconcile();\n        }\n\n        const finalResults = results.filter(result => !!result);\n\n        return processLintReport(this, {\n            results: finalResults\n        });\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} code A string of JavaScript code to lint.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to the file of the source code.\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n     */\n    async lintText(code, options = {}) {\n\n        // Parameter validation\n\n        if (typeof code !== \"string\") {\n            throw new Error(\"'code' must be a string\");\n        }\n\n        if (typeof options !== \"object\") {\n            throw new Error(\"'options' must be an object, null, or undefined\");\n        }\n\n        // Options validation\n\n        const {\n            filePath,\n            warnIgnored,\n            ...unknownOptions\n        } = options || {};\n\n        const unknownOptionKeys = Object.keys(unknownOptions);\n\n        if (unknownOptionKeys.length > 0) {\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n        }\n\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n        }\n\n        if (typeof warnIgnored !== \"boolean\" && typeof warnIgnored !== \"undefined\") {\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n        }\n\n        // Now we can get down to linting\n\n        const {\n            linter,\n            options: eslintOptions\n        } = privateMembers.get(this);\n        const configs = await calculateConfigArray(this, eslintOptions);\n        const {\n            allowInlineConfig,\n            cwd,\n            fix,\n            fixTypes,\n            warnIgnored: constructorWarnIgnored\n        } = eslintOptions;\n        const results = [];\n        const startTime = Date.now();\n        const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n        const resolvedFilename = path.resolve(cwd, filePath || \"__placeholder__.js\");\n        const config = configs.getConfig(resolvedFilename);\n\n        const fixer = getFixerForFixTypes(fix, fixTypesSet, config);\n\n        // Clear the last used config arrays.\n        if (resolvedFilename && await this.isPathIgnored(resolvedFilename)) {\n            const shouldWarnIgnored = typeof warnIgnored === \"boolean\" ? warnIgnored : constructorWarnIgnored;\n\n            if (shouldWarnIgnored) {\n                results.push(createIgnoreResult(resolvedFilename, cwd));\n            }\n        } else {\n\n            // Do lint.\n            results.push(verifyText({\n                text: code,\n                filePath: resolvedFilename.endsWith(\"__placeholder__.js\") ? \"<text>\" : resolvedFilename,\n                configs,\n                cwd,\n                fix: fixer,\n                allowInlineConfig,\n                linter\n            }));\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n\n        return processLintReport(this, {\n            results\n        });\n\n    }\n\n    /**\n     * Returns the formatter representing the given formatter name.\n     * @param {string} [name] The name of the formatter to load.\n     * The following values are allowed:\n     * - `undefined` ... Load `stylish` builtin formatter.\n     * - A builtin formatter name ... Load the builtin formatter.\n     * - A third-party formatter name:\n     *   - `foo` → `eslint-formatter-foo`\n     *   - `@foo` → `@foo/eslint-formatter`\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n     * - A file path ... Load the file.\n     * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n     * This promise will be rejected if the given formatter was not found or not\n     * a function.\n     */\n    async loadFormatter(name = \"stylish\") {\n        if (typeof name !== \"string\") {\n            throw new Error(\"'name' must be a string\");\n        }\n\n        // replace \\ with / for Windows compatibility\n        const normalizedFormatName = name.replace(/\\\\/gu, \"/\");\n        const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n        // grab our options\n        const { cwd } = privateMembers.get(this).options;\n\n\n        let formatterPath;\n\n        // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n        if (!namespace && normalizedFormatName.includes(\"/\")) {\n            formatterPath = path.resolve(cwd, normalizedFormatName);\n        } else {\n            try {\n                const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n                // TODO: This is pretty dirty...would be nice to clean up at some point.\n                formatterPath = ModuleResolver.resolve(npmFormat, getPlaceholderPath(cwd));\n            } catch {\n                formatterPath = path.resolve(__dirname, \"../\", \"cli-engine\", \"formatters\", `${normalizedFormatName}.js`);\n            }\n        }\n\n        let formatter;\n\n        try {\n            formatter = (await import(pathToFileURL(formatterPath))).default;\n        } catch (ex) {\n\n            // check for formatters that have been removed\n            if (removedFormatters.has(name)) {\n                ex.message = `The ${name} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${name}\\``;\n            } else {\n                ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n            }\n\n            throw ex;\n        }\n\n\n        if (typeof formatter !== \"function\") {\n            throw new TypeError(`Formatter must be a function, but got a ${typeof formatter}.`);\n        }\n\n        const eslint = this;\n\n        return {\n\n            /**\n             * The main formatter method.\n             * @param {LintResults[]} results The lint results to format.\n             * @param {ResultsMeta} resultsMeta Warning count and max threshold.\n             * @returns {string} The formatted lint results.\n             */\n            format(results, resultsMeta) {\n                let rulesMeta = null;\n\n                results.sort(compareResultsByFilePath);\n\n                return formatter(results, {\n                    ...resultsMeta,\n                    cwd,\n                    get rulesMeta() {\n                        if (!rulesMeta) {\n                            rulesMeta = eslint.getRulesMetaForResults(results);\n                        }\n\n                        return rulesMeta;\n                    }\n                });\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n     *      or `undefined` if there is no configuration data for the object.\n     */\n    async calculateConfigForFile(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const options = privateMembers.get(this).options;\n        const absolutePath = path.resolve(options.cwd, filePath);\n        const configs = await calculateConfigArray(this, options);\n\n        return configs.getConfig(absolutePath);\n    }\n\n    /**\n     * Finds the config file being used by this instance based on the options\n     * passed to the constructor.\n     * @returns {string|undefined} The path to the config file being used or\n     *      `undefined` if no config file is being used.\n     */\n    async findConfigFile() {\n        const options = privateMembers.get(this).options;\n        const { configFilePath } = await locateConfigFileToUse(options);\n\n        return configFilePath;\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\n     */\n    async isPathIgnored(filePath) {\n        const config = await this.calculateConfigForFile(filePath);\n\n        return config === void 0;\n    }\n}\n\n/**\n * The type of configuration used by this class.\n * @type {string}\n * @static\n */\nFlatESLint.configType = \"flat\";\n\n/**\n * Returns whether flat config should be used.\n * @param {Object} [options] The options for this function.\n * @param {string} [options.cwd] The current working directory.\n * @returns {Promise<boolean>} Whether flat config should be used.\n */\nasync function shouldUseFlatConfig({ cwd = process.cwd() } = {}) {\n    switch (process.env.ESLINT_USE_FLAT_CONFIG) {\n        case \"true\":\n            return true;\n        case \"false\":\n            return false;\n        default:\n\n            /*\n             * If neither explicitly enabled nor disabled, then use the presence\n             * of a flat config file to determine enablement.\n             */\n            return !!(await findFlatConfigFile(cwd));\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    FlatESLint,\n    shouldUseFlatConfig\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC,CAACC,QAAQ;AACjC,MAAM;EAAEC;AAAW,CAAC,GAAGF,OAAO,CAAC,IAAI,CAAC;AACpC,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAS,CAAC;AACjC,MAAM;EAAEK;AAAQ,CAAC,GAAGL,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAM;EAAEM;AAAO,CAAC,GAAGN,OAAO,CAAC,WAAW,CAAC;AACvC,MAAM;EAAEO;AAAkB,CAAC,GAAGP,OAAO,CAAC,+BAA+B,CAAC;AACtE,MAAM;EACFQ,MAAM,EAAE;IACJC,SAAS,EAAE;MACPC;IACJ,CAAC;IACDC,cAAc;IACdC;EACJ;AACJ,CAAC,GAAGZ,OAAO,CAAC,kBAAkB,CAAC;AAE/B,MAAM;EACFa,SAAS;EACTC,YAAY;EAEZC,gBAAgB;EAChBC,uBAAuB;EAEvBC,kBAAkB;EAClBC,cAAc;EAEdC;AACJ,CAAC,GAAGnB,OAAO,CAAC,kBAAkB,CAAC;AAC/B,MAAM;EAAEoB;AAAc,CAAC,GAAGpB,OAAO,CAAC,KAAK,CAAC;AACxC,MAAM;EAAEqB;AAAgB,CAAC,GAAGrB,OAAO,CAAC,6BAA6B,CAAC;AAClE,MAAMsB,eAAe,GAAGtB,OAAO,CAAC,iCAAiC,CAAC;;AAElE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAMuB,qBAAqB,GAAG,CAC1B,kBAAkB,EAClB,mBAAmB,EACnB,mBAAmB,CACtB;AACD,MAAMC,KAAK,GAAGxB,OAAO,CAAC,OAAO,CAAC,CAAC,oBAAoB,CAAC;AACpD,MAAMyB,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AACzD,MAAMC,cAAc,GAAG,IAAIC,OAAO,CAAC,CAAC;AACpC,MAAMC,kCAAkC,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,QAAQ,EAAE;EACrC,MAAMC,IAAI,GAAG;IACTC,UAAU,EAAE,CAAC;IACbC,eAAe,EAAE,CAAC;IAClBC,YAAY,EAAE,CAAC;IACfC,iBAAiB,EAAE,CAAC;IACpBC,mBAAmB,EAAE;EACzB,CAAC;EAED,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,QAAQ,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,MAAME,OAAO,GAAGT,QAAQ,CAACO,CAAC,CAAC;IAE3B,IAAIE,OAAO,CAACC,KAAK,IAAID,OAAO,CAACE,QAAQ,KAAK,CAAC,EAAE;MACzCV,IAAI,CAACC,UAAU,EAAE;MACjB,IAAIO,OAAO,CAACC,KAAK,EAAE;QACfT,IAAI,CAACE,eAAe,EAAE;MAC1B;MACA,IAAIM,OAAO,CAACG,GAAG,EAAE;QACbX,IAAI,CAACI,iBAAiB,EAAE;MAC5B;IACJ,CAAC,MAAM;MACHJ,IAAI,CAACG,YAAY,EAAE;MACnB,IAAIK,OAAO,CAACG,GAAG,EAAE;QACbX,IAAI,CAACK,mBAAmB,EAAE;MAC9B;IACJ;EACJ;EACA,OAAOL,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASY,eAAeA,CAACC,KAAK,EAAE;EAC5B,OAAOC,KAAK,CAACC,IAAI,CAACF,KAAK,CAAC,CAACG,MAAM,CAAC,CAACC,MAAM,EAAE,CAACC,EAAE,EAAEC,IAAI,CAAC,KAAK;IACpDF,MAAM,CAACC,EAAE,CAAC,GAAGC,IAAI,CAACC,IAAI;IACtB,OAAOH,MAAM;EACjB,CAAC,EAAE,CAAC,CAAC,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,kBAAkBA,CAACC,GAAG,EAAE;EAC7B,OAAOpD,IAAI,CAACqD,IAAI,CAACD,GAAG,EAAE,oBAAoB,CAAC;AAC/C;;AAEA;AACA,MAAME,wBAAwB,GAAG,IAAI7B,OAAO,CAAC,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8B,4BAA4BA,CAACC,MAAM,EAAEC,aAAa,EAAE;EACzD,MAAM;IACFC,OAAO;IACPC,OAAO,EAAE;MAAEP;IAAI;EACnB,CAAC,GAAG5B,cAAc,CAACoC,GAAG,CAACJ,MAAM,CAAC;EAC9B,MAAMK,QAAQ,GAAG7D,IAAI,CAAC8D,UAAU,CAACL,aAAa,CAAC,GACzCA,aAAa,GACbN,kBAAkB,CAACC,GAAG,CAAC;EAC7B,MAAMW,MAAM,GAAGL,OAAO,CAACM,SAAS,CAACH,QAAQ,CAAC;;EAE1C;EACA,IAAIE,MAAM,IAAI,CAACT,wBAAwB,CAACW,GAAG,CAACF,MAAM,CAAC,EAAE;IACjD,MAAMG,IAAI,GAAG,EAAE;IAEf,IAAIH,MAAM,CAACpB,KAAK,EAAE;MACd,KAAK,MAAM,CAACwB,MAAM,EAAEC,QAAQ,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACP,MAAM,CAACpB,KAAK,CAAC,EAAE;QAC3D,IAAIpC,eAAe,CAAC6D,QAAQ,CAAC,KAAK,CAAC,EAAE;UACjC;QACJ;QACA,MAAMnB,IAAI,GAAG7C,iBAAiB,CAAC+D,MAAM,EAAEJ,MAAM,CAAC;QAC9C,MAAMb,IAAI,GAAGD,IAAI,IAAIA,IAAI,CAACC,IAAI;QAE9B,IAAIA,IAAI,IAAIA,IAAI,CAACqB,UAAU,EAAE;UACzBL,IAAI,CAACM,IAAI,CAAC;YAAEL,MAAM;YAAEM,UAAU,EAAEvB,IAAI,CAACuB,UAAU,IAAI;UAAG,CAAC,CAAC;QAC5D;MACJ;IACJ;IAGAnB,wBAAwB,CAACoB,GAAG,CAACX,MAAM,EAAEM,MAAM,CAACM,MAAM,CAACT,IAAI,CAAC,CAAC;EAC7D;EAEA,OAAOH,MAAM,GAAGT,wBAAwB,CAACM,GAAG,CAACG,MAAM,CAAC,GAAGM,MAAM,CAACM,MAAM,CAAC,EAAE,CAAC;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAACpB,MAAM,EAAE;EAAEqB;AAAQ,CAAC,EAAE;EAC5C,MAAMC,UAAU,GAAG;IACfC,YAAY,EAAE,IAAI;IAClBC,UAAU,EAAE,IAAI;IAChBpB,GAAGA,CAAA,EAAG;MACF,OAAOL,4BAA4B,CAACC,MAAM,EAAE,IAAI,CAACK,QAAQ,CAAC;IAC9D;EACJ,CAAC;EAED,KAAK,MAAMoB,MAAM,IAAIJ,OAAO,EAAE;IAC1BR,MAAM,CAACa,cAAc,CAACD,MAAM,EAAE,qBAAqB,EAAEH,UAAU,CAAC;EACpE;EAEA,OAAOD,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,wBAAwBA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACpC,IAAID,CAAC,CAACvB,QAAQ,GAAGwB,CAAC,CAACxB,QAAQ,EAAE;IACzB,OAAO,CAAC,CAAC;EACb;EAEA,IAAIuB,CAAC,CAACvB,QAAQ,GAAGwB,CAAC,CAACxB,QAAQ,EAAE;IACzB,OAAO,CAAC;EACZ;EAEA,OAAO,CAAC;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyB,kBAAkBA,CAAClC,GAAG,EAAE;EAC7B,OAAOnD,MAAM,CACTmB,qBAAqB,EACrB;IAAEgC;EAAI,CACV,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAemC,kBAAkBA,CAAC1B,QAAQ,EAAE;EACxCxC,KAAK,CAAC,uBAAuBwC,QAAQ,EAAE,CAAC;EAExC,MAAM2B,OAAO,GAAGvE,aAAa,CAAC4C,QAAQ,CAAC;EAEvCxC,KAAK,CAAC,sBAAsBmE,OAAO,EAAE,CAAC;EAEtC,MAAMC,KAAK,GAAG,CAAC,MAAM7F,EAAE,CAACkC,IAAI,CAAC+B,QAAQ,CAAC,EAAE4B,KAAK,CAACC,OAAO,CAAC,CAAC;;EAEvD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,OAAO,CAACG,YAAY,CAACC,MAAM,CAAC,OAAO,EAAEH,KAAK,CAAC;;EAE3C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI/D,kCAAkC,CAACkC,GAAG,CAACC,QAAQ,CAAC,KAAK4B,KAAK,EAAE;IAC5D,OAAO5F,OAAO,CAACgG,KAAK,CAAChC,QAAQ,CAAC;EAClC;EAEA,MAAME,MAAM,GAAG,CAAC,MAAM,MAAM,CAACyB,OAAO,CAAC,EAAEM,OAAO;EAE9CpE,kCAAkC,CAACgD,GAAG,CAACb,QAAQ,EAAE4B,KAAK,CAAC;EAEvD,OAAO1B,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAegC,qBAAqBA,CAAC;EAAEC,UAAU;EAAE5C;AAAI,CAAC,EAAE;EAEtD;EACA,IAAI6C,cAAc;EAClB,IAAIC,QAAQ,GAAG9C,GAAG;EAClB,IAAI+C,KAAK,GAAG,IAAI;EAEhB,IAAI,OAAOH,UAAU,KAAK,QAAQ,EAAE;IAChC3E,KAAK,CAAC,gCAAgC2E,UAAU,EAAE,CAAC;IACnDC,cAAc,GAAGjG,IAAI,CAACoG,OAAO,CAAChD,GAAG,EAAE4C,UAAU,CAAC;EAClD,CAAC,MAAM,IAAIA,UAAU,KAAK,KAAK,EAAE;IAC7B3E,KAAK,CAAC,gCAAgC,CAAC;IACvC4E,cAAc,GAAG,MAAMX,kBAAkB,CAAClC,GAAG,CAAC;IAE9C,IAAI6C,cAAc,EAAE;MAChBC,QAAQ,GAAGlG,IAAI,CAACoG,OAAO,CAACpG,IAAI,CAACqG,OAAO,CAACJ,cAAc,CAAC,CAAC;IACzD,CAAC,MAAM;MACHE,KAAK,GAAG,IAAIG,KAAK,CAAC,6BAA6B,CAAC;IACpD;EAEJ;EAEA,OAAO;IACHL,cAAc;IACdC,QAAQ;IACRC;EACJ,CAAC;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeI,oBAAoBA,CAAC/C,MAAM,EAAE;EACxCJ,GAAG;EACHoD,UAAU;EACVC,cAAc;EACdT,UAAU;EACVU,MAAM,EAAEC,YAAY;EACpBC;AACJ,CAAC,EAAE;EAEC;EACA,MAAMC,KAAK,GAAGrF,cAAc,CAACoC,GAAG,CAACJ,MAAM,CAAC;EAExC,IAAIqD,KAAK,CAACnD,OAAO,EAAE;IACf,OAAOmD,KAAK,CAACnD,OAAO;EACxB;EAEA,MAAM;IAAEuC,cAAc;IAAEC,QAAQ;IAAEC;EAAM,CAAC,GAAG,MAAMJ,qBAAqB,CAAC;IAAEC,UAAU;IAAE5C;EAAI,CAAC,CAAC;;EAE5F;EACA,IAAI+C,KAAK,EAAE;IACP,MAAMA,KAAK;EACf;EAEA,MAAMzC,OAAO,GAAG,IAAIxC,eAAe,CAACsF,UAAU,IAAI,EAAE,EAAE;IAAEN,QAAQ;IAAES;EAAa,CAAC,CAAC;;EAEjF;EACA,IAAIV,cAAc,EAAE;IAChB,MAAMa,UAAU,GAAG,MAAMvB,kBAAkB,CAACU,cAAc,CAAC;IAE3D,IAAIrD,KAAK,CAACmE,OAAO,CAACD,UAAU,CAAC,EAAE;MAC3BpD,OAAO,CAACc,IAAI,CAAC,GAAGsC,UAAU,CAAC;IAC/B,CAAC,MAAM;MACHpD,OAAO,CAACc,IAAI,CAACsC,UAAU,CAAC;IAC5B;EACJ;;EAEA;EACApD,OAAO,CAACc,IAAI,CAAC,GAAGqC,KAAK,CAACG,cAAc,CAAC;;EAErC;EACA,IAAIJ,cAAc,IAAIA,cAAc,CAACvE,MAAM,GAAG,CAAC,EAAE;IAE7C,IAAI4E,sBAAsB;;IAE1B;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAIf,QAAQ,KAAK9C,GAAG,EAAE;MAClB6D,sBAAsB,GAAGL,cAAc;IAC3C,CAAC,MAAM;MAEH,MAAMM,kBAAkB,GAAGlH,IAAI,CAACmH,QAAQ,CAACjB,QAAQ,EAAE9C,GAAG,CAAC;MAEvD6D,sBAAsB,GAAGL,cAAc,CAACQ,GAAG,CAACC,OAAO,IAAI;QACnD,MAAMC,OAAO,GAAGD,OAAO,CAACE,UAAU,CAAC,GAAG,CAAC;QACvC,MAAMC,WAAW,GAAGF,OAAO,GAAGD,OAAO,CAACI,KAAK,CAAC,CAAC,CAAC,GAAGJ,OAAO;QAExD,OAAO,CAACC,OAAO,GAAG,GAAG,GAAG,EAAE,IAC1BtH,IAAI,CAAC0H,KAAK,CAACrE,IAAI,CAAC6D,kBAAkB,EAAEM,WAAW,CAAC;MACpD,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;IACQ9D,OAAO,CAACc,IAAI,CAAC;MACTmD,OAAO,EAAEV;IACb,CAAC,CAAC;EACN;EAEA,IAAIR,cAAc,EAAE;IAChB,IAAI7D,KAAK,CAACmE,OAAO,CAACN,cAAc,CAAC,EAAE;MAC/B/C,OAAO,CAACc,IAAI,CAAC,GAAGiC,cAAc,CAAC;IACnC,CAAC,MAAM;MACH/C,OAAO,CAACc,IAAI,CAACiC,cAAc,CAAC;IAChC;EACJ;EAEA,MAAM/C,OAAO,CAACkE,SAAS,CAAC,CAAC;;EAEzB;EACAf,KAAK,CAACnD,OAAO,GAAGA,OAAO;EAEvB,OAAOA,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmE,UAAUA,CAAC;EAChBC,IAAI;EACJ1E,GAAG;EACHS,QAAQ,EAAEkE,gBAAgB;EAC1BrE,OAAO;EACPjB,GAAG;EACHuF,iBAAiB;EACjBC;AACJ,CAAC,EAAE;EACC,MAAMpE,QAAQ,GAAGkE,gBAAgB,IAAI,QAAQ;EAE7C1G,KAAK,CAAC,QAAQwC,QAAQ,EAAE,CAAC;;EAEzB;AACJ;AACA;AACA;AACA;EACI,MAAMqE,gBAAgB,GAAGrE,QAAQ,KAAK,QAAQ,GAAGV,kBAAkB,CAACC,GAAG,CAAC,GAAGS,QAAQ;EACnF,MAAM;IAAEsE,KAAK;IAAEtG,QAAQ;IAAEuG;EAAO,CAAC,GAAGH,MAAM,CAACI,YAAY,CACnDP,IAAI,EACJpE,OAAO,EACP;IACIsE,iBAAiB;IACjBM,QAAQ,EAAEJ,gBAAgB;IAC1BzF,GAAG;IAEH;AACZ;AACA;AACA;AACA;IACY8F,eAAeA,CAACC,aAAa,EAAE;MAC3B,OAAO9E,OAAO,CAACM,SAAS,CAACwE,aAAa,CAAC,KAAK,KAAK,CAAC;IACtD;EACJ,CACJ,CAAC;;EAED;EACA,MAAMvD,MAAM,GAAG;IACXpB,QAAQ,EAAEA,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAG7D,IAAI,CAACoG,OAAO,CAACvC,QAAQ,CAAC;IACnEhC,QAAQ;IACR4G,kBAAkB,EAAER,MAAM,CAACS,qBAAqB,CAAC,CAAC;IAClD,GAAG9G,qBAAqB,CAACC,QAAQ;EACrC,CAAC;EAED,IAAIsG,KAAK,EAAE;IACPlD,MAAM,CAACmD,MAAM,GAAGA,MAAM;EAC1B;EAEA,IACInD,MAAM,CAAClD,UAAU,GAAGkD,MAAM,CAAChD,YAAY,GAAG,CAAC,IAC3C,OAAOgD,MAAM,CAACmD,MAAM,KAAK,WAAW,EACtC;IACEnD,MAAM,CAAC0D,MAAM,GAAGb,IAAI;EACxB;EAEA,OAAO7C,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2D,oBAAoBA,CAACtG,OAAO,EAAEyB,MAAM,EAAE8E,QAAQ,EAAE;EACrD,IAAI,CAACvG,OAAO,CAAC6B,MAAM,EAAE;IACjB,OAAO0E,QAAQ,CAAC5E,GAAG,CAAC,WAAW,CAAC;EACpC;EAEA,MAAMhB,IAAI,GAAGX,OAAO,CAAC6B,MAAM,IAAI/D,iBAAiB,CAACkC,OAAO,CAAC6B,MAAM,EAAEJ,MAAM,CAAC;EAExE,OAAO+E,OAAO,CAAC7F,IAAI,IAAIA,IAAI,CAACC,IAAI,IAAI2F,QAAQ,CAAC5E,GAAG,CAAChB,IAAI,CAACC,IAAI,CAAC6F,IAAI,CAAC,CAAC;AACrE;;AAEA;AACA;AACA;AACA;AACA,SAASC,4BAA4BA,CAAA,EAAG;EACpC,OAAO,IAAIC,SAAS,CAAC,2DAA2D,CAAC;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACzG,GAAG,EAAE0G,WAAW,EAAEpF,MAAM,EAAE;EACnD,IAAI,CAACtB,GAAG,IAAI,CAAC0G,WAAW,EAAE;IACtB,OAAO1G,GAAG;EACd;EAEA,MAAM2G,WAAW,GAAI,OAAO3G,GAAG,KAAK,UAAU,GAAIA,GAAG,GAAG,MAAM,IAAI;EAElE,OAAOH,OAAO,IAAIsG,oBAAoB,CAACtG,OAAO,EAAEyB,MAAM,EAAEoF,WAAW,CAAC,IAAIC,WAAW,CAAC9G,OAAO,CAAC;AAChG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM+G,UAAU,CAAC;EAEb;AACJ;AACA;AACA;EACIC,WAAWA,CAAC3F,OAAO,GAAG,CAAC,CAAC,EAAE;IAEtB,MAAMqD,cAAc,GAAG,EAAE;IACzB,MAAMuC,gBAAgB,GAAGvI,cAAc,CAAC2C,OAAO,CAAC;IAChD,MAAMsE,MAAM,GAAG,IAAI9H,MAAM,CAAC;MACtBiD,GAAG,EAAEmG,gBAAgB,CAACnG,GAAG;MACzBoG,UAAU,EAAE;IAChB,CAAC,CAAC;IAEF,MAAMC,aAAa,GAAG9I,YAAY,CAC9B4I,gBAAgB,CAACG,aAAa,EAC9BH,gBAAgB,CAACnG,GACrB,CAAC;IAED,MAAMuG,eAAe,GAAGJ,gBAAgB,CAAC1D,KAAK,GACxC,IAAI1E,eAAe,CAACsI,aAAa,EAAEF,gBAAgB,CAACK,aAAa,CAAC,GAClE,IAAI;IAEVpI,cAAc,CAACkD,GAAG,CAAC,IAAI,EAAE;MACrBf,OAAO,EAAE4F,gBAAgB;MACzBtB,MAAM;MACNwB,aAAa;MACbE,eAAe;MACf3C,cAAc;MACdtD,OAAO,EAAE;IACb,CAAC,CAAC;;IAEF;AACR;AACA;AACA;IACQ,IAAIC,OAAO,CAACkG,OAAO,EAAE;MAEjB,MAAMA,OAAO,GAAG,CAAC,CAAC;MAElB,KAAK,MAAM,CAACC,UAAU,EAAEC,MAAM,CAAC,IAAI1F,MAAM,CAACC,OAAO,CAACX,OAAO,CAACkG,OAAO,CAAC,EAAE;QAChEA,OAAO,CAACpJ,MAAM,CAACuJ,gBAAgB,CAACF,UAAU,EAAE,eAAe,CAAC,CAAC,GAAGC,MAAM;MAC1E;MAEA/C,cAAc,CAACxC,IAAI,CAAC;QAChBqF;MACJ,CAAC,CAAC;IACN;EAEJ;;EAEA;AACJ;AACA;AACA;EACI,WAAW3J,OAAOA,CAAA,EAAG;IACjB,OAAOA,OAAO;EAClB;;EAEA;AACJ;AACA;AACA;AACA;EACI,aAAa+J,WAAWA,CAACpF,OAAO,EAAE;IAC9B,IAAI,CAACjC,KAAK,CAACmE,OAAO,CAAClC,OAAO,CAAC,EAAE;MACzB,MAAM,IAAIyB,KAAK,CAAC,4BAA4B,CAAC;IACjD;IAEA,MAAM4D,OAAO,CAACC,GAAG,CACbtF,OAAO,CACFuF,MAAM,CAACnF,MAAM,IAAI;MACd,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,EAAE;QAC/C,MAAM,IAAIqB,KAAK,CAAC,qCAAqC,CAAC;MAC1D;MACA,OACI,OAAOrB,MAAM,CAACmD,MAAM,KAAK,QAAQ,IACjCpI,IAAI,CAAC8D,UAAU,CAACmB,MAAM,CAACpB,QAAQ,CAAC;IAExC,CAAC,CAAC,CACDuD,GAAG,CAACiD,CAAC,IAAIzK,EAAE,CAAC0K,SAAS,CAACD,CAAC,CAACxG,QAAQ,EAAEwG,CAAC,CAACjC,MAAM,CAAC,CACpD,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;EACI,OAAOmC,eAAeA,CAAC1F,OAAO,EAAE;IAC5B,MAAM2F,QAAQ,GAAG,EAAE;IAEnB3F,OAAO,CAAC4F,OAAO,CAACxF,MAAM,IAAI;MACtB,MAAMyF,gBAAgB,GAAGzF,MAAM,CAACpD,QAAQ,CAACuI,MAAM,CAACrJ,cAAc,CAAC;MAC/D,MAAM4J,0BAA0B,GAAG1F,MAAM,CAACwD,kBAAkB,CAAC2B,MAAM,CAACrJ,cAAc,CAAC;MAEnF,IAAI2J,gBAAgB,CAACrI,MAAM,GAAG,CAAC,EAAE;QAC7BmI,QAAQ,CAAChG,IAAI,CAAC;UACV,GAAGS,MAAM;UACTpD,QAAQ,EAAE6I,gBAAgB;UAC1BjC,kBAAkB,EAAEkC,0BAA0B;UAC9C5I,UAAU,EAAE2I,gBAAgB,CAACrI,MAAM;UACnCJ,YAAY,EAAE,CAAC;UACfC,iBAAiB,EAAE+C,MAAM,CAAC/C,iBAAiB;UAC3CC,mBAAmB,EAAE;QACzB,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;IAEF,OAAOqI,QAAQ;EACnB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACII,sBAAsBA,CAAC/F,OAAO,EAAE;IAE5B;IACA,IAAIA,OAAO,CAACxC,MAAM,KAAK,CAAC,EAAE;MACtB,OAAO,CAAC,CAAC;IACb;IAEA,MAAMwI,WAAW,GAAG,IAAIlJ,GAAG,CAAC,CAAC;IAC7B,MAAM;MACF+B,OAAO;MACPC,OAAO,EAAE;QAAEP;MAAI;IACnB,CAAC,GAAG5B,cAAc,CAACoC,GAAG,CAAC,IAAI,CAAC;;IAE5B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACF,OAAO,EAAE;MACV,MAAMsF,4BAA4B,CAAC,CAAC;IACxC;IAEA,KAAK,MAAM/D,MAAM,IAAIJ,OAAO,EAAE;MAE1B;AACZ;AACA;MACY,MAAMhB,QAAQ,GAAGoB,MAAM,CAACpB,QAAQ,KAAK,QAAQ,GACvCV,kBAAkB,CAACC,GAAG,CAAC,GAAG6B,MAAM,CAACpB,QAAQ;MAC/C,MAAMiH,WAAW,GAAG7F,MAAM,CAACpD,QAAQ,CAACkJ,MAAM,CAAC9F,MAAM,CAACwD,kBAAkB,CAAC;MAErE,KAAK,MAAM;QAAEtE;MAAO,CAAC,IAAI2G,WAAW,EAAE;QAClC,IAAI,CAAC3G,MAAM,EAAE;UACT;QACJ;;QAEA;AAChB;AACA;AACA;QACgB,MAAMJ,MAAM,GAAGL,OAAO,CAACM,SAAS,CAACH,QAAQ,CAAC;QAE1C,IAAI,CAACE,MAAM,EAAE;UACT,MAAMiF,4BAA4B,CAAC,CAAC;QACxC;QACA,MAAM/F,IAAI,GAAG7C,iBAAiB,CAAC+D,MAAM,EAAEJ,MAAM,CAAC;;QAE9C;QACA,IAAId,IAAI,EAAE;UACN4H,WAAW,CAACnG,GAAG,CAACP,MAAM,EAAElB,IAAI,CAAC;QACjC;MACJ;IACJ;IAEA,OAAOP,eAAe,CAACmI,WAAW,CAAC;EACvC;;EAEA;AACJ;AACA;AACA;AACA;EACI,MAAMG,SAASA,CAACC,QAAQ,EAAE;IACtB,IAAI,CAACrK,gBAAgB,CAACqK,QAAQ,CAAC,IAAI,CAACpK,uBAAuB,CAACoK,QAAQ,CAAC,EAAE;MACnE,MAAM,IAAI3E,KAAK,CAAC,wEAAwE,CAAC;IAC7F;IAEA,MAAM;MACFmD,aAAa;MACbE,eAAe;MACf1B,MAAM;MACNtE,OAAO,EAAEuH;IACb,CAAC,GAAG1J,cAAc,CAACoC,GAAG,CAAC,IAAI,CAAC;IAC5B,MAAMF,OAAO,GAAG,MAAM6C,oBAAoB,CAAC,IAAI,EAAE2E,aAAa,CAAC;IAC/D,MAAM;MACFlD,iBAAiB;MACjBnC,KAAK;MACLzC,GAAG;MACHX,GAAG;MACHoG,QAAQ;MACRsC,cAAc;MACdC,uBAAuB;MACvBC;IACJ,CAAC,GAAGH,aAAa;IACjB,MAAMI,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAC5B,MAAMrC,WAAW,GAAGN,QAAQ,GAAG,IAAItH,GAAG,CAACsH,QAAQ,CAAC,GAAG,IAAI;;IAEvD;IACA,IAAI,CAAChD,KAAK,IAAI4D,aAAa,EAAE;MACzBpI,KAAK,CAAC,0BAA0BoI,aAAa,EAAE,CAAC;MAEhD,IAAI;QACA,MAAM7J,EAAE,CAAC6L,MAAM,CAAChC,aAAa,CAAC;MAClC,CAAC,CAAC,OAAOtD,KAAK,EAAE;QACZ,MAAMuF,SAAS,GAAGvF,KAAK,IAAIA,KAAK,CAACwF,IAAI;;QAErC;QACA,IAAID,SAAS,KAAK,QAAQ,IAAI,EAAEA,SAAS,KAAK,OAAO,IAAI,CAAC3L,UAAU,CAAC0J,aAAa,CAAC,CAAC,EAAE;UAClF,MAAMtD,KAAK;QACf;MACJ;IACJ;IAEA,MAAMyF,SAAS,GAAG,MAAMlL,SAAS,CAAC;MAC9BuK,QAAQ,EAAE,OAAOA,QAAQ,KAAK,QAAQ,GAAG,CAACA,QAAQ,CAAC,GAAGA,QAAQ;MAC9D7H,GAAG;MACH+H,cAAc;MACdzH,OAAO;MACP0H;IACJ,CAAC,CAAC;IAEF/J,KAAK,CAAC,GAAGuK,SAAS,CAACvJ,MAAM,oBAAoBkJ,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS,IAAI,CAAC;;IAExE;AACR;AACA;AACA;AACA;AACA;IACQ,MAAMzG,OAAO,GAAG,MAAMqF,OAAO,CAACC,GAAG,CAE7ByB,SAAS,CAACxE,GAAG,CAACvD,QAAQ,IAAI;MAEtB,MAAME,MAAM,GAAGL,OAAO,CAACM,SAAS,CAACH,QAAQ,CAAC;;MAE1C;AAChB;AACA;AACA;MACgB,IAAI,CAACE,MAAM,EAAE;QACT,IAAIsH,WAAW,EAAE;UACb,OAAOvK,kBAAkB,CAAC+C,QAAQ,EAAET,GAAG,CAAC;QAC5C;QAEA,OAAO,KAAK,CAAC;MACjB;;MAEA;MACA,IAAIuG,eAAe,EAAE;QACjB,MAAMkC,YAAY,GACdlC,eAAe,CAACmC,oBAAoB,CAACjI,QAAQ,EAAEE,MAAM,CAAC;QAE1D,IAAI8H,YAAY,EAAE;UACd,MAAME,WAAW,GACbF,YAAY,CAAChK,QAAQ,IACrBgK,YAAY,CAAChK,QAAQ,CAACQ,MAAM,GAAG,CAAC;UAEpC,IAAI0J,WAAW,IAAItJ,GAAG,EAAE;YACpBpB,KAAK,CAAC,8CAA8CwC,QAAQ,EAAE,CAAC;UACnE,CAAC,MAAM;YACHxC,KAAK,CAAC,0CAA0CwC,QAAQ,EAAE,CAAC;YAC3D,OAAOgI,YAAY;UACvB;QACJ;MACJ;;MAGA;MACA,MAAMG,KAAK,GAAG9C,mBAAmB,CAACzG,GAAG,EAAE0G,WAAW,EAAEpF,MAAM,CAAC;MAE3D,OAAOnE,EAAE,CAACqM,QAAQ,CAACpI,QAAQ,EAAE,MAAM,CAAC,CAC/BqI,IAAI,CAACpE,IAAI,IAAI;QAEV;QACA,MAAM7C,MAAM,GAAG4C,UAAU,CAAC;UACtBC,IAAI;UACJjE,QAAQ;UACRH,OAAO;UACPN,GAAG;UACHX,GAAG,EAAEuJ,KAAK;UACVhE,iBAAiB;UACjBC;QACJ,CAAC,CAAC;;QAEF;AACxB;AACA;AACA;AACA;AACA;QACwB,IAAI0B,eAAe,EAAE;UACjBA,eAAe,CAACwC,oBAAoB,CAACtI,QAAQ,EAAEE,MAAM,EAAEkB,MAAM,CAAC;QAClE;QAEA,OAAOA,MAAM;MACjB,CAAC,CAAC;IAEV,CAAC,CACL,CAAC;;IAED;IACA,IAAI0E,eAAe,EAAE;MACjBA,eAAe,CAACyC,SAAS,CAAC,CAAC;IAC/B;IAEA,MAAMC,YAAY,GAAGxH,OAAO,CAACuF,MAAM,CAACnF,MAAM,IAAI,CAAC,CAACA,MAAM,CAAC;IAEvD,OAAOL,iBAAiB,CAAC,IAAI,EAAE;MAC3BC,OAAO,EAAEwH;IACb,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,QAAQA,CAACX,IAAI,EAAEhI,OAAO,GAAG,CAAC,CAAC,EAAE;IAE/B;;IAEA,IAAI,OAAOgI,IAAI,KAAK,QAAQ,EAAE;MAC1B,MAAM,IAAIrF,KAAK,CAAC,yBAAyB,CAAC;IAC9C;IAEA,IAAI,OAAO3C,OAAO,KAAK,QAAQ,EAAE;MAC7B,MAAM,IAAI2C,KAAK,CAAC,iDAAiD,CAAC;IACtE;;IAEA;;IAEA,MAAM;MACFzC,QAAQ;MACRwH,WAAW;MACX,GAAGkB;IACP,CAAC,GAAG5I,OAAO,IAAI,CAAC,CAAC;IAEjB,MAAM6I,iBAAiB,GAAGnI,MAAM,CAACoI,IAAI,CAACF,cAAc,CAAC;IAErD,IAAIC,iBAAiB,CAACnK,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAM,IAAIiE,KAAK,CAAC,qDAAqDkG,iBAAiB,CAACnJ,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IACxG;IAEA,IAAIQ,QAAQ,KAAK,KAAK,CAAC,IAAI,CAACjD,gBAAgB,CAACiD,QAAQ,CAAC,EAAE;MACpD,MAAM,IAAIyC,KAAK,CAAC,4DAA4D,CAAC;IACjF;IAEA,IAAI,OAAO+E,WAAW,KAAK,SAAS,IAAI,OAAOA,WAAW,KAAK,WAAW,EAAE;MACxE,MAAM,IAAI/E,KAAK,CAAC,sDAAsD,CAAC;IAC3E;;IAEA;;IAEA,MAAM;MACF2B,MAAM;MACNtE,OAAO,EAAEuH;IACb,CAAC,GAAG1J,cAAc,CAACoC,GAAG,CAAC,IAAI,CAAC;IAC5B,MAAMF,OAAO,GAAG,MAAM6C,oBAAoB,CAAC,IAAI,EAAE2E,aAAa,CAAC;IAC/D,MAAM;MACFlD,iBAAiB;MACjB5E,GAAG;MACHX,GAAG;MACHoG,QAAQ;MACRwC,WAAW,EAAEqB;IACjB,CAAC,GAAGxB,aAAa;IACjB,MAAMrG,OAAO,GAAG,EAAE;IAClB,MAAMyG,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAC5B,MAAMrC,WAAW,GAAGN,QAAQ,GAAG,IAAItH,GAAG,CAACsH,QAAQ,CAAC,GAAG,IAAI;IACvD,MAAM8D,gBAAgB,GAAG3M,IAAI,CAACoG,OAAO,CAAChD,GAAG,EAAES,QAAQ,IAAI,oBAAoB,CAAC;IAC5E,MAAME,MAAM,GAAGL,OAAO,CAACM,SAAS,CAAC2I,gBAAgB,CAAC;IAElD,MAAMX,KAAK,GAAG9C,mBAAmB,CAACzG,GAAG,EAAE0G,WAAW,EAAEpF,MAAM,CAAC;;IAE3D;IACA,IAAI4I,gBAAgB,KAAI,MAAM,IAAI,CAACC,aAAa,CAACD,gBAAgB,CAAC,GAAE;MAChE,MAAME,iBAAiB,GAAG,OAAOxB,WAAW,KAAK,SAAS,GAAGA,WAAW,GAAGqB,sBAAsB;MAEjG,IAAIG,iBAAiB,EAAE;QACnBhI,OAAO,CAACL,IAAI,CAAC1D,kBAAkB,CAAC6L,gBAAgB,EAAEvJ,GAAG,CAAC,CAAC;MAC3D;IACJ,CAAC,MAAM;MAEH;MACAyB,OAAO,CAACL,IAAI,CAACqD,UAAU,CAAC;QACpBC,IAAI,EAAE6D,IAAI;QACV9H,QAAQ,EAAE8I,gBAAgB,CAACG,QAAQ,CAAC,oBAAoB,CAAC,GAAG,QAAQ,GAAGH,gBAAgB;QACvFjJ,OAAO;QACPN,GAAG;QACHX,GAAG,EAAEuJ,KAAK;QACVhE,iBAAiB;QACjBC;MACJ,CAAC,CAAC,CAAC;IACP;IAEA5G,KAAK,CAAC,wBAAwBkK,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS,IAAI,CAAC;IAEzD,OAAO1G,iBAAiB,CAAC,IAAI,EAAE;MAC3BC;IACJ,CAAC,CAAC;EAEN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMkI,aAAaA,CAACC,IAAI,GAAG,SAAS,EAAE;IAClC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC1B,MAAM,IAAI1G,KAAK,CAAC,yBAAyB,CAAC;IAC9C;;IAEA;IACA,MAAM2G,oBAAoB,GAAGD,IAAI,CAACE,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;IACtD,MAAMC,SAAS,GAAG1M,MAAM,CAAC2M,oBAAoB,CAACH,oBAAoB,CAAC;;IAEnE;IACA,MAAM;MAAE7J;IAAI,CAAC,GAAG5B,cAAc,CAACoC,GAAG,CAAC,IAAI,CAAC,CAACD,OAAO;IAGhD,IAAI0J,aAAa;;IAEjB;IACA,IAAI,CAACF,SAAS,IAAIF,oBAAoB,CAACK,QAAQ,CAAC,GAAG,CAAC,EAAE;MAClDD,aAAa,GAAGrN,IAAI,CAACoG,OAAO,CAAChD,GAAG,EAAE6J,oBAAoB,CAAC;IAC3D,CAAC,MAAM;MACH,IAAI;QACA,MAAMM,SAAS,GAAG9M,MAAM,CAAC+M,oBAAoB,CAACP,oBAAoB,EAAE,kBAAkB,CAAC;;QAEvF;QACAI,aAAa,GAAG7M,cAAc,CAAC4F,OAAO,CAACmH,SAAS,EAAEpK,kBAAkB,CAACC,GAAG,CAAC,CAAC;MAC9E,CAAC,CAAC,MAAM;QACJiK,aAAa,GAAGrN,IAAI,CAACoG,OAAO,CAACqH,SAAS,EAAE,KAAK,EAAE,YAAY,EAAE,YAAY,EAAE,GAAGR,oBAAoB,KAAK,CAAC;MAC5G;IACJ;IAEA,IAAIS,SAAS;IAEb,IAAI;MACAA,SAAS,GAAG,CAAC,MAAM,MAAM,CAACzM,aAAa,CAACoM,aAAa,CAAC,CAAC,EAAEvH,OAAO;IACpE,CAAC,CAAC,OAAO6H,EAAE,EAAE;MAET;MACA,IAAIrM,iBAAiB,CAAC2C,GAAG,CAAC+I,IAAI,CAAC,EAAE;QAC7BW,EAAE,CAACrL,OAAO,GAAG,OAAO0K,IAAI,2GAA2GA,IAAI,IAAI;MAC/I,CAAC,MAAM;QACHW,EAAE,CAACrL,OAAO,GAAG,0CAA0C+K,aAAa,YAAYM,EAAE,CAACrL,OAAO,EAAE;MAChG;MAEA,MAAMqL,EAAE;IACZ;IAGA,IAAI,OAAOD,SAAS,KAAK,UAAU,EAAE;MACjC,MAAM,IAAIzE,SAAS,CAAC,2CAA2C,OAAOyE,SAAS,GAAG,CAAC;IACvF;IAEA,MAAMlK,MAAM,GAAG,IAAI;IAEnB,OAAO;MAEH;AACZ;AACA;AACA;AACA;AACA;MACYoK,MAAMA,CAAC/I,OAAO,EAAEgJ,WAAW,EAAE;QACzB,IAAIC,SAAS,GAAG,IAAI;QAEpBjJ,OAAO,CAACkJ,IAAI,CAAC5I,wBAAwB,CAAC;QAEtC,OAAOuI,SAAS,CAAC7I,OAAO,EAAE;UACtB,GAAGgJ,WAAW;UACdzK,GAAG;UACH,IAAI0K,SAASA,CAAA,EAAG;YACZ,IAAI,CAACA,SAAS,EAAE;cACZA,SAAS,GAAGtK,MAAM,CAACoH,sBAAsB,CAAC/F,OAAO,CAAC;YACtD;YAEA,OAAOiJ,SAAS;UACpB;QACJ,CAAC,CAAC;MACN;IACJ,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAME,sBAAsBA,CAACnK,QAAQ,EAAE;IACnC,IAAI,CAACjD,gBAAgB,CAACiD,QAAQ,CAAC,EAAE;MAC7B,MAAM,IAAIyC,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,MAAM3C,OAAO,GAAGnC,cAAc,CAACoC,GAAG,CAAC,IAAI,CAAC,CAACD,OAAO;IAChD,MAAMsK,YAAY,GAAGjO,IAAI,CAACoG,OAAO,CAACzC,OAAO,CAACP,GAAG,EAAES,QAAQ,CAAC;IACxD,MAAMH,OAAO,GAAG,MAAM6C,oBAAoB,CAAC,IAAI,EAAE5C,OAAO,CAAC;IAEzD,OAAOD,OAAO,CAACM,SAAS,CAACiK,YAAY,CAAC;EAC1C;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMC,cAAcA,CAAA,EAAG;IACnB,MAAMvK,OAAO,GAAGnC,cAAc,CAACoC,GAAG,CAAC,IAAI,CAAC,CAACD,OAAO;IAChD,MAAM;MAAEsC;IAAe,CAAC,GAAG,MAAMF,qBAAqB,CAACpC,OAAO,CAAC;IAE/D,OAAOsC,cAAc;EACzB;;EAEA;AACJ;AACA;AACA;AACA;EACI,MAAM2G,aAAaA,CAAC/I,QAAQ,EAAE;IAC1B,MAAME,MAAM,GAAG,MAAM,IAAI,CAACiK,sBAAsB,CAACnK,QAAQ,CAAC;IAE1D,OAAOE,MAAM,KAAK,KAAK,CAAC;EAC5B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACAsF,UAAU,CAACG,UAAU,GAAG,MAAM;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe2E,mBAAmBA,CAAC;EAAE/K,GAAG,GAAGgL,OAAO,CAAChL,GAAG,CAAC;AAAE,CAAC,GAAG,CAAC,CAAC,EAAE;EAC7D,QAAQgL,OAAO,CAACC,GAAG,CAACC,sBAAsB;IACtC,KAAK,MAAM;MACP,OAAO,IAAI;IACf,KAAK,OAAO;MACR,OAAO,KAAK;IAChB;MAEI;AACZ;AACA;AACA;MACY,OAAO,CAAC,EAAE,MAAMhJ,kBAAkB,CAAClC,GAAG,CAAC,CAAC;EAChD;AACJ;;AAEA;AACA;AACA;;AAEAmL,MAAM,CAACC,OAAO,GAAG;EACbnF,UAAU;EACV8E;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}