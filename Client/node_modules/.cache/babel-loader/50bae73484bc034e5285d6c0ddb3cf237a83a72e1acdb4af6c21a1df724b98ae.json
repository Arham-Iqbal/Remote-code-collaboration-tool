{"ast":null,"code":"/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ConstructorInfo\n * @property {ConstructorInfo | null} upper Info about the constructor that encloses this constructor.\n * @property {boolean} hasSuperCall The flag about having `super()` expressions.\n */\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n  return Boolean(node.init);\n}\n\n/**\n * Checks all segments in a set and returns true if all are unreachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if all segments are unreachable; false otherwise.\n */\nfunction areAllSegmentsUnreachable(segments) {\n  for (const segment of segments) {\n    if (segment.reachable) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.startNode = null;\n    this.endNode = null;\n  }\n\n  /**\n   * The location object of this range.\n   * @type {Object}\n   */\n  get location() {\n    return {\n      start: this.startNode.loc.start,\n      end: this.endNode.loc.end\n    };\n  }\n\n  /**\n   * `true` if this range is empty.\n   * @type {boolean}\n   */\n  get isEmpty() {\n    return !(this.startNode && this.endNode);\n  }\n\n  /**\n   * Checks whether the given node is inside of this range.\n   * @param {ASTNode|Token} node The node to check.\n   * @returns {boolean} `true` if the node is inside of this range.\n   */\n  contains(node) {\n    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];\n  }\n\n  /**\n   * Checks whether the given node is consecutive to this range.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if the node is consecutive to this range.\n   */\n  isConsecutive(node) {\n    return this.contains(this.sourceCode.getTokenBefore(node));\n  }\n\n  /**\n   * Merges the given node to this range.\n   * @param {ASTNode} node The node to merge.\n   * @returns {void}\n   */\n  merge(node) {\n    this.endNode = node;\n  }\n\n  /**\n   * Resets this range by the given node or null.\n   * @param {ASTNode|null} node The node to reset, or null.\n   * @returns {void}\n   */\n  reset(node) {\n    this.startNode = this.endNode = node;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-unreachable\"\n    },\n    schema: [],\n    messages: {\n      unreachableCode: \"Unreachable code.\"\n    }\n  },\n  create(context) {\n    /** @type {ConstructorInfo | null} */\n    let constructorInfo = null;\n\n    /** @type {ConsecutiveRange} */\n    const range = new ConsecutiveRange(context.sourceCode);\n\n    /** @type {Array<Set<CodePathSegment>>} */\n    const codePathSegments = [];\n\n    /** @type {Set<CodePathSegment>} */\n    let currentCodePathSegments = new Set();\n\n    /**\n     * Reports a given node if it's unreachable.\n     * @param {ASTNode} node A statement node to report.\n     * @returns {void}\n     */\n    function reportIfUnreachable(node) {\n      let nextNode = null;\n      if (node && (node.type === \"PropertyDefinition\" || areAllSegmentsUnreachable(currentCodePathSegments))) {\n        // Store this statement to distinguish consecutive statements.\n        if (range.isEmpty) {\n          range.reset(node);\n          return;\n        }\n\n        // Skip if this statement is inside of the current range.\n        if (range.contains(node)) {\n          return;\n        }\n\n        // Merge if this statement is consecutive to the current range.\n        if (range.isConsecutive(node)) {\n          range.merge(node);\n          return;\n        }\n        nextNode = node;\n      }\n\n      /*\n       * Report the current range since this statement is reachable or is\n       * not consecutive to the current range.\n       */\n      if (!range.isEmpty) {\n        context.report({\n          messageId: \"unreachableCode\",\n          loc: range.location,\n          node: range.startNode\n        });\n      }\n\n      // Update the current range.\n      range.reset(nextNode);\n    }\n    return {\n      // Manages the current code path.\n      onCodePathStart() {\n        codePathSegments.push(currentCodePathSegments);\n        currentCodePathSegments = new Set();\n      },\n      onCodePathEnd() {\n        currentCodePathSegments = codePathSegments.pop();\n      },\n      onUnreachableCodePathSegmentStart(segment) {\n        currentCodePathSegments.add(segment);\n      },\n      onUnreachableCodePathSegmentEnd(segment) {\n        currentCodePathSegments.delete(segment);\n      },\n      onCodePathSegmentEnd(segment) {\n        currentCodePathSegments.delete(segment);\n      },\n      onCodePathSegmentStart(segment) {\n        currentCodePathSegments.add(segment);\n      },\n      // Registers for all statement nodes (excludes FunctionDeclaration).\n      BlockStatement: reportIfUnreachable,\n      BreakStatement: reportIfUnreachable,\n      ClassDeclaration: reportIfUnreachable,\n      ContinueStatement: reportIfUnreachable,\n      DebuggerStatement: reportIfUnreachable,\n      DoWhileStatement: reportIfUnreachable,\n      ExpressionStatement: reportIfUnreachable,\n      ForInStatement: reportIfUnreachable,\n      ForOfStatement: reportIfUnreachable,\n      ForStatement: reportIfUnreachable,\n      IfStatement: reportIfUnreachable,\n      ImportDeclaration: reportIfUnreachable,\n      LabeledStatement: reportIfUnreachable,\n      ReturnStatement: reportIfUnreachable,\n      SwitchStatement: reportIfUnreachable,\n      ThrowStatement: reportIfUnreachable,\n      TryStatement: reportIfUnreachable,\n      VariableDeclaration(node) {\n        if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n          reportIfUnreachable(node);\n        }\n      },\n      WhileStatement: reportIfUnreachable,\n      WithStatement: reportIfUnreachable,\n      ExportNamedDeclaration: reportIfUnreachable,\n      ExportDefaultDeclaration: reportIfUnreachable,\n      ExportAllDeclaration: reportIfUnreachable,\n      \"Program:exit\"() {\n        reportIfUnreachable();\n      },\n      /*\n       * Instance fields defined in a subclass are never created if the constructor of the subclass\n       * doesn't call `super()`, so their definitions are unreachable code.\n       */\n      \"MethodDefinition[kind='constructor']\"() {\n        constructorInfo = {\n          upper: constructorInfo,\n          hasSuperCall: false\n        };\n      },\n      \"MethodDefinition[kind='constructor']:exit\"(node) {\n        const {\n          hasSuperCall\n        } = constructorInfo;\n        constructorInfo = constructorInfo.upper;\n\n        // skip typescript constructors without the body\n        if (!node.value.body) {\n          return;\n        }\n        const classDefinition = node.parent.parent;\n        if (classDefinition.superClass && !hasSuperCall) {\n          for (const element of classDefinition.body.body) {\n            if (element.type === \"PropertyDefinition\" && !element.static) {\n              reportIfUnreachable(element);\n            }\n          }\n        }\n      },\n      \"CallExpression > Super.callee\"() {\n        if (constructorInfo) {\n          constructorInfo.hasSuperCall = true;\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["isInitialized","node","Boolean","init","areAllSegmentsUnreachable","segments","segment","reachable","ConsecutiveRange","constructor","sourceCode","startNode","endNode","location","start","loc","end","isEmpty","contains","range","isConsecutive","getTokenBefore","merge","reset","module","exports","meta","type","docs","description","recommended","url","schema","messages","unreachableCode","create","context","constructorInfo","codePathSegments","currentCodePathSegments","Set","reportIfUnreachable","nextNode","report","messageId","onCodePathStart","push","onCodePathEnd","pop","onUnreachableCodePathSegmentStart","add","onUnreachableCodePathSegmentEnd","delete","onCodePathSegmentEnd","onCodePathSegmentStart","BlockStatement","BreakStatement","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","ReturnStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","kind","declarations","some","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","Program:exit","MethodDefinition[kind='constructor']","upper","hasSuperCall","MethodDefinition[kind='constructor']:exit","value","body","classDefinition","parent","superClass","element","static","CallExpression > Super.callee"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-unreachable.js"],"sourcesContent":["/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ConstructorInfo\n * @property {ConstructorInfo | null} upper Info about the constructor that encloses this constructor.\n * @property {boolean} hasSuperCall The flag about having `super()` expressions.\n */\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks all segments in a set and returns true if all are unreachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if all segments are unreachable; false otherwise.\n */\nfunction areAllSegmentsUnreachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unreachable\"\n        },\n\n        schema: [],\n\n        messages: {\n            unreachableCode: \"Unreachable code.\"\n        }\n    },\n\n    create(context) {\n\n        /** @type {ConstructorInfo | null} */\n        let constructorInfo = null;\n\n        /** @type {ConsecutiveRange} */\n        const range = new ConsecutiveRange(context.sourceCode);\n\n        /** @type {Array<Set<CodePathSegment>>} */\n        const codePathSegments = [];\n\n        /** @type {Set<CodePathSegment>} */\n        let currentCodePathSegments = new Set();\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && (node.type === \"PropertyDefinition\" || areAllSegmentsUnreachable(currentCodePathSegments))) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    messageId: \"unreachableCode\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart() {\n                codePathSegments.push(currentCodePathSegments);\n                currentCodePathSegments = new Set();\n            },\n\n            onCodePathEnd() {\n                currentCodePathSegments = codePathSegments.pop();\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            },\n\n            /*\n             * Instance fields defined in a subclass are never created if the constructor of the subclass\n             * doesn't call `super()`, so their definitions are unreachable code.\n             */\n            \"MethodDefinition[kind='constructor']\"() {\n                constructorInfo = {\n                    upper: constructorInfo,\n                    hasSuperCall: false\n                };\n            },\n            \"MethodDefinition[kind='constructor']:exit\"(node) {\n                const { hasSuperCall } = constructorInfo;\n\n                constructorInfo = constructorInfo.upper;\n\n                // skip typescript constructors without the body\n                if (!node.value.body) {\n                    return;\n                }\n\n                const classDefinition = node.parent.parent;\n\n                if (classDefinition.superClass && !hasSuperCall) {\n                    for (const element of classDefinition.body.body) {\n                        if (element.type === \"PropertyDefinition\" && !element.static) {\n                            reportIfUnreachable(element);\n                        }\n                    }\n                }\n            },\n            \"CallExpression > Super.callee\"() {\n                if (constructorInfo) {\n                    constructorInfo.hasSuperCall = true;\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}