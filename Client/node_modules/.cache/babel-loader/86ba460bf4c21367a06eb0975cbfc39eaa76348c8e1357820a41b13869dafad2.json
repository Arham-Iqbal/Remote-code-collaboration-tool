{"ast":null,"code":"/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst CodePathSegment = require(\"./code-path-segment\"),\n  ForkContext = require(\"./fork-context\");\n\n//-----------------------------------------------------------------------------\n// Contexts\n//-----------------------------------------------------------------------------\n\n/**\n * Represents the context in which a `break` statement can be used.\n *\n * A `break` statement without a label is only valid in a few places in\n * JavaScript: any type of loop or a `switch` statement. Otherwise, `break`\n * without a label causes a syntax error. For these contexts, `breakable` is\n * set to `true` to indicate that a `break` without a label is valid.\n *\n * However, a `break` statement with a label is also valid inside of a labeled\n * statement. For example, this is valid:\n *\n *     a : {\n *         break a;\n *     }\n *\n * The `breakable` property is set false for labeled statements to indicate\n * that `break` without a label is invalid.\n */\nclass BreakContext {\n  /**\n   * Creates a new instance.\n   * @param {BreakContext} upperContext The previous `BreakContext`.\n   * @param {boolean} breakable Indicates if we are inside a statement where\n   *      `break` without a label will exit the statement.\n   * @param {string|null} label The label for the statement.\n   * @param {ForkContext} forkContext The current fork context.\n   */\n  constructor(upperContext, breakable, label, forkContext) {\n    /**\n     * The previous `BreakContext`\n     * @type {BreakContext}\n     */\n    this.upper = upperContext;\n\n    /**\n     * Indicates if we are inside a statement where `break` without a label\n     * will exit the statement.\n     * @type {boolean}\n     */\n    this.breakable = breakable;\n\n    /**\n     * The label associated with the statement.\n     * @type {string|null}\n     */\n    this.label = label;\n\n    /**\n     * The fork context for the `break`.\n     * @type {ForkContext}\n     */\n    this.brokenForkContext = ForkContext.newEmpty(forkContext);\n  }\n}\n\n/**\n * Represents the context for `ChainExpression` nodes.\n */\nclass ChainContext {\n  /**\n   * Creates a new instance.\n   * @param {ChainContext} upperContext The previous `ChainContext`.\n   */\n  constructor(upperContext) {\n    /**\n     * The previous `ChainContext`\n     * @type {ChainContext}\n     */\n    this.upper = upperContext;\n\n    /**\n     * The number of choice contexts inside of the `ChainContext`.\n     * @type {number}\n     */\n    this.choiceContextCount = 0;\n  }\n}\n\n/**\n * Represents a choice in the code path.\n *\n * Choices are created by logical operators such as `&&`, loops, conditionals,\n * and `if` statements. This is the point at which the code path has a choice of\n * which direction to go.\n *\n * The result of a choice might be in the left (test) expression of another choice,\n * and in that case, may create a new fork. For example, `a || b` is a choice\n * but does not create a new fork because the result of the expression is\n * not used as the test expression in another expression. In this case,\n * `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`\n * expression appears as the test expression for `|| c`, so the\n * result of `a || b` creates a fork because execution may or may not\n * continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true\n * while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always\n * false for `if` statements, conditional expressions, and loops.)\n *\n * All of the choices except one (`??`) operate on a true/false fork, meaning if\n * true go one way and if false go the other (tracked by `trueForkContext` and\n * `falseForkContext`). The `??` operator doesn't operate on true/false because\n * the left expression is evaluated to be nullish or not, so only if nullish do\n * we fork to the right expression (tracked by `nullishForkContext`).\n */\nclass ChoiceContext {\n  /**\n   * Creates a new instance.\n   * @param {ChoiceContext} upperContext The previous `ChoiceContext`.\n   * @param {string} kind The kind of choice. If it's a logical or assignment expression, this\n   *      is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or\n   *      conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.\n   * @param {boolean} isForkingAsResult Indicates if the result of the choice\n   *      creates a fork.\n   * @param {ForkContext} forkContext The containing `ForkContext`.\n   */\n  constructor(upperContext, kind, isForkingAsResult, forkContext) {\n    /**\n     * The previous `ChoiceContext`\n     * @type {ChoiceContext}\n     */\n    this.upper = upperContext;\n\n    /**\n     * The kind of choice. If it's a logical or assignment expression, this\n     * is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or\n     * conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.\n     * @type {string}\n     */\n    this.kind = kind;\n\n    /**\n     * Indicates if the result of the choice forks the code path.\n     * @type {boolean}\n     */\n    this.isForkingAsResult = isForkingAsResult;\n\n    /**\n     * The fork context for the `true` path of the choice.\n     * @type {ForkContext}\n     */\n    this.trueForkContext = ForkContext.newEmpty(forkContext);\n\n    /**\n     * The fork context for the `false` path of the choice.\n     * @type {ForkContext}\n     */\n    this.falseForkContext = ForkContext.newEmpty(forkContext);\n\n    /**\n     * The fork context for when the choice result is `null` or `undefined`.\n     * @type {ForkContext}\n     */\n    this.nullishForkContext = ForkContext.newEmpty(forkContext);\n\n    /**\n     * Indicates if any of `trueForkContext`, `falseForkContext`, or\n     * `nullishForkContext` have been updated with segments from a child context.\n     * @type {boolean}\n     */\n    this.processed = false;\n  }\n}\n\n/**\n * Base class for all loop contexts.\n */\nclass LoopContextBase {\n  /**\n   * Creates a new instance.\n   * @param {LoopContext|null} upperContext The previous `LoopContext`.\n   * @param {string} type The AST node's `type` for the loop.\n   * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n   * @param {BreakContext} breakContext The context for breaking the loop.\n   */\n  constructor(upperContext, type, label, breakContext) {\n    /**\n     * The previous `LoopContext`.\n     * @type {LoopContext}\n     */\n    this.upper = upperContext;\n\n    /**\n     * The AST node's `type` for the loop.\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * The label for the loop from an enclosing `LabeledStatement`.\n     * @type {string|null}\n     */\n    this.label = label;\n\n    /**\n     * The fork context for when `break` is encountered.\n     * @type {ForkContext}\n     */\n    this.brokenForkContext = breakContext.brokenForkContext;\n  }\n}\n\n/**\n * Represents the context for a `while` loop.\n */\nclass WhileLoopContext extends LoopContextBase {\n  /**\n   * Creates a new instance.\n   * @param {LoopContext|null} upperContext The previous `LoopContext`.\n   * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n   * @param {BreakContext} breakContext The context for breaking the loop.\n   */\n  constructor(upperContext, label, breakContext) {\n    super(upperContext, \"WhileStatement\", label, breakContext);\n\n    /**\n     * The hardcoded literal boolean test condition for\n     * the loop. Used to catch infinite or skipped loops.\n     * @type {boolean|undefined}\n     */\n    this.test = void 0;\n\n    /**\n     * The segments representing the test condition where `continue` will\n     * jump to. The test condition will typically have just one segment but\n     * it's possible for there to be more than one.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.continueDestSegments = null;\n  }\n}\n\n/**\n * Represents the context for a `do-while` loop.\n */\nclass DoWhileLoopContext extends LoopContextBase {\n  /**\n   * Creates a new instance.\n   * @param {LoopContext|null} upperContext The previous `LoopContext`.\n   * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n   * @param {BreakContext} breakContext The context for breaking the loop.\n   * @param {ForkContext} forkContext The enclosing fork context.\n   */\n  constructor(upperContext, label, breakContext, forkContext) {\n    super(upperContext, \"DoWhileStatement\", label, breakContext);\n\n    /**\n     * The hardcoded literal boolean test condition for\n     * the loop. Used to catch infinite or skipped loops.\n     * @type {boolean|undefined}\n     */\n    this.test = void 0;\n\n    /**\n     * The segments at the start of the loop body. This is the only loop\n     * where the test comes at the end, so the first iteration always\n     * happens and we need a reference to the first statements.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.entrySegments = null;\n\n    /**\n     * The fork context to follow when a `continue` is found.\n     * @type {ForkContext}\n     */\n    this.continueForkContext = ForkContext.newEmpty(forkContext);\n  }\n}\n\n/**\n * Represents the context for a `for` loop.\n */\nclass ForLoopContext extends LoopContextBase {\n  /**\n   * Creates a new instance.\n   * @param {LoopContext|null} upperContext The previous `LoopContext`.\n   * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n   * @param {BreakContext} breakContext The context for breaking the loop.\n   */\n  constructor(upperContext, label, breakContext) {\n    super(upperContext, \"ForStatement\", label, breakContext);\n\n    /**\n     * The hardcoded literal boolean test condition for\n     * the loop. Used to catch infinite or skipped loops.\n     * @type {boolean|undefined}\n     */\n    this.test = void 0;\n\n    /**\n     * The end of the init expression. This may change during the lifetime\n     * of the instance as we traverse the loop because some loops don't have\n     * an init expression.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.endOfInitSegments = null;\n\n    /**\n     * The start of the test expression. This may change during the lifetime\n     * of the instance as we traverse the loop because some loops don't have\n     * a test expression.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.testSegments = null;\n\n    /**\n     * The end of the test expression. This may change during the lifetime\n     * of the instance as we traverse the loop because some loops don't have\n     * a test expression.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.endOfTestSegments = null;\n\n    /**\n     * The start of the update expression. This may change during the lifetime\n     * of the instance as we traverse the loop because some loops don't have\n     * an update expression.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.updateSegments = null;\n\n    /**\n     * The end of the update expresion. This may change during the lifetime\n     * of the instance as we traverse the loop because some loops don't have\n     * an update expression.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.endOfUpdateSegments = null;\n\n    /**\n     * The segments representing the test condition where `continue` will\n     * jump to. The test condition will typically have just one segment but\n     * it's possible for there to be more than one. This may change during the\n     * lifetime of the instance as we traverse the loop because some loops\n     * don't have an update expression. When there is an update expression, this\n     * will end up pointing to that expression; otherwise it will end up pointing\n     * to the test expression.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.continueDestSegments = null;\n  }\n}\n\n/**\n * Represents the context for a `for-in` loop.\n *\n * Terminology:\n * - \"left\" means the part of the loop to the left of the `in` keyword. For\n *   example, in `for (var x in y)`, the left is `var x`.\n * - \"right\" means the part of the loop to the right of the `in` keyword. For\n *   example, in `for (var x in y)`, the right is `y`.\n */\nclass ForInLoopContext extends LoopContextBase {\n  /**\n   * Creates a new instance.\n   * @param {LoopContext|null} upperContext The previous `LoopContext`.\n   * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n   * @param {BreakContext} breakContext The context for breaking the loop.\n   */\n  constructor(upperContext, label, breakContext) {\n    super(upperContext, \"ForInStatement\", label, breakContext);\n\n    /**\n     * The segments that came immediately before the start of the loop.\n     * This allows you to traverse backwards out of the loop into the\n     * surrounding code. This is necessary to evaluate the right expression\n     * correctly, as it must be evaluated in the same way as the left\n     * expression, but the pointer to these segments would otherwise be\n     * lost if not stored on the instance. Once the right expression has\n     * been evaluated, this property is no longer used.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.prevSegments = null;\n\n    /**\n     * Segments representing the start of everything to the left of the\n     * `in` keyword. This can be used to move forward towards\n     * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are\n     * effectively the head and tail of a doubly-linked list.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.leftSegments = null;\n\n    /**\n     * Segments representing the end of everything to the left of the\n     * `in` keyword. This can be used to move backward towards `leftSegments`.\n     * `leftSegments` and `endOfLeftSegments` are effectively the head\n     * and tail of a doubly-linked list.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.endOfLeftSegments = null;\n\n    /**\n     * The segments representing the left expression where `continue` will\n     * jump to. In `for-in` loops, `continue` must always re-execute the\n     * left expression each time through the loop. This contains the same\n     * segments as `leftSegments`, but is duplicated here so each loop\n     * context has the same property pointing to where `continue` should\n     * end up.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.continueDestSegments = null;\n  }\n}\n\n/**\n * Represents the context for a `for-of` loop.\n */\nclass ForOfLoopContext extends LoopContextBase {\n  /**\n   * Creates a new instance.\n   * @param {LoopContext|null} upperContext The previous `LoopContext`.\n   * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n   * @param {BreakContext} breakContext The context for breaking the loop.\n   */\n  constructor(upperContext, label, breakContext) {\n    super(upperContext, \"ForOfStatement\", label, breakContext);\n\n    /**\n     * The segments that came immediately before the start of the loop.\n     * This allows you to traverse backwards out of the loop into the\n     * surrounding code. This is necessary to evaluate the right expression\n     * correctly, as it must be evaluated in the same way as the left\n     * expression, but the pointer to these segments would otherwise be\n     * lost if not stored on the instance. Once the right expression has\n     * been evaluated, this property is no longer used.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.prevSegments = null;\n\n    /**\n     * Segments representing the start of everything to the left of the\n     * `of` keyword. This can be used to move forward towards\n     * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are\n     * effectively the head and tail of a doubly-linked list.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.leftSegments = null;\n\n    /**\n     * Segments representing the end of everything to the left of the\n     * `of` keyword. This can be used to move backward towards `leftSegments`.\n     * `leftSegments` and `endOfLeftSegments` are effectively the head\n     * and tail of a doubly-linked list.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.endOfLeftSegments = null;\n\n    /**\n     * The segments representing the left expression where `continue` will\n     * jump to. In `for-in` loops, `continue` must always re-execute the\n     * left expression each time through the loop. This contains the same\n     * segments as `leftSegments`, but is duplicated here so each loop\n     * context has the same property pointing to where `continue` should\n     * end up.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.continueDestSegments = null;\n  }\n}\n\n/**\n * Represents the context for any loop.\n * @typedef {WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext\n */\n\n/**\n * Represents the context for a `switch` statement.\n */\nclass SwitchContext {\n  /**\n   * Creates a new instance.\n   * @param {SwitchContext} upperContext The previous context.\n   * @param {boolean} hasCase Indicates if there is at least one `case` statement.\n   *      `default` doesn't count.\n   */\n  constructor(upperContext, hasCase) {\n    /**\n     * The previous context.\n     * @type {SwitchContext}\n     */\n    this.upper = upperContext;\n\n    /**\n     * Indicates if there is at least one `case` statement. `default` doesn't count.\n     * @type {boolean}\n     */\n    this.hasCase = hasCase;\n\n    /**\n     * The `default` keyword.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.defaultSegments = null;\n\n    /**\n     * The default case body starting segments.\n     * @type {Array<CodePathSegment>|null}\n     */\n    this.defaultBodySegments = null;\n\n    /**\n     * Indicates if a `default` case and is empty exists.\n     * @type {boolean}\n     */\n    this.foundEmptyDefault = false;\n\n    /**\n     * Indicates that a `default` exists and is the last case.\n     * @type {boolean}\n     */\n    this.lastIsDefault = false;\n\n    /**\n     * The number of fork contexts created. This is equivalent to the\n     * number of `case` statements plus a `default` statement (if present).\n     * @type {number}\n     */\n    this.forkCount = 0;\n  }\n}\n\n/**\n * Represents the context for a `try` statement.\n */\nclass TryContext {\n  /**\n   * Creates a new instance.\n   * @param {TryContext} upperContext The previous context.\n   * @param {boolean} hasFinalizer Indicates if the `try` statement has a\n   *      `finally` block.\n   * @param {ForkContext} forkContext The enclosing fork context.\n   */\n  constructor(upperContext, hasFinalizer, forkContext) {\n    /**\n     * The previous context.\n     * @type {TryContext}\n     */\n    this.upper = upperContext;\n\n    /**\n     * Indicates if the `try` statement has a `finally` block.\n     * @type {boolean}\n     */\n    this.hasFinalizer = hasFinalizer;\n\n    /**\n     * Tracks the traversal position inside of the `try` statement. This is\n     * used to help determine the context necessary to create paths because\n     * a `try` statement may or may not have `catch` or `finally` blocks,\n     * and code paths behave differently in those blocks.\n     * @type {\"try\"|\"catch\"|\"finally\"}\n     */\n    this.position = \"try\";\n\n    /**\n     * If the `try` statement has a `finally` block, this affects how a\n     * `return` statement behaves in the `try` block. Without `finally`,\n     * `return` behaves as usual and doesn't require a fork; with `finally`,\n     * `return` forks into the `finally` block, so we need a fork context\n     * to track it.\n     * @type {ForkContext|null}\n     */\n    this.returnedForkContext = hasFinalizer ? ForkContext.newEmpty(forkContext) : null;\n\n    /**\n     * When a `throw` occurs inside of a `try` block, the code path forks\n     * into the `catch` or `finally` blocks, and this fork context tracks\n     * that path.\n     * @type {ForkContext}\n     */\n    this.thrownForkContext = ForkContext.newEmpty(forkContext);\n\n    /**\n     * Indicates if the last segment in the `try` block is reachable.\n     * @type {boolean}\n     */\n    this.lastOfTryIsReachable = false;\n\n    /**\n     * Indicates if the last segment in the `catch` block is reachable.\n     * @type {boolean}\n     */\n    this.lastOfCatchIsReachable = false;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not include the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    dest.push(segment);\n    if (!others.includes(segment)) {\n      all.push(segment);\n    }\n  }\n}\n\n/**\n * Gets a loop context for a `continue` statement based on a given label.\n * @param {CodePathState} state The state to search within.\n * @param {string|null} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n  if (!label) {\n    return state.loopContext;\n  }\n  let context = state.loopContext;\n  while (context) {\n    if (context.label === label) {\n      return context;\n    }\n    context = context.upper;\n  }\n\n  /* c8 ignore next */\n  return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state The state to search within.\n * @param {string|null} label The label of a `break` statement.\n * @returns {BreakContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n  let context = state.breakContext;\n  while (context) {\n    if (label ? context.label === label : context.breakable) {\n      return context;\n    }\n    context = context.upper;\n  }\n\n  /* c8 ignore next */\n  return null;\n}\n\n/**\n * Gets a context for a `return` statement. There is just one special case:\n * if there is a `try` statement with a `finally` block, because that alters\n * how `return` behaves; otherwise, this just passes through the given state.\n * @param {CodePathState} state The state to search within\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n  let context = state.tryContext;\n  while (context) {\n    if (context.hasFinalizer && context.position !== \"finally\") {\n      return context;\n    }\n    context = context.upper;\n  }\n  return state;\n}\n\n/**\n * Gets a context for a `throw` statement. There is just one special case:\n * if there is a `try` statement with a `finally` block and we are inside of\n * a `catch` because that changes how `throw` behaves; otherwise, this just\n * passes through the given state.\n * @param {CodePathState} state The state to search within.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n  let context = state.tryContext;\n  while (context) {\n    if (context.position === \"try\" || context.hasFinalizer && context.position === \"catch\") {\n      return context;\n    }\n    context = context.upper;\n  }\n  return state;\n}\n\n/**\n * Removes a given value from a given array.\n * @param {any[]} elements An array to remove the specific element.\n * @param {any} value The value to be removed.\n * @returns {void}\n */\nfunction removeFromArray(elements, value) {\n  elements.splice(elements.indexOf(value), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction disconnectSegments(prevSegments, nextSegments) {\n  for (let i = 0; i < prevSegments.length; ++i) {\n    const prevSegment = prevSegments[i];\n    const nextSegment = nextSegments[i];\n    removeFromArray(prevSegment.nextSegments, nextSegment);\n    removeFromArray(prevSegment.allNextSegments, nextSegment);\n    removeFromArray(nextSegment.prevSegments, prevSegment);\n    removeFromArray(nextSegment.allPrevSegments, prevSegment);\n  }\n}\n\n/**\n * Creates looping path between two arrays of segments, ensuring that there are\n * paths going between matching segments in the arrays.\n * @param {CodePathState} state The state to operate on.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n  const end = Math.min(fromSegments.length, toSegments.length);\n\n  /*\n   * This loop effectively updates a doubly-linked list between two collections\n   * of segments making sure that segments in the same array indices are\n   * combined to create a path.\n   */\n  for (let i = 0; i < end; ++i) {\n    // get the segments in matching array indices\n    const fromSegment = fromSegments[i];\n    const toSegment = toSegments[i];\n\n    /*\n     * If the destination segment is reachable, then create a path from the\n     * source segment to the destination segment.\n     */\n    if (toSegment.reachable) {\n      fromSegment.nextSegments.push(toSegment);\n    }\n\n    /*\n     * If the source segment is reachable, then create a path from the\n     * destination segment back to the source segment.\n     */\n    if (fromSegment.reachable) {\n      toSegment.prevSegments.push(fromSegment);\n    }\n\n    /*\n     * Also update the arrays that don't care if the segments are reachable\n     * or not. This should always happen regardless of anything else.\n     */\n    fromSegment.allNextSegments.push(toSegment);\n    toSegment.allPrevSegments.push(fromSegment);\n\n    /*\n     * If the destination segment has at least two previous segments in its\n     * path then that means there was one previous segment before this iteration\n     * of the loop was executed. So, we need to mark the source segment as\n     * looped.\n     */\n    if (toSegment.allPrevSegments.length >= 2) {\n      CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n    }\n\n    // let the code path analyzer know that there's been a loop created\n    state.notifyLooped(fromSegment, toSegment);\n  }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n  /*\n   * If this choice context doesn't already contain paths from a\n   * child context, then add the current head to each potential path.\n   */\n  if (!choiceContext.processed) {\n    choiceContext.trueForkContext.add(head);\n    choiceContext.falseForkContext.add(head);\n    choiceContext.nullishForkContext.add(head);\n  }\n\n  /*\n   * If the test condition isn't a hardcoded truthy value, then `break`\n   * must follow the same path as if the test condition is false. To represent\n   * that, we append the path for when the loop test is false (represented by\n   * `falseForkContext`) to the `brokenForkContext`.\n   */\n  if (context.test !== true) {\n    context.brokenForkContext.addAll(choiceContext.falseForkContext);\n  }\n  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n  /**\n   * Creates a new instance.\n   * @param {IdGenerator} idGenerator An id generator to generate id for code\n   *   path segments.\n   * @param {Function} onLooped A callback function to notify looping.\n   */\n  constructor(idGenerator, onLooped) {\n    /**\n     * The ID generator to use when creating new segments.\n     * @type {IdGenerator}\n     */\n    this.idGenerator = idGenerator;\n\n    /**\n     * A callback function to call when there is a loop.\n     * @type {Function}\n     */\n    this.notifyLooped = onLooped;\n\n    /**\n     * The root fork context for this state.\n     * @type {ForkContext}\n     */\n    this.forkContext = ForkContext.newRoot(idGenerator);\n\n    /**\n     * Context for logical expressions, conditional expressions, `if` statements,\n     * and loops.\n     * @type {ChoiceContext}\n     */\n    this.choiceContext = null;\n\n    /**\n     * Context for `switch` statements.\n     * @type {SwitchContext}\n     */\n    this.switchContext = null;\n\n    /**\n     * Context for `try` statements.\n     * @type {TryContext}\n     */\n    this.tryContext = null;\n\n    /**\n     * Context for loop statements.\n     * @type {LoopContext}\n     */\n    this.loopContext = null;\n\n    /**\n     * Context for `break` statements.\n     * @type {BreakContext}\n     */\n    this.breakContext = null;\n\n    /**\n     * Context for `ChainExpression` nodes.\n     * @type {ChainContext}\n     */\n    this.chainContext = null;\n\n    /**\n     * An array that tracks the current segments in the state. The array\n     * starts empty and segments are added with each `onCodePathSegmentStart`\n     * event and removed with each `onCodePathSegmentEnd` event. Effectively,\n     * this is tracking the code path segment traversal as the state is\n     * modified.\n     * @type {Array<CodePathSegment>}\n     */\n    this.currentSegments = [];\n\n    /**\n     * Tracks the starting segment for this path. This value never changes.\n     * @type {CodePathSegment}\n     */\n    this.initialSegment = this.forkContext.head[0];\n\n    /**\n     * The final segments of the code path which are either `return` or `throw`.\n     * This is a union of the segments in `returnedForkContext` and `thrownForkContext`.\n     * @type {Array<CodePathSegment>}\n     */\n    this.finalSegments = [];\n\n    /**\n     * The final segments of the code path which are `return`. These\n     * segments are also contained in `finalSegments`.\n     * @type {Array<CodePathSegment>}\n     */\n    this.returnedForkContext = [];\n\n    /**\n     * The final segments of the code path which are `throw`. These\n     * segments are also contained in `finalSegments`.\n     * @type {Array<CodePathSegment>}\n     */\n    this.thrownForkContext = [];\n\n    /*\n     * We add an `add` method so that these look more like fork contexts and\n     * can be used interchangeably when a fork context is needed to add more\n     * segments to a path.\n     *\n     * Ultimately, we want anything added to `returned` or `thrown` to also\n     * be added to `final`. We only add reachable and used segments to these\n     * arrays.\n     */\n    const final = this.finalSegments;\n    const returned = this.returnedForkContext;\n    const thrown = this.thrownForkContext;\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n  }\n\n  /**\n   * A passthrough property exposing the current pointer as part of the API.\n   * @type {CodePathSegment[]}\n   */\n  get headSegments() {\n    return this.forkContext.head;\n  }\n\n  /**\n   * The parent forking context.\n   * This is used for the root of new forks.\n   * @type {ForkContext}\n   */\n  get parentForkContext() {\n    const current = this.forkContext;\n    return current && current.upper;\n  }\n\n  /**\n   * Creates and stacks new forking context.\n   * @param {boolean} forkLeavingPath A flag which shows being in a\n   *   \"finally\" block.\n   * @returns {ForkContext} The created context.\n   */\n  pushForkContext(forkLeavingPath) {\n    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);\n    return this.forkContext;\n  }\n\n  /**\n   * Pops and merges the last forking context.\n   * @returns {ForkContext} The last context.\n   */\n  popForkContext() {\n    const lastContext = this.forkContext;\n    this.forkContext = lastContext.upper;\n    this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n    return lastContext;\n  }\n\n  /**\n   * Creates a new path.\n   * @returns {void}\n   */\n  forkPath() {\n    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n  }\n\n  /**\n   * Creates a bypass path.\n   * This is used for such as IfStatement which does not have \"else\" chunk.\n   * @returns {void}\n   */\n  forkBypassPath() {\n    this.forkContext.add(this.parentForkContext.head);\n  }\n\n  //--------------------------------------------------------------------------\n  // ConditionalExpression, LogicalExpression, IfStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n   *\n   * LogicalExpressions have cases that it goes different paths between the\n   * `true` case and the `false` case.\n   *\n   * For Example:\n   *\n   *     if (a || b) {\n   *         foo();\n   *     } else {\n   *         bar();\n   *     }\n   *\n   * In this case, `b` is evaluated always in the code path of the `else`\n   * block, but it's not so in the code path of the `if` block.\n   * So there are 3 paths.\n   *\n   *     a -> foo();\n   *     a -> b -> foo();\n   *     a -> b -> bar();\n   * @param {string} kind A kind string.\n   *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n   *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n   *   Otherwise, this is `\"loop\"`.\n   * @param {boolean} isForkingAsResult Indicates if the result of the choice\n   *      creates a fork.\n   * @returns {void}\n   */\n  pushChoiceContext(kind, isForkingAsResult) {\n    this.choiceContext = new ChoiceContext(this.choiceContext, kind, isForkingAsResult, this.forkContext);\n  }\n\n  /**\n   * Pops the last choice context and finalizes it.\n   * This is called upon leaving a node that represents a choice.\n   * @throws {Error} (Unreachable.)\n   * @returns {ChoiceContext} The popped context.\n   */\n  popChoiceContext() {\n    const poppedChoiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n    const head = forkContext.head;\n    this.choiceContext = poppedChoiceContext.upper;\n    switch (poppedChoiceContext.kind) {\n      case \"&&\":\n      case \"||\":\n      case \"??\":\n        /*\n         * The `head` are the path of the right-hand operand.\n         * If we haven't previously added segments from child contexts,\n         * then we add these segments to all possible forks.\n         */\n        if (!poppedChoiceContext.processed) {\n          poppedChoiceContext.trueForkContext.add(head);\n          poppedChoiceContext.falseForkContext.add(head);\n          poppedChoiceContext.nullishForkContext.add(head);\n        }\n\n        /*\n         * If this context is the left (test) expression for another choice\n         * context, such as `a || b` in the expression `a || b || c`,\n         * then we take the segments for this context and move them up\n         * to the parent context.\n         */\n        if (poppedChoiceContext.isForkingAsResult) {\n          const parentContext = this.choiceContext;\n          parentContext.trueForkContext.addAll(poppedChoiceContext.trueForkContext);\n          parentContext.falseForkContext.addAll(poppedChoiceContext.falseForkContext);\n          parentContext.nullishForkContext.addAll(poppedChoiceContext.nullishForkContext);\n          parentContext.processed = true;\n\n          // Exit early so we don't collapse all paths into one.\n          return poppedChoiceContext;\n        }\n        break;\n      case \"test\":\n        if (!poppedChoiceContext.processed) {\n          /*\n           * The head segments are the path of the `if` block here.\n           * Updates the `true` path with the end of the `if` block.\n           */\n          poppedChoiceContext.trueForkContext.clear();\n          poppedChoiceContext.trueForkContext.add(head);\n        } else {\n          /*\n           * The head segments are the path of the `else` block here.\n           * Updates the `false` path with the end of the `else`\n           * block.\n           */\n          poppedChoiceContext.falseForkContext.clear();\n          poppedChoiceContext.falseForkContext.add(head);\n        }\n        break;\n      case \"loop\":\n        /*\n         * Loops are addressed in `popLoopContext()` so just return\n         * the context without modification.\n         */\n        return poppedChoiceContext;\n\n      /* c8 ignore next */\n      default:\n        throw new Error(\"unreachable\");\n    }\n\n    /*\n     * Merge the true path with the false path to create a single path.\n     */\n    const combinedForkContext = poppedChoiceContext.trueForkContext;\n    combinedForkContext.addAll(poppedChoiceContext.falseForkContext);\n    forkContext.replaceHead(combinedForkContext.makeNext(0, -1));\n    return poppedChoiceContext;\n  }\n\n  /**\n   * Creates a code path segment to represent right-hand operand of a logical\n   * expression.\n   * This is called in the preprocessing phase when entering a node.\n   * @throws {Error} (Unreachable.)\n   * @returns {void}\n   */\n  makeLogicalRight() {\n    const currentChoiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n    if (currentChoiceContext.processed) {\n      /*\n       * This context was already assigned segments from a child\n       * choice context. In this case, we are concerned only about\n       * the path that does not short-circuit and so ends up on the\n       * right-hand operand of the logical expression.\n       */\n      let prevForkContext;\n      switch (currentChoiceContext.kind) {\n        case \"&&\":\n          // if true then go to the right-hand side.\n          prevForkContext = currentChoiceContext.trueForkContext;\n          break;\n        case \"||\":\n          // if false then go to the right-hand side.\n          prevForkContext = currentChoiceContext.falseForkContext;\n          break;\n        case \"??\":\n          // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's nullishForkContext.\n          prevForkContext = currentChoiceContext.nullishForkContext;\n          break;\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      /*\n       * Create the segment for the right-hand operand of the logical expression\n       * and adjust the fork context pointer to point there. The right-hand segment\n       * is added at the end of all segments in `prevForkContext`.\n       */\n      forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n      /*\n       * We no longer need this list of segments.\n       *\n       * Reset `processed` because we've removed the segments from the child\n       * choice context. This allows `popChoiceContext()` to continue adding\n       * segments later.\n       */\n      prevForkContext.clear();\n      currentChoiceContext.processed = false;\n    } else {\n      /*\n       * This choice context was not assigned segments from a child\n       * choice context, which means that it's a terminal logical\n       * expression.\n       *\n       * `head` is the segments for the left-hand operand of the\n       * logical expression.\n       *\n       * Each of the fork contexts below are empty at this point. We choose\n       * the path(s) that will short-circuit and add the segment for the\n       * left-hand operand to it. Ultimately, this will be the only segment\n       * in that path due to the short-circuting, so we are just seeding\n       * these paths to start.\n       */\n      switch (currentChoiceContext.kind) {\n        case \"&&\":\n          /*\n           * In most contexts, when a && expression evaluates to false,\n           * it short circuits, so we need to account for that by setting\n           * the `falseForkContext` to the left operand.\n           *\n           * When a && expression is the left-hand operand for a ??\n           * expression, such as `(a && b) ?? c`, a nullish value will\n           * also short-circuit in a different way than a false value,\n           * so we also set the `nullishForkContext` to the left operand.\n           * This path is only used with a ?? expression and is thrown\n           * away for any other type of logical expression, so it's safe\n           * to always add.\n           */\n          currentChoiceContext.falseForkContext.add(forkContext.head);\n          currentChoiceContext.nullishForkContext.add(forkContext.head);\n          break;\n        case \"||\":\n          // the true path can short-circuit.\n          currentChoiceContext.trueForkContext.add(forkContext.head);\n          break;\n        case \"??\":\n          // both can short-circuit.\n          currentChoiceContext.trueForkContext.add(forkContext.head);\n          currentChoiceContext.falseForkContext.add(forkContext.head);\n          break;\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      /*\n       * Create the segment for the right-hand operand of the logical expression\n       * and adjust the fork context pointer to point there.\n       */\n      forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n  }\n\n  /**\n   * Makes a code path segment of the `if` block.\n   * @returns {void}\n   */\n  makeIfConsequent() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    /*\n     * If any result were not transferred from child contexts,\n     * this sets the head segments to both cases.\n     * The head segments are the path of the test expression.\n     */\n    if (!context.processed) {\n      context.trueForkContext.add(forkContext.head);\n      context.falseForkContext.add(forkContext.head);\n      context.nullishForkContext.add(forkContext.head);\n    }\n    context.processed = false;\n\n    // Creates new path from the `true` case.\n    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));\n  }\n\n  /**\n   * Makes a code path segment of the `else` block.\n   * @returns {void}\n   */\n  makeIfAlternate() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    /*\n     * The head segments are the path of the `if` block.\n     * Updates the `true` path with the end of the `if` block.\n     */\n    context.trueForkContext.clear();\n    context.trueForkContext.add(forkContext.head);\n    context.processed = true;\n\n    // Creates new path from the `false` case.\n    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));\n  }\n\n  //--------------------------------------------------------------------------\n  // ChainExpression\n  //--------------------------------------------------------------------------\n\n  /**\n   * Pushes a new `ChainExpression` context to the stack. This method is\n   * called when entering a `ChainExpression` node. A chain context is used to\n   * count forking in the optional chain then merge them on the exiting from the\n   * `ChainExpression` node.\n   * @returns {void}\n   */\n  pushChainContext() {\n    this.chainContext = new ChainContext(this.chainContext);\n  }\n\n  /**\n   * Pop a `ChainExpression` context from the stack. This method is called on\n   * exiting from each `ChainExpression` node. This merges all forks of the\n   * last optional chaining.\n   * @returns {void}\n   */\n  popChainContext() {\n    const context = this.chainContext;\n    this.chainContext = context.upper;\n\n    // pop all choice contexts of this.\n    for (let i = context.choiceContextCount; i > 0; --i) {\n      this.popChoiceContext();\n    }\n  }\n\n  /**\n   * Create a choice context for optional access.\n   * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n   * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n   * @returns {void}\n   */\n  makeOptionalNode() {\n    if (this.chainContext) {\n      this.chainContext.choiceContextCount += 1;\n      this.pushChoiceContext(\"??\", false);\n    }\n  }\n\n  /**\n   * Create a fork.\n   * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n   * @returns {void}\n   */\n  makeOptionalRight() {\n    if (this.chainContext) {\n      this.makeLogicalRight();\n    }\n  }\n\n  //--------------------------------------------------------------------------\n  // SwitchStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of SwitchStatement and stacks it.\n   * @param {boolean} hasCase `true` if the switch statement has one or more\n   *   case parts.\n   * @param {string|null} label The label text.\n   * @returns {void}\n   */\n  pushSwitchContext(hasCase, label) {\n    this.switchContext = new SwitchContext(this.switchContext, hasCase);\n    this.pushBreakContext(true, label);\n  }\n\n  /**\n   * Pops the last context of SwitchStatement and finalizes it.\n   *\n   * - Disposes all forking stack for `case` and `default`.\n   * - Creates the next code path segment from `context.brokenForkContext`.\n   * - If the last `SwitchCase` node is not a `default` part, creates a path\n   *   to the `default` body.\n   * @returns {void}\n   */\n  popSwitchContext() {\n    const context = this.switchContext;\n    this.switchContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n    if (context.forkCount === 0) {\n      /*\n       * When there is only one `default` chunk and there is one or more\n       * `break` statements, even if forks are nothing, it needs to merge\n       * those.\n       */\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.makeNext(-1, -1));\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n      return;\n    }\n    const lastSegments = forkContext.head;\n    this.forkBypassPath();\n    const lastCaseSegments = forkContext.head;\n\n    /*\n     * `brokenForkContext` is used to make the next segment.\n     * It must add the last segment into `brokenForkContext`.\n     */\n    brokenForkContext.add(lastSegments);\n\n    /*\n     * Any value that doesn't match a `case` test should flow to the default\n     * case. That happens normally when the default case is last in the `switch`,\n     * but if it's not, we need to rewire some of the paths to be correct.\n     */\n    if (!context.lastIsDefault) {\n      if (context.defaultBodySegments) {\n        /*\n         * There is a non-empty default case, so remove the path from the `default`\n         * label to its body for an accurate representation.\n         */\n        disconnectSegments(context.defaultSegments, context.defaultBodySegments);\n\n        /*\n         * Connect the path from the last non-default case to the body of the\n         * default case.\n         */\n        makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n      } else {\n        /*\n         * There is no default case, so we treat this as if the last case\n         * had a `break` in it.\n         */\n        brokenForkContext.add(lastCaseSegments);\n      }\n    }\n\n    // Traverse up to the original fork context for the `switch` statement\n    for (let i = 0; i < context.forkCount; ++i) {\n      this.forkContext = this.forkContext.upper;\n    }\n\n    /*\n     * Creates a path from all `brokenForkContext` paths.\n     * This is a path after `switch` statement.\n     */\n    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n  }\n\n  /**\n   * Makes a code path segment for a `SwitchCase` node.\n   * @param {boolean} isCaseBodyEmpty `true` if the body is empty.\n   * @param {boolean} isDefaultCase `true` if the body is the default case.\n   * @returns {void}\n   */\n  makeSwitchCaseBody(isCaseBodyEmpty, isDefaultCase) {\n    const context = this.switchContext;\n    if (!context.hasCase) {\n      return;\n    }\n\n    /*\n     * Merge forks.\n     * The parent fork context has two segments.\n     * Those are from the current `case` and the body of the previous case.\n     */\n    const parentForkContext = this.forkContext;\n    const forkContext = this.pushForkContext();\n    forkContext.add(parentForkContext.makeNext(0, -1));\n\n    /*\n     * Add information about the default case.\n     *\n     * The purpose of this is to identify the starting segments for the\n     * default case to make sure there is a path there.\n     */\n    if (isDefaultCase) {\n      /*\n       * This is the default case in the `switch`.\n       *\n       * We first save the current pointer as `defaultSegments` to point\n       * to the `default` keyword.\n       */\n      context.defaultSegments = parentForkContext.head;\n\n      /*\n       * If the body of the case is empty then we just set\n       * `foundEmptyDefault` to true; otherwise, we save a reference\n       * to the current pointer as `defaultBodySegments`.\n       */\n      if (isCaseBodyEmpty) {\n        context.foundEmptyDefault = true;\n      } else {\n        context.defaultBodySegments = forkContext.head;\n      }\n    } else {\n      /*\n       * This is not the default case in the `switch`.\n       *\n       * If it's not empty and there is already an empty default case found,\n       * that means the default case actually comes before this case,\n       * and that it will fall through to this case. So, we can now\n       * ignore the previous default case (reset `foundEmptyDefault` to false)\n       * and set `defaultBodySegments` to the current segments because this is\n       * effectively the new default case.\n       */\n      if (!isCaseBodyEmpty && context.foundEmptyDefault) {\n        context.foundEmptyDefault = false;\n        context.defaultBodySegments = forkContext.head;\n      }\n    }\n\n    // keep track if the default case ends up last\n    context.lastIsDefault = isDefaultCase;\n    context.forkCount += 1;\n  }\n\n  //--------------------------------------------------------------------------\n  // TryStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of TryStatement and stacks it.\n   * @param {boolean} hasFinalizer `true` if the try statement has a\n   *   `finally` block.\n   * @returns {void}\n   */\n  pushTryContext(hasFinalizer) {\n    this.tryContext = new TryContext(this.tryContext, hasFinalizer, this.forkContext);\n  }\n\n  /**\n   * Pops the last context of TryStatement and finalizes it.\n   * @returns {void}\n   */\n  popTryContext() {\n    const context = this.tryContext;\n    this.tryContext = context.upper;\n\n    /*\n     * If we're inside the `catch` block, that means there is no `finally`,\n     * so we can process the `try` and `catch` blocks the simple way and\n     * merge their two paths.\n     */\n    if (context.position === \"catch\") {\n      this.popForkContext();\n      return;\n    }\n\n    /*\n     * The following process is executed only when there is a `finally`\n     * block.\n     */\n\n    const originalReturnedForkContext = context.returnedForkContext;\n    const originalThrownForkContext = context.thrownForkContext;\n\n    // no `return` or `throw` in `try` or `catch` so there's nothing left to do\n    if (originalReturnedForkContext.empty && originalThrownForkContext.empty) {\n      return;\n    }\n\n    /*\n     * The following process is executed only when there is a `finally`\n     * block and there was a `return` or `throw` in the `try` or `catch`\n     * blocks.\n     */\n\n    // Separate head to normal paths and leaving paths.\n    const headSegments = this.forkContext.head;\n    this.forkContext = this.forkContext.upper;\n    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n    // Forwards the leaving path to upper contexts.\n    if (!originalReturnedForkContext.empty) {\n      getReturnContext(this).returnedForkContext.add(leavingSegments);\n    }\n    if (!originalThrownForkContext.empty) {\n      getThrowContext(this).thrownForkContext.add(leavingSegments);\n    }\n\n    // Sets the normal path as the next.\n    this.forkContext.replaceHead(normalSegments);\n\n    /*\n     * If both paths of the `try` block and the `catch` block are\n     * unreachable, the next path becomes unreachable as well.\n     */\n    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n      this.forkContext.makeUnreachable();\n    }\n  }\n\n  /**\n   * Makes a code path segment for a `catch` block.\n   * @returns {void}\n   */\n  makeCatchBlock() {\n    const context = this.tryContext;\n    const forkContext = this.forkContext;\n    const originalThrownForkContext = context.thrownForkContext;\n\n    /*\n     * We are now in a catch block so we need to update the context\n     * with that information. This includes creating a new fork\n     * context in case we encounter any `throw` statements here.\n     */\n    context.position = \"catch\";\n    context.thrownForkContext = ForkContext.newEmpty(forkContext);\n    context.lastOfTryIsReachable = forkContext.reachable;\n\n    // Merge the thrown paths from the `try` and `catch` blocks\n    originalThrownForkContext.add(forkContext.head);\n    const thrownSegments = originalThrownForkContext.makeNext(0, -1);\n\n    // Fork to a bypass and the merged thrown path.\n    this.pushForkContext();\n    this.forkBypassPath();\n    this.forkContext.add(thrownSegments);\n  }\n\n  /**\n   * Makes a code path segment for a `finally` block.\n   *\n   * In the `finally` block, parallel paths are created. The parallel paths\n   * are used as leaving-paths. The leaving-paths are paths from `return`\n   * statements and `throw` statements in a `try` block or a `catch` block.\n   * @returns {void}\n   */\n  makeFinallyBlock() {\n    const context = this.tryContext;\n    let forkContext = this.forkContext;\n    const originalReturnedForkContext = context.returnedForkContext;\n    const originalThrownForContext = context.thrownForkContext;\n    const headOfLeavingSegments = forkContext.head;\n\n    // Update state.\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block.\n      this.popForkContext();\n      forkContext = this.forkContext;\n      context.lastOfCatchIsReachable = forkContext.reachable;\n    } else {\n      context.lastOfTryIsReachable = forkContext.reachable;\n    }\n    context.position = \"finally\";\n\n    /*\n     * If there was no `return` or `throw` in either the `try` or `catch`\n     * blocks, then there's no further code paths to create for `finally`.\n     */\n    if (originalReturnedForkContext.empty && originalThrownForContext.empty) {\n      // This path does not leave.\n      return;\n    }\n\n    /*\n     * Create a parallel segment from merging returned and thrown.\n     * This segment will leave at the end of this `finally` block.\n     */\n    const segments = forkContext.makeNext(-1, -1);\n    for (let i = 0; i < forkContext.count; ++i) {\n      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n      for (let j = 0; j < originalReturnedForkContext.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(originalReturnedForkContext.segmentsList[j][i]);\n      }\n      for (let j = 0; j < originalThrownForContext.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(originalThrownForContext.segmentsList[j][i]);\n      }\n      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));\n    }\n    this.pushForkContext(true);\n    this.forkContext.add(segments);\n  }\n\n  /**\n   * Makes a code path segment from the first throwable node to the `catch`\n   * block or the `finally` block.\n   * @returns {void}\n   */\n  makeFirstThrowablePathInTryBlock() {\n    const forkContext = this.forkContext;\n    if (!forkContext.reachable) {\n      return;\n    }\n    const context = getThrowContext(this);\n    if (context === this || context.position !== \"try\" || !context.thrownForkContext.empty) {\n      return;\n    }\n    context.thrownForkContext.add(forkContext.head);\n    forkContext.replaceHead(forkContext.makeNext(-1, -1));\n  }\n\n  //--------------------------------------------------------------------------\n  // Loop Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of a loop statement and stacks it.\n   * @param {string} type The type of the node which was triggered. One of\n   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n   *   and `ForStatement`.\n   * @param {string|null} label A label of the node which was triggered.\n   * @throws {Error} (Unreachable - unknown type.)\n   * @returns {void}\n   */\n  pushLoopContext(type, label) {\n    const forkContext = this.forkContext;\n\n    // All loops need a path to account for `break` statements\n    const breakContext = this.pushBreakContext(true, label);\n    switch (type) {\n      case \"WhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = new WhileLoopContext(this.loopContext, label, breakContext);\n        break;\n      case \"DoWhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = new DoWhileLoopContext(this.loopContext, label, breakContext, forkContext);\n        break;\n      case \"ForStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = new ForLoopContext(this.loopContext, label, breakContext);\n        break;\n      case \"ForInStatement\":\n        this.loopContext = new ForInLoopContext(this.loopContext, label, breakContext);\n        break;\n      case \"ForOfStatement\":\n        this.loopContext = new ForOfLoopContext(this.loopContext, label, breakContext);\n        break;\n\n      /* c8 ignore next */\n      default:\n        throw new Error(`unknown type: \"${type}\"`);\n    }\n  }\n\n  /**\n   * Pops the last context of a loop statement and finalizes it.\n   * @throws {Error} (Unreachable - unknown type.)\n   * @returns {void}\n   */\n  popLoopContext() {\n    const context = this.loopContext;\n    this.loopContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    // Creates a looped path.\n    switch (context.type) {\n      case \"WhileStatement\":\n      case \"ForStatement\":\n        this.popChoiceContext();\n\n        /*\n         * Creates the path from the end of the loop body up to the\n         * location where `continue` would jump to.\n         */\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n        break;\n      case \"DoWhileStatement\":\n        {\n          const choiceContext = this.popChoiceContext();\n          if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n          }\n\n          /*\n           * If this isn't a hardcoded `true` condition, then `break`\n           * should continue down the path as if the condition evaluated\n           * to false.\n           */\n          if (context.test !== true) {\n            brokenForkContext.addAll(choiceContext.falseForkContext);\n          }\n\n          /*\n           * When the condition is true, the loop continues back to the top,\n           * so create a path from each possible true condition back to the\n           * top of the loop.\n           */\n          const segmentsList = choiceContext.trueForkContext.segmentsList;\n          for (let i = 0; i < segmentsList.length; ++i) {\n            makeLooped(this, segmentsList[i], context.entrySegments);\n          }\n          break;\n        }\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        brokenForkContext.add(forkContext.head);\n\n        /*\n         * Creates the path from the end of the loop body up to the\n         * left expression (left of `in` or `of`) of the loop.\n         */\n        makeLooped(this, forkContext.head, context.leftSegments);\n        break;\n\n      /* c8 ignore next */\n      default:\n        throw new Error(\"unreachable\");\n    }\n\n    /*\n     * If there wasn't a `break` statement in the loop, then we're at\n     * the end of the loop's path, so we make an unreachable segment\n     * to mark that.\n     *\n     * If there was a `break` statement, then we continue on into the\n     * `brokenForkContext`.\n     */\n    if (brokenForkContext.empty) {\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    } else {\n      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n  }\n\n  /**\n   * Makes a code path segment for the test part of a WhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n  makeWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const testSegments = forkContext.makeNext(0, -1);\n\n    // Update state.\n    context.test = test;\n    context.continueDestSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n\n  /**\n   * Makes a code path segment for the body part of a WhileStatement.\n   * @returns {void}\n   */\n  makeWhileBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n    if (!choiceContext.processed) {\n      choiceContext.trueForkContext.add(forkContext.head);\n      choiceContext.falseForkContext.add(forkContext.head);\n    }\n\n    /*\n     * If this isn't a hardcoded `true` condition, then `break`\n     * should continue down the path as if the condition evaluated\n     * to false.\n     */\n    if (context.test !== true) {\n      context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n  }\n\n  /**\n   * Makes a code path segment for the body part of a DoWhileStatement.\n   * @returns {void}\n   */\n  makeDoWhileBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const bodySegments = forkContext.makeNext(-1, -1);\n\n    // Update state.\n    context.entrySegments = bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n\n  /**\n   * Makes a code path segment for the test part of a DoWhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n  makeDoWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    context.test = test;\n\n    /*\n     * If there is a `continue` statement in the loop then `continueForkContext`\n     * won't be empty. We wire up the path from `continue` to the loop\n     * test condition and then continue the traversal in the root fork context.\n     */\n    if (!context.continueForkContext.empty) {\n      context.continueForkContext.add(forkContext.head);\n      const testSegments = context.continueForkContext.makeNext(0, -1);\n      forkContext.replaceHead(testSegments);\n    }\n  }\n\n  /**\n   * Makes a code path segment for the test part of a ForStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n  makeForTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const endOfInitSegments = forkContext.head;\n    const testSegments = forkContext.makeNext(-1, -1);\n\n    /*\n     * Update the state.\n     *\n     * The `continueDestSegments` are set to `testSegments` because we\n     * don't yet know if there is an update expression in this loop. So,\n     * from what we already know at this point, a `continue` statement\n     * will jump back to the test expression.\n     */\n    context.test = test;\n    context.endOfInitSegments = endOfInitSegments;\n    context.continueDestSegments = context.testSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n\n  /**\n   * Makes a code path segment for the update part of a ForStatement.\n   * @returns {void}\n   */\n  makeForUpdate() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    // Make the next paths of the test.\n    if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n\n    /*\n     * Update the state.\n     *\n     * The `continueDestSegments` are now set to `updateSegments` because we\n     * know there is an update expression in this loop. So, a `continue` statement\n     * in the loop will jump to the update expression first, and then to any\n     * test expression the loop might have.\n     */\n    const updateSegments = forkContext.makeDisconnected(-1, -1);\n    context.continueDestSegments = context.updateSegments = updateSegments;\n    forkContext.replaceHead(updateSegments);\n  }\n\n  /**\n   * Makes a code path segment for the body part of a ForStatement.\n   * @returns {void}\n   */\n  makeForBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    /*\n     * Determine what to do based on which part of the `for` loop are present.\n     * 1. If there is an update expression, then `updateSegments` is not null and\n     *    we need to assign `endOfUpdateSegments`, and if there is a test\n     *    expression, we then need to create the looped path to get back to\n     *    the test condition.\n     * 2. If there is no update expression but there is a test expression,\n     *    then we only need to update the test segment information.\n     * 3. If there is no update expression and no test expression, then we\n     *    just save `endOfInitSegments`.\n     */\n    if (context.updateSegments) {\n      context.endOfUpdateSegments = forkContext.head;\n\n      /*\n       * In a `for` loop that has both an update expression and a test\n       * condition, execution flows from the test expression into the\n       * loop body, to the update expression, and then back to the test\n       * expression to determine if the loop should continue.\n       *\n       * To account for that, we need to make a path from the end of the\n       * update expression to the start of the test expression. This is\n       * effectively what creates the loop in the code path.\n       */\n      if (context.testSegments) {\n        makeLooped(this, context.endOfUpdateSegments, context.testSegments);\n      }\n    } else if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n    let bodySegments = context.endOfTestSegments;\n\n    /*\n     * If there is a test condition, then there `endOfTestSegments` is also\n     * the start of the loop body. If there isn't a test condition then\n     * `bodySegments` will be null and we need to look elsewhere to find\n     * the start of the body.\n     *\n     * The body starts at the end of the init expression and ends at the end\n     * of the update expression, so we use those locations to determine the\n     * body segments.\n     */\n    if (!bodySegments) {\n      const prevForkContext = ForkContext.newEmpty(forkContext);\n      prevForkContext.add(context.endOfInitSegments);\n      if (context.endOfUpdateSegments) {\n        prevForkContext.add(context.endOfUpdateSegments);\n      }\n      bodySegments = prevForkContext.makeNext(0, -1);\n    }\n\n    /*\n     * If there was no test condition and no update expression, then\n     * `continueDestSegments` will be null. In that case, a\n     * `continue` should skip directly to the body of the loop.\n     * Otherwise, we want to keep the current `continueDestSegments`.\n     */\n    context.continueDestSegments = context.continueDestSegments || bodySegments;\n\n    // move pointer to the body\n    forkContext.replaceHead(bodySegments);\n  }\n\n  /**\n   * Makes a code path segment for the left part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n  makeForInOfLeft() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n    // Update state.\n    context.prevSegments = forkContext.head;\n    context.leftSegments = context.continueDestSegments = leftSegments;\n    forkContext.replaceHead(leftSegments);\n  }\n\n  /**\n   * Makes a code path segment for the right part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n  makeForInOfRight() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.prevSegments);\n    const rightSegments = temp.makeNext(-1, -1);\n\n    // Update state.\n    context.endOfLeftSegments = forkContext.head;\n    forkContext.replaceHead(rightSegments);\n  }\n\n  /**\n   * Makes a code path segment for the body part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n  makeForInOfBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.endOfLeftSegments);\n    const bodySegments = temp.makeNext(-1, -1);\n\n    // Make a path: `right` -> `left`.\n    makeLooped(this, forkContext.head, context.leftSegments);\n\n    // Update state.\n    context.brokenForkContext.add(forkContext.head);\n    forkContext.replaceHead(bodySegments);\n  }\n\n  //--------------------------------------------------------------------------\n  // Control Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates new context in which a `break` statement can be used. This occurs inside of a loop,\n   * labeled statement, or switch statement.\n   * @param {boolean} breakable Indicates if we are inside a statement where\n   *      `break` without a label will exit the statement.\n   * @param {string|null} label The label associated with the statement.\n   * @returns {BreakContext} The new context.\n   */\n  pushBreakContext(breakable, label) {\n    this.breakContext = new BreakContext(this.breakContext, breakable, label, this.forkContext);\n    return this.breakContext;\n  }\n\n  /**\n   * Removes the top item of the break context stack.\n   * @returns {Object} The removed context.\n   */\n  popBreakContext() {\n    const context = this.breakContext;\n    const forkContext = this.forkContext;\n    this.breakContext = context.upper;\n\n    // Process this context here for other than switches and loops.\n    if (!context.breakable) {\n      const brokenForkContext = context.brokenForkContext;\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Makes a path for a `break` statement.\n   *\n   * It registers the head segment to a context of `break`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string|null} label A label of the break statement.\n   * @returns {void}\n   */\n  makeBreak(label) {\n    const forkContext = this.forkContext;\n    if (!forkContext.reachable) {\n      return;\n    }\n    const context = getBreakContext(this, label);\n    if (context) {\n      context.brokenForkContext.add(forkContext.head);\n    }\n\n    /* c8 ignore next */\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n\n  /**\n   * Makes a path for a `continue` statement.\n   *\n   * It makes a looping path.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string|null} label A label of the continue statement.\n   * @returns {void}\n   */\n  makeContinue(label) {\n    const forkContext = this.forkContext;\n    if (!forkContext.reachable) {\n      return;\n    }\n    const context = getContinueContext(this, label);\n    if (context) {\n      if (context.continueDestSegments) {\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n\n        // If the context is a for-in/of loop, this affects a break also.\n        if (context.type === \"ForInStatement\" || context.type === \"ForOfStatement\") {\n          context.brokenForkContext.add(forkContext.head);\n        }\n      } else {\n        context.continueForkContext.add(forkContext.head);\n      }\n    }\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n\n  /**\n   * Makes a path for a `return` statement.\n   *\n   * It registers the head segment to a context of `return`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n  makeReturn() {\n    const forkContext = this.forkContext;\n    if (forkContext.reachable) {\n      getReturnContext(this).returnedForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n\n  /**\n   * Makes a path for a `throw` statement.\n   *\n   * It registers the head segment to a context of `throw`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n  makeThrow() {\n    const forkContext = this.forkContext;\n    if (forkContext.reachable) {\n      getThrowContext(this).thrownForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n\n  /**\n   * Makes the final path.\n   * @returns {void}\n   */\n  makeFinal() {\n    const segments = this.currentSegments;\n    if (segments.length > 0 && segments[0].reachable) {\n      this.returnedForkContext.add(segments);\n    }\n  }\n}\nmodule.exports = CodePathState;","map":{"version":3,"names":["CodePathSegment","require","ForkContext","BreakContext","constructor","upperContext","breakable","label","forkContext","upper","brokenForkContext","newEmpty","ChainContext","choiceContextCount","ChoiceContext","kind","isForkingAsResult","trueForkContext","falseForkContext","nullishForkContext","processed","LoopContextBase","type","breakContext","WhileLoopContext","test","continueDestSegments","DoWhileLoopContext","entrySegments","continueForkContext","ForLoopContext","endOfInitSegments","testSegments","endOfTestSegments","updateSegments","endOfUpdateSegments","ForInLoopContext","prevSegments","leftSegments","endOfLeftSegments","ForOfLoopContext","SwitchContext","hasCase","defaultSegments","defaultBodySegments","foundEmptyDefault","lastIsDefault","forkCount","TryContext","hasFinalizer","position","returnedForkContext","thrownForkContext","lastOfTryIsReachable","lastOfCatchIsReachable","addToReturnedOrThrown","dest","others","all","segments","i","length","segment","push","includes","getContinueContext","state","loopContext","context","getBreakContext","getReturnContext","tryContext","getThrowContext","removeFromArray","elements","value","splice","indexOf","disconnectSegments","nextSegments","prevSegment","nextSegment","allNextSegments","allPrevSegments","makeLooped","unflattenedFromSegments","unflattenedToSegments","fromSegments","flattenUnusedSegments","toSegments","end","Math","min","fromSegment","toSegment","reachable","markPrevSegmentAsLooped","notifyLooped","finalizeTestSegmentsOfFor","choiceContext","head","add","addAll","makeNext","CodePathState","idGenerator","onLooped","newRoot","switchContext","chainContext","currentSegments","initialSegment","finalSegments","final","returned","thrown","bind","headSegments","parentForkContext","current","pushForkContext","forkLeavingPath","popForkContext","lastContext","replaceHead","forkPath","forkBypassPath","pushChoiceContext","popChoiceContext","poppedChoiceContext","parentContext","clear","Error","combinedForkContext","makeLogicalRight","currentChoiceContext","prevForkContext","makeIfConsequent","makeIfAlternate","pushChainContext","popChainContext","makeOptionalNode","makeOptionalRight","pushSwitchContext","pushBreakContext","popSwitchContext","popBreakContext","empty","lastSegments","lastCaseSegments","makeSwitchCaseBody","isCaseBodyEmpty","isDefaultCase","pushTryContext","popTryContext","originalReturnedForkContext","originalThrownForkContext","normalSegments","slice","leavingSegments","makeUnreachable","makeCatchBlock","thrownSegments","makeFinallyBlock","originalThrownForContext","headOfLeavingSegments","count","prevSegsOfLeavingSegment","j","segmentsList","newNext","next","makeFirstThrowablePathInTryBlock","pushLoopContext","popLoopContext","makeWhileTest","makeWhileBody","makeDoWhileBody","bodySegments","makeDoWhileTest","makeForTest","makeForUpdate","makeDisconnected","makeForBody","makeForInOfLeft","makeForInOfRight","temp","rightSegments","makeForInOfBody","makeBreak","makeContinue","makeReturn","makeThrow","makeFinal","module","exports"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js"],"sourcesContent":["/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//-----------------------------------------------------------------------------\n// Contexts\n//-----------------------------------------------------------------------------\n\n/**\n * Represents the context in which a `break` statement can be used.\n *\n * A `break` statement without a label is only valid in a few places in\n * JavaScript: any type of loop or a `switch` statement. Otherwise, `break`\n * without a label causes a syntax error. For these contexts, `breakable` is\n * set to `true` to indicate that a `break` without a label is valid.\n *\n * However, a `break` statement with a label is also valid inside of a labeled\n * statement. For example, this is valid:\n *\n *     a : {\n *         break a;\n *     }\n *\n * The `breakable` property is set false for labeled statements to indicate\n * that `break` without a label is invalid.\n */\nclass BreakContext {\n\n    /**\n     * Creates a new instance.\n     * @param {BreakContext} upperContext The previous `BreakContext`.\n     * @param {boolean} breakable Indicates if we are inside a statement where\n     *      `break` without a label will exit the statement.\n     * @param {string|null} label The label for the statement.\n     * @param {ForkContext} forkContext The current fork context.\n     */\n    constructor(upperContext, breakable, label, forkContext) {\n\n        /**\n         * The previous `BreakContext`\n         * @type {BreakContext}\n         */\n        this.upper = upperContext;\n\n        /**\n         * Indicates if we are inside a statement where `break` without a label\n         * will exit the statement.\n         * @type {boolean}\n         */\n        this.breakable = breakable;\n\n        /**\n         * The label associated with the statement.\n         * @type {string|null}\n         */\n        this.label = label;\n\n        /**\n         * The fork context for the `break`.\n         * @type {ForkContext}\n         */\n        this.brokenForkContext = ForkContext.newEmpty(forkContext);\n    }\n}\n\n/**\n * Represents the context for `ChainExpression` nodes.\n */\nclass ChainContext {\n\n    /**\n     * Creates a new instance.\n     * @param {ChainContext} upperContext The previous `ChainContext`.\n     */\n    constructor(upperContext) {\n\n        /**\n         * The previous `ChainContext`\n         * @type {ChainContext}\n         */\n        this.upper = upperContext;\n\n        /**\n         * The number of choice contexts inside of the `ChainContext`.\n         * @type {number}\n         */\n        this.choiceContextCount = 0;\n\n    }\n}\n\n/**\n * Represents a choice in the code path.\n *\n * Choices are created by logical operators such as `&&`, loops, conditionals,\n * and `if` statements. This is the point at which the code path has a choice of\n * which direction to go.\n *\n * The result of a choice might be in the left (test) expression of another choice,\n * and in that case, may create a new fork. For example, `a || b` is a choice\n * but does not create a new fork because the result of the expression is\n * not used as the test expression in another expression. In this case,\n * `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`\n * expression appears as the test expression for `|| c`, so the\n * result of `a || b` creates a fork because execution may or may not\n * continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true\n * while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always\n * false for `if` statements, conditional expressions, and loops.)\n *\n * All of the choices except one (`??`) operate on a true/false fork, meaning if\n * true go one way and if false go the other (tracked by `trueForkContext` and\n * `falseForkContext`). The `??` operator doesn't operate on true/false because\n * the left expression is evaluated to be nullish or not, so only if nullish do\n * we fork to the right expression (tracked by `nullishForkContext`).\n */\nclass ChoiceContext {\n\n    /**\n     * Creates a new instance.\n     * @param {ChoiceContext} upperContext The previous `ChoiceContext`.\n     * @param {string} kind The kind of choice. If it's a logical or assignment expression, this\n     *      is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or\n     *      conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult Indicates if the result of the choice\n     *      creates a fork.\n     * @param {ForkContext} forkContext The containing `ForkContext`.\n     */\n    constructor(upperContext, kind, isForkingAsResult, forkContext) {\n\n        /**\n         * The previous `ChoiceContext`\n         * @type {ChoiceContext}\n         */\n        this.upper = upperContext;\n\n        /**\n         * The kind of choice. If it's a logical or assignment expression, this\n         * is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or\n         * conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.\n         * @type {string}\n         */\n        this.kind = kind;\n\n        /**\n         * Indicates if the result of the choice forks the code path.\n         * @type {boolean}\n         */\n        this.isForkingAsResult = isForkingAsResult;\n\n        /**\n         * The fork context for the `true` path of the choice.\n         * @type {ForkContext}\n         */\n        this.trueForkContext = ForkContext.newEmpty(forkContext);\n\n        /**\n         * The fork context for the `false` path of the choice.\n         * @type {ForkContext}\n         */\n        this.falseForkContext = ForkContext.newEmpty(forkContext);\n\n        /**\n         * The fork context for when the choice result is `null` or `undefined`.\n         * @type {ForkContext}\n         */\n        this.nullishForkContext = ForkContext.newEmpty(forkContext);\n\n        /**\n         * Indicates if any of `trueForkContext`, `falseForkContext`, or\n         * `nullishForkContext` have been updated with segments from a child context.\n         * @type {boolean}\n         */\n        this.processed = false;\n    }\n\n}\n\n/**\n * Base class for all loop contexts.\n */\nclass LoopContextBase {\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string} type The AST node's `type` for the loop.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n    constructor(upperContext, type, label, breakContext) {\n\n        /**\n         * The previous `LoopContext`.\n         * @type {LoopContext}\n         */\n        this.upper = upperContext;\n\n        /**\n         * The AST node's `type` for the loop.\n         * @type {string}\n         */\n        this.type = type;\n\n        /**\n         * The label for the loop from an enclosing `LabeledStatement`.\n         * @type {string|null}\n         */\n        this.label = label;\n\n        /**\n         * The fork context for when `break` is encountered.\n         * @type {ForkContext}\n         */\n        this.brokenForkContext = breakContext.brokenForkContext;\n    }\n}\n\n/**\n * Represents the context for a `while` loop.\n */\nclass WhileLoopContext extends LoopContextBase {\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n    constructor(upperContext, label, breakContext) {\n        super(upperContext, \"WhileStatement\", label, breakContext);\n\n        /**\n         * The hardcoded literal boolean test condition for\n         * the loop. Used to catch infinite or skipped loops.\n         * @type {boolean|undefined}\n         */\n        this.test = void 0;\n\n        /**\n         * The segments representing the test condition where `continue` will\n         * jump to. The test condition will typically have just one segment but\n         * it's possible for there to be more than one.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.continueDestSegments = null;\n    }\n}\n\n/**\n * Represents the context for a `do-while` loop.\n */\nclass DoWhileLoopContext extends LoopContextBase {\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     * @param {ForkContext} forkContext The enclosing fork context.\n     */\n    constructor(upperContext, label, breakContext, forkContext) {\n        super(upperContext, \"DoWhileStatement\", label, breakContext);\n\n        /**\n         * The hardcoded literal boolean test condition for\n         * the loop. Used to catch infinite or skipped loops.\n         * @type {boolean|undefined}\n         */\n        this.test = void 0;\n\n        /**\n         * The segments at the start of the loop body. This is the only loop\n         * where the test comes at the end, so the first iteration always\n         * happens and we need a reference to the first statements.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.entrySegments = null;\n\n        /**\n         * The fork context to follow when a `continue` is found.\n         * @type {ForkContext}\n         */\n        this.continueForkContext = ForkContext.newEmpty(forkContext);\n    }\n}\n\n/**\n * Represents the context for a `for` loop.\n */\nclass ForLoopContext extends LoopContextBase {\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n    constructor(upperContext, label, breakContext) {\n        super(upperContext, \"ForStatement\", label, breakContext);\n\n        /**\n         * The hardcoded literal boolean test condition for\n         * the loop. Used to catch infinite or skipped loops.\n         * @type {boolean|undefined}\n         */\n        this.test = void 0;\n\n        /**\n         * The end of the init expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * an init expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.endOfInitSegments = null;\n\n        /**\n         * The start of the test expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * a test expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.testSegments = null;\n\n        /**\n         * The end of the test expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * a test expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.endOfTestSegments = null;\n\n        /**\n         * The start of the update expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * an update expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.updateSegments = null;\n\n        /**\n         * The end of the update expresion. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * an update expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.endOfUpdateSegments = null;\n\n        /**\n         * The segments representing the test condition where `continue` will\n         * jump to. The test condition will typically have just one segment but\n         * it's possible for there to be more than one. This may change during the\n         * lifetime of the instance as we traverse the loop because some loops\n         * don't have an update expression. When there is an update expression, this\n         * will end up pointing to that expression; otherwise it will end up pointing\n         * to the test expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.continueDestSegments = null;\n    }\n}\n\n/**\n * Represents the context for a `for-in` loop.\n *\n * Terminology:\n * - \"left\" means the part of the loop to the left of the `in` keyword. For\n *   example, in `for (var x in y)`, the left is `var x`.\n * - \"right\" means the part of the loop to the right of the `in` keyword. For\n *   example, in `for (var x in y)`, the right is `y`.\n */\nclass ForInLoopContext extends LoopContextBase {\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n    constructor(upperContext, label, breakContext) {\n        super(upperContext, \"ForInStatement\", label, breakContext);\n\n        /**\n         * The segments that came immediately before the start of the loop.\n         * This allows you to traverse backwards out of the loop into the\n         * surrounding code. This is necessary to evaluate the right expression\n         * correctly, as it must be evaluated in the same way as the left\n         * expression, but the pointer to these segments would otherwise be\n         * lost if not stored on the instance. Once the right expression has\n         * been evaluated, this property is no longer used.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.prevSegments = null;\n\n        /**\n         * Segments representing the start of everything to the left of the\n         * `in` keyword. This can be used to move forward towards\n         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are\n         * effectively the head and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.leftSegments = null;\n\n        /**\n         * Segments representing the end of everything to the left of the\n         * `in` keyword. This can be used to move backward towards `leftSegments`.\n         * `leftSegments` and `endOfLeftSegments` are effectively the head\n         * and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.endOfLeftSegments = null;\n\n        /**\n         * The segments representing the left expression where `continue` will\n         * jump to. In `for-in` loops, `continue` must always re-execute the\n         * left expression each time through the loop. This contains the same\n         * segments as `leftSegments`, but is duplicated here so each loop\n         * context has the same property pointing to where `continue` should\n         * end up.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.continueDestSegments = null;\n    }\n}\n\n/**\n * Represents the context for a `for-of` loop.\n */\nclass ForOfLoopContext extends LoopContextBase {\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n    constructor(upperContext, label, breakContext) {\n        super(upperContext, \"ForOfStatement\", label, breakContext);\n\n        /**\n         * The segments that came immediately before the start of the loop.\n         * This allows you to traverse backwards out of the loop into the\n         * surrounding code. This is necessary to evaluate the right expression\n         * correctly, as it must be evaluated in the same way as the left\n         * expression, but the pointer to these segments would otherwise be\n         * lost if not stored on the instance. Once the right expression has\n         * been evaluated, this property is no longer used.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.prevSegments = null;\n\n        /**\n         * Segments representing the start of everything to the left of the\n         * `of` keyword. This can be used to move forward towards\n         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are\n         * effectively the head and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.leftSegments = null;\n\n        /**\n         * Segments representing the end of everything to the left of the\n         * `of` keyword. This can be used to move backward towards `leftSegments`.\n         * `leftSegments` and `endOfLeftSegments` are effectively the head\n         * and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.endOfLeftSegments = null;\n\n        /**\n         * The segments representing the left expression where `continue` will\n         * jump to. In `for-in` loops, `continue` must always re-execute the\n         * left expression each time through the loop. This contains the same\n         * segments as `leftSegments`, but is duplicated here so each loop\n         * context has the same property pointing to where `continue` should\n         * end up.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.continueDestSegments = null;\n    }\n}\n\n/**\n * Represents the context for any loop.\n * @typedef {WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext\n */\n\n/**\n * Represents the context for a `switch` statement.\n */\nclass SwitchContext {\n\n    /**\n     * Creates a new instance.\n     * @param {SwitchContext} upperContext The previous context.\n     * @param {boolean} hasCase Indicates if there is at least one `case` statement.\n     *      `default` doesn't count.\n     */\n    constructor(upperContext, hasCase) {\n\n        /**\n         * The previous context.\n         * @type {SwitchContext}\n         */\n        this.upper = upperContext;\n\n        /**\n         * Indicates if there is at least one `case` statement. `default` doesn't count.\n         * @type {boolean}\n         */\n        this.hasCase = hasCase;\n\n        /**\n         * The `default` keyword.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.defaultSegments = null;\n\n        /**\n         * The default case body starting segments.\n         * @type {Array<CodePathSegment>|null}\n         */\n        this.defaultBodySegments = null;\n\n        /**\n         * Indicates if a `default` case and is empty exists.\n         * @type {boolean}\n         */\n        this.foundEmptyDefault = false;\n\n        /**\n         * Indicates that a `default` exists and is the last case.\n         * @type {boolean}\n         */\n        this.lastIsDefault = false;\n\n        /**\n         * The number of fork contexts created. This is equivalent to the\n         * number of `case` statements plus a `default` statement (if present).\n         * @type {number}\n         */\n        this.forkCount = 0;\n    }\n}\n\n/**\n * Represents the context for a `try` statement.\n */\nclass TryContext {\n\n    /**\n     * Creates a new instance.\n     * @param {TryContext} upperContext The previous context.\n     * @param {boolean} hasFinalizer Indicates if the `try` statement has a\n     *      `finally` block.\n     * @param {ForkContext} forkContext The enclosing fork context.\n     */\n    constructor(upperContext, hasFinalizer, forkContext) {\n\n        /**\n         * The previous context.\n         * @type {TryContext}\n         */\n        this.upper = upperContext;\n\n        /**\n         * Indicates if the `try` statement has a `finally` block.\n         * @type {boolean}\n         */\n        this.hasFinalizer = hasFinalizer;\n\n        /**\n         * Tracks the traversal position inside of the `try` statement. This is\n         * used to help determine the context necessary to create paths because\n         * a `try` statement may or may not have `catch` or `finally` blocks,\n         * and code paths behave differently in those blocks.\n         * @type {\"try\"|\"catch\"|\"finally\"}\n         */\n        this.position = \"try\";\n\n        /**\n         * If the `try` statement has a `finally` block, this affects how a\n         * `return` statement behaves in the `try` block. Without `finally`,\n         * `return` behaves as usual and doesn't require a fork; with `finally`,\n         * `return` forks into the `finally` block, so we need a fork context\n         * to track it.\n         * @type {ForkContext|null}\n         */\n        this.returnedForkContext = hasFinalizer\n            ? ForkContext.newEmpty(forkContext)\n            : null;\n\n        /**\n         * When a `throw` occurs inside of a `try` block, the code path forks\n         * into the `catch` or `finally` blocks, and this fork context tracks\n         * that path.\n         * @type {ForkContext}\n         */\n        this.thrownForkContext = ForkContext.newEmpty(forkContext);\n\n        /**\n         * Indicates if the last segment in the `try` block is reachable.\n         * @type {boolean}\n         */\n        this.lastOfTryIsReachable = false;\n\n        /**\n         * Indicates if the last segment in the `catch` block is reachable.\n         * @type {boolean}\n         */\n        this.lastOfCatchIsReachable = false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not include the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (!others.includes(segment)) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop context for a `continue` statement based on a given label.\n * @param {CodePathState} state The state to search within.\n * @param {string|null} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state The state to search within.\n * @param {string|null} label The label of a `break` statement.\n * @returns {BreakContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement. There is just one special case:\n * if there is a `try` statement with a `finally` block, because that alters\n * how `return` behaves; otherwise, this just passes through the given state.\n * @param {CodePathState} state The state to search within\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement. There is just one special case:\n * if there is a `try` statement with a `finally` block and we are inside of\n * a `catch` because that changes how `throw` behaves; otherwise, this just\n * passes through the given state.\n * @param {CodePathState} state The state to search within.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given value from a given array.\n * @param {any[]} elements An array to remove the specific element.\n * @param {any} value The value to be removed.\n * @returns {void}\n */\nfunction removeFromArray(elements, value) {\n    elements.splice(elements.indexOf(value), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction disconnectSegments(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        removeFromArray(prevSegment.nextSegments, nextSegment);\n        removeFromArray(prevSegment.allNextSegments, nextSegment);\n        removeFromArray(nextSegment.prevSegments, prevSegment);\n        removeFromArray(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path between two arrays of segments, ensuring that there are\n * paths going between matching segments in the arrays.\n * @param {CodePathState} state The state to operate on.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    /*\n     * This loop effectively updates a doubly-linked list between two collections\n     * of segments making sure that segments in the same array indices are\n     * combined to create a path.\n     */\n    for (let i = 0; i < end; ++i) {\n\n        // get the segments in matching array indices\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        /*\n         * If the destination segment is reachable, then create a path from the\n         * source segment to the destination segment.\n         */\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n\n        /*\n         * If the source segment is reachable, then create a path from the\n         * destination segment back to the source segment.\n         */\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n\n        /*\n         * Also update the arrays that don't care if the segments are reachable\n         * or not. This should always happen regardless of anything else.\n         */\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        /*\n         * If the destination segment has at least two previous segments in its\n         * path then that means there was one previous segment before this iteration\n         * of the loop was executed. So, we need to mark the source segment as\n         * looped.\n         */\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        // let the code path analyzer know that there's been a loop created\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n\n    /*\n     * If this choice context doesn't already contain paths from a\n     * child context, then add the current head to each potential path.\n     */\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n        choiceContext.nullishForkContext.add(head);\n    }\n\n    /*\n     * If the test condition isn't a hardcoded truthy value, then `break`\n     * must follow the same path as if the test condition is false. To represent\n     * that, we append the path for when the loop test is false (represented by\n     * `falseForkContext`) to the `brokenForkContext`.\n     */\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    /**\n     * Creates a new instance.\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n\n        /**\n         * The ID generator to use when creating new segments.\n         * @type {IdGenerator}\n         */\n        this.idGenerator = idGenerator;\n\n        /**\n         * A callback function to call when there is a loop.\n         * @type {Function}\n         */\n        this.notifyLooped = onLooped;\n\n        /**\n         * The root fork context for this state.\n         * @type {ForkContext}\n         */\n        this.forkContext = ForkContext.newRoot(idGenerator);\n\n        /**\n         * Context for logical expressions, conditional expressions, `if` statements,\n         * and loops.\n         * @type {ChoiceContext}\n         */\n        this.choiceContext = null;\n\n        /**\n         * Context for `switch` statements.\n         * @type {SwitchContext}\n         */\n        this.switchContext = null;\n\n        /**\n         * Context for `try` statements.\n         * @type {TryContext}\n         */\n        this.tryContext = null;\n\n        /**\n         * Context for loop statements.\n         * @type {LoopContext}\n         */\n        this.loopContext = null;\n\n        /**\n         * Context for `break` statements.\n         * @type {BreakContext}\n         */\n        this.breakContext = null;\n\n        /**\n         * Context for `ChainExpression` nodes.\n         * @type {ChainContext}\n         */\n        this.chainContext = null;\n\n        /**\n         * An array that tracks the current segments in the state. The array\n         * starts empty and segments are added with each `onCodePathSegmentStart`\n         * event and removed with each `onCodePathSegmentEnd` event. Effectively,\n         * this is tracking the code path segment traversal as the state is\n         * modified.\n         * @type {Array<CodePathSegment>}\n         */\n        this.currentSegments = [];\n\n        /**\n         * Tracks the starting segment for this path. This value never changes.\n         * @type {CodePathSegment}\n         */\n        this.initialSegment = this.forkContext.head[0];\n\n        /**\n         * The final segments of the code path which are either `return` or `throw`.\n         * This is a union of the segments in `returnedForkContext` and `thrownForkContext`.\n         * @type {Array<CodePathSegment>}\n         */\n        this.finalSegments = [];\n\n        /**\n         * The final segments of the code path which are `return`. These\n         * segments are also contained in `finalSegments`.\n         * @type {Array<CodePathSegment>}\n         */\n        this.returnedForkContext = [];\n\n        /**\n         * The final segments of the code path which are `throw`. These\n         * segments are also contained in `finalSegments`.\n         * @type {Array<CodePathSegment>}\n         */\n        this.thrownForkContext = [];\n\n        /*\n         * We add an `add` method so that these look more like fork contexts and\n         * can be used interchangeably when a fork context is needed to add more\n         * segments to a path.\n         *\n         * Ultimately, we want anything added to `returned` or `thrown` to also\n         * be added to `final`. We only add reachable and used segments to these\n         * arrays.\n         */\n        const final = this.finalSegments;\n        const returned = this.returnedForkContext;\n        const thrown = this.thrownForkContext;\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * A passthrough property exposing the current pointer as part of the API.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     * @param {boolean} forkLeavingPath A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     * @param {string} kind A kind string.\n     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult Indicates if the result of the choice\n     *      creates a fork.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = new ChoiceContext(this.choiceContext, kind, isForkingAsResult, this.forkContext);\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     * This is called upon leaving a node that represents a choice.\n     * @throws {Error} (Unreachable.)\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const poppedChoiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n        const head = forkContext.head;\n\n        this.choiceContext = poppedChoiceContext.upper;\n\n        switch (poppedChoiceContext.kind) {\n            case \"&&\":\n            case \"||\":\n            case \"??\":\n\n                /*\n                 * The `head` are the path of the right-hand operand.\n                 * If we haven't previously added segments from child contexts,\n                 * then we add these segments to all possible forks.\n                 */\n                if (!poppedChoiceContext.processed) {\n                    poppedChoiceContext.trueForkContext.add(head);\n                    poppedChoiceContext.falseForkContext.add(head);\n                    poppedChoiceContext.nullishForkContext.add(head);\n                }\n\n                /*\n                 * If this context is the left (test) expression for another choice\n                 * context, such as `a || b` in the expression `a || b || c`,\n                 * then we take the segments for this context and move them up\n                 * to the parent context.\n                 */\n                if (poppedChoiceContext.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(poppedChoiceContext.trueForkContext);\n                    parentContext.falseForkContext.addAll(poppedChoiceContext.falseForkContext);\n                    parentContext.nullishForkContext.addAll(poppedChoiceContext.nullishForkContext);\n                    parentContext.processed = true;\n\n                    // Exit early so we don't collapse all paths into one.\n                    return poppedChoiceContext;\n                }\n\n                break;\n\n            case \"test\":\n                if (!poppedChoiceContext.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    poppedChoiceContext.trueForkContext.clear();\n                    poppedChoiceContext.trueForkContext.add(head);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    poppedChoiceContext.falseForkContext.clear();\n                    poppedChoiceContext.falseForkContext.add(head);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in `popLoopContext()` so just return\n                 * the context without modification.\n                 */\n                return poppedChoiceContext;\n\n            /* c8 ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        /*\n         * Merge the true path with the false path to create a single path.\n         */\n        const combinedForkContext = poppedChoiceContext.trueForkContext;\n\n        combinedForkContext.addAll(poppedChoiceContext.falseForkContext);\n        forkContext.replaceHead(combinedForkContext.makeNext(0, -1));\n\n        return poppedChoiceContext;\n    }\n\n    /**\n     * Creates a code path segment to represent right-hand operand of a logical\n     * expression.\n     * This is called in the preprocessing phase when entering a node.\n     * @throws {Error} (Unreachable.)\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const currentChoiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (currentChoiceContext.processed) {\n\n            /*\n             * This context was already assigned segments from a child\n             * choice context. In this case, we are concerned only about\n             * the path that does not short-circuit and so ends up on the\n             * right-hand operand of the logical expression.\n             */\n            let prevForkContext;\n\n            switch (currentChoiceContext.kind) {\n                case \"&&\": // if true then go to the right-hand side.\n                    prevForkContext = currentChoiceContext.trueForkContext;\n                    break;\n                case \"||\": // if false then go to the right-hand side.\n                    prevForkContext = currentChoiceContext.falseForkContext;\n                    break;\n                case \"??\": // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's nullishForkContext.\n                    prevForkContext = currentChoiceContext.nullishForkContext;\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            /*\n             * Create the segment for the right-hand operand of the logical expression\n             * and adjust the fork context pointer to point there. The right-hand segment\n             * is added at the end of all segments in `prevForkContext`.\n             */\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n            /*\n             * We no longer need this list of segments.\n             *\n             * Reset `processed` because we've removed the segments from the child\n             * choice context. This allows `popChoiceContext()` to continue adding\n             * segments later.\n             */\n            prevForkContext.clear();\n            currentChoiceContext.processed = false;\n\n        } else {\n\n            /*\n             * This choice context was not assigned segments from a child\n             * choice context, which means that it's a terminal logical\n             * expression.\n             *\n             * `head` is the segments for the left-hand operand of the\n             * logical expression.\n             *\n             * Each of the fork contexts below are empty at this point. We choose\n             * the path(s) that will short-circuit and add the segment for the\n             * left-hand operand to it. Ultimately, this will be the only segment\n             * in that path due to the short-circuting, so we are just seeding\n             * these paths to start.\n             */\n            switch (currentChoiceContext.kind) {\n                case \"&&\":\n\n                    /*\n                     * In most contexts, when a && expression evaluates to false,\n                     * it short circuits, so we need to account for that by setting\n                     * the `falseForkContext` to the left operand.\n                     *\n                     * When a && expression is the left-hand operand for a ??\n                     * expression, such as `(a && b) ?? c`, a nullish value will\n                     * also short-circuit in a different way than a false value,\n                     * so we also set the `nullishForkContext` to the left operand.\n                     * This path is only used with a ?? expression and is thrown\n                     * away for any other type of logical expression, so it's safe\n                     * to always add.\n                     */\n                    currentChoiceContext.falseForkContext.add(forkContext.head);\n                    currentChoiceContext.nullishForkContext.add(forkContext.head);\n                    break;\n                case \"||\": // the true path can short-circuit.\n                    currentChoiceContext.trueForkContext.add(forkContext.head);\n                    break;\n                case \"??\": // both can short-circuit.\n                    currentChoiceContext.trueForkContext.add(forkContext.head);\n                    currentChoiceContext.falseForkContext.add(forkContext.head);\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            /*\n             * Create the segment for the right-hand operand of the logical expression\n             * and adjust the fork context pointer to point there.\n             */\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n            context.nullishForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // ChainExpression\n    //--------------------------------------------------------------------------\n\n    /**\n     * Pushes a new `ChainExpression` context to the stack. This method is\n     * called when entering a `ChainExpression` node. A chain context is used to\n     * count forking in the optional chain then merge them on the exiting from the\n     * `ChainExpression` node.\n     * @returns {void}\n     */\n    pushChainContext() {\n        this.chainContext = new ChainContext(this.chainContext);\n    }\n\n    /**\n     * Pop a `ChainExpression` context from the stack. This method is called on\n     * exiting from each `ChainExpression` node. This merges all forks of the\n     * last optional chaining.\n     * @returns {void}\n     */\n    popChainContext() {\n        const context = this.chainContext;\n\n        this.chainContext = context.upper;\n\n        // pop all choice contexts of this.\n        for (let i = context.choiceContextCount; i > 0; --i) {\n            this.popChoiceContext();\n        }\n    }\n\n    /**\n     * Create a choice context for optional access.\n     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n     * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n     * @returns {void}\n     */\n    makeOptionalNode() {\n        if (this.chainContext) {\n            this.chainContext.choiceContextCount += 1;\n            this.pushChoiceContext(\"??\", false);\n        }\n    }\n\n    /**\n     * Create a fork.\n     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n     * @returns {void}\n     */\n    makeOptionalRight() {\n        if (this.chainContext) {\n            this.makeLogicalRight();\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     * @param {boolean} hasCase `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = new SwitchContext(this.switchContext, hasCase);\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.forkCount === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * Any value that doesn't match a `case` test should flow to the default\n         * case. That happens normally when the default case is last in the `switch`,\n         * but if it's not, we need to rewire some of the paths to be correct.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * There is a non-empty default case, so remove the path from the `default`\n                 * label to its body for an accurate representation.\n                 */\n                disconnectSegments(context.defaultSegments, context.defaultBodySegments);\n\n                /*\n                 * Connect the path from the last non-default case to the body of the\n                 * default case.\n                 */\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n\n            } else {\n\n                /*\n                 * There is no default case, so we treat this as if the last case\n                 * had a `break` in it.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Traverse up to the original fork context for the `switch` statement\n        for (let i = 0; i < context.forkCount; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all `brokenForkContext` paths.\n         * This is a path after `switch` statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     * @param {boolean} isCaseBodyEmpty `true` if the body is empty.\n     * @param {boolean} isDefaultCase `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isCaseBodyEmpty, isDefaultCase) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current `case` and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Add information about the default case.\n         *\n         * The purpose of this is to identify the starting segments for the\n         * default case to make sure there is a path there.\n         */\n        if (isDefaultCase) {\n\n            /*\n             * This is the default case in the `switch`.\n             *\n             * We first save the current pointer as `defaultSegments` to point\n             * to the `default` keyword.\n             */\n            context.defaultSegments = parentForkContext.head;\n\n            /*\n             * If the body of the case is empty then we just set\n             * `foundEmptyDefault` to true; otherwise, we save a reference\n             * to the current pointer as `defaultBodySegments`.\n             */\n            if (isCaseBodyEmpty) {\n                context.foundEmptyDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n\n        } else {\n\n            /*\n             * This is not the default case in the `switch`.\n             *\n             * If it's not empty and there is already an empty default case found,\n             * that means the default case actually comes before this case,\n             * and that it will fall through to this case. So, we can now\n             * ignore the previous default case (reset `foundEmptyDefault` to false)\n             * and set `defaultBodySegments` to the current segments because this is\n             * effectively the new default case.\n             */\n            if (!isCaseBodyEmpty && context.foundEmptyDefault) {\n                context.foundEmptyDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        // keep track if the default case ends up last\n        context.lastIsDefault = isDefaultCase;\n        context.forkCount += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     * @param {boolean} hasFinalizer `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = new TryContext(this.tryContext, hasFinalizer, this.forkContext);\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        /*\n         * If we're inside the `catch` block, that means there is no `finally`,\n         * so we can process the `try` and `catch` blocks the simple way and\n         * merge their two paths.\n         */\n        if (context.position === \"catch\") {\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is a `finally`\n         * block.\n         */\n\n        const originalReturnedForkContext = context.returnedForkContext;\n        const originalThrownForkContext = context.thrownForkContext;\n\n        // no `return` or `throw` in `try` or `catch` so there's nothing left to do\n        if (originalReturnedForkContext.empty && originalThrownForkContext.empty) {\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is a `finally`\n         * block and there was a `return` or `throw` in the `try` or `catch`\n         * blocks.\n         */\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!originalReturnedForkContext.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!originalThrownForkContext.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const originalThrownForkContext = context.thrownForkContext;\n\n        /*\n         * We are now in a catch block so we need to update the context\n         * with that information. This includes creating a new fork\n         * context in case we encounter any `throw` statements here.\n         */\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge the thrown paths from the `try` and `catch` blocks\n        originalThrownForkContext.add(forkContext.head);\n        const thrownSegments = originalThrownForkContext.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const originalReturnedForkContext = context.returnedForkContext;\n        const originalThrownForContext = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n\n\n        context.position = \"finally\";\n\n        /*\n         * If there was no `return` or `throw` in either the `try` or `catch`\n         * blocks, then there's no further code paths to create for `finally`.\n         */\n        if (originalReturnedForkContext.empty && originalThrownForContext.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this `finally` block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (let j = 0; j < originalReturnedForkContext.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(originalReturnedForkContext.segmentsList[j][i]);\n            }\n            for (let j = 0; j < originalThrownForContext.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(originalThrownForContext.segmentsList[j][i]);\n            }\n\n            segments.push(\n                CodePathSegment.newNext(\n                    this.idGenerator.next(),\n                    prevSegsOfLeavingSegment\n                )\n            );\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     * @param {string} type The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label A label of the node which was triggered.\n     * @throws {Error} (Unreachable - unknown type.)\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n\n        // All loops need a path to account for `break` statements\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = new WhileLoopContext(this.loopContext, label, breakContext);\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = new DoWhileLoopContext(this.loopContext, label, breakContext, forkContext);\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = new ForLoopContext(this.loopContext, label, breakContext);\n                break;\n\n            case \"ForInStatement\":\n                this.loopContext = new ForInLoopContext(this.loopContext, label, breakContext);\n                break;\n\n            case \"ForOfStatement\":\n                this.loopContext = new ForOfLoopContext(this.loopContext, label, breakContext);\n                break;\n\n            /* c8 ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     * @throws {Error} (Unreachable - unknown type.)\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                this.popChoiceContext();\n\n                /*\n                 * Creates the path from the end of the loop body up to the\n                 * location where `continue` would jump to.\n                 */\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments\n                );\n                break;\n\n            case \"DoWhileStatement\": {\n                const choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n\n                /*\n                 * If this isn't a hardcoded `true` condition, then `break`\n                 * should continue down the path as if the condition evaluated\n                 * to false.\n                 */\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                /*\n                 * When the condition is true, the loop continues back to the top,\n                 * so create a path from each possible true condition back to the\n                 * top of the loop.\n                 */\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments\n                    );\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n\n                /*\n                 * Creates the path from the end of the loop body up to the\n                 * left expression (left of `in` or `of`) of the loop.\n                 */\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments\n                );\n                break;\n\n            /* c8 ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        /*\n         * If there wasn't a `break` statement in the loop, then we're at\n         * the end of the loop's path, so we make an unreachable segment\n         * to mark that.\n         *\n         * If there was a `break` statement, then we continue on into the\n         * `brokenForkContext`.\n         */\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        /*\n         * If this isn't a hardcoded `true` condition, then `break`\n         * should continue down the path as if the condition evaluated\n         * to false.\n         */\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        /*\n         * If there is a `continue` statement in the loop then `continueForkContext`\n         * won't be empty. We wire up the path from `continue` to the loop\n         * test condition and then continue the traversal in the root fork context.\n         */\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        /*\n         * Update the state.\n         *\n         * The `continueDestSegments` are set to `testSegments` because we\n         * don't yet know if there is an update expression in this loop. So,\n         * from what we already know at this point, a `continue` statement\n         * will jump back to the test expression.\n         */\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        /*\n         * Update the state.\n         *\n         * The `continueDestSegments` are now set to `updateSegments` because we\n         * know there is an update expression in this loop. So, a `continue` statement\n         * in the loop will jump to the update expression first, and then to any\n         * test expression the loop might have.\n         */\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * Determine what to do based on which part of the `for` loop are present.\n         * 1. If there is an update expression, then `updateSegments` is not null and\n         *    we need to assign `endOfUpdateSegments`, and if there is a test\n         *    expression, we then need to create the looped path to get back to\n         *    the test condition.\n         * 2. If there is no update expression but there is a test expression,\n         *    then we only need to update the test segment information.\n         * 3. If there is no update expression and no test expression, then we\n         *    just save `endOfInitSegments`.\n         */\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            /*\n             * In a `for` loop that has both an update expression and a test\n             * condition, execution flows from the test expression into the\n             * loop body, to the update expression, and then back to the test\n             * expression to determine if the loop should continue.\n             *\n             * To account for that, we need to make a path from the end of the\n             * update expression to the start of the test expression. This is\n             * effectively what creates the loop in the code path.\n             */\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments\n                );\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        /*\n         * If there is a test condition, then there `endOfTestSegments` is also\n         * the start of the loop body. If there isn't a test condition then\n         * `bodySegments` will be null and we need to look elsewhere to find\n         * the start of the body.\n         *\n         * The body starts at the end of the init expression and ends at the end\n         * of the update expression, so we use those locations to determine the\n         * body segments.\n         */\n        if (!bodySegments) {\n\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n\n        /*\n         * If there was no test condition and no update expression, then\n         * `continueDestSegments` will be null. In that case, a\n         * `continue` should skip directly to the body of the loop.\n         * Otherwise, we want to keep the current `continueDestSegments`.\n         */\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n\n        // move pointer to the body\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context in which a `break` statement can be used. This occurs inside of a loop,\n     * labeled statement, or switch statement.\n     * @param {boolean} breakable Indicates if we are inside a statement where\n     *      `break` without a label will exit the statement.\n     * @param {string|null} label The label associated with the statement.\n     * @returns {BreakContext} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = new BreakContext(this.breakContext, breakable, label, this.forkContext);\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string|null} label A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        /* c8 ignore next */\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string|null} label A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this affects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,qBAAqB,CAAC;EAClDC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,YAAY,CAAC;EAEf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAACC,YAAY,EAAEC,SAAS,EAAEC,KAAK,EAAEC,WAAW,EAAE;IAErD;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAGJ,YAAY;;IAEzB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAGA,SAAS;;IAE1B;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAGA,KAAK;;IAElB;AACR;AACA;AACA;IACQ,IAAI,CAACG,iBAAiB,GAAGR,WAAW,CAACS,QAAQ,CAACH,WAAW,CAAC;EAC9D;AACJ;;AAEA;AACA;AACA;AACA,MAAMI,YAAY,CAAC;EAEf;AACJ;AACA;AACA;EACIR,WAAWA,CAACC,YAAY,EAAE;IAEtB;AACR;AACA;AACA;IACQ,IAAI,CAACI,KAAK,GAAGJ,YAAY;;IAEzB;AACR;AACA;AACA;IACQ,IAAI,CAACQ,kBAAkB,GAAG,CAAC;EAE/B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,CAAC;EAEhB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIV,WAAWA,CAACC,YAAY,EAAEU,IAAI,EAAEC,iBAAiB,EAAER,WAAW,EAAE;IAE5D;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAGJ,YAAY;;IAEzB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACU,IAAI,GAAGA,IAAI;;I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K,EAAEgB,YAAY,CAAC;;IAE1D;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACc,YAAY,GAAG,IAAI;;IAExB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAI;;IAExB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAI;;IAE7B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACb,oBAAoB,GAAG,IAAI;EACpC;AACJ;;AAEA;AACA;AACA;AACA,MAAMc,gBAAgB,SAASnB,eAAe,CAAC;EAE3C;AACJ;AACA;AACA;AACA;AACA;EACIjB,WAAWA,CAACC,YAAY,EAAEE,KAAK,EAAEgB,YAAY,EAAE;IAC3C,KAAK,CAAClB,YAAY,EAAE,gBAAgB,EAAEE,KAAK,EAAEgB,YAAY,CAAC;;IAE1D;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACc,YAAY,GAAG,IAAI;;IAExB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAI;;IAExB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAI;;IAE7B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACb,oBAAoB,GAAG,IAAI;EACpC;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMe,aAAa,CAAC;EAEhB;AACJ;AACA;AACA;AACA;AACA;EACIrC,WAAWA,CAACC,YAAY,EAAEqC,OAAO,EAAE;IAE/B;AACR;AACA;AACA;IACQ,IAAI,CAACjC,KAAK,GAAGJ,YAAY;;IAEzB;AACR;AACA;AACA;IACQ,IAAI,CAACqC,OAAO,GAAGA,OAAO;;IAEtB;AACR;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,IAAI;;IAE3B;AACR;AACA;AACA;IACQ,IAAI,CAACC,mBAAmB,GAAG,IAAI;;IAE/B;AACR;A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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}