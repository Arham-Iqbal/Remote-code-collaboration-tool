{"ast":null,"code":"/**\n * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit\n * @author Jordan Eldredge <https://jordaneldredge.com>\n */\n\n\"use strict\";\n\nconst globals = require(\"globals\");\nconst {\n  isNullLiteral,\n  isConstant,\n  isReferenceToGlobalVariable,\n  isLogicalAssignmentOperator\n} = require(\"./utils/ast-utils\");\nconst NUMERIC_OR_STRING_BINARY_OPERATORS = new Set([\"+\", \"-\", \"*\", \"/\", \"%\", \"|\", \"^\", \"&\", \"**\", \"<<\", \">>\", \">>>\"]);\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is `null` or `undefined`. Similar to the one\n * found in ast-utils.js, but this one correctly handles the edge case that\n * `undefined` has been redefined.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(scope, node) {\n  return isNullLiteral(node) || node.type === \"Identifier\" && node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node) || node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Test if an AST node has a statically knowable constant nullishness. Meaning,\n * it will always resolve to a constant value of either: `null`, `undefined`\n * or not `null` _or_ `undefined`. An expression that can vary between those\n * three states at runtime would return `false`.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The AST node being tested.\n * @param {boolean} nonNullish if `true` then nullish values are not considered constant.\n * @returns {boolean} Does `node` have constant nullishness?\n */\nfunction hasConstantNullishness(scope, node, nonNullish) {\n  if (nonNullish && isNullOrUndefined(scope, node)) {\n    return false;\n  }\n  switch (node.type) {\n    case \"ObjectExpression\": // Objects are never nullish\n    case \"ArrayExpression\": // Arrays are never nullish\n    case \"ArrowFunctionExpression\": // Functions never nullish\n    case \"FunctionExpression\": // Functions are never nullish\n    case \"ClassExpression\": // Classes are never nullish\n    case \"NewExpression\": // Objects are never nullish\n    case \"Literal\": // Nullish, or non-nullish, literals never change\n    case \"TemplateLiteral\": // A string is never nullish\n    case \"UpdateExpression\": // Numbers are never nullish\n    case \"BinaryExpression\":\n      // Numbers, strings, or booleans are never nullish\n      return true;\n    case \"CallExpression\":\n      {\n        if (node.callee.type !== \"Identifier\") {\n          return false;\n        }\n        const functionName = node.callee.name;\n        return (functionName === \"Boolean\" || functionName === \"String\" || functionName === \"Number\") && isReferenceToGlobalVariable(scope, node.callee);\n      }\n    case \"LogicalExpression\":\n      {\n        return node.operator === \"??\" && hasConstantNullishness(scope, node.right, true);\n      }\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return hasConstantNullishness(scope, node.right, nonNullish);\n      }\n\n      /*\n       * Handling short-circuiting assignment operators would require\n       * walking the scope. We won't attempt that (for now...) /\n       */\n      if (isLogicalAssignmentOperator(node.operator)) {\n        return false;\n      }\n\n      /*\n       * The remaining assignment expressions all result in a numeric or\n       * string (non-nullish) value:\n       *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n       */\n\n      return true;\n    case \"UnaryExpression\":\n      /*\n       * \"void\" Always returns `undefined`\n       * \"typeof\" All types are strings, and thus non-nullish\n       * \"!\" Boolean is never nullish\n       * \"delete\" Returns a boolean, which is never nullish\n       * Math operators always return numbers or strings, neither of which\n       * are non-nullish \"+\", \"-\", \"~\"\n       */\n\n      return true;\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return hasConstantNullishness(scope, last, nonNullish);\n      }\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n    case \"JSXFragment\":\n      return false;\n    default:\n      return false;\n  }\n}\n\n/**\n * Test if an AST node is a boolean value that never changes. Specifically we\n * test for:\n * 1. Literal booleans (`true` or `false`)\n * 2. Unary `!` expressions with a constant value\n * 3. Constant booleans created via the `Boolean` global function\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Is `node` guaranteed to be a boolean?\n */\nfunction isStaticBoolean(scope, node) {\n  switch (node.type) {\n    case \"Literal\":\n      return typeof node.value === \"boolean\";\n    case \"CallExpression\":\n      return node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee) && (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n    case \"UnaryExpression\":\n      return node.operator === \"!\" && isConstant(scope, node.argument, true);\n    default:\n      return false;\n  }\n}\n\n/**\n * Test if an AST node will always give the same result when compared to a\n * boolean value. Note that comparison to boolean values is different than\n * truthiness.\n * https://262.ecma-international.org/5.1/#sec-11.9.3\n *\n * Javascript `==` operator works by converting the boolean to `1` (true) or\n * `+0` (false) and then checks the values `==` equality to that number.\n * @param {Scope} scope The scope in which node was found.\n * @param {ASTNode} node The node to test.\n * @returns {boolean} Will `node` always coerce to the same boolean value?\n */\nfunction hasConstantLooseBooleanComparison(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n    case \"ClassExpression\":\n      /**\n       * In theory objects like:\n       *\n       * `{toString: () => a}`\n       * `{valueOf: () => a}`\n       *\n       * Or a classes like:\n       *\n       * `class { static toString() { return a } }`\n       * `class { static valueOf() { return a } }`\n       *\n       * Are not constant verifiably when `inBooleanPosition` is\n       * false, but it's an edge case we've opted not to handle.\n       */\n      return true;\n    case \"ArrayExpression\":\n      {\n        const nonSpreadElements = node.elements.filter(e =>\n        // Elements can be `null` in sparse arrays: `[,,]`;\n        e !== null && e.type !== \"SpreadElement\");\n\n        /*\n         * Possible future direction if needed: We could check if the\n         * single value would result in variable boolean comparison.\n         * For now we will err on the side of caution since `[x]` could\n         * evaluate to `[0]` or `[1]`.\n         */\n        return node.elements.length === 0 || nonSpreadElements.length > 1;\n      }\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n      return true;\n    case \"UnaryExpression\":\n      if (node.operator === \"void\" ||\n      // Always returns `undefined`\n      node.operator === \"typeof\" // All `typeof` strings, when coerced to number, are not 0 or 1.\n      ) {\n        return true;\n      }\n      if (node.operator === \"!\") {\n        return isConstant(scope, node.argument, true);\n      }\n\n      /*\n       * We won't try to reason about +, -, ~, or delete\n       * In theory, for the mathematical operators, we could look at the\n       * argument and try to determine if it coerces to a constant numeric\n       * value.\n       */\n      return false;\n    case \"NewExpression\":\n      // Objects might have custom `.valueOf` or `.toString`.\n      return false;\n    case \"CallExpression\":\n      {\n        if (node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n          return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n        }\n        return false;\n      }\n    case \"Literal\":\n      // True or false, literals never change\n      return true;\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n    case \"TemplateLiteral\":\n      /*\n       * In theory we could try to check if the quasi are sufficient to\n       * prove that the expression will always be true, but it would be\n       * tricky to get right. For example: `000.${foo}000`\n       */\n      return node.expressions.length === 0;\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return hasConstantLooseBooleanComparison(scope, node.right);\n      }\n\n      /*\n       * Handling short-circuiting assignment operators would require\n       * walking the scope. We won't attempt that (for now...)\n       *\n       * The remaining assignment expressions all result in a numeric or\n       * string (non-nullish) values which could be truthy or falsy:\n       *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n       */\n      return false;\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return hasConstantLooseBooleanComparison(scope, last);\n      }\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n    case \"JSXFragment\":\n      return false;\n    default:\n      return false;\n  }\n}\n\n/**\n * Test if an AST node will always give the same result when _strictly_ compared\n * to a boolean value. This can happen if the expression can never be boolean, or\n * if it is always the same boolean value.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always give the same result when compared to a\n * static boolean value?\n */\nfunction hasConstantStrictBooleanComparison(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\": // Objects are not booleans\n    case \"ArrayExpression\": // Arrays are not booleans\n    case \"ArrowFunctionExpression\": // Functions are not booleans\n    case \"FunctionExpression\":\n    case \"ClassExpression\": // Classes are not booleans\n    case \"NewExpression\": // Objects are not booleans\n    case \"TemplateLiteral\": // Strings are not booleans\n    case \"Literal\": // True, false, or not boolean, literals never change.\n    case \"UpdateExpression\":\n      // Numbers are not booleans\n      return true;\n    case \"BinaryExpression\":\n      return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);\n    case \"UnaryExpression\":\n      {\n        if (node.operator === \"delete\") {\n          return false;\n        }\n        if (node.operator === \"!\") {\n          return isConstant(scope, node.argument, true);\n        }\n\n        /*\n         * The remaining operators return either strings or numbers, neither\n         * of which are boolean.\n         */\n        return true;\n      }\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return hasConstantStrictBooleanComparison(scope, last);\n      }\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return hasConstantStrictBooleanComparison(scope, node.right);\n      }\n\n      /*\n       * Handling short-circuiting assignment operators would require\n       * walking the scope. We won't attempt that (for now...)\n       */\n      if (isLogicalAssignmentOperator(node.operator)) {\n        return false;\n      }\n\n      /*\n       * The remaining assignment expressions all result in either a number\n       * or a string, neither of which can ever be boolean.\n       */\n      return true;\n    case \"CallExpression\":\n      {\n        if (node.callee.type !== \"Identifier\") {\n          return false;\n        }\n        const functionName = node.callee.name;\n        if ((functionName === \"String\" || functionName === \"Number\") && isReferenceToGlobalVariable(scope, node.callee)) {\n          return true;\n        }\n        if (functionName === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n          return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n        }\n        return false;\n      }\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n    case \"JSXFragment\":\n      return false;\n    default:\n      return false;\n  }\n}\n\n/**\n * Test if an AST node will always result in a newly constructed object\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always be new?\n */\nfunction isAlwaysNew(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n    case \"ArrayExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n      return true;\n    case \"NewExpression\":\n      {\n        if (node.callee.type !== \"Identifier\") {\n          return false;\n        }\n\n        /*\n         * All the built-in constructors are always new, but\n         * user-defined constructors could return a sentinel\n         * object.\n         *\n         * Catching these is especially useful for primitive constructors\n         * which return boxed values, a surprising gotcha' in JavaScript.\n         */\n        return Object.hasOwnProperty.call(globals.builtin, node.callee.name) && isReferenceToGlobalVariable(scope, node.callee);\n      }\n    case \"Literal\":\n      // Regular expressions are objects, and thus always new\n      return typeof node.regex === \"object\";\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return isAlwaysNew(scope, last);\n      }\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return isAlwaysNew(scope, node.right);\n      }\n      return false;\n    case \"ConditionalExpression\":\n      return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n    case \"JSXFragment\":\n      return false;\n    default:\n      return false;\n  }\n}\n\n/**\n * Checks if one operand will cause the result to be constant.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} a One side of the expression\n * @param {ASTNode} b The other side of the expression\n * @param {string} operator The binary expression operator\n * @returns {ASTNode | null} The node which will cause the expression to have a constant result.\n */\nfunction findBinaryExpressionConstantOperand(scope, a, b, operator) {\n  if (operator === \"==\" || operator === \"!=\") {\n    if (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false) || isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b)) {\n      return b;\n    }\n  } else if (operator === \"===\" || operator === \"!==\") {\n    if (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false) || isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b)) {\n      return b;\n    }\n  }\n  return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow expressions where the operation doesn't affect the value\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-constant-binary-expression\"\n    },\n    schema: [],\n    messages: {\n      constantBinaryOperand: \"Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.\",\n      constantShortCircuit: \"Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.\",\n      alwaysNew: \"Unexpected comparison to newly constructed object. These two values can never be equal.\",\n      bothAlwaysNew: \"Unexpected comparison of two newly constructed objects. These two values can never be equal.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n    return {\n      LogicalExpression(node) {\n        const {\n          operator,\n          left\n        } = node;\n        const scope = sourceCode.getScope(node);\n        if ((operator === \"&&\" || operator === \"||\") && isConstant(scope, left, true)) {\n          context.report({\n            node: left,\n            messageId: \"constantShortCircuit\",\n            data: {\n              property: \"truthiness\",\n              operator\n            }\n          });\n        } else if (operator === \"??\" && hasConstantNullishness(scope, left, false)) {\n          context.report({\n            node: left,\n            messageId: \"constantShortCircuit\",\n            data: {\n              property: \"nullishness\",\n              operator\n            }\n          });\n        }\n      },\n      BinaryExpression(node) {\n        const scope = sourceCode.getScope(node);\n        const {\n          right,\n          left,\n          operator\n        } = node;\n        const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);\n        const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);\n        if (rightConstantOperand) {\n          context.report({\n            node: rightConstantOperand,\n            messageId: \"constantBinaryOperand\",\n            data: {\n              operator,\n              otherSide: \"left\"\n            }\n          });\n        } else if (leftConstantOperand) {\n          context.report({\n            node: leftConstantOperand,\n            messageId: \"constantBinaryOperand\",\n            data: {\n              operator,\n              otherSide: \"right\"\n            }\n          });\n        } else if (operator === \"===\" || operator === \"!==\") {\n          if (isAlwaysNew(scope, left)) {\n            context.report({\n              node: left,\n              messageId: \"alwaysNew\"\n            });\n          } else if (isAlwaysNew(scope, right)) {\n            context.report({\n              node: right,\n              messageId: \"alwaysNew\"\n            });\n          }\n        } else if (operator === \"==\" || operator === \"!=\") {\n          /*\n           * If both sides are \"new\", then both sides are objects and\n           * therefore they will be compared by reference even with `==`\n           * equality.\n           */\n          if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {\n            context.report({\n              node: left,\n              messageId: \"bothAlwaysNew\"\n            });\n          }\n        }\n      }\n\n      /*\n       * In theory we could handle short-circuiting assignment operators,\n       * for some constant values, but that would require walking the\n       * scope to find the value of the variable being assigned. This is\n       * dependant on https://github.com/eslint/eslint/issues/13776\n       *\n       * AssignmentExpression() {},\n       */\n    };\n  }\n};","map":{"version":3,"names":["globals","require","isNullLiteral","isConstant","isReferenceToGlobalVariable","isLogicalAssignmentOperator","NUMERIC_OR_STRING_BINARY_OPERATORS","Set","isNullOrUndefined","scope","node","type","name","operator","hasConstantNullishness","nonNullish","callee","functionName","right","last","expressions","length","isStaticBoolean","value","arguments","argument","hasConstantLooseBooleanComparison","nonSpreadElements","elements","filter","e","hasConstantStrictBooleanComparison","has","isAlwaysNew","Object","hasOwnProperty","call","builtin","regex","consequent","alternate","findBinaryExpressionConstantOperand","a","b","module","exports","meta","docs","description","recommended","url","schema","messages","constantBinaryOperand","constantShortCircuit","alwaysNew","bothAlwaysNew","create","context","sourceCode","LogicalExpression","left","getScope","report","messageId","data","property","BinaryExpression","rightConstantOperand","leftConstantOperand","otherSide"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-constant-binary-expression.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit\n * @author Jordan Eldredge <https://jordaneldredge.com>\n */\n\n\"use strict\";\n\nconst globals = require(\"globals\");\nconst { isNullLiteral, isConstant, isReferenceToGlobalVariable, isLogicalAssignmentOperator } = require(\"./utils/ast-utils\");\n\nconst NUMERIC_OR_STRING_BINARY_OPERATORS = new Set([\"+\", \"-\", \"*\", \"/\", \"%\", \"|\", \"^\", \"&\", \"**\", \"<<\", \">>\", \">>>\"]);\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is `null` or `undefined`. Similar to the one\n * found in ast-utils.js, but this one correctly handles the edge case that\n * `undefined` has been redefined.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(scope, node) {\n    return (\n        isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node)) ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Test if an AST node has a statically knowable constant nullishness. Meaning,\n * it will always resolve to a constant value of either: `null`, `undefined`\n * or not `null` _or_ `undefined`. An expression that can vary between those\n * three states at runtime would return `false`.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The AST node being tested.\n * @param {boolean} nonNullish if `true` then nullish values are not considered constant.\n * @returns {boolean} Does `node` have constant nullishness?\n */\nfunction hasConstantNullishness(scope, node, nonNullish) {\n    if (nonNullish && isNullOrUndefined(scope, node)) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ObjectExpression\": // Objects are never nullish\n        case \"ArrayExpression\": // Arrays are never nullish\n        case \"ArrowFunctionExpression\": // Functions never nullish\n        case \"FunctionExpression\": // Functions are never nullish\n        case \"ClassExpression\": // Classes are never nullish\n        case \"NewExpression\": // Objects are never nullish\n        case \"Literal\": // Nullish, or non-nullish, literals never change\n        case \"TemplateLiteral\": // A string is never nullish\n        case \"UpdateExpression\": // Numbers are never nullish\n        case \"BinaryExpression\": // Numbers, strings, or booleans are never nullish\n            return true;\n        case \"CallExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n            const functionName = node.callee.name;\n\n            return (functionName === \"Boolean\" || functionName === \"String\" || functionName === \"Number\") &&\n                isReferenceToGlobalVariable(scope, node.callee);\n        }\n        case \"LogicalExpression\": {\n            return node.operator === \"??\" && hasConstantNullishness(scope, node.right, true);\n        }\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantNullishness(scope, node.right, nonNullish);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...) /\n             */\n            if (isLogicalAssignmentOperator(node.operator)) {\n                return false;\n            }\n\n            /*\n             * The remaining assignment expressions all result in a numeric or\n             * string (non-nullish) value:\n             *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n             */\n\n            return true;\n        case \"UnaryExpression\":\n\n            /*\n             * \"void\" Always returns `undefined`\n             * \"typeof\" All types are strings, and thus non-nullish\n             * \"!\" Boolean is never nullish\n             * \"delete\" Returns a boolean, which is never nullish\n             * Math operators always return numbers or strings, neither of which\n             * are non-nullish \"+\", \"-\", \"~\"\n             */\n\n            return true;\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return hasConstantNullishness(scope, last, nonNullish);\n        }\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Test if an AST node is a boolean value that never changes. Specifically we\n * test for:\n * 1. Literal booleans (`true` or `false`)\n * 2. Unary `!` expressions with a constant value\n * 3. Constant booleans created via the `Boolean` global function\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Is `node` guaranteed to be a boolean?\n */\nfunction isStaticBoolean(scope, node) {\n    switch (node.type) {\n        case \"Literal\":\n            return typeof node.value === \"boolean\";\n        case \"CallExpression\":\n            return node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" &&\n              isReferenceToGlobalVariable(scope, node.callee) &&\n              (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n        case \"UnaryExpression\":\n            return node.operator === \"!\" && isConstant(scope, node.argument, true);\n        default:\n            return false;\n    }\n}\n\n\n/**\n * Test if an AST node will always give the same result when compared to a\n * boolean value. Note that comparison to boolean values is different than\n * truthiness.\n * https://262.ecma-international.org/5.1/#sec-11.9.3\n *\n * Javascript `==` operator works by converting the boolean to `1` (true) or\n * `+0` (false) and then checks the values `==` equality to that number.\n * @param {Scope} scope The scope in which node was found.\n * @param {ASTNode} node The node to test.\n * @returns {boolean} Will `node` always coerce to the same boolean value?\n */\nfunction hasConstantLooseBooleanComparison(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ClassExpression\":\n\n            /**\n             * In theory objects like:\n             *\n             * `{toString: () => a}`\n             * `{valueOf: () => a}`\n             *\n             * Or a classes like:\n             *\n             * `class { static toString() { return a } }`\n             * `class { static valueOf() { return a } }`\n             *\n             * Are not constant verifiably when `inBooleanPosition` is\n             * false, but it's an edge case we've opted not to handle.\n             */\n            return true;\n        case \"ArrayExpression\": {\n            const nonSpreadElements = node.elements.filter(e =>\n\n                // Elements can be `null` in sparse arrays: `[,,]`;\n                e !== null && e.type !== \"SpreadElement\");\n\n\n            /*\n             * Possible future direction if needed: We could check if the\n             * single value would result in variable boolean comparison.\n             * For now we will err on the side of caution since `[x]` could\n             * evaluate to `[0]` or `[1]`.\n             */\n            return node.elements.length === 0 || nonSpreadElements.length > 1;\n        }\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n            return true;\n        case \"UnaryExpression\":\n            if (node.operator === \"void\" || // Always returns `undefined`\n                node.operator === \"typeof\" // All `typeof` strings, when coerced to number, are not 0 or 1.\n            ) {\n                return true;\n            }\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            /*\n             * We won't try to reason about +, -, ~, or delete\n             * In theory, for the mathematical operators, we could look at the\n             * argument and try to determine if it coerces to a constant numeric\n             * value.\n             */\n            return false;\n        case \"NewExpression\": // Objects might have custom `.valueOf` or `.toString`.\n            return false;\n        case \"CallExpression\": {\n            if (node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Boolean\" &&\n                isReferenceToGlobalVariable(scope, node.callee)\n            ) {\n                return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n            }\n            return false;\n        }\n        case \"Literal\": // True or false, literals never change\n            return true;\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"TemplateLiteral\":\n\n            /*\n             * In theory we could try to check if the quasi are sufficient to\n             * prove that the expression will always be true, but it would be\n             * tricky to get right. For example: `000.${foo}000`\n             */\n            return node.expressions.length === 0;\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantLooseBooleanComparison(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...)\n             *\n             * The remaining assignment expressions all result in a numeric or\n             * string (non-nullish) values which could be truthy or falsy:\n             *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n             */\n            return false;\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return hasConstantLooseBooleanComparison(scope, last);\n        }\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n\n/**\n * Test if an AST node will always give the same result when _strictly_ compared\n * to a boolean value. This can happen if the expression can never be boolean, or\n * if it is always the same boolean value.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always give the same result when compared to a\n * static boolean value?\n */\nfunction hasConstantStrictBooleanComparison(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\": // Objects are not booleans\n        case \"ArrayExpression\": // Arrays are not booleans\n        case \"ArrowFunctionExpression\": // Functions are not booleans\n        case \"FunctionExpression\":\n        case \"ClassExpression\": // Classes are not booleans\n        case \"NewExpression\": // Objects are not booleans\n        case \"TemplateLiteral\": // Strings are not booleans\n        case \"Literal\": // True, false, or not boolean, literals never change.\n        case \"UpdateExpression\": // Numbers are not booleans\n            return true;\n        case \"BinaryExpression\":\n            return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);\n        case \"UnaryExpression\": {\n            if (node.operator === \"delete\") {\n                return false;\n            }\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            /*\n             * The remaining operators return either strings or numbers, neither\n             * of which are boolean.\n             */\n            return true;\n        }\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return hasConstantStrictBooleanComparison(scope, last);\n        }\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantStrictBooleanComparison(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...)\n             */\n            if (isLogicalAssignmentOperator(node.operator)) {\n                return false;\n            }\n\n            /*\n             * The remaining assignment expressions all result in either a number\n             * or a string, neither of which can ever be boolean.\n             */\n            return true;\n        case \"CallExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n            const functionName = node.callee.name;\n\n            if (\n                (functionName === \"String\" || functionName === \"Number\") &&\n                isReferenceToGlobalVariable(scope, node.callee)\n            ) {\n                return true;\n            }\n            if (functionName === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n                return (\n                    node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n            }\n            return false;\n        }\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Test if an AST node will always result in a newly constructed object\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always be new?\n */\nfunction isAlwaysNew(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n        case \"ClassExpression\":\n            return true;\n        case \"NewExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n\n            /*\n             * All the built-in constructors are always new, but\n             * user-defined constructors could return a sentinel\n             * object.\n             *\n             * Catching these is especially useful for primitive constructors\n             * which return boxed values, a surprising gotcha' in JavaScript.\n             */\n            return Object.hasOwnProperty.call(globals.builtin, node.callee.name) &&\n              isReferenceToGlobalVariable(scope, node.callee);\n        }\n        case \"Literal\":\n\n            // Regular expressions are objects, and thus always new\n            return typeof node.regex === \"object\";\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return isAlwaysNew(scope, last);\n        }\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return isAlwaysNew(scope, node.right);\n            }\n            return false;\n        case \"ConditionalExpression\":\n            return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks if one operand will cause the result to be constant.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} a One side of the expression\n * @param {ASTNode} b The other side of the expression\n * @param {string} operator The binary expression operator\n * @returns {ASTNode | null} The node which will cause the expression to have a constant result.\n */\nfunction findBinaryExpressionConstantOperand(scope, a, b, operator) {\n    if (operator === \"==\" || operator === \"!=\") {\n        if (\n            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false)) ||\n            (isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b))\n        ) {\n            return b;\n        }\n    } else if (operator === \"===\" || operator === \"!==\") {\n        if (\n            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false)) ||\n            (isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b))\n        ) {\n            return b;\n        }\n    }\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n        docs: {\n            description: \"Disallow expressions where the operation doesn't affect the value\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-constant-binary-expression\"\n        },\n        schema: [],\n        messages: {\n            constantBinaryOperand: \"Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.\",\n            constantShortCircuit: \"Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.\",\n            alwaysNew: \"Unexpected comparison to newly constructed object. These two values can never be equal.\",\n            bothAlwaysNew: \"Unexpected comparison of two newly constructed objects. These two values can never be equal.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        return {\n            LogicalExpression(node) {\n                const { operator, left } = node;\n                const scope = sourceCode.getScope(node);\n\n                if ((operator === \"&&\" || operator === \"||\") && isConstant(scope, left, true)) {\n                    context.report({ node: left, messageId: \"constantShortCircuit\", data: { property: \"truthiness\", operator } });\n                } else if (operator === \"??\" && hasConstantNullishness(scope, left, false)) {\n                    context.report({ node: left, messageId: \"constantShortCircuit\", data: { property: \"nullishness\", operator } });\n                }\n            },\n            BinaryExpression(node) {\n                const scope = sourceCode.getScope(node);\n                const { right, left, operator } = node;\n                const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);\n                const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);\n\n                if (rightConstantOperand) {\n                    context.report({ node: rightConstantOperand, messageId: \"constantBinaryOperand\", data: { operator, otherSide: \"left\" } });\n                } else if (leftConstantOperand) {\n                    context.report({ node: leftConstantOperand, messageId: \"constantBinaryOperand\", data: { operator, otherSide: \"right\" } });\n                } else if (operator === \"===\" || operator === \"!==\") {\n                    if (isAlwaysNew(scope, left)) {\n                        context.report({ node: left, messageId: \"alwaysNew\" });\n                    } else if (isAlwaysNew(scope, right)) {\n                        context.report({ node: right, messageId: \"alwaysNew\" });\n                    }\n                } else if (operator === \"==\" || operator === \"!=\") {\n\n                    /*\n                     * If both sides are \"new\", then both sides are objects and\n                     * therefore they will be compared by reference even with `==`\n                     * equality.\n                     */\n                    if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {\n                        context.report({ node: left, messageId: \"bothAlwaysNew\" });\n                    }\n                }\n\n            }\n\n            /*\n             * In theory we could handle short-circuiting assignment operators,\n             * for some constant values, but that would require walking the\n             * scope to find the value of the variable being assigned. This is\n             * dependant on https://github.com/eslint/eslint/issues/13776\n             *\n             * AssignmentExpression() {},\n             */\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}