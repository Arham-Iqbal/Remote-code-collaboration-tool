{"ast":null,"code":"/**\n * @fileoverview This rule sets a specific indentation style and width for your code\n *\n * @author Teddy Katz\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst KNOWN_NODES = new Set([\"AssignmentExpression\", \"AssignmentPattern\", \"ArrayExpression\", \"ArrayPattern\", \"ArrowFunctionExpression\", \"AwaitExpression\", \"BlockStatement\", \"BinaryExpression\", \"BreakStatement\", \"CallExpression\", \"CatchClause\", \"ChainExpression\", \"ClassBody\", \"ClassDeclaration\", \"ClassExpression\", \"ConditionalExpression\", \"ContinueStatement\", \"DoWhileStatement\", \"DebuggerStatement\", \"EmptyStatement\", \"ExperimentalRestProperty\", \"ExperimentalSpreadProperty\", \"ExpressionStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"FunctionDeclaration\", \"FunctionExpression\", \"Identifier\", \"IfStatement\", \"Literal\", \"LabeledStatement\", \"LogicalExpression\", \"MemberExpression\", \"MetaProperty\", \"MethodDefinition\", \"NewExpression\", \"ObjectExpression\", \"ObjectPattern\", \"PrivateIdentifier\", \"Program\", \"Property\", \"PropertyDefinition\", \"RestElement\", \"ReturnStatement\", \"SequenceExpression\", \"SpreadElement\", \"StaticBlock\", \"Super\", \"SwitchCase\", \"SwitchStatement\", \"TaggedTemplateExpression\", \"TemplateElement\", \"TemplateLiteral\", \"ThisExpression\", \"ThrowStatement\", \"TryStatement\", \"UnaryExpression\", \"UpdateExpression\", \"VariableDeclaration\", \"VariableDeclarator\", \"WhileStatement\", \"WithStatement\", \"YieldExpression\", \"JSXFragment\", \"JSXOpeningFragment\", \"JSXClosingFragment\", \"JSXIdentifier\", \"JSXNamespacedName\", \"JSXMemberExpression\", \"JSXEmptyExpression\", \"JSXExpressionContainer\", \"JSXElement\", \"JSXClosingElement\", \"JSXOpeningElement\", \"JSXAttribute\", \"JSXSpreadAttribute\", \"JSXText\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExportAllDeclaration\", \"ExportSpecifier\", \"ImportDeclaration\", \"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\", \"ImportExpression\"]);\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n/**\n * A mutable map that stores (key, value) pairs. The keys are numeric indices, and must be unique.\n * This is intended to be a generic wrapper around a map with non-negative integer keys, so that the underlying implementation\n * can easily be swapped out.\n */\nclass IndexMap {\n  /**\n   * Creates an empty map\n   * @param {number} maxKey The maximum key\n   */\n  constructor(maxKey) {\n    // Initializing the array with the maximum expected size avoids dynamic reallocations that could degrade performance.\n    this._values = Array(maxKey + 1);\n  }\n\n  /**\n   * Inserts an entry into the map.\n   * @param {number} key The entry's key\n   * @param {any} value The entry's value\n   * @returns {void}\n   */\n  insert(key, value) {\n    this._values[key] = value;\n  }\n\n  /**\n   * Finds the value of the entry with the largest key less than or equal to the provided key\n   * @param {number} key The provided key\n   * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.\n   */\n  findLastNotAfter(key) {\n    const values = this._values;\n    for (let index = key; index >= 0; index--) {\n      const value = values[index];\n      if (value) {\n        return value;\n      }\n    }\n    return void 0;\n  }\n\n  /**\n   * Deletes all of the keys in the interval [start, end)\n   * @param {number} start The start of the range\n   * @param {number} end The end of the range\n   * @returns {void}\n   */\n  deleteRange(start, end) {\n    this._values.fill(void 0, start, end);\n  }\n}\n\n/**\n * A helper class to get token-based info related to indentation\n */\nclass TokenInfo {\n  /**\n   * @param {SourceCode} sourceCode A SourceCode object\n   */\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.firstTokensByLineNumber = new Map();\n    const tokens = sourceCode.tokensAndComments;\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {\n        this.firstTokensByLineNumber.set(token.loc.start.line, token);\n      }\n      if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n        this.firstTokensByLineNumber.set(token.loc.end.line, token);\n      }\n    }\n  }\n\n  /**\n   * Gets the first token on a given token's line\n   * @param {Token|ASTNode} token a node or token\n   * @returns {Token} The first token on the given line\n   */\n  getFirstTokenOfLine(token) {\n    return this.firstTokensByLineNumber.get(token.loc.start.line);\n  }\n\n  /**\n   * Determines whether a token is the first token in its line\n   * @param {Token} token The token\n   * @returns {boolean} `true` if the token is the first on its line\n   */\n  isFirstTokenOfLine(token) {\n    return this.getFirstTokenOfLine(token) === token;\n  }\n\n  /**\n   * Get the actual indent of a token\n   * @param {Token} token Token to examine. This should be the first token on its line.\n   * @returns {string} The indentation characters that precede the token\n   */\n  getTokenIndent(token) {\n    return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n  }\n}\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\nclass OffsetStorage {\n  /**\n   * @param {TokenInfo} tokenInfo a TokenInfo instance\n   * @param {number} indentSize The desired size of each indentation level\n   * @param {string} indentType The indentation character\n   * @param {number} maxIndex The maximum end index of any token\n   */\n  constructor(tokenInfo, indentSize, indentType, maxIndex) {\n    this._tokenInfo = tokenInfo;\n    this._indentSize = indentSize;\n    this._indentType = indentType;\n    this._indexMap = new IndexMap(maxIndex);\n    this._indexMap.insert(0, {\n      offset: 0,\n      from: null,\n      force: false\n    });\n    this._lockedFirstTokens = new WeakMap();\n    this._desiredIndentCache = new WeakMap();\n    this._ignoredTokens = new WeakSet();\n  }\n  _getOffsetDescriptor(token) {\n    return this._indexMap.findLastNotAfter(token.range[0]);\n  }\n\n  /**\n   * Sets the offset column of token B to match the offset column of token A.\n   * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\n   * most cases, `setDesiredOffset` should be used instead.\n   * @param {Token} baseToken The first token\n   * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n   * @returns {void}\n   */\n  matchOffsetOf(baseToken, offsetToken) {\n    /*\n     * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n     * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n     * token of each element in the array after the first will be mapped to the first token of the first\n     * element. The desired indentation of each of these tokens is computed based on the desired indentation\n     * of the \"first\" element, rather than through the normal offset mechanism.\n     */\n    this._lockedFirstTokens.set(offsetToken, baseToken);\n  }\n\n  /**\n   * Sets the desired offset of a token.\n   *\n   * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n   * For example, consider the following two cases:\n   *\n   * (\n   *     [\n   *         bar\n   *     ]\n   * )\n   *\n   * ([\n   *     bar\n   * ])\n   *\n   * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n   * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n   * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n   * from the start of its line.\n   *\n   * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n   * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n   * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n   * by 1 indent level from the start of the line.\n   *\n   * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n   * without needing to check which lines those tokens are on.\n   *\n   * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n   * behavior can occur. For example, consider the following cases:\n   *\n   * foo(\n   * ).\n   *     bar(\n   *         baz\n   *     )\n   *\n   * foo(\n   * ).bar(\n   *     baz\n   * )\n   *\n   * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n   * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n   * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n   * collapsing would occur).\n   *\n   * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n   * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n   * in the second case.\n   * @param {Token} token The token\n   * @param {Token} fromToken The token that `token` should be offset from\n   * @param {number} offset The desired indent level\n   * @returns {void}\n   */\n  setDesiredOffset(token, fromToken, offset) {\n    return this.setDesiredOffsets(token.range, fromToken, offset);\n  }\n\n  /**\n   * Sets the desired offset of all tokens in a range\n   * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\n   * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\n   * it). This means that the offset of each token is updated O(AST depth) times.\n   * It would not be performant to store and update the offsets for each token independently, because the rule would end\n   * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\n   *\n   * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\n   * list could represent the state of the offset tree at a given point:\n   *\n   * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file\n   * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\n   * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\n   * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\n   * - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token\n   *\n   * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\n   * `setDesiredOffsets([30, 43], fooToken, 1);`\n   * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\n   * @param {Token} fromToken The token that this is offset from\n   * @param {number} offset The desired indent level\n   * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\n   * @returns {void}\n   */\n  setDesiredOffsets(range, fromToken, offset, force) {\n    /*\n     * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\n     * descriptor. The tree for the example above would have the following nodes:\n     *\n     * * key: 0, value: { offset: 0, from: null }\n     * * key: 15, value: { offset: 1, from: barToken }\n     * * key: 30, value: { offset: 1, from: fooToken }\n     * * key: 43, value: { offset: 2, from: barToken }\n     * * key: 820, value: { offset: 1, from: bazToken }\n     *\n     * To find the offset descriptor for any given token, one needs to find the node with the largest key\n     * which is <= token.start. To make this operation fast, the nodes are stored in a map indexed by key.\n     */\n\n    const descriptorToInsert = {\n      offset,\n      from: fromToken,\n      force\n    };\n    const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);\n    const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n    const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n    // First, remove any existing nodes in the range from the map.\n    this._indexMap.deleteRange(range[0] + 1, range[1]);\n\n    // Insert a new node into the map for this range\n    this._indexMap.insert(range[0], descriptorToInsert);\n\n    /*\n     * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\n     * even if it's in the current range.\n     */\n    if (fromTokenIsInRange) {\n      this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);\n      this._indexMap.insert(fromToken.range[1], descriptorToInsert);\n    }\n\n    /*\n     * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\n     * tokens the same as it was before.\n     */\n    this._indexMap.insert(range[1], descriptorAfterRange);\n  }\n\n  /**\n   * Gets the desired indent of a token\n   * @param {Token} token The token\n   * @returns {string} The desired indent of the token\n   */\n  getDesiredIndent(token) {\n    if (!this._desiredIndentCache.has(token)) {\n      if (this._ignoredTokens.has(token)) {\n        /*\n         * If the token is ignored, use the actual indent of the token as the desired indent.\n         * This ensures that no errors are reported for this token.\n         */\n        this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));\n      } else if (this._lockedFirstTokens.has(token)) {\n        const firstToken = this._lockedFirstTokens.get(token);\n        this._desiredIndentCache.set(token,\n        // (indentation for the first element's line)\n        this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\n        // (space between the start of the first element's line and the first element)\n        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));\n      } else {\n        const offsetInfo = this._getOffsetDescriptor(token);\n        const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\\s*?\\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;\n        this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset));\n      }\n    }\n    return this._desiredIndentCache.get(token);\n  }\n\n  /**\n   * Ignores a token, preventing it from being reported.\n   * @param {Token} token The token\n   * @returns {void}\n   */\n  ignoreToken(token) {\n    if (this._tokenInfo.isFirstTokenOfLine(token)) {\n      this._ignoredTokens.add(token);\n    }\n  }\n\n  /**\n   * Gets the first token that the given token's indentation is dependent on\n   * @param {Token} token The token\n   * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n   */\n  getFirstDependency(token) {\n    return this._getOffsetDescriptor(token).from;\n  }\n}\nconst ELEMENT_LIST_SCHEMA = {\n  oneOf: [{\n    type: \"integer\",\n    minimum: 0\n  }, {\n    enum: [\"first\", \"off\"]\n  }]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent indentation\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/indent\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0,\n          default: 0\n        },\n        VariableDeclarator: {\n          oneOf: [ELEMENT_LIST_SCHEMA, {\n            type: \"object\",\n            properties: {\n              var: ELEMENT_LIST_SCHEMA,\n              let: ELEMENT_LIST_SCHEMA,\n              const: ELEMENT_LIST_SCHEMA\n            },\n            additionalProperties: false\n          }]\n        },\n        outerIIFEBody: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"off\"]\n          }]\n        },\n        MemberExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"off\"]\n          }]\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: ELEMENT_LIST_SCHEMA,\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: ELEMENT_LIST_SCHEMA,\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        StaticBlock: {\n          type: \"object\",\n          properties: {\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            arguments: ELEMENT_LIST_SCHEMA\n          },\n          additionalProperties: false\n        },\n        ArrayExpression: ELEMENT_LIST_SCHEMA,\n        ObjectExpression: ELEMENT_LIST_SCHEMA,\n        ImportDeclaration: ELEMENT_LIST_SCHEMA,\n        flatTernaryExpressions: {\n          type: \"boolean\",\n          default: false\n        },\n        offsetTernaryExpressions: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoredNodes: {\n          type: \"array\",\n          items: {\n            type: \"string\",\n            not: {\n              pattern: \":exit$\"\n            }\n          }\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    const DEFAULT_PARAMETER_INDENT = 1;\n    const DEFAULT_FUNCTION_BODY_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: DEFAULT_VARIABLE_INDENT,\n        let: DEFAULT_VARIABLE_INDENT,\n        const: DEFAULT_VARIABLE_INDENT\n      },\n      outerIIFEBody: 1,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      StaticBlock: {\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      MemberExpression: 1,\n      ArrayExpression: 1,\n      ObjectExpression: 1,\n      ImportDeclaration: 1,\n      flatTernaryExpressions: false,\n      ignoredNodes: [],\n      ignoreComments: false\n    };\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else {\n        indentSize = context.options[0];\n        indentType = \"space\";\n      }\n      if (context.options[1]) {\n        Object.assign(options, context.options[1]);\n        if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n          options.VariableDeclarator = {\n            var: options.VariableDeclarator,\n            let: options.VariableDeclarator,\n            const: options.VariableDeclarator\n          };\n        }\n      }\n    }\n    const sourceCode = context.sourceCode;\n    const tokenInfo = new TokenInfo(sourceCode);\n    const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\", sourceCode.text.length);\n    const parameterParens = new WeakSet();\n\n    /**\n     * Creates an error message for a line, given the expected/actual indentation.\n     * @param {int} expectedAmount The expected amount of indentation characters for this line\n     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n     * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n     * @returns {string} An error message for this line\n     */\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n      let foundStatement;\n      if (actualSpaces > 0) {\n        /*\n         * Abbreviate the message if the expected indentation is also spaces.\n         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n         */\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n\n    /**\n     * Reports a given indent violation\n     * @param {Token} token Token violating the indent rule\n     * @param {string} neededIndent Expected indentation string\n     * @returns {void}\n     */\n    function report(token, neededIndent) {\n      const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n      const numSpaces = actualIndent.filter(char => char === \" \").length;\n      const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n      context.report({\n        node: token,\n        messageId: \"wrongIndentation\",\n        data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n        loc: {\n          start: {\n            line: token.loc.start.line,\n            column: 0\n          },\n          end: {\n            line: token.loc.start.line,\n            column: token.loc.start.column\n          }\n        },\n        fix(fixer) {\n          const range = [token.range[0] - token.loc.start.column, token.range[0]];\n          const newText = neededIndent;\n          return fixer.replaceTextRange(range, newText);\n        }\n      });\n    }\n\n    /**\n     * Checks if a token's indentation is correct\n     * @param {Token} token Token to examine\n     * @param {string} desiredIndent Desired indentation of the string\n     * @returns {boolean} `true` if the token's indentation is correct\n     */\n    function validateTokenIndent(token, desiredIndent) {\n      const indentation = tokenInfo.getTokenIndent(token);\n      return indentation === desiredIndent ||\n      // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n      indentation.includes(\" \") && indentation.includes(\"\\t\");\n    }\n\n    /**\n     * Check to see if the node is a file level IIFE\n     * @param {ASTNode} node The function node to check.\n     * @returns {boolean} True if the node is the outer IIFE\n     */\n    function isOuterIIFE(node) {\n      /*\n       * Verify that the node is an IIFE\n       */\n      if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n        return false;\n      }\n\n      /*\n       * Navigate legal ancestors to determine whether this IIFE is outer.\n       * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n       * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n       */\n      let statement = node.parent && node.parent.parent;\n      while (statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].includes(statement.operator) || statement.type === \"AssignmentExpression\" || statement.type === \"LogicalExpression\" || statement.type === \"SequenceExpression\" || statement.type === \"VariableDeclarator\") {\n        statement = statement.parent;\n      }\n      return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n    }\n\n    /**\n     * Counts the number of linebreaks that follow the last non-whitespace character in a string\n     * @param {string} string The string to check\n     * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\n     * or the total number of linebreaks if the string is all whitespace.\n     */\n    function countTrailingLinebreaks(string) {\n      const trailingWhitespace = string.match(/\\s*$/u)[0];\n      const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n      return linebreakMatches === null ? 0 : linebreakMatches.length;\n    }\n\n    /**\n     * Check indentation for lists of elements (arrays, objects, function params)\n     * @param {ASTNode[]} elements List of elements that should be offset\n     * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n     * @param {Token} endToken The end token of the list, e.g. ']'\n     * @param {number|string} offset The amount that the elements should be offset\n     * @returns {void}\n     */\n    function addElementListIndent(elements, startToken, endToken, offset) {\n      /**\n       * Gets the first token of a given element, including surrounding parentheses.\n       * @param {ASTNode} element A node in the `elements` list\n       * @returns {Token} The first token of this element\n       */\n      function getFirstToken(element) {\n        let token = sourceCode.getTokenBefore(element);\n        while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n          token = sourceCode.getTokenBefore(token);\n        }\n        return sourceCode.getTokenAfter(token);\n      }\n\n      // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n      offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === \"number\" ? offset : 1);\n      offsets.setDesiredOffset(endToken, startToken, 0);\n\n      // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n      if (offset === \"first\" && elements.length && !elements[0]) {\n        return;\n      }\n      elements.forEach((element, index) => {\n        if (!element) {\n          // Skip holes in arrays\n          return;\n        }\n        if (offset === \"off\") {\n          // Ignore the first token of every element if the \"off\" option is used\n          offsets.ignoreToken(getFirstToken(element));\n        }\n\n        // Offset the following elements correctly relative to the first element\n        if (index === 0) {\n          return;\n        }\n        if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n          offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n        } else {\n          const previousElement = elements[index - 1];\n          const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n          const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n          if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {\n            offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);\n          }\n        }\n      });\n    }\n\n    /**\n     * Check and decide whether to check for indentation for blockless nodes\n     * Scenarios are for or while statements without braces around them\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n    function addBlocklessNodeIndent(node) {\n      if (node.type !== \"BlockStatement\") {\n        const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n        let firstBodyToken = sourceCode.getFirstToken(node);\n        let lastBodyToken = sourceCode.getLastToken(node);\n        while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {\n          firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n          lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n        }\n        offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n      }\n    }\n\n    /**\n     * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n     * @param {ASTNode} node A CallExpression or NewExpression node\n     * @returns {void}\n     */\n    function addFunctionCallIndent(node) {\n      let openingParen;\n      if (node.arguments.length) {\n        openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n      } else {\n        openingParen = sourceCode.getLastToken(node, 1);\n      }\n      const closingParen = sourceCode.getLastToken(node);\n      parameterParens.add(openingParen);\n      parameterParens.add(closingParen);\n\n      /*\n       * If `?.` token exists, set desired offset for that.\n       * This logic is copied from `MemberExpression`'s.\n       */\n      if (node.optional) {\n        const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\n        const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, {\n          filter: astUtils.isClosingParenToken\n        }).length;\n        const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, {\n          skip: calleeParenCount - 1\n        }) : sourceCode.getFirstToken(node.callee);\n        const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\n        const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;\n        offsets.setDesiredOffset(dotToken, offsetBase, 1);\n      }\n      const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\n      const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\n      offsets.setDesiredOffset(openingParen, offsetToken, 0);\n      addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n    }\n\n    /**\n     * Checks the indentation of parenthesized values, given a list of tokens in a program\n     * @param {Token[]} tokens A list of tokens\n     * @returns {void}\n     */\n    function addParensIndent(tokens) {\n      const parenStack = [];\n      const parenPairs = [];\n      for (let i = 0; i < tokens.length; i++) {\n        const nextToken = tokens[i];\n        if (astUtils.isOpeningParenToken(nextToken)) {\n          parenStack.push(nextToken);\n        } else if (astUtils.isClosingParenToken(nextToken)) {\n          parenPairs.push({\n            left: parenStack.pop(),\n            right: nextToken\n          });\n        }\n      }\n      for (let i = parenPairs.length - 1; i >= 0; i--) {\n        const leftParen = parenPairs[i].left;\n        const rightParen = parenPairs[i].right;\n\n        // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n        if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n          const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n          parenthesizedTokens.forEach(token => {\n            if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n              offsets.setDesiredOffset(token, leftParen, 1);\n            }\n          });\n        }\n        offsets.setDesiredOffset(rightParen, leftParen, 0);\n      }\n    }\n\n    /**\n     * Ignore all tokens within an unknown node whose offset do not depend\n     * on another token's offset within the unknown node\n     * @param {ASTNode} node Unknown Node\n     * @returns {void}\n     */\n    function ignoreNode(node) {\n      const unknownNodeTokens = new Set(sourceCode.getTokens(node, {\n        includeComments: true\n      }));\n      unknownNodeTokens.forEach(token => {\n        if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n          const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n          if (token === firstTokenOfLine) {\n            offsets.ignoreToken(token);\n          } else {\n            offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n          }\n        }\n      });\n    }\n\n    /**\n     * Check whether the given token is on the first line of a statement.\n     * @param {Token} token The token to check.\n     * @param {ASTNode} leafNode The expression node that the token belongs directly.\n     * @returns {boolean} `true` if the token is on the first line of a statement.\n     */\n    function isOnFirstLineOfStatement(token, leafNode) {\n      let node = leafNode;\n      while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n        node = node.parent;\n      }\n      node = node.parent;\n      return !node || node.loc.start.line === token.loc.start.line;\n    }\n\n    /**\n     * Check whether there are any blank (whitespace-only) lines between\n     * two tokens on separate lines.\n     * @param {Token} firstToken The first token.\n     * @param {Token} secondToken The second token.\n     * @returns {boolean} `true` if the tokens are on separate lines and\n     *   there exists a blank line between them, `false` otherwise.\n     */\n    function hasBlankLinesBetween(firstToken, secondToken) {\n      const firstTokenLine = firstToken.loc.end.line;\n      const secondTokenLine = secondToken.loc.start.line;\n      if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n        return false;\n      }\n      for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n        if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    const ignoredNodeFirstTokens = new Set();\n    const baseOffsetListeners = {\n      \"ArrayExpression, ArrayPattern\"(node) {\n        const openingBracket = sourceCode.getFirstToken(node);\n        const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);\n        addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n      },\n      \"ObjectExpression, ObjectPattern\"(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);\n        addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n      },\n      ArrowFunctionExpression(node) {\n        const maybeOpeningParen = sourceCode.getFirstToken(node, {\n          skip: node.async ? 1 : 0\n        });\n        if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\n          const openingParen = maybeOpeningParen;\n          const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n          parameterParens.add(openingParen);\n          parameterParens.add(closingParen);\n          addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n        }\n        addBlocklessNodeIndent(node.body);\n      },\n      AssignmentExpression(node) {\n        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n        offsets.ignoreToken(operator);\n        offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n      },\n      \"BinaryExpression, LogicalExpression\"(node) {\n        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n        /*\n         * For backwards compatibility, don't check BinaryExpression indents, e.g.\n         * var foo = bar &&\n         *                   baz;\n         */\n\n        const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n        offsets.ignoreToken(operator);\n        offsets.ignoreToken(tokenAfterOperator);\n        offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n      },\n      \"BlockStatement, ClassBody\"(node) {\n        let blockIndentLevel;\n        if (node.parent && isOuterIIFE(node.parent)) {\n          blockIndentLevel = options.outerIIFEBody;\n        } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n          blockIndentLevel = options.FunctionExpression.body;\n        } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n          blockIndentLevel = options.FunctionDeclaration.body;\n        } else {\n          blockIndentLevel = 1;\n        }\n\n        /*\n         * For blocks that aren't lone statements, ensure that the opening curly brace\n         * is aligned with the parent.\n         */\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n        }\n        addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n      },\n      CallExpression: addFunctionCallIndent,\n      \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n        const classToken = sourceCode.getFirstToken(node);\n        const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n        offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n      },\n      ConditionalExpression(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n\n        // `flatTernaryExpressions` option is for the following style:\n        // var a =\n        //     foo > 0 ? bar :\n        //     foo < 0 ? baz :\n        //     /*else*/ qiz ;\n        if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {\n          const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n          const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n          const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n          const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n          const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n          offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n          offsets.setDesiredOffset(colonToken, firstToken, 1);\n          offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === \"Punctuator\" && options.offsetTernaryExpressions ? 2 : 1);\n\n          /*\n           * The alternate and the consequent should usually have the same indentation.\n           * If they share part of a line, align the alternate against the first token of the consequent.\n           * This allows the alternate to be indented correctly in cases like this:\n           * foo ? (\n           *   bar\n           * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n           *   baz // as a result, `baz` is offset by 1 rather than 2\n           * )\n           */\n          if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n            offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n          } else {\n            /**\n             * If the alternate and consequent do not share part of a line, offset the alternate from the first\n             * token of the conditional expression. For example:\n             * foo ? bar\n             *   : baz\n             *\n             * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n             * having no expected indentation.\n             */\n            offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === \"Punctuator\" && options.offsetTernaryExpressions ? 2 : 1);\n          }\n        }\n      },\n      \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement\": node => addBlocklessNodeIndent(node.body),\n      ExportNamedDeclaration(node) {\n        if (node.declaration === null) {\n          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n          // Indent the specifiers in `export {foo, bar, baz}`\n          addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, {\n            skip: 1\n          }), closingCurly, 1);\n          if (node.source) {\n            // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n            offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n          }\n        }\n      },\n      ForStatement(node) {\n        const forOpeningParen = sourceCode.getFirstToken(node, 1);\n        if (node.init) {\n          offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n        }\n        if (node.test) {\n          offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n        }\n        if (node.update) {\n          offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n        }\n        addBlocklessNodeIndent(node.body);\n      },\n      \"FunctionDeclaration, FunctionExpression\"(node) {\n        const closingParen = sourceCode.getTokenBefore(node.body);\n        const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n        parameterParens.add(openingParen);\n        parameterParens.add(closingParen);\n        addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n      },\n      IfStatement(node) {\n        addBlocklessNodeIndent(node.consequent);\n        if (node.alternate) {\n          addBlocklessNodeIndent(node.alternate);\n        }\n      },\n      /*\n       * For blockless nodes with semicolon-first style, don't indent the semicolon.\n       * e.g.\n       * if (foo)\n       *     bar()\n       * ; [1, 2, 3].map(foo)\n       *\n       * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.\n       */\n      \":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit\"(node) {\n        let nodesToCheck;\n        if (node.type === \"IfStatement\") {\n          nodesToCheck = [node.consequent];\n          if (node.alternate) {\n            nodesToCheck.push(node.alternate);\n          }\n        } else {\n          nodesToCheck = [node.body];\n        }\n        for (const nodeToCheck of nodesToCheck) {\n          const lastToken = sourceCode.getLastToken(nodeToCheck);\n          if (astUtils.isSemicolonToken(lastToken)) {\n            const tokenBeforeLast = sourceCode.getTokenBefore(lastToken);\n            const tokenAfterLast = sourceCode.getTokenAfter(lastToken);\n\n            // override indentation of `;` only if its line looks like a semicolon-first style line\n            if (!astUtils.isTokenOnSameLine(tokenBeforeLast, lastToken) && tokenAfterLast && astUtils.isTokenOnSameLine(lastToken, tokenAfterLast)) {\n              offsets.setDesiredOffset(lastToken, sourceCode.getFirstToken(node), 0);\n            }\n          }\n        }\n      },\n      ImportDeclaration(node) {\n        if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n          const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n          addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n        }\n        const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n        const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n        const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n        if (fromToken) {\n          const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n          offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n        }\n      },\n      ImportExpression(node) {\n        const openingParen = sourceCode.getFirstToken(node, 1);\n        const closingParen = sourceCode.getLastToken(node);\n        parameterParens.add(openingParen);\n        parameterParens.add(closingParen);\n        offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n        addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\n      },\n      \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n        const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n        const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n        const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n        const objectParenCount = sourceCode.getTokensBetween(object, node.property, {\n          filter: astUtils.isClosingParenToken\n        }).length;\n        const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, {\n          skip: objectParenCount - 1\n        }) : sourceCode.getFirstToken(object);\n        const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n        const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n        if (node.computed) {\n          // For computed MemberExpressions, match the closing bracket with the opening bracket.\n          offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n          offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n        }\n\n        /*\n         * If the object ends on the same line that the property starts, match against the last token\n         * of the object, to ensure that the MemberExpression is not indented.\n         *\n         * Otherwise, match against the first token of the object, e.g.\n         * foo\n         *   .bar\n         *   .baz // <-- offset by 1 from `foo`\n         */\n        const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;\n        if (typeof options.MemberExpression === \"number\") {\n          // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n\n          /*\n           * For computed MemberExpressions, match the first token of the property against the opening bracket.\n           * Otherwise, match the first token of the property against the object.\n           */\n          offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n        } else {\n          // If the MemberExpression option is off, ignore the dot and the first token of the property.\n          offsets.ignoreToken(firstNonObjectToken);\n          offsets.ignoreToken(secondNonObjectToken);\n\n          // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n          offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n        }\n      },\n      NewExpression(node) {\n        // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n        if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n          addFunctionCallIndent(node);\n        }\n      },\n      Property(node) {\n        if (!node.shorthand && !node.method && node.kind === \"init\") {\n          const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n          offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n        }\n      },\n      PropertyDefinition(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const maybeSemicolonToken = sourceCode.getLastToken(node);\n        let keyLastToken = null;\n\n        // Indent key.\n        if (node.computed) {\n          const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);\n          const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);\n          const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];\n          if (bracketTokenL !== firstToken) {\n            offsets.setDesiredOffset(bracketTokenL, firstToken, 0);\n          }\n          offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);\n          offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);\n        } else {\n          const idToken = keyLastToken = sourceCode.getFirstToken(node.key);\n          if (idToken !== firstToken) {\n            offsets.setDesiredOffset(idToken, firstToken, 1);\n          }\n        }\n\n        // Indent initializer.\n        if (node.value) {\n          const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);\n          const valueToken = sourceCode.getTokenAfter(eqToken);\n          offsets.setDesiredOffset(eqToken, keyLastToken, 1);\n          offsets.setDesiredOffset(valueToken, eqToken, 1);\n          if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n            offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);\n          }\n        } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n          offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);\n        }\n      },\n      StaticBlock(node) {\n        const openingCurly = sourceCode.getFirstToken(node, {\n          skip: 1\n        }); // skip the `static` token\n        const closingCurly = sourceCode.getLastToken(node);\n        addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);\n      },\n      SwitchStatement(node) {\n        const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n        if (node.cases.length) {\n          sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, {\n            includeComments: true,\n            filter: astUtils.isCommentToken\n          }).forEach(token => offsets.ignoreToken(token));\n        }\n      },\n      SwitchCase(node) {\n        if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n          const caseKeyword = sourceCode.getFirstToken(node);\n          const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n          offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n        }\n      },\n      TemplateLiteral(node) {\n        node.expressions.forEach((expression, index) => {\n          const previousQuasi = node.quasis[index];\n          const nextQuasi = node.quasis[index + 1];\n          const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;\n          offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n          offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n        });\n      },\n      VariableDeclaration(node) {\n        let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;\n        const firstToken = sourceCode.getFirstToken(node),\n          lastToken = sourceCode.getLastToken(node);\n        if (options.VariableDeclarator[node.kind] === \"first\") {\n          if (node.declarations.length > 1) {\n            addElementListIndent(node.declarations, firstToken, lastToken, \"first\");\n            return;\n          }\n          variableIndent = DEFAULT_VARIABLE_INDENT;\n        }\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n          /*\n           * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n           * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n           * the following indentations are correct:\n           *\n           * var foo = {\n           *   ok: true\n           * };\n           *\n           * var foo = {\n           *     ok: true,\n           *   },\n           *   bar = 1;\n           *\n           * Account for when exiting the AST (after indentations have already been set for the nodes in\n           * the declaration) by manually increasing the indentation level of the tokens in this declarator\n           * on the same line as the start of the declaration, provided that there are declarators that\n           * follow this one.\n           */\n          offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n        } else {\n          offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n        }\n        if (astUtils.isSemicolonToken(lastToken)) {\n          offsets.ignoreToken(lastToken);\n        }\n      },\n      VariableDeclarator(node) {\n        if (node.init) {\n          const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n          const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n          offsets.ignoreToken(equalOperator);\n          offsets.ignoreToken(tokenAfterOperator);\n          offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n          offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n        }\n      },\n      \"JSXAttribute[value]\"(node) {\n        const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n        offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n      },\n      JSXElement(node) {\n        if (node.closingElement) {\n          addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n        }\n      },\n      JSXOpeningElement(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        let closingToken;\n        if (node.selfClosing) {\n          closingToken = sourceCode.getLastToken(node, {\n            skip: 1\n          });\n          offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n        } else {\n          closingToken = sourceCode.getLastToken(node);\n        }\n        offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n        addElementListIndent(node.attributes, firstToken, closingToken, 1);\n      },\n      JSXClosingElement(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n      },\n      JSXFragment(node) {\n        const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\n        const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\n        addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\n      },\n      JSXOpeningFragment(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const closingToken = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets(node.range, firstToken, 1);\n        offsets.matchOffsetOf(firstToken, closingToken);\n      },\n      JSXClosingFragment(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const slashToken = sourceCode.getLastToken(node, {\n          skip: 1\n        });\n        const closingToken = sourceCode.getLastToken(node);\n        const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\n        offsets.setDesiredOffsets(node.range, firstToken, 1);\n        offsets.matchOffsetOf(firstToken, tokenToMatch);\n      },\n      JSXExpressionContainer(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);\n      },\n      JSXSpreadAttribute(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);\n      },\n      \"*\"(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n\n        // Ensure that the children of every node are indented at least as much as the first token.\n        if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n          offsets.setDesiredOffsets(node.range, firstToken, 0);\n        }\n      }\n    };\n    const listenerCallQueue = [];\n\n    /*\n     * To ignore the indentation of a node:\n     * 1. Don't call the node's listener when entering it (if it has a listener)\n     * 2. Don't set any offsets against the first token of the node.\n     * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\n     */\n    const offsetListeners = {};\n    for (const [selector, listener] of Object.entries(baseOffsetListeners)) {\n      /*\n       * Offset listener calls are deferred until traversal is finished, and are called as\n       * part of the final `Program:exit` listener. This is necessary because a node might\n       * be matched by multiple selectors.\n       *\n       * Example: Suppose there is an offset listener for `Identifier`, and the user has\n       * specified in configuration that `MemberExpression > Identifier` should be ignored.\n       * Due to selector specificity rules, the `Identifier` listener will get called first. However,\n       * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\n       * should not have been called at all. Without doing extra selector matching, we don't know\n       * whether the Identifier matches the `MemberExpression > Identifier` selector until the\n       * `MemberExpression > Identifier` listener is called.\n       *\n       * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\n       * ignored nodes are known.\n       */\n      offsetListeners[selector] = node => listenerCallQueue.push({\n        listener,\n        node\n      });\n    }\n\n    // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n    const ignoredNodes = new Set();\n\n    /**\n     * Ignores a node\n     * @param {ASTNode} node The node to ignore\n     * @returns {void}\n     */\n    function addToIgnoredNodes(node) {\n      ignoredNodes.add(node);\n      ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n    }\n    const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, {\n      [ignoredSelector]: addToIgnoredNodes\n    }), {});\n\n    /*\n     * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\n     * at the end.\n     *\n     * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\n     * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\n     * so those listeners wouldn't be called anyway.\n     */\n    return Object.assign(offsetListeners, ignoredNodeListeners, {\n      \"*:exit\"(node) {\n        // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n        if (!KNOWN_NODES.has(node.type)) {\n          addToIgnoredNodes(node);\n        }\n      },\n      \"Program:exit\"() {\n        // If ignoreComments option is enabled, ignore all comment tokens.\n        if (options.ignoreComments) {\n          sourceCode.getAllComments().forEach(comment => offsets.ignoreToken(comment));\n        }\n\n        // Invoke the queued offset listeners for the nodes that aren't ignored.\n        for (let i = 0; i < listenerCallQueue.length; i++) {\n          const nodeInfo = listenerCallQueue[i];\n          if (!ignoredNodes.has(nodeInfo.node)) {\n            nodeInfo.listener(nodeInfo.node);\n          }\n        }\n\n        // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n        ignoredNodes.forEach(ignoreNode);\n        addParensIndent(sourceCode.ast.tokens);\n\n        /*\n         * Create a Map from (tokenOrComment) => (precedingToken).\n         * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n         */\n        const precedingTokens = new WeakMap();\n        for (let i = 0; i < sourceCode.ast.comments.length; i++) {\n          const comment = sourceCode.ast.comments[i];\n          const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;\n          precedingTokens.set(comment, hasToken);\n        }\n        for (let i = 1; i < sourceCode.lines.length + 1; i++) {\n          if (!tokenInfo.firstTokensByLineNumber.has(i)) {\n            // Don't check indentation on blank lines\n            continue;\n          }\n          const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i);\n          if (firstTokenOfLine.loc.start.line !== i) {\n            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n            continue;\n          }\n          if (astUtils.isCommentToken(firstTokenOfLine)) {\n            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n\n            /*\n             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.\n             *\n             * let foo\n             * // comment\n             * ;(async () => {})()\n             */\n            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\n              offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\n            }\n\n            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n            if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {\n              continue;\n            }\n          }\n\n          // If the token matches the expected indentation, don't report it.\n          if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n            continue;\n          }\n\n          // Otherwise, report the token/comment.\n          report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n        }\n      }\n    });\n  }\n};","map":{"version":3,"names":["astUtils","require","KNOWN_NODES","Set","IndexMap","constructor","maxKey","_values","Array","insert","key","value","findLastNotAfter","values","index","deleteRange","start","end","fill","TokenInfo","sourceCode","firstTokensByLineNumber","Map","tokens","tokensAndComments","i","length","token","has","loc","line","set","text","slice","range","column","trim","getFirstTokenOfLine","get","isFirstTokenOfLine","getTokenIndent","OffsetStorage","tokenInfo","indentSize","indentType","maxIndex","_tokenInfo","_indentSize","_indentType","_indexMap","offset","from","force","_lockedFirstTokens","WeakMap","_desiredIndentCache","_ignoredTokens","WeakSet","_getOffsetDescriptor","matchOffsetOf","baseToken","offsetToken","setDesiredOffset","fromToken","setDesiredOffsets","descriptorToInsert","descriptorAfterRange","fromTokenIsInRange","fromTokenDescriptor","getDesiredIndent","firstToken","repeat","offsetInfo","test","ignoreToken","add","getFirstDependency","ELEMENT_LIST_SCHEMA","oneOf","type","minimum","enum","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","fixable","schema","properties","SwitchCase","default","VariableDeclarator","var","let","const","additionalProperties","outerIIFEBody","MemberExpression","FunctionDeclaration","parameters","body","FunctionExpression","StaticBlock","CallExpression","arguments","ArrayExpression","ObjectExpression","ImportDeclaration","flatTernaryExpressions","offsetTernaryExpressions","ignoredNodes","items","not","pattern","ignoreComments","messages","wrongIndentation","create","context","DEFAULT_VARIABLE_INDENT","DEFAULT_PARAMETER_INDENT","DEFAULT_FUNCTION_BODY_INDENT","options","Object","assign","offsets","parameterParens","createErrorMessageData","expectedAmount","actualSpaces","actualTabs","expectedStatement","foundSpacesWord","foundTabsWord","foundStatement","expected","actual","report","neededIndent","actualIndent","numSpaces","filter","char","numTabs","node","messageId","data","fix","fixer","newText","replaceTextRange","validateTokenIndent","desiredIndent","indentation","includes","isOuterIIFE","parent","callee","statement","operator","countTrailingLinebreaks","string","trailingWhitespace","match","linebreakMatches","createGlobalLinebreakMatcher","addElementListIndent","elements","startToken","endToken","getFirstToken","element","getTokenBefore","isOpeningParenToken","getTokenAfter","forEach","previousElement","firstTokenOfPreviousElement","previousElementLastToken","getLastToken","addBlocklessNodeIndent","lastParentToken","isNotOpeningParenToken","firstBodyToken","lastBodyToken","isClosingParenToken","addFunctionCallIndent","openingParen","getFirstTokenBetween","closingParen","optional","dotToken","isQuestionDotToken","calleeParenCount","getTokensBetween","firstTokenOfCallee","skip","lastTokenOfCallee","offsetBase","offsetAfterToken","quasi","addParensIndent","parenStack","parenPairs","nextToken","push","left","pop","right","leftParen","rightParen","parenthesizedTokens","ignoreNode","unknownNodeTokens","getTokens","includeComments","firstTokenOfLine","isOnFirstLineOfStatement","leafNode","endsWith","hasBlankLinesBetween","secondToken","firstTokenLine","secondTokenLine","ignoredNodeFirstTokens","baseOffsetListeners","ArrayExpression, ArrayPattern","openingBracket","closingBracket","reverse","find","_","isClosingBracketToken","ObjectExpression, ObjectPattern","openingCurly","closingCurly","isClosingBraceToken","ArrowFunctionExpression","maybeOpeningParen","async","params","AssignmentExpression","BinaryExpression, LogicalExpression","tokenAfterOperator","BlockStatement, ClassBody","blockIndentLevel","STATEMENT_LIST_PARENTS","ClassDeclaration[superClass], ClassExpression[superClass]","classToken","extendsToken","superClass","ConditionalExpression","isTokenOnSameLine","consequent","questionMarkToken","colonToken","alternate","firstConsequentToken","lastConsequentToken","firstAlternateToken","ExportNamedDeclaration","declaration","specifiers","source","ForStatement","forOpeningParen","init","update","FunctionDeclaration, FunctionExpression","IfStatement",":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit","nodesToCheck","nodeToCheck","lastToken","isSemicolonToken","tokenBeforeLast","tokenAfterLast","some","specifier","isOpeningBraceToken","sourceToken","semiToken","ImportExpression","MemberExpression, JSXMemberExpression, MetaProperty","object","firstNonObjectToken","property","isNotClosingParenToken","secondNonObjectToken","objectParenCount","firstObjectToken","lastObjectToken","firstPropertyToken","computed","NewExpression","Property","shorthand","method","kind","colon","isColonToken","PropertyDefinition","maybeSemicolonToken","keyLastToken","bracketTokenL","isOpeningBracketToken","bracketTokenR","keyRange","idToken","eqToken","isEqToken","valueToken","SwitchStatement","discriminant","cases","isCommentToken","caseKeyword","tokenAfterCurrentCase","TemplateLiteral","expressions","expression","previousQuasi","quasis","nextQuasi","tokenToAlignFrom","VariableDeclaration","variableIndent","prototype","hasOwnProperty","call","declarations","equalOperator","id","JSXAttribute[value]","equalsToken","name","JSXElement","closingElement","children","openingElement","JSXOpeningElement","closingToken","selfClosing","attributes","JSXClosingElement","JSXFragment","firstOpeningToken","openingFragment","firstClosingToken","closingFragment","JSXOpeningFragment","JSXClosingFragment","slashToken","tokenToMatch","JSXExpressionContainer","JSXSpreadAttribute","*","listenerCallQueue","offsetListeners","selector","listener","entries","addToIgnoredNodes","ignoredNodeListeners","reduce","listeners","ignoredSelector","*:exit","Program:exit","getAllComments","comment","nodeInfo","ast","precedingTokens","comments","tokenOrCommentBefore","hasToken","lines","tokenBefore","tokenAfter","mayAlignWithBefore","mayAlignWithAfter"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/indent.js"],"sourcesContent":["/**\n * @fileoverview This rule sets a specific indentation style and width for your code\n *\n * @author Teddy Katz\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst KNOWN_NODES = new Set([\n    \"AssignmentExpression\",\n    \"AssignmentPattern\",\n    \"ArrayExpression\",\n    \"ArrayPattern\",\n    \"ArrowFunctionExpression\",\n    \"AwaitExpression\",\n    \"BlockStatement\",\n    \"BinaryExpression\",\n    \"BreakStatement\",\n    \"CallExpression\",\n    \"CatchClause\",\n    \"ChainExpression\",\n    \"ClassBody\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"ConditionalExpression\",\n    \"ContinueStatement\",\n    \"DoWhileStatement\",\n    \"DebuggerStatement\",\n    \"EmptyStatement\",\n    \"ExperimentalRestProperty\",\n    \"ExperimentalSpreadProperty\",\n    \"ExpressionStatement\",\n    \"ForStatement\",\n    \"ForInStatement\",\n    \"ForOfStatement\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"IfStatement\",\n    \"Literal\",\n    \"LabeledStatement\",\n    \"LogicalExpression\",\n    \"MemberExpression\",\n    \"MetaProperty\",\n    \"MethodDefinition\",\n    \"NewExpression\",\n    \"ObjectExpression\",\n    \"ObjectPattern\",\n    \"PrivateIdentifier\",\n    \"Program\",\n    \"Property\",\n    \"PropertyDefinition\",\n    \"RestElement\",\n    \"ReturnStatement\",\n    \"SequenceExpression\",\n    \"SpreadElement\",\n    \"StaticBlock\",\n    \"Super\",\n    \"SwitchCase\",\n    \"SwitchStatement\",\n    \"TaggedTemplateExpression\",\n    \"TemplateElement\",\n    \"TemplateLiteral\",\n    \"ThisExpression\",\n    \"ThrowStatement\",\n    \"TryStatement\",\n    \"UnaryExpression\",\n    \"UpdateExpression\",\n    \"VariableDeclaration\",\n    \"VariableDeclarator\",\n    \"WhileStatement\",\n    \"WithStatement\",\n    \"YieldExpression\",\n    \"JSXFragment\",\n    \"JSXOpeningFragment\",\n    \"JSXClosingFragment\",\n    \"JSXIdentifier\",\n    \"JSXNamespacedName\",\n    \"JSXMemberExpression\",\n    \"JSXEmptyExpression\",\n    \"JSXExpressionContainer\",\n    \"JSXElement\",\n    \"JSXClosingElement\",\n    \"JSXOpeningElement\",\n    \"JSXAttribute\",\n    \"JSXSpreadAttribute\",\n    \"JSXText\",\n    \"ExportDefaultDeclaration\",\n    \"ExportNamedDeclaration\",\n    \"ExportAllDeclaration\",\n    \"ExportSpecifier\",\n    \"ImportDeclaration\",\n    \"ImportSpecifier\",\n    \"ImportDefaultSpecifier\",\n    \"ImportNamespaceSpecifier\",\n    \"ImportExpression\"\n]);\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n\n/**\n * A mutable map that stores (key, value) pairs. The keys are numeric indices, and must be unique.\n * This is intended to be a generic wrapper around a map with non-negative integer keys, so that the underlying implementation\n * can easily be swapped out.\n */\nclass IndexMap {\n\n    /**\n     * Creates an empty map\n     * @param {number} maxKey The maximum key\n     */\n    constructor(maxKey) {\n\n        // Initializing the array with the maximum expected size avoids dynamic reallocations that could degrade performance.\n        this._values = Array(maxKey + 1);\n    }\n\n    /**\n     * Inserts an entry into the map.\n     * @param {number} key The entry's key\n     * @param {any} value The entry's value\n     * @returns {void}\n     */\n    insert(key, value) {\n        this._values[key] = value;\n    }\n\n    /**\n     * Finds the value of the entry with the largest key less than or equal to the provided key\n     * @param {number} key The provided key\n     * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.\n     */\n    findLastNotAfter(key) {\n        const values = this._values;\n\n        for (let index = key; index >= 0; index--) {\n            const value = values[index];\n\n            if (value) {\n                return value;\n            }\n        }\n        return void 0;\n    }\n\n    /**\n     * Deletes all of the keys in the interval [start, end)\n     * @param {number} start The start of the range\n     * @param {number} end The end of the range\n     * @returns {void}\n     */\n    deleteRange(start, end) {\n        this._values.fill(void 0, start, end);\n    }\n}\n\n/**\n * A helper class to get token-based info related to indentation\n */\nclass TokenInfo {\n\n    /**\n     * @param {SourceCode} sourceCode A SourceCode object\n     */\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.firstTokensByLineNumber = new Map();\n        const tokens = sourceCode.tokensAndComments;\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {\n                this.firstTokensByLineNumber.set(token.loc.start.line, token);\n            }\n            if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n                this.firstTokensByLineNumber.set(token.loc.end.line, token);\n            }\n        }\n    }\n\n    /**\n     * Gets the first token on a given token's line\n     * @param {Token|ASTNode} token a node or token\n     * @returns {Token} The first token on the given line\n     */\n    getFirstTokenOfLine(token) {\n        return this.firstTokensByLineNumber.get(token.loc.start.line);\n    }\n\n    /**\n     * Determines whether a token is the first token in its line\n     * @param {Token} token The token\n     * @returns {boolean} `true` if the token is the first on its line\n     */\n    isFirstTokenOfLine(token) {\n        return this.getFirstTokenOfLine(token) === token;\n    }\n\n    /**\n     * Get the actual indent of a token\n     * @param {Token} token Token to examine. This should be the first token on its line.\n     * @returns {string} The indentation characters that precede the token\n     */\n    getTokenIndent(token) {\n        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n    }\n}\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\nclass OffsetStorage {\n\n    /**\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\n     * @param {number} indentSize The desired size of each indentation level\n     * @param {string} indentType The indentation character\n     * @param {number} maxIndex The maximum end index of any token\n     */\n    constructor(tokenInfo, indentSize, indentType, maxIndex) {\n        this._tokenInfo = tokenInfo;\n        this._indentSize = indentSize;\n        this._indentType = indentType;\n\n        this._indexMap = new IndexMap(maxIndex);\n        this._indexMap.insert(0, { offset: 0, from: null, force: false });\n\n        this._lockedFirstTokens = new WeakMap();\n        this._desiredIndentCache = new WeakMap();\n        this._ignoredTokens = new WeakSet();\n    }\n\n    _getOffsetDescriptor(token) {\n        return this._indexMap.findLastNotAfter(token.range[0]);\n    }\n\n    /**\n     * Sets the offset column of token B to match the offset column of token A.\n     * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\n     * most cases, `setDesiredOffset` should be used instead.\n     * @param {Token} baseToken The first token\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n     * @returns {void}\n     */\n    matchOffsetOf(baseToken, offsetToken) {\n\n        /*\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n         * token of each element in the array after the first will be mapped to the first token of the first\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\n         * of the \"first\" element, rather than through the normal offset mechanism.\n         */\n        this._lockedFirstTokens.set(offsetToken, baseToken);\n    }\n\n    /**\n     * Sets the desired offset of a token.\n     *\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n     * For example, consider the following two cases:\n     *\n     * (\n     *     [\n     *         bar\n     *     ]\n     * )\n     *\n     * ([\n     *     bar\n     * ])\n     *\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n     * from the start of its line.\n     *\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n     * by 1 indent level from the start of the line.\n     *\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n     * without needing to check which lines those tokens are on.\n     *\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n     * behavior can occur. For example, consider the following cases:\n     *\n     * foo(\n     * ).\n     *     bar(\n     *         baz\n     *     )\n     *\n     * foo(\n     * ).bar(\n     *     baz\n     * )\n     *\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n     * collapsing would occur).\n     *\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n     * in the second case.\n     * @param {Token} token The token\n     * @param {Token} fromToken The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n    setDesiredOffset(token, fromToken, offset) {\n        return this.setDesiredOffsets(token.range, fromToken, offset);\n    }\n\n    /**\n     * Sets the desired offset of all tokens in a range\n     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\n     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\n     * it). This means that the offset of each token is updated O(AST depth) times.\n     * It would not be performant to store and update the offsets for each token independently, because the rule would end\n     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\n     *\n     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\n     * list could represent the state of the offset tree at a given point:\n     *\n     * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file\n     * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\n     * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\n     * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\n     * - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token\n     *\n     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\n     * `setDesiredOffsets([30, 43], fooToken, 1);`\n     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\n     * @param {Token} fromToken The token that this is offset from\n     * @param {number} offset The desired indent level\n     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\n     * @returns {void}\n     */\n    setDesiredOffsets(range, fromToken, offset, force) {\n\n        /*\n         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\n         * descriptor. The tree for the example above would have the following nodes:\n         *\n         * * key: 0, value: { offset: 0, from: null }\n         * * key: 15, value: { offset: 1, from: barToken }\n         * * key: 30, value: { offset: 1, from: fooToken }\n         * * key: 43, value: { offset: 2, from: barToken }\n         * * key: 820, value: { offset: 1, from: bazToken }\n         *\n         * To find the offset descriptor for any given token, one needs to find the node with the largest key\n         * which is <= token.start. To make this operation fast, the nodes are stored in a map indexed by key.\n         */\n\n        const descriptorToInsert = { offset, from: fromToken, force };\n\n        const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);\n\n        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n        // First, remove any existing nodes in the range from the map.\n        this._indexMap.deleteRange(range[0] + 1, range[1]);\n\n        // Insert a new node into the map for this range\n        this._indexMap.insert(range[0], descriptorToInsert);\n\n        /*\n         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\n         * even if it's in the current range.\n         */\n        if (fromTokenIsInRange) {\n            this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);\n            this._indexMap.insert(fromToken.range[1], descriptorToInsert);\n        }\n\n        /*\n         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\n         * tokens the same as it was before.\n         */\n        this._indexMap.insert(range[1], descriptorAfterRange);\n    }\n\n    /**\n     * Gets the desired indent of a token\n     * @param {Token} token The token\n     * @returns {string} The desired indent of the token\n     */\n    getDesiredIndent(token) {\n        if (!this._desiredIndentCache.has(token)) {\n\n            if (this._ignoredTokens.has(token)) {\n\n                /*\n                 * If the token is ignored, use the actual indent of the token as the desired indent.\n                 * This ensures that no errors are reported for this token.\n                 */\n                this._desiredIndentCache.set(\n                    token,\n                    this._tokenInfo.getTokenIndent(token)\n                );\n            } else if (this._lockedFirstTokens.has(token)) {\n                const firstToken = this._lockedFirstTokens.get(token);\n\n                this._desiredIndentCache.set(\n                    token,\n\n                    // (indentation for the first element's line)\n                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\n\n                        // (space between the start of the first element's line and the first element)\n                        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)\n                );\n            } else {\n                const offsetInfo = this._getOffsetDescriptor(token);\n                const offset = (\n                    offsetInfo.from &&\n                    offsetInfo.from.loc.start.line === token.loc.start.line &&\n                    !/^\\s*?\\n/u.test(token.value) &&\n                    !offsetInfo.force\n                ) ? 0 : offsetInfo.offset * this._indentSize;\n\n                this._desiredIndentCache.set(\n                    token,\n                    (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset)\n                );\n            }\n        }\n        return this._desiredIndentCache.get(token);\n    }\n\n    /**\n     * Ignores a token, preventing it from being reported.\n     * @param {Token} token The token\n     * @returns {void}\n     */\n    ignoreToken(token) {\n        if (this._tokenInfo.isFirstTokenOfLine(token)) {\n            this._ignoredTokens.add(token);\n        }\n    }\n\n    /**\n     * Gets the first token that the given token's indentation is dependent on\n     * @param {Token} token The token\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n     */\n    getFirstDependency(token) {\n        return this._getOffsetDescriptor(token).from;\n    }\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n    oneOf: [\n        {\n            type: \"integer\",\n            minimum: 0\n        },\n        {\n            enum: [\"first\", \"off\"]\n        }\n    ]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [],\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent indentation\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/indent\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0,\n                        default: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            ELEMENT_LIST_SCHEMA,\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: ELEMENT_LIST_SCHEMA,\n                                    let: ELEMENT_LIST_SCHEMA,\n                                    const: ELEMENT_LIST_SCHEMA\n                                },\n                                additionalProperties: false\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    MemberExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    StaticBlock: {\n                        type: \"object\",\n                        properties: {\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            arguments: ELEMENT_LIST_SCHEMA\n                        },\n                        additionalProperties: false\n                    },\n                    ArrayExpression: ELEMENT_LIST_SCHEMA,\n                    ObjectExpression: ELEMENT_LIST_SCHEMA,\n                    ImportDeclaration: ELEMENT_LIST_SCHEMA,\n                    flatTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    offsetTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoredNodes: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            not: {\n                                pattern: \":exit$\"\n                            }\n                        }\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = 1;\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: 1,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            StaticBlock: {\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            MemberExpression: 1,\n            ArrayExpression: 1,\n            ObjectExpression: 1,\n            ImportDeclaration: 1,\n            flatTernaryExpressions: false,\n            ignoredNodes: [],\n            ignoreComments: false\n        };\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                Object.assign(options, context.options[1]);\n\n                if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n                    options.VariableDeclarator = {\n                        var: options.VariableDeclarator,\n                        let: options.VariableDeclarator,\n                        const: options.VariableDeclarator\n                    };\n                }\n            }\n        }\n\n        const sourceCode = context.sourceCode;\n        const tokenInfo = new TokenInfo(sourceCode);\n        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\", sourceCode.text.length);\n        const parameterParens = new WeakSet();\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {Token} token Token violating the indent rule\n         * @param {string} neededIndent Expected indentation string\n         * @returns {void}\n         */\n        function report(token, neededIndent) {\n            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n            const numSpaces = actualIndent.filter(char => char === \" \").length;\n            const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n\n            context.report({\n                node: token,\n                messageId: \"wrongIndentation\",\n                data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n                loc: {\n                    start: { line: token.loc.start.line, column: 0 },\n                    end: { line: token.loc.start.line, column: token.loc.start.column }\n                },\n                fix(fixer) {\n                    const range = [token.range[0] - token.loc.start.column, token.range[0]];\n                    const newText = neededIndent;\n\n                    return fixer.replaceTextRange(range, newText);\n                }\n            });\n        }\n\n        /**\n         * Checks if a token's indentation is correct\n         * @param {Token} token Token to examine\n         * @param {string} desiredIndent Desired indentation of the string\n         * @returns {boolean} `true` if the token's indentation is correct\n         */\n        function validateTokenIndent(token, desiredIndent) {\n            const indentation = tokenInfo.getTokenIndent(token);\n\n            return indentation === desiredIndent ||\n\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n                indentation.includes(\" \") && indentation.includes(\"\\t\");\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n\n            /*\n             * Verify that the node is an IIFE\n             */\n            if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIFE is outer.\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n             */\n            let statement = node.parent && node.parent.parent;\n\n            while (\n                statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].includes(statement.operator) ||\n                statement.type === \"AssignmentExpression\" ||\n                statement.type === \"LogicalExpression\" ||\n                statement.type === \"SequenceExpression\" ||\n                statement.type === \"VariableDeclarator\"\n            ) {\n                statement = statement.parent;\n            }\n\n            return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n        }\n\n        /**\n         * Counts the number of linebreaks that follow the last non-whitespace character in a string\n         * @param {string} string The string to check\n         * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\n         * or the total number of linebreaks if the string is all whitespace.\n         */\n        function countTrailingLinebreaks(string) {\n            const trailingWhitespace = string.match(/\\s*$/u)[0];\n            const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n\n            return linebreakMatches === null ? 0 : linebreakMatches.length;\n        }\n\n        /**\n         * Check indentation for lists of elements (arrays, objects, function params)\n         * @param {ASTNode[]} elements List of elements that should be offset\n         * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n         * @param {Token} endToken The end token of the list, e.g. ']'\n         * @param {number|string} offset The amount that the elements should be offset\n         * @returns {void}\n         */\n        function addElementListIndent(elements, startToken, endToken, offset) {\n\n            /**\n             * Gets the first token of a given element, including surrounding parentheses.\n             * @param {ASTNode} element A node in the `elements` list\n             * @returns {Token} The first token of this element\n             */\n            function getFirstToken(element) {\n                let token = sourceCode.getTokenBefore(element);\n\n                while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n                    token = sourceCode.getTokenBefore(token);\n                }\n                return sourceCode.getTokenAfter(token);\n            }\n\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n            offsets.setDesiredOffsets(\n                [startToken.range[1], endToken.range[0]],\n                startToken,\n                typeof offset === \"number\" ? offset : 1\n            );\n            offsets.setDesiredOffset(endToken, startToken, 0);\n\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n            if (offset === \"first\" && elements.length && !elements[0]) {\n                return;\n            }\n            elements.forEach((element, index) => {\n                if (!element) {\n\n                    // Skip holes in arrays\n                    return;\n                }\n                if (offset === \"off\") {\n\n                    // Ignore the first token of every element if the \"off\" option is used\n                    offsets.ignoreToken(getFirstToken(element));\n                }\n\n                // Offset the following elements correctly relative to the first element\n                if (index === 0) {\n                    return;\n                }\n                if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n                } else {\n                    const previousElement = elements[index - 1];\n                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n                    const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n\n                    if (\n                        previousElement &&\n                        previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line\n                    ) {\n                        offsets.setDesiredOffsets(\n                            [previousElement.range[1], element.range[1]],\n                            firstTokenOfPreviousElement,\n                            0\n                        );\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function addBlocklessNodeIndent(node) {\n            if (node.type !== \"BlockStatement\") {\n                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n\n                let firstBodyToken = sourceCode.getFirstToken(node);\n                let lastBodyToken = sourceCode.getLastToken(node);\n\n                while (\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&\n                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))\n                ) {\n                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n                }\n\n                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n            }\n        }\n\n        /**\n         * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n         * @param {ASTNode} node A CallExpression or NewExpression node\n         * @returns {void}\n         */\n        function addFunctionCallIndent(node) {\n            let openingParen;\n\n            if (node.arguments.length) {\n                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n            } else {\n                openingParen = sourceCode.getLastToken(node, 1);\n            }\n            const closingParen = sourceCode.getLastToken(node);\n\n            parameterParens.add(openingParen);\n            parameterParens.add(closingParen);\n\n            /*\n             * If `?.` token exists, set desired offset for that.\n             * This logic is copied from `MemberExpression`'s.\n             */\n            if (node.optional) {\n                const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\n                const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: astUtils.isClosingParenToken }).length;\n                const firstTokenOfCallee = calleeParenCount\n                    ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 })\n                    : sourceCode.getFirstToken(node.callee);\n                const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\n                const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line\n                    ? lastTokenOfCallee\n                    : firstTokenOfCallee;\n\n                offsets.setDesiredOffset(dotToken, offsetBase, 1);\n            }\n\n            const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\n            const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\n\n            offsets.setDesiredOffset(openingParen, offsetToken, 0);\n\n            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n        }\n\n        /**\n         * Checks the indentation of parenthesized values, given a list of tokens in a program\n         * @param {Token[]} tokens A list of tokens\n         * @returns {void}\n         */\n        function addParensIndent(tokens) {\n            const parenStack = [];\n            const parenPairs = [];\n\n            for (let i = 0; i < tokens.length; i++) {\n                const nextToken = tokens[i];\n\n                if (astUtils.isOpeningParenToken(nextToken)) {\n                    parenStack.push(nextToken);\n                } else if (astUtils.isClosingParenToken(nextToken)) {\n                    parenPairs.push({ left: parenStack.pop(), right: nextToken });\n                }\n            }\n\n            for (let i = parenPairs.length - 1; i >= 0; i--) {\n                const leftParen = parenPairs[i].left;\n                const rightParen = parenPairs[i].right;\n\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n\n                    parenthesizedTokens.forEach(token => {\n                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n                            offsets.setDesiredOffset(token, leftParen, 1);\n                        }\n                    });\n                }\n\n                offsets.setDesiredOffset(rightParen, leftParen, 0);\n            }\n        }\n\n        /**\n         * Ignore all tokens within an unknown node whose offset do not depend\n         * on another token's offset within the unknown node\n         * @param {ASTNode} node Unknown Node\n         * @returns {void}\n         */\n        function ignoreNode(node) {\n            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));\n\n            unknownNodeTokens.forEach(token => {\n                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n                    if (token === firstTokenOfLine) {\n                        offsets.ignoreToken(token);\n                    } else {\n                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check whether the given token is on the first line of a statement.\n         * @param {Token} token The token to check.\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\n         * @returns {boolean} `true` if the token is on the first line of a statement.\n         */\n        function isOnFirstLineOfStatement(token, leafNode) {\n            let node = leafNode;\n\n            while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n                node = node.parent;\n            }\n            node = node.parent;\n\n            return !node || node.loc.start.line === token.loc.start.line;\n        }\n\n        /**\n         * Check whether there are any blank (whitespace-only) lines between\n         * two tokens on separate lines.\n         * @param {Token} firstToken The first token.\n         * @param {Token} secondToken The second token.\n         * @returns {boolean} `true` if the tokens are on separate lines and\n         *   there exists a blank line between them, `false` otherwise.\n         */\n        function hasBlankLinesBetween(firstToken, secondToken) {\n            const firstTokenLine = firstToken.loc.end.line;\n            const secondTokenLine = secondToken.loc.start.line;\n\n            if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n                return false;\n            }\n\n            for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n                if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        const ignoredNodeFirstTokens = new Set();\n\n        const baseOffsetListeners = {\n            \"ArrayExpression, ArrayPattern\"(node) {\n                const openingBracket = sourceCode.getFirstToken(node);\n                const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);\n\n                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n            },\n\n            \"ObjectExpression, ObjectPattern\"(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getTokenAfter(\n                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,\n                    astUtils.isClosingBraceToken\n                );\n\n                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n            },\n\n            ArrowFunctionExpression(node) {\n                const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });\n\n                if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\n                    const openingParen = maybeOpeningParen;\n                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n\n                    parameterParens.add(openingParen);\n                    parameterParens.add(closingParen);\n                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n                }\n\n                addBlocklessNodeIndent(node.body);\n            },\n\n            AssignmentExpression(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n            },\n\n            \"BinaryExpression, LogicalExpression\"(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                /*\n                 * For backwards compatibility, don't check BinaryExpression indents, e.g.\n                 * var foo = bar &&\n                 *                   baz;\n                 */\n\n                const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(tokenAfterOperator);\n                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n            },\n\n            \"BlockStatement, ClassBody\"(node) {\n                let blockIndentLevel;\n\n                if (node.parent && isOuterIIFE(node.parent)) {\n                    blockIndentLevel = options.outerIIFEBody;\n                } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n                    blockIndentLevel = options.FunctionExpression.body;\n                } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n                    blockIndentLevel = options.FunctionDeclaration.body;\n                } else {\n                    blockIndentLevel = 1;\n                }\n\n                /*\n                 * For blocks that aren't lone statements, ensure that the opening curly brace\n                 * is aligned with the parent.\n                 */\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n                }\n\n                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n            },\n\n            CallExpression: addFunctionCallIndent,\n\n            \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n                const classToken = sourceCode.getFirstToken(node);\n                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n\n                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n            },\n\n            ConditionalExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // `flatTernaryExpressions` option is for the following style:\n                // var a =\n                //     foo > 0 ? bar :\n                //     foo < 0 ? baz :\n                //     /*else*/ qiz ;\n                if (!options.flatTernaryExpressions ||\n                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||\n                    isOnFirstLineOfStatement(firstToken, node)\n                ) {\n                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n\n                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n\n                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n                    offsets.setDesiredOffset(colonToken, firstToken, 1);\n\n                    offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === \"Punctuator\" &&\n                        options.offsetTernaryExpressions ? 2 : 1);\n\n                    /*\n                     * The alternate and the consequent should usually have the same indentation.\n                     * If they share part of a line, align the alternate against the first token of the consequent.\n                     * This allows the alternate to be indented correctly in cases like this:\n                     * foo ? (\n                     *   bar\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\n                     * )\n                     */\n                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n                    } else {\n\n                        /**\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\n                         * token of the conditional expression. For example:\n                         * foo ? bar\n                         *   : baz\n                         *\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n                         * having no expected indentation.\n                         */\n                        offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === \"Punctuator\" &&\n                            options.offsetTernaryExpressions ? 2 : 1);\n                    }\n                }\n            },\n\n            \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement\": node => addBlocklessNodeIndent(node.body),\n\n            ExportNamedDeclaration(node) {\n                if (node.declaration === null) {\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    // Indent the specifiers in `export {foo, bar, baz}`\n                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);\n\n                    if (node.source) {\n\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n                    }\n                }\n            },\n\n            ForStatement(node) {\n                const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n                if (node.init) {\n                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n                }\n                if (node.test) {\n                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n                }\n                if (node.update) {\n                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n                }\n                addBlocklessNodeIndent(node.body);\n            },\n\n            \"FunctionDeclaration, FunctionExpression\"(node) {\n                const closingParen = sourceCode.getTokenBefore(node.body);\n                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n            },\n\n            IfStatement(node) {\n                addBlocklessNodeIndent(node.consequent);\n                if (node.alternate) {\n                    addBlocklessNodeIndent(node.alternate);\n                }\n            },\n\n            /*\n             * For blockless nodes with semicolon-first style, don't indent the semicolon.\n             * e.g.\n             * if (foo)\n             *     bar()\n             * ; [1, 2, 3].map(foo)\n             *\n             * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.\n             */\n            \":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit\"(node) {\n                let nodesToCheck;\n\n                if (node.type === \"IfStatement\") {\n                    nodesToCheck = [node.consequent];\n                    if (node.alternate) {\n                        nodesToCheck.push(node.alternate);\n                    }\n                } else {\n                    nodesToCheck = [node.body];\n                }\n\n                for (const nodeToCheck of nodesToCheck) {\n                    const lastToken = sourceCode.getLastToken(nodeToCheck);\n\n                    if (astUtils.isSemicolonToken(lastToken)) {\n                        const tokenBeforeLast = sourceCode.getTokenBefore(lastToken);\n                        const tokenAfterLast = sourceCode.getTokenAfter(lastToken);\n\n                        // override indentation of `;` only if its line looks like a semicolon-first style line\n                        if (\n                            !astUtils.isTokenOnSameLine(tokenBeforeLast, lastToken) &&\n                            tokenAfterLast &&\n                            astUtils.isTokenOnSameLine(lastToken, tokenAfterLast)\n                        ) {\n                            offsets.setDesiredOffset(\n                                lastToken,\n                                sourceCode.getFirstToken(node),\n                                0\n                            );\n                        }\n                    }\n                }\n            },\n\n            ImportDeclaration(node) {\n                if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n                }\n\n                const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n                const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n                const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n\n                if (fromToken) {\n                    const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n\n                    offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n                }\n            },\n\n            ImportExpression(node) {\n                const openingParen = sourceCode.getFirstToken(node, 1);\n                const closingParen = sourceCode.getLastToken(node);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n\n                addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\n            },\n\n            \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n                const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n\n                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;\n                const firstObjectToken = objectParenCount\n                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })\n                    : sourceCode.getFirstToken(object);\n                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n                if (node.computed) {\n\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n                }\n\n                /*\n                 * If the object ends on the same line that the property starts, match against the last token\n                 * of the object, to ensure that the MemberExpression is not indented.\n                 *\n                 * Otherwise, match against the first token of the object, e.g.\n                 * foo\n                 *   .bar\n                 *   .baz // <-- offset by 1 from `foo`\n                 */\n                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line\n                    ? lastObjectToken\n                    : firstObjectToken;\n\n                if (typeof options.MemberExpression === \"number\") {\n\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n\n                    /*\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\n                     * Otherwise, match the first token of the property against the object.\n                     */\n                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n                } else {\n\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\n                    offsets.ignoreToken(firstNonObjectToken);\n                    offsets.ignoreToken(secondNonObjectToken);\n\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n                }\n            },\n\n            NewExpression(node) {\n\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n                if (node.arguments.length > 0 ||\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node)) &&\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n                    addFunctionCallIndent(node);\n                }\n            },\n\n            Property(node) {\n                if (!node.shorthand && !node.method && node.kind === \"init\") {\n                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n\n                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n                }\n            },\n\n            PropertyDefinition(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const maybeSemicolonToken = sourceCode.getLastToken(node);\n                let keyLastToken = null;\n\n                // Indent key.\n                if (node.computed) {\n                    const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);\n                    const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);\n                    const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];\n\n                    if (bracketTokenL !== firstToken) {\n                        offsets.setDesiredOffset(bracketTokenL, firstToken, 0);\n                    }\n                    offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);\n                    offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);\n                } else {\n                    const idToken = keyLastToken = sourceCode.getFirstToken(node.key);\n\n                    if (idToken !== firstToken) {\n                        offsets.setDesiredOffset(idToken, firstToken, 1);\n                    }\n                }\n\n                // Indent initializer.\n                if (node.value) {\n                    const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);\n                    const valueToken = sourceCode.getTokenAfter(eqToken);\n\n                    offsets.setDesiredOffset(eqToken, keyLastToken, 1);\n                    offsets.setDesiredOffset(valueToken, eqToken, 1);\n                    if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n                        offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);\n                    }\n                } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n                    offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);\n                }\n            },\n\n            StaticBlock(node) {\n                const openingCurly = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\n                const closingCurly = sourceCode.getLastToken(node);\n\n                addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);\n            },\n\n            SwitchStatement(node) {\n                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n                if (node.cases.length) {\n                    sourceCode.getTokensBetween(\n                        node.cases[node.cases.length - 1],\n                        closingCurly,\n                        { includeComments: true, filter: astUtils.isCommentToken }\n                    ).forEach(token => offsets.ignoreToken(token));\n                }\n            },\n\n            SwitchCase(node) {\n                if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n                    const caseKeyword = sourceCode.getFirstToken(node);\n                    const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n\n                    offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n                }\n            },\n\n            TemplateLiteral(node) {\n                node.expressions.forEach((expression, index) => {\n                    const previousQuasi = node.quasis[index];\n                    const nextQuasi = node.quasis[index + 1];\n                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line\n                        ? sourceCode.getFirstToken(previousQuasi)\n                        : null;\n\n                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n                });\n            },\n\n            VariableDeclaration(node) {\n                let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind)\n                    ? options.VariableDeclarator[node.kind]\n                    : DEFAULT_VARIABLE_INDENT;\n\n                const firstToken = sourceCode.getFirstToken(node),\n                    lastToken = sourceCode.getLastToken(node);\n\n                if (options.VariableDeclarator[node.kind] === \"first\") {\n                    if (node.declarations.length > 1) {\n                        addElementListIndent(\n                            node.declarations,\n                            firstToken,\n                            lastToken,\n                            \"first\"\n                        );\n                        return;\n                    }\n\n                    variableIndent = DEFAULT_VARIABLE_INDENT;\n                }\n\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n\n                    /*\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n                     * the following indentations are correct:\n                     *\n                     * var foo = {\n                     *   ok: true\n                     * };\n                     *\n                     * var foo = {\n                     *     ok: true,\n                     *   },\n                     *   bar = 1;\n                     *\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\n                     * on the same line as the start of the declaration, provided that there are declarators that\n                     * follow this one.\n                     */\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n                } else {\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n                }\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    offsets.ignoreToken(lastToken);\n                }\n            },\n\n            VariableDeclarator(node) {\n                if (node.init) {\n                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n\n                    offsets.ignoreToken(equalOperator);\n                    offsets.ignoreToken(tokenAfterOperator);\n                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n                }\n            },\n\n            \"JSXAttribute[value]\"(node) {\n                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n\n                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n            },\n\n            JSXElement(node) {\n                if (node.closingElement) {\n                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n                }\n            },\n\n            JSXOpeningElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                let closingToken;\n\n                if (node.selfClosing) {\n                    closingToken = sourceCode.getLastToken(node, { skip: 1 });\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n                } else {\n                    closingToken = sourceCode.getLastToken(node);\n                }\n                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n                addElementListIndent(node.attributes, firstToken, closingToken, 1);\n            },\n\n            JSXClosingElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n            },\n\n            JSXFragment(node) {\n                const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\n                const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\n\n                addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\n            },\n\n            JSXOpeningFragment(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const closingToken = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\n                offsets.matchOffsetOf(firstToken, closingToken);\n            },\n\n            JSXClosingFragment(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const slashToken = sourceCode.getLastToken(node, { skip: 1 });\n                const closingToken = sourceCode.getLastToken(node);\n                const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\n\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\n                offsets.matchOffsetOf(firstToken, tokenToMatch);\n            },\n\n            JSXExpressionContainer(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            JSXSpreadAttribute(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            \"*\"(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // Ensure that the children of every node are indented at least as much as the first token.\n                if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n                    offsets.setDesiredOffsets(node.range, firstToken, 0);\n                }\n            }\n        };\n\n        const listenerCallQueue = [];\n\n        /*\n         * To ignore the indentation of a node:\n         * 1. Don't call the node's listener when entering it (if it has a listener)\n         * 2. Don't set any offsets against the first token of the node.\n         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\n         */\n        const offsetListeners = {};\n\n        for (const [selector, listener] of Object.entries(baseOffsetListeners)) {\n\n            /*\n             * Offset listener calls are deferred until traversal is finished, and are called as\n             * part of the final `Program:exit` listener. This is necessary because a node might\n             * be matched by multiple selectors.\n             *\n             * Example: Suppose there is an offset listener for `Identifier`, and the user has\n             * specified in configuration that `MemberExpression > Identifier` should be ignored.\n             * Due to selector specificity rules, the `Identifier` listener will get called first. However,\n             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\n             * should not have been called at all. Without doing extra selector matching, we don't know\n             * whether the Identifier matches the `MemberExpression > Identifier` selector until the\n             * `MemberExpression > Identifier` listener is called.\n             *\n             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\n             * ignored nodes are known.\n             */\n            offsetListeners[selector] = node => listenerCallQueue.push({ listener, node });\n        }\n\n        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n        const ignoredNodes = new Set();\n\n        /**\n         * Ignores a node\n         * @param {ASTNode} node The node to ignore\n         * @returns {void}\n         */\n        function addToIgnoredNodes(node) {\n            ignoredNodes.add(node);\n            ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n        }\n\n        const ignoredNodeListeners = options.ignoredNodes.reduce(\n            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),\n            {}\n        );\n\n        /*\n         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\n         * at the end.\n         *\n         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\n         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\n         * so those listeners wouldn't be called anyway.\n         */\n        return Object.assign(\n            offsetListeners,\n            ignoredNodeListeners,\n            {\n                \"*:exit\"(node) {\n\n                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n                    if (!KNOWN_NODES.has(node.type)) {\n                        addToIgnoredNodes(node);\n                    }\n                },\n                \"Program:exit\"() {\n\n                    // If ignoreComments option is enabled, ignore all comment tokens.\n                    if (options.ignoreComments) {\n                        sourceCode.getAllComments()\n                            .forEach(comment => offsets.ignoreToken(comment));\n                    }\n\n                    // Invoke the queued offset listeners for the nodes that aren't ignored.\n                    for (let i = 0; i < listenerCallQueue.length; i++) {\n                        const nodeInfo = listenerCallQueue[i];\n\n                        if (!ignoredNodes.has(nodeInfo.node)) {\n                            nodeInfo.listener(nodeInfo.node);\n                        }\n                    }\n\n                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n                    ignoredNodes.forEach(ignoreNode);\n\n                    addParensIndent(sourceCode.ast.tokens);\n\n                    /*\n                     * Create a Map from (tokenOrComment) => (precedingToken).\n                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n                     */\n                    const precedingTokens = new WeakMap();\n\n                    for (let i = 0; i < sourceCode.ast.comments.length; i++) {\n                        const comment = sourceCode.ast.comments[i];\n\n                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n                        const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;\n\n                        precedingTokens.set(comment, hasToken);\n                    }\n\n                    for (let i = 1; i < sourceCode.lines.length + 1; i++) {\n\n                        if (!tokenInfo.firstTokensByLineNumber.has(i)) {\n\n                            // Don't check indentation on blank lines\n                            continue;\n                        }\n\n                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i);\n\n                        if (firstTokenOfLine.loc.start.line !== i) {\n\n                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n                            continue;\n                        }\n\n                        if (astUtils.isCommentToken(firstTokenOfLine)) {\n                            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n                            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n                            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n\n                            /*\n                             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.\n                             *\n                             * let foo\n                             * // comment\n                             * ;(async () => {})()\n                             */\n                            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\n                                offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\n                            }\n\n                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n                            if (\n                                mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||\n                                mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))\n                            ) {\n                                continue;\n                            }\n                        }\n\n                        // If the token matches the expected indentation, don't report it.\n                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n                            continue;\n                        }\n\n                        // Otherwise, report the token/comment.\n                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n                    }\n                }\n            }\n        );\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}