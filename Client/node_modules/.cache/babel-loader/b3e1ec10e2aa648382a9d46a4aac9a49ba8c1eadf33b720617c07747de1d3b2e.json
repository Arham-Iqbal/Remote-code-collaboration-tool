{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst boundaries_1 = require(\"./boundaries\");\n// BreakTypes\n// @type {BreakType}\nconst NotBreak = 0;\nconst BreakStart = 1;\nconst Break = 2;\nconst BreakLastRegional = 3;\nconst BreakPenultimateRegional = 4;\nclass GraphemerHelper {\n  /**\n   * Check if the the character at the position {pos} of the string is surrogate\n   * @param str {string}\n   * @param pos {number}\n   * @returns {boolean}\n   */\n  static isSurrogate(str, pos) {\n    return 0xd800 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 0xdbff && 0xdc00 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 0xdfff;\n  }\n  /**\n   * The String.prototype.codePointAt polyfill\n   * Private function, gets a Unicode code point from a JavaScript UTF-16 string\n   * handling surrogate pairs appropriately\n   * @param str {string}\n   * @param idx {number}\n   * @returns {number}\n   */\n  static codePointAt(str, idx) {\n    if (idx === undefined) {\n      idx = 0;\n    }\n    const code = str.charCodeAt(idx);\n    // if a high surrogate\n    if (0xd800 <= code && code <= 0xdbff && idx < str.length - 1) {\n      const hi = code;\n      const low = str.charCodeAt(idx + 1);\n      if (0xdc00 <= low && low <= 0xdfff) {\n        return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;\n      }\n      return hi;\n    }\n    // if a low surrogate\n    if (0xdc00 <= code && code <= 0xdfff && idx >= 1) {\n      const hi = str.charCodeAt(idx - 1);\n      const low = code;\n      if (0xd800 <= hi && hi <= 0xdbff) {\n        return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;\n      }\n      return low;\n    }\n    // just return the char if an unmatched surrogate half or a\n    // single-char codepoint\n    return code;\n  }\n  //\n  /**\n   * Private function, returns whether a break is allowed between the two given grapheme breaking classes\n   * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters\n   * @param start {number}\n   * @param mid {Array<number>}\n   * @param end {number}\n   * @param startEmoji {number}\n   * @param midEmoji {Array<number>}\n   * @param endEmoji {number}\n   * @returns {number}\n   */\n  static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {\n    const all = [start].concat(mid).concat([end]);\n    const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);\n    const previous = all[all.length - 2];\n    const next = end;\n    const nextEmoji = endEmoji;\n    // Lookahead terminator for:\n    // GB12. ^ (RI RI)* RI ? RI\n    // GB13. [^RI] (RI RI)* RI ? RI\n    const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);\n    if (rIIndex > 0 && all.slice(1, rIIndex).every(function (c) {\n      return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;\n    }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {\n      if (all.filter(function (c) {\n        return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;\n      }).length % 2 === 1) {\n        return BreakLastRegional;\n      } else {\n        return BreakPenultimateRegional;\n      }\n    }\n    // GB3. CR × LF\n    if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {\n      return NotBreak;\n    }\n    // GB4. (Control|CR|LF) ÷\n    else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {\n      return BreakStart;\n    }\n    // GB5. ÷ (Control|CR|LF)\n    else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {\n      return BreakStart;\n    }\n    // GB6. L × (L|V|LV|LVT)\n    else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {\n      return NotBreak;\n    }\n    // GB7. (LV|V) × (V|T)\n    else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {\n      return NotBreak;\n    }\n    // GB8. (LVT|T) × (T)\n    else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {\n      return NotBreak;\n    }\n    // GB9. × (Extend|ZWJ)\n    else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {\n      return NotBreak;\n    }\n    // GB9a. × SpacingMark\n    else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {\n      return NotBreak;\n    }\n    // GB9b. Prepend ×\n    else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {\n      return NotBreak;\n    }\n    // GB11. \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n    const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);\n    if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function (c) {\n      return c === boundaries_1.CLUSTER_BREAK.EXTEND;\n    }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {\n      return NotBreak;\n    }\n    // GB12. ^ (RI RI)* RI × RI\n    // GB13. [^RI] (RI RI)* RI × RI\n    if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {\n      return Break;\n    }\n    if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {\n      return NotBreak;\n    }\n    // GB999. Any ? Any\n    return BreakStart;\n  }\n}\nexports.default = GraphemerHelper;","map":{"version":3,"names":["Object","defineProperty","exports","value","boundaries_1","require","NotBreak","BreakStart","Break","BreakLastRegional","BreakPenultimateRegional","GraphemerHelper","isSurrogate","str","pos","charCodeAt","codePointAt","idx","undefined","code","length","hi","low","shouldBreak","start","mid","end","startEmoji","midEmoji","endEmoji","all","concat","allEmoji","previous","next","nextEmoji","rIIndex","lastIndexOf","CLUSTER_BREAK","REGIONAL_INDICATOR","slice","every","c","PREPEND","indexOf","filter","CR","LF","CONTROL","L","V","LV","LVT","T","EXTEND","ZWJ","SPACINGMARK","previousNonExtendIndex","EXTENDED_PICTOGRAPHIC","default"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/graphemer/lib/GraphemerHelper.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst boundaries_1 = require(\"./boundaries\");\n// BreakTypes\n// @type {BreakType}\nconst NotBreak = 0;\nconst BreakStart = 1;\nconst Break = 2;\nconst BreakLastRegional = 3;\nconst BreakPenultimateRegional = 4;\nclass GraphemerHelper {\n    /**\n     * Check if the the character at the position {pos} of the string is surrogate\n     * @param str {string}\n     * @param pos {number}\n     * @returns {boolean}\n     */\n    static isSurrogate(str, pos) {\n        return (0xd800 <= str.charCodeAt(pos) &&\n            str.charCodeAt(pos) <= 0xdbff &&\n            0xdc00 <= str.charCodeAt(pos + 1) &&\n            str.charCodeAt(pos + 1) <= 0xdfff);\n    }\n    /**\n     * The String.prototype.codePointAt polyfill\n     * Private function, gets a Unicode code point from a JavaScript UTF-16 string\n     * handling surrogate pairs appropriately\n     * @param str {string}\n     * @param idx {number}\n     * @returns {number}\n     */\n    static codePointAt(str, idx) {\n        if (idx === undefined) {\n            idx = 0;\n        }\n        const code = str.charCodeAt(idx);\n        // if a high surrogate\n        if (0xd800 <= code && code <= 0xdbff && idx < str.length - 1) {\n            const hi = code;\n            const low = str.charCodeAt(idx + 1);\n            if (0xdc00 <= low && low <= 0xdfff) {\n                return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;\n            }\n            return hi;\n        }\n        // if a low surrogate\n        if (0xdc00 <= code && code <= 0xdfff && idx >= 1) {\n            const hi = str.charCodeAt(idx - 1);\n            const low = code;\n            if (0xd800 <= hi && hi <= 0xdbff) {\n                return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;\n            }\n            return low;\n        }\n        // just return the char if an unmatched surrogate half or a\n        // single-char codepoint\n        return code;\n    }\n    //\n    /**\n     * Private function, returns whether a break is allowed between the two given grapheme breaking classes\n     * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters\n     * @param start {number}\n     * @param mid {Array<number>}\n     * @param end {number}\n     * @param startEmoji {number}\n     * @param midEmoji {Array<number>}\n     * @param endEmoji {number}\n     * @returns {number}\n     */\n    static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {\n        const all = [start].concat(mid).concat([end]);\n        const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);\n        const previous = all[all.length - 2];\n        const next = end;\n        const nextEmoji = endEmoji;\n        // Lookahead terminator for:\n        // GB12. ^ (RI RI)* RI ? RI\n        // GB13. [^RI] (RI RI)* RI ? RI\n        const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);\n        if (rIIndex > 0 &&\n            all.slice(1, rIIndex).every(function (c) {\n                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;\n            }) &&\n            [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {\n            if (all.filter(function (c) {\n                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;\n            }).length %\n                2 ===\n                1) {\n                return BreakLastRegional;\n            }\n            else {\n                return BreakPenultimateRegional;\n            }\n        }\n        // GB3. CR × LF\n        if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {\n            return NotBreak;\n        }\n        // GB4. (Control|CR|LF) ÷\n        else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL ||\n            previous === boundaries_1.CLUSTER_BREAK.CR ||\n            previous === boundaries_1.CLUSTER_BREAK.LF) {\n            return BreakStart;\n        }\n        // GB5. ÷ (Control|CR|LF)\n        else if (next === boundaries_1.CLUSTER_BREAK.CONTROL ||\n            next === boundaries_1.CLUSTER_BREAK.CR ||\n            next === boundaries_1.CLUSTER_BREAK.LF) {\n            return BreakStart;\n        }\n        // GB6. L × (L|V|LV|LVT)\n        else if (previous === boundaries_1.CLUSTER_BREAK.L &&\n            (next === boundaries_1.CLUSTER_BREAK.L ||\n                next === boundaries_1.CLUSTER_BREAK.V ||\n                next === boundaries_1.CLUSTER_BREAK.LV ||\n                next === boundaries_1.CLUSTER_BREAK.LVT)) {\n            return NotBreak;\n        }\n        // GB7. (LV|V) × (V|T)\n        else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) &&\n            (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {\n            return NotBreak;\n        }\n        // GB8. (LVT|T) × (T)\n        else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) &&\n            next === boundaries_1.CLUSTER_BREAK.T) {\n            return NotBreak;\n        }\n        // GB9. × (Extend|ZWJ)\n        else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {\n            return NotBreak;\n        }\n        // GB9a. × SpacingMark\n        else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {\n            return NotBreak;\n        }\n        // GB9b. Prepend ×\n        else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {\n            return NotBreak;\n        }\n        // GB11. \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n        const previousNonExtendIndex = allEmoji\n            .slice(0, -1)\n            .lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);\n        if (previousNonExtendIndex !== -1 &&\n            allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC &&\n            all.slice(previousNonExtendIndex + 1, -2).every(function (c) {\n                return c === boundaries_1.CLUSTER_BREAK.EXTEND;\n            }) &&\n            previous === boundaries_1.CLUSTER_BREAK.ZWJ &&\n            nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {\n            return NotBreak;\n        }\n        // GB12. ^ (RI RI)* RI × RI\n        // GB13. [^RI] (RI RI)* RI × RI\n        if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {\n            return Break;\n        }\n        if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR &&\n            next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {\n            return NotBreak;\n        }\n        // GB999. Any ? Any\n        return BreakStart;\n    }\n}\nexports.default = GraphemerHelper;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}