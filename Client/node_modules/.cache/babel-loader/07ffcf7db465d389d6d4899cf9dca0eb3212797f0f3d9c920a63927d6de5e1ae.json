{"ast":null,"code":"/**\n * @fileoverview Rule to disallow calls to the `Object` constructor without an argument\n * @author Francesco Trotta\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst {\n  getVariableByName,\n  isArrowToken,\n  isStartOfExpressionStatement,\n  needsPrecedingSemicolon\n} = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow calls to the `Object` constructor without an argument\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/no-object-constructor\"\n    },\n    hasSuggestions: true,\n    schema: [],\n    messages: {\n      preferLiteral: \"The object literal notation {} is preferable.\",\n      useLiteral: \"Replace with '{{replacement}}'.\",\n      useLiteralAfterSemicolon: \"Replace with '{{replacement}}', add preceding semicolon.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Determines whether or not an object literal that replaces a specified node needs to be enclosed in parentheses.\n     * @param {ASTNode} node The node to be replaced.\n     * @returns {boolean} Whether or not parentheses around the object literal are required.\n     */\n    function needsParentheses(node) {\n      if (isStartOfExpressionStatement(node)) {\n        return true;\n      }\n      const prevToken = sourceCode.getTokenBefore(node);\n      if (prevToken && isArrowToken(prevToken)) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Reports on nodes where the `Object` constructor is called without arguments.\n     * @param {ASTNode} node The node to evaluate.\n     * @returns {void}\n     */\n    function check(node) {\n      if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Object\" || node.arguments.length) {\n        return;\n      }\n      const variable = getVariableByName(sourceCode.getScope(node), \"Object\");\n      if (variable && variable.identifiers.length === 0) {\n        let replacement;\n        let fixText;\n        let messageId = \"useLiteral\";\n        if (needsParentheses(node)) {\n          replacement = \"({})\";\n          if (needsPrecedingSemicolon(sourceCode, node)) {\n            fixText = \";({})\";\n            messageId = \"useLiteralAfterSemicolon\";\n          } else {\n            fixText = \"({})\";\n          }\n        } else {\n          replacement = fixText = \"{}\";\n        }\n        context.report({\n          node,\n          messageId: \"preferLiteral\",\n          suggest: [{\n            messageId,\n            data: {\n              replacement\n            },\n            fix: fixer => fixer.replaceText(node, fixText)\n          }]\n        });\n      }\n    }\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n};","map":{"version":3,"names":["getVariableByName","isArrowToken","isStartOfExpressionStatement","needsPrecedingSemicolon","require","module","exports","meta","type","docs","description","recommended","url","hasSuggestions","schema","messages","preferLiteral","useLiteral","useLiteralAfterSemicolon","create","context","sourceCode","needsParentheses","node","prevToken","getTokenBefore","check","callee","name","arguments","length","variable","getScope","identifiers","replacement","fixText","messageId","report","suggest","data","fix","fixer","replaceText","CallExpression","NewExpression"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-object-constructor.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow calls to the `Object` constructor without an argument\n * @author Francesco Trotta\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    getVariableByName,\n    isArrowToken,\n    isStartOfExpressionStatement,\n    needsPrecedingSemicolon\n} = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow calls to the `Object` constructor without an argument\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-object-constructor\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            preferLiteral: \"The object literal notation {} is preferable.\",\n            useLiteral: \"Replace with '{{replacement}}'.\",\n            useLiteralAfterSemicolon: \"Replace with '{{replacement}}', add preceding semicolon.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether or not an object literal that replaces a specified node needs to be enclosed in parentheses.\n         * @param {ASTNode} node The node to be replaced.\n         * @returns {boolean} Whether or not parentheses around the object literal are required.\n         */\n        function needsParentheses(node) {\n            if (isStartOfExpressionStatement(node)) {\n                return true;\n            }\n\n            const prevToken = sourceCode.getTokenBefore(node);\n\n            if (prevToken && isArrowToken(prevToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports on nodes where the `Object` constructor is called without arguments.\n         * @param {ASTNode} node The node to evaluate.\n         * @returns {void}\n         */\n        function check(node) {\n            if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Object\" || node.arguments.length) {\n                return;\n            }\n\n            const variable = getVariableByName(sourceCode.getScope(node), \"Object\");\n\n            if (variable && variable.identifiers.length === 0) {\n                let replacement;\n                let fixText;\n                let messageId = \"useLiteral\";\n\n                if (needsParentheses(node)) {\n                    replacement = \"({})\";\n                    if (needsPrecedingSemicolon(sourceCode, node)) {\n                        fixText = \";({})\";\n                        messageId = \"useLiteralAfterSemicolon\";\n                    } else {\n                        fixText = \"({})\";\n                    }\n                } else {\n                    replacement = fixText = \"{}\";\n                }\n\n                context.report({\n                    node,\n                    messageId: \"preferLiteral\",\n                    suggest: [\n                        {\n                            messageId,\n                            data: { replacement },\n                            fix: fixer => fixer.replaceText(node, fixText)\n                        }\n                    ]\n                });\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAM;EACFA,iBAAiB;EACjBC,YAAY;EACZC,4BAA4B;EAC5BC;AACJ,CAAC,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAEhC;AACA;AACA;;AAEA;AACAC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YAAY;IAElBC,IAAI,EAAE;MACFC,WAAW,EAAE,gEAAgE;MAC7EC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,cAAc,EAAE,IAAI;IAEpBC,MAAM,EAAE,EAAE;IAEVC,QAAQ,EAAE;MACNC,aAAa,EAAE,+CAA+C;MAC9DC,UAAU,EAAE,iCAAiC;MAC7CC,wBAAwB,EAAE;IAC9B;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IAEZ,MAAMC,UAAU,GAAGD,OAAO,CAACC,UAAU;;IAErC;AACR;AACA;AACA;AACA;IACQ,SAASC,gBAAgBA,CAACC,IAAI,EAAE;MAC5B,IAAIrB,4BAA4B,CAACqB,IAAI,CAAC,EAAE;QACpC,OAAO,IAAI;MACf;MAEA,MAAMC,SAAS,GAAGH,UAAU,CAACI,cAAc,CAACF,IAAI,CAAC;MAEjD,IAAIC,SAAS,IAAIvB,YAAY,CAACuB,SAAS,CAAC,EAAE;QACtC,OAAO,IAAI;MACf;MAEA,OAAO,KAAK;IAChB;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASE,KAAKA,CAACH,IAAI,EAAE;MACjB,IAAIA,IAAI,CAACI,MAAM,CAACnB,IAAI,KAAK,YAAY,IAAIe,IAAI,CAACI,MAAM,CAACC,IAAI,KAAK,QAAQ,IAAIL,IAAI,CAACM,SAAS,CAACC,MAAM,EAAE;QAC7F;MACJ;MAEA,MAAMC,QAAQ,GAAG/B,iBAAiB,CAACqB,UAAU,CAACW,QAAQ,CAACT,IAAI,CAAC,EAAE,QAAQ,CAAC;MAEvE,IAAIQ,QAAQ,IAAIA,QAAQ,CAACE,WAAW,CAACH,MAAM,KAAK,CAAC,EAAE;QAC/C,IAAII,WAAW;QACf,IAAIC,OAAO;QACX,IAAIC,SAAS,GAAG,YAAY;QAE5B,IAAId,gBAAgB,CAACC,IAAI,CAAC,EAAE;UACxBW,WAAW,GAAG,MAAM;UACpB,IAAI/B,uBAAuB,CAACkB,UAAU,EAAEE,IAAI,CAAC,EAAE;YAC3CY,OAAO,GAAG,OAAO;YACjBC,SAAS,GAAG,0BAA0B;UAC1C,CAAC,MAAM;YACHD,OAAO,GAAG,MAAM;UACpB;QACJ,CAAC,MAAM;UACHD,WAAW,GAAGC,OAAO,GAAG,IAAI;QAChC;QAEAf,OAAO,CAACiB,MAAM,CAAC;UACXd,IAAI;UACJa,SAAS,EAAE,eAAe;UAC1BE,OAAO,EAAE,CACL;YACIF,SAAS;YACTG,IAAI,EAAE;cAAEL;YAAY,CAAC;YACrBM,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAW,CAACnB,IAAI,EAAEY,OAAO;UACjD,CAAC;QAET,CAAC,CAAC;MACN;IACJ;IAEA,OAAO;MACHQ,cAAc,EAAEjB,KAAK;MACrBkB,aAAa,EAAElB;IACnB,CAAC;EAEL;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}