{"ast":null,"code":"/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n  const directives = [];\n  for (let i = 0; i < statements.length; i++) {\n    const statement = statements[i];\n    if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && statement.expression.value === \"use strict\") {\n      directives[i] = statement;\n    } else {\n      break;\n    }\n  }\n  return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n * @param {ASTNode} node A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n  return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n * @param {ASTNode[]} params A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n  return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require or disallow strict mode directives\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/strict\"\n    },\n    schema: [{\n      enum: [\"never\", \"global\", \"function\", \"safe\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      function: \"Use the function form of 'use strict'.\",\n      global: \"Use the global form of 'use strict'.\",\n      multiple: \"Multiple 'use strict' directives.\",\n      never: \"Strict mode is not permitted.\",\n      unnecessary: \"Unnecessary 'use strict' directive.\",\n      module: \"'use strict' is unnecessary inside of modules.\",\n      implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n      unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n      nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n      wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n    }\n  },\n  create(context) {\n    const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n      scopes = [],\n      classScopes = [];\n    let mode = context.options[0] || \"safe\";\n    if (ecmaFeatures.impliedStrict) {\n      mode = \"implied\";\n    } else if (mode === \"safe\") {\n      mode = ecmaFeatures.globalReturn || context.languageOptions.sourceType === \"commonjs\" ? \"global\" : \"function\";\n    }\n\n    /**\n     * Determines whether a reported error should be fixed, depending on the error type.\n     * @param {string} errorType The type of error\n     * @returns {boolean} `true` if the reported error should be fixed\n     */\n    function shouldFix(errorType) {\n      return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n    }\n\n    /**\n     * Gets a fixer function to remove a given 'use strict' directive.\n     * @param {ASTNode} node The directive that should be removed\n     * @returns {Function} A fixer function\n     */\n    function getFixFunction(node) {\n      return fixer => fixer.remove(node);\n    }\n\n    /**\n     * Report a slice of an array of nodes with a given message.\n     * @param {ASTNode[]} nodes Nodes.\n     * @param {string} start Index to start from.\n     * @param {string} end Index to end before.\n     * @param {string} messageId Message to display.\n     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n     * @returns {void}\n     */\n    function reportSlice(nodes, start, end, messageId, fix) {\n      nodes.slice(start, end).forEach(node => {\n        context.report({\n          node,\n          messageId,\n          fix: fix ? getFixFunction(node) : null\n        });\n      });\n    }\n\n    /**\n     * Report all nodes in an array with a given message.\n     * @param {ASTNode[]} nodes Nodes.\n     * @param {string} messageId Message id to display.\n     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n     * @returns {void}\n     */\n    function reportAll(nodes, messageId, fix) {\n      reportSlice(nodes, 0, nodes.length, messageId, fix);\n    }\n\n    /**\n     * Report all nodes in an array, except the first, with a given message.\n     * @param {ASTNode[]} nodes Nodes.\n     * @param {string} messageId Message id to display.\n     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n     * @returns {void}\n     */\n    function reportAllExceptFirst(nodes, messageId, fix) {\n      reportSlice(nodes, 1, nodes.length, messageId, fix);\n    }\n\n    /**\n     * Entering a function in 'function' mode pushes a new nested scope onto the\n     * stack. The new scope is true if the nested function is strict mode code.\n     * @param {ASTNode} node The function declaration or expression.\n     * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n     * @returns {void}\n     */\n    function enterFunctionInFunctionMode(node, useStrictDirectives) {\n      const isInClass = classScopes.length > 0,\n        isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n        isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n        isStrict = useStrictDirectives.length > 0;\n      if (isStrict) {\n        if (!isSimpleParameterList(node.params)) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"nonSimpleParameterList\"\n          });\n        } else if (isParentStrict) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"unnecessary\",\n            fix: getFixFunction(useStrictDirectives[0])\n          });\n        } else if (isInClass) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"unnecessaryInClasses\",\n            fix: getFixFunction(useStrictDirectives[0])\n          });\n        }\n        reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n      } else if (isParentGlobal) {\n        if (isSimpleParameterList(node.params)) {\n          context.report({\n            node,\n            messageId: \"function\"\n          });\n        } else {\n          context.report({\n            node,\n            messageId: \"wrap\",\n            data: {\n              name: astUtils.getFunctionNameWithKind(node)\n            }\n          });\n        }\n      }\n      scopes.push(isParentStrict || isStrict);\n    }\n\n    /**\n     * Exiting a function in 'function' mode pops its scope off the stack.\n     * @returns {void}\n     */\n    function exitFunctionInFunctionMode() {\n      scopes.pop();\n    }\n\n    /**\n     * Enter a function and either:\n     * - Push a new nested scope onto the stack (in 'function' mode).\n     * - Report all the Use Strict Directives (in the other modes).\n     * @param {ASTNode} node The function declaration or expression.\n     * @returns {void}\n     */\n    function enterFunction(node) {\n      const isBlock = node.body.type === \"BlockStatement\",\n        useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];\n      if (mode === \"function\") {\n        enterFunctionInFunctionMode(node, useStrictDirectives);\n      } else if (useStrictDirectives.length > 0) {\n        if (isSimpleParameterList(node.params)) {\n          reportAll(useStrictDirectives, mode, shouldFix(mode));\n        } else {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"nonSimpleParameterList\"\n          });\n          reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n        }\n      }\n    }\n    const rule = {\n      Program(node) {\n        const useStrictDirectives = getUseStrictDirectives(node.body);\n        if (node.sourceType === \"module\") {\n          mode = \"module\";\n        }\n        if (mode === \"global\") {\n          if (node.body.length > 0 && useStrictDirectives.length === 0) {\n            context.report({\n              node,\n              messageId: \"global\"\n            });\n          }\n          reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n        } else {\n          reportAll(useStrictDirectives, mode, shouldFix(mode));\n        }\n      },\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction\n    };\n    if (mode === \"function\") {\n      Object.assign(rule, {\n        // Inside of class bodies are always strict mode.\n        ClassBody() {\n          classScopes.push(true);\n        },\n        \"ClassBody:exit\"() {\n          classScopes.pop();\n        },\n        \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n        \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n        \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n      });\n    }\n    return rule;\n  }\n};","map":{"version":3,"names":["astUtils","require","getUseStrictDirectives","statements","directives","i","length","statement","type","expression","value","isSimpleParameter","node","isSimpleParameterList","params","every","module","exports","meta","docs","description","recommended","url","schema","enum","fixable","messages","function","global","multiple","never","unnecessary","implied","unnecessaryInClasses","nonSimpleParameterList","wrap","create","context","ecmaFeatures","parserOptions","scopes","classScopes","mode","options","impliedStrict","globalReturn","languageOptions","sourceType","shouldFix","errorType","getFixFunction","fixer","remove","reportSlice","nodes","start","end","messageId","fix","slice","forEach","report","reportAll","reportAllExceptFirst","enterFunctionInFunctionMode","useStrictDirectives","isInClass","isParentGlobal","isParentStrict","isStrict","data","name","getFunctionNameWithKind","push","exitFunctionInFunctionMode","pop","enterFunction","isBlock","body","rule","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","Object","assign","ClassBody","ClassBody:exit"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/strict.js"],"sourcesContent":["/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n * @param {ASTNode} node A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n * @param {ASTNode[]} params A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n    return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require or disallow strict mode directives\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/strict\"\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            function: \"Use the function form of 'use strict'.\",\n            global: \"Use the global form of 'use strict'.\",\n            multiple: \"Multiple 'use strict' directives.\",\n            never: \"Strict mode is not permitted.\",\n            unnecessary: \"Unnecessary 'use strict' directive.\",\n            module: \"'use strict' is unnecessary inside of modules.\",\n            implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n            unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n            nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n            wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n        }\n    },\n\n    create(context) {\n\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n            scopes = [],\n            classScopes = [];\n        let mode = context.options[0] || \"safe\";\n\n        if (ecmaFeatures.impliedStrict) {\n            mode = \"implied\";\n        } else if (mode === \"safe\") {\n            mode = ecmaFeatures.globalReturn || context.languageOptions.sourceType === \"commonjs\" ? \"global\" : \"function\";\n        }\n\n        /**\n         * Determines whether a reported error should be fixed, depending on the error type.\n         * @param {string} errorType The type of error\n         * @returns {boolean} `true` if the reported error should be fixed\n         */\n        function shouldFix(errorType) {\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n        }\n\n        /**\n         * Gets a fixer function to remove a given 'use strict' directive.\n         * @param {ASTNode} node The directive that should be removed\n         * @returns {Function} A fixer function\n         */\n        function getFixFunction(node) {\n            return fixer => fixer.remove(node);\n        }\n\n        /**\n         * Report a slice of an array of nodes with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} start Index to start from.\n         * @param {string} end Index to end before.\n         * @param {string} messageId Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportSlice(nodes, start, end, messageId, fix) {\n            nodes.slice(start, end).forEach(node => {\n                context.report({ node, messageId, fix: fix ? getFixFunction(node) : null });\n            });\n        }\n\n        /**\n         * Report all nodes in an array with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAll(nodes, messageId, fix) {\n            reportSlice(nodes, 0, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Report all nodes in an array, except the first, with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAllExceptFirst(nodes, messageId, fix) {\n            reportSlice(nodes, 1, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Entering a function in 'function' mode pushes a new nested scope onto the\n         * stack. The new scope is true if the nested function is strict mode code.\n         * @param {ASTNode} node The function declaration or expression.\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n         * @returns {void}\n         */\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\n            const isInClass = classScopes.length > 0,\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n                isStrict = useStrictDirectives.length > 0;\n\n            if (isStrict) {\n                if (!isSimpleParameterList(node.params)) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                } else if (isParentStrict) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessary\", fix: getFixFunction(useStrictDirectives[0]) });\n                } else if (isInClass) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessaryInClasses\", fix: getFixFunction(useStrictDirectives[0]) });\n                }\n\n                reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n            } else if (isParentGlobal) {\n                if (isSimpleParameterList(node.params)) {\n                    context.report({ node, messageId: \"function\" });\n                } else {\n                    context.report({\n                        node,\n                        messageId: \"wrap\",\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\n                    });\n                }\n            }\n\n            scopes.push(isParentStrict || isStrict);\n        }\n\n        /**\n         * Exiting a function in 'function' mode pops its scope off the stack.\n         * @returns {void}\n         */\n        function exitFunctionInFunctionMode() {\n            scopes.pop();\n        }\n\n        /**\n         * Enter a function and either:\n         * - Push a new nested scope onto the stack (in 'function' mode).\n         * - Report all the Use Strict Directives (in the other modes).\n         * @param {ASTNode} node The function declaration or expression.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const isBlock = node.body.type === \"BlockStatement\",\n                useStrictDirectives = isBlock\n                    ? getUseStrictDirectives(node.body.body) : [];\n\n            if (mode === \"function\") {\n                enterFunctionInFunctionMode(node, useStrictDirectives);\n            } else if (useStrictDirectives.length > 0) {\n                if (isSimpleParameterList(node.params)) {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                } else {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                }\n            }\n        }\n\n        const rule = {\n            Program(node) {\n                const useStrictDirectives = getUseStrictDirectives(node.body);\n\n                if (node.sourceType === \"module\") {\n                    mode = \"module\";\n                }\n\n                if (mode === \"global\") {\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\n                        context.report({ node, messageId: \"global\" });\n                    }\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                } else {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                }\n            },\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction\n        };\n\n        if (mode === \"function\") {\n            Object.assign(rule, {\n\n                // Inside of class bodies are always strict mode.\n                ClassBody() {\n                    classScopes.push(true);\n                },\n                \"ClassBody:exit\"() {\n                    classScopes.pop();\n                },\n\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n            });\n        }\n\n        return rule;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}