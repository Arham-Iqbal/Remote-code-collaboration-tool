{"ast":null,"code":"/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst regexpp = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst regExpParser = new regexpp.RegExpParser();\nconst DOUBLE_SPACE = / {2}/u;\n\n/**\n * Check if node is a string\n * @param {ASTNode} node node to evaluate\n * @returns {boolean} True if its a string\n * @private\n */\nfunction isString(node) {\n  return node && node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow multiple spaces in regular expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/latest/rules/no-regex-spaces\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.sourceCode;\n\n    /**\n     * Validate regular expression\n     * @param {ASTNode} nodeToReport Node to report.\n     * @param {string} pattern Regular expression pattern to validate.\n     * @param {string} rawPattern Raw representation of the pattern in the source code.\n     * @param {number} rawPatternStartRange Start range of the pattern in the source code.\n     * @param {string} flags Regular expression flags.\n     * @returns {void}\n     * @private\n     */\n    function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\n      // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \\ ').\n      if (!DOUBLE_SPACE.test(rawPattern)) {\n        return;\n      }\n      const characterClassNodes = [];\n      let regExpAST;\n      try {\n        regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, {\n          unicode: flags.includes(\"u\"),\n          unicodeSets: flags.includes(\"v\")\n        });\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n      regexpp.visitRegExpAST(regExpAST, {\n        onCharacterClassEnter(ccNode) {\n          characterClassNodes.push(ccNode);\n        }\n      });\n      const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;\n      let match;\n      while (match = spacesPattern.exec(pattern)) {\n        const {\n          1: {\n            length\n          },\n          index\n        } = match;\n\n        // Report only consecutive spaces that are not in character classes.\n        if (characterClassNodes.every(({\n          start,\n          end\n        }) => index < start || end <= index)) {\n          context.report({\n            node: nodeToReport,\n            messageId: \"multipleSpaces\",\n            data: {\n              length\n            },\n            fix(fixer) {\n              if (pattern !== rawPattern) {\n                return null;\n              }\n              return fixer.replaceTextRange([rawPatternStartRange + index, rawPatternStartRange + index + length], ` {${length}}`);\n            }\n          });\n\n          // Report only the first occurrence of consecutive spaces\n          return;\n        }\n      }\n    }\n\n    /**\n     * Validate regular expression literals\n     * @param {ASTNode} node node to validate\n     * @returns {void}\n     * @private\n     */\n    function checkLiteral(node) {\n      if (node.regex) {\n        const pattern = node.regex.pattern;\n        const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\n        const rawPatternStartRange = node.range[0] + 1;\n        const flags = node.regex.flags;\n        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);\n      }\n    }\n\n    /**\n     * Validate strings passed to the RegExp constructor\n     * @param {ASTNode} node node to validate\n     * @returns {void}\n     * @private\n     */\n    function checkFunction(node) {\n      const scope = sourceCode.getScope(node);\n      const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n      const shadowed = regExpVar && regExpVar.defs.length > 0;\n      const patternNode = node.arguments[0];\n      if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\n        const pattern = patternNode.value;\n        const rawPattern = patternNode.raw.slice(1, -1);\n        const rawPatternStartRange = patternNode.range[0] + 1;\n        let flags;\n        if (node.arguments.length < 2) {\n          // It has no flags.\n          flags = \"\";\n        } else {\n          const flagsNode = node.arguments[1];\n          if (isString(flagsNode)) {\n            flags = flagsNode.value;\n          } else {\n            // The flags cannot be determined.\n            return;\n          }\n        }\n        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);\n      }\n    }\n    return {\n      Literal: checkLiteral,\n      CallExpression: checkFunction,\n      NewExpression: checkFunction\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","regexpp","regExpParser","RegExpParser","DOUBLE_SPACE","isString","node","type","value","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","multipleSpaces","create","context","sourceCode","checkRegex","nodeToReport","pattern","rawPattern","rawPatternStartRange","flags","test","characterClassNodes","regExpAST","parsePattern","length","unicode","includes","unicodeSets","visitRegExpAST","onCharacterClassEnter","ccNode","push","spacesPattern","match","exec","index","every","start","end","report","messageId","data","fix","fixer","replaceTextRange","checkLiteral","regex","raw","slice","lastIndexOf","range","checkFunction","scope","getScope","regExpVar","getVariableByName","shadowed","defs","patternNode","arguments","callee","name","flagsNode","Literal","CallExpression","NewExpression"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/no-regex-spaces.js"],"sourcesContent":["/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst regexpp = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst regExpParser = new regexpp.RegExpParser();\nconst DOUBLE_SPACE = / {2}/u;\n\n/**\n * Check if node is a string\n * @param {ASTNode} node node to evaluate\n * @returns {boolean} True if its a string\n * @private\n */\nfunction isString(node) {\n    return node && node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow multiple spaces in regular expressions\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-regex-spaces\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Validate regular expression\n         * @param {ASTNode} nodeToReport Node to report.\n         * @param {string} pattern Regular expression pattern to validate.\n         * @param {string} rawPattern Raw representation of the pattern in the source code.\n         * @param {number} rawPatternStartRange Start range of the pattern in the source code.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         * @private\n         */\n        function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\n\n            // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \\ ').\n            if (!DOUBLE_SPACE.test(rawPattern)) {\n                return;\n            }\n\n            const characterClassNodes = [];\n            let regExpAST;\n\n            try {\n                regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, { unicode: flags.includes(\"u\"), unicodeSets: flags.includes(\"v\") });\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(regExpAST, {\n                onCharacterClassEnter(ccNode) {\n                    characterClassNodes.push(ccNode);\n                }\n            });\n\n            const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;\n            let match;\n\n            while ((match = spacesPattern.exec(pattern))) {\n                const { 1: { length }, index } = match;\n\n                // Report only consecutive spaces that are not in character classes.\n                if (\n                    characterClassNodes.every(({ start, end }) => index < start || end <= index)\n                ) {\n                    context.report({\n                        node: nodeToReport,\n                        messageId: \"multipleSpaces\",\n                        data: { length },\n                        fix(fixer) {\n                            if (pattern !== rawPattern) {\n                                return null;\n                            }\n                            return fixer.replaceTextRange(\n                                [rawPatternStartRange + index, rawPatternStartRange + index + length],\n                                ` {${length}}`\n                            );\n                        }\n                    });\n\n                    // Report only the first occurrence of consecutive spaces\n                    return;\n                }\n            }\n        }\n\n        /**\n         * Validate regular expression literals\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkLiteral(node) {\n            if (node.regex) {\n                const pattern = node.regex.pattern;\n                const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\n                const rawPatternStartRange = node.range[0] + 1;\n                const flags = node.regex.flags;\n\n                checkRegex(\n                    node,\n                    pattern,\n                    rawPattern,\n                    rawPatternStartRange,\n                    flags\n                );\n            }\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const scope = sourceCode.getScope(node);\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\n            const patternNode = node.arguments[0];\n\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\n                const pattern = patternNode.value;\n                const rawPattern = patternNode.raw.slice(1, -1);\n                const rawPatternStartRange = patternNode.range[0] + 1;\n                let flags;\n\n                if (node.arguments.length < 2) {\n\n                    // It has no flags.\n                    flags = \"\";\n                } else {\n                    const flagsNode = node.arguments[1];\n\n                    if (isString(flagsNode)) {\n                        flags = flagsNode.value;\n                    } else {\n\n                        // The flags cannot be determined.\n                        return;\n                    }\n                }\n\n                checkRegex(\n                    node,\n                    pattern,\n                    rawPattern,\n                    rawPatternStartRange,\n                    flags\n                );\n            }\n        }\n\n        return {\n            Literal: checkLiteral,\n            CallExpression: checkFunction,\n            NewExpression: checkFunction\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}