{"ast":null,"code":"/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\"),\n  naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n * @param {ASTNode} node The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n  const staticName = astUtils.getStaticPropertyName(node);\n  if (staticName !== null) {\n    return staticName;\n  }\n  return node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natural.\n * @private\n */\nconst isValidOrders = {\n  asc(a, b) {\n    return a <= b;\n  },\n  ascI(a, b) {\n    return a.toLowerCase() <= b.toLowerCase();\n  },\n  ascN(a, b) {\n    return naturalCompare(a, b) <= 0;\n  },\n  ascIN(a, b) {\n    return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n  },\n  desc(a, b) {\n    return isValidOrders.asc(b, a);\n  },\n  descI(a, b) {\n    return isValidOrders.ascI(b, a);\n  },\n  descN(a, b) {\n    return isValidOrders.ascN(b, a);\n  },\n  descIN(a, b) {\n    return isValidOrders.ascIN(b, a);\n  }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require object keys to be sorted\",\n      recommended: false,\n      url: \"https://eslint.org/docs/latest/rules/sort-keys\"\n    },\n    schema: [{\n      enum: [\"asc\", \"desc\"]\n    }, {\n      type: \"object\",\n      properties: {\n        caseSensitive: {\n          type: \"boolean\",\n          default: true\n        },\n        natural: {\n          type: \"boolean\",\n          default: false\n        },\n        minKeys: {\n          type: \"integer\",\n          minimum: 2,\n          default: 2\n        },\n        allowLineSeparatedGroups: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\n    }\n  },\n  create(context) {\n    // Parse options.\n    const order = context.options[0] || \"asc\";\n    const options = context.options[1];\n    const insensitive = options && options.caseSensitive === false;\n    const natural = options && options.natural;\n    const minKeys = options && options.minKeys;\n    const allowLineSeparatedGroups = options && options.allowLineSeparatedGroups || false;\n    const isValidOrder = isValidOrders[order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")];\n\n    // The stack to save the previous property's name for each object literals.\n    let stack = null;\n    const sourceCode = context.sourceCode;\n    return {\n      ObjectExpression(node) {\n        stack = {\n          upper: stack,\n          prevNode: null,\n          prevBlankLine: false,\n          prevName: null,\n          numKeys: node.properties.length\n        };\n      },\n      \"ObjectExpression:exit\"() {\n        stack = stack.upper;\n      },\n      SpreadElement(node) {\n        if (node.parent.type === \"ObjectExpression\") {\n          stack.prevName = null;\n        }\n      },\n      Property(node) {\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        }\n        const prevName = stack.prevName;\n        const numKeys = stack.numKeys;\n        const thisName = getPropertyName(node);\n\n        // Get tokens between current node and previous node\n        const tokens = stack.prevNode && sourceCode.getTokensBetween(stack.prevNode, node, {\n          includeComments: true\n        });\n        let isBlankLineBetweenNodes = stack.prevBlankLine;\n        if (tokens) {\n          // check blank line between tokens\n          tokens.forEach((token, index) => {\n            const previousToken = tokens[index - 1];\n            if (previousToken && token.loc.start.line - previousToken.loc.end.line > 1) {\n              isBlankLineBetweenNodes = true;\n            }\n          });\n\n          // check blank line between the current node and the last token\n          if (!isBlankLineBetweenNodes && node.loc.start.line - tokens[tokens.length - 1].loc.end.line > 1) {\n            isBlankLineBetweenNodes = true;\n          }\n\n          // check blank line between the first token and the previous node\n          if (!isBlankLineBetweenNodes && tokens[0].loc.start.line - stack.prevNode.loc.end.line > 1) {\n            isBlankLineBetweenNodes = true;\n          }\n        }\n        stack.prevNode = node;\n        if (thisName !== null) {\n          stack.prevName = thisName;\n        }\n        if (allowLineSeparatedGroups && isBlankLineBetweenNodes) {\n          stack.prevBlankLine = thisName === null;\n          return;\n        }\n        if (prevName === null || thisName === null || numKeys < minKeys) {\n          return;\n        }\n        if (!isValidOrder(prevName, thisName)) {\n          context.report({\n            node,\n            loc: node.key.loc,\n            messageId: \"sortKeys\",\n            data: {\n              thisName,\n              prevName,\n              order,\n              insensitive: insensitive ? \"insensitive \" : \"\",\n              natural: natural ? \"natural \" : \"\"\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","naturalCompare","getPropertyName","node","staticName","getStaticPropertyName","key","name","isValidOrders","asc","a","b","ascI","toLowerCase","ascN","ascIN","desc","descI","descN","descIN","module","exports","meta","type","docs","description","recommended","url","schema","enum","properties","caseSensitive","default","natural","minKeys","minimum","allowLineSeparatedGroups","additionalProperties","messages","sortKeys","create","context","order","options","insensitive","isValidOrder","stack","sourceCode","ObjectExpression","upper","prevNode","prevBlankLine","prevName","numKeys","length","ObjectExpression:exit","SpreadElement","parent","Property","thisName","tokens","getTokensBetween","includeComments","isBlankLineBetweenNodes","forEach","token","index","previousToken","loc","start","line","end","report","messageId","data"],"sources":["C:/Users/iarha/OneDrive/Desktop/React mini/mega project/remotre code collab/Frontend/node_modules/eslint/lib/rules/sort-keys.js"],"sourcesContent":["/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n * @param {ASTNode} node The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n    const staticName = astUtils.getStaticPropertyName(node);\n\n    if (staticName !== null) {\n        return staticName;\n    }\n\n    return node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natural.\n * @private\n */\nconst isValidOrders = {\n    asc(a, b) {\n        return a <= b;\n    },\n    ascI(a, b) {\n        return a.toLowerCase() <= b.toLowerCase();\n    },\n    ascN(a, b) {\n        return naturalCompare(a, b) <= 0;\n    },\n    ascIN(a, b) {\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n    },\n    desc(a, b) {\n        return isValidOrders.asc(b, a);\n    },\n    descI(a, b) {\n        return isValidOrders.ascI(b, a);\n    },\n    descN(a, b) {\n        return isValidOrders.ascN(b, a);\n    },\n    descIN(a, b) {\n        return isValidOrders.ascIN(b, a);\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require object keys to be sorted\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/sort-keys\"\n        },\n\n        schema: [\n            {\n                enum: [\"asc\", \"desc\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    caseSensitive: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    natural: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    minKeys: {\n                        type: \"integer\",\n                        minimum: 2,\n                        default: 2\n                    },\n                    allowLineSeparatedGroups: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\n        }\n    },\n\n    create(context) {\n\n        // Parse options.\n        const order = context.options[0] || \"asc\";\n        const options = context.options[1];\n        const insensitive = options && options.caseSensitive === false;\n        const natural = options && options.natural;\n        const minKeys = options && options.minKeys;\n        const allowLineSeparatedGroups = options && options.allowLineSeparatedGroups || false;\n        const isValidOrder = isValidOrders[\n            order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")\n        ];\n\n        // The stack to save the previous property's name for each object literals.\n        let stack = null;\n        const sourceCode = context.sourceCode;\n\n        return {\n            ObjectExpression(node) {\n                stack = {\n                    upper: stack,\n                    prevNode: null,\n                    prevBlankLine: false,\n                    prevName: null,\n                    numKeys: node.properties.length\n                };\n            },\n\n            \"ObjectExpression:exit\"() {\n                stack = stack.upper;\n            },\n\n            SpreadElement(node) {\n                if (node.parent.type === \"ObjectExpression\") {\n                    stack.prevName = null;\n                }\n            },\n\n            Property(node) {\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                const prevName = stack.prevName;\n                const numKeys = stack.numKeys;\n                const thisName = getPropertyName(node);\n\n                // Get tokens between current node and previous node\n                const tokens = stack.prevNode && sourceCode\n                    .getTokensBetween(stack.prevNode, node, { includeComments: true });\n\n                let isBlankLineBetweenNodes = stack.prevBlankLine;\n\n                if (tokens) {\n\n                    // check blank line between tokens\n                    tokens.forEach((token, index) => {\n                        const previousToken = tokens[index - 1];\n\n                        if (previousToken && (token.loc.start.line - previousToken.loc.end.line > 1)) {\n                            isBlankLineBetweenNodes = true;\n                        }\n                    });\n\n                    // check blank line between the current node and the last token\n                    if (!isBlankLineBetweenNodes && (node.loc.start.line - tokens[tokens.length - 1].loc.end.line > 1)) {\n                        isBlankLineBetweenNodes = true;\n                    }\n\n                    // check blank line between the first token and the previous node\n                    if (!isBlankLineBetweenNodes && (tokens[0].loc.start.line - stack.prevNode.loc.end.line > 1)) {\n                        isBlankLineBetweenNodes = true;\n                    }\n                }\n\n                stack.prevNode = node;\n\n                if (thisName !== null) {\n                    stack.prevName = thisName;\n                }\n\n                if (allowLineSeparatedGroups && isBlankLineBetweenNodes) {\n                    stack.prevBlankLine = thisName === null;\n                    return;\n                }\n\n                if (prevName === null || thisName === null || numKeys < minKeys) {\n                    return;\n                }\n\n                if (!isValidOrder(prevName, thisName)) {\n                    context.report({\n                        node,\n                        loc: node.key.loc,\n                        messageId: \"sortKeys\",\n                        data: {\n                            thisName,\n                            prevName,\n                            order,\n                            insensitive: insensitive ? \"insensitive \" : \"\",\n                            natural: natural ? \"natural \" : \"\"\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}